<Type Name="Type" FullName="System.Type">
  <Metadata><Meta Name="ms.openlocfilehash" Value="86e12cd5d024de5c0e84aa3d936d352176427ed3" /><Meta Name="ms.sourcegitcommit" Value="cb4d218ffd5a459a5f921fe1d945c682d1e09aca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/16/2019" /><Meta Name="ms.locfileid" Value="69541078" /></Metadata><TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="dd86b-101">Stellt Typdeklarationen dar: Klassentypen, Schnittstellentypen, Arraytypen, Werttypen, Enumerationstypen, Typparameter, generische Typdefinitionen und offen oder geschlossen konstruierte generische Typen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-101">Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-102">`Type`ist der Stamm der <xref:System.Reflection> Funktionalität und ist die primäre Methode für den Zugriff auf Metadaten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-102">`Type` is the root of the <xref:System.Reflection> functionality and is the primary way to access metadata.</span></span> <span data-ttu-id="dd86b-103">Verwenden Sie die Member <xref:System.Type> von, um Informationen über eine Typdeklaration, Informationen zu den Membern eines Typs (z. b. Konstruktoren, Methoden, Felder, Eigenschaften und Ereignisse einer Klasse) sowie das Modul und die Assembly, in der die Klasse bereitgestellt wird, zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-103">Use the members of <xref:System.Type> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.</span></span>  
  
 <span data-ttu-id="dd86b-104">Es sind keine Berechtigungen erforderlich, damit der Code Reflektion verwendet, um Informationen über Typen und ihre Member zu erhalten, unabhängig von ihren Zugriffsebenen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-104">No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.</span></span> <span data-ttu-id="dd86b-105">Für den Code sind keine Berechtigungen erforderlich, um über Reflektion auf öffentliche Member oder andere Member zuzugreifen, deren Zugriffsebenen Sie während der normalen Kompilierung sichtbar machen würden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-105">No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.</span></span> <span data-ttu-id="dd86b-106">Damit der Code jedoch auf Member, auf die normalerweise nicht zugegriffen werden kann, z. b. private oder interne Methoden, oder geschützte Felder eines Typs, die Ihre Klasse nicht erbt, über Reflektion auf <xref:System.Security.Permissions.ReflectionPermission>Member zugreifen kann, muss der Code über verfügen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-106">However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="dd86b-107">Siehe [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="dd86b-107">See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span>  
  
 <span data-ttu-id="dd86b-108">`Type`ist eine abstrakte Basisklasse, die mehrere Implementierungen zulässt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-108">`Type` is an abstract base class that allows multiple implementations.</span></span> <span data-ttu-id="dd86b-109">Das System stellt immer die abgeleitete Klasse `RuntimeType`bereit.</span><span class="sxs-lookup"><span data-stu-id="dd86b-109">The system will always provide the derived class `RuntimeType`.</span></span> <span data-ttu-id="dd86b-110">Bei der Reflektion werden alle Klassen, die mit der Word-Laufzeit beginnen, pro Objekt im System nur einmal erstellt und unterstützen Vergleichs Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-110">In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-111">Sperren <xref:System.Type> Sie Objekte in Multithreading Szenarien nicht, um den Zugriff auf `static` Daten zu synchronisieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-111">In multithreading scenarios, do not lock <xref:System.Type> objects in order to synchronize access to `static` data.</span></span> <span data-ttu-id="dd86b-112">Anderer Code, über den Sie kein Steuerelement verfügen, kann auch den Klassentyp sperren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-112">Other code, over which you have no control, might also lock your class type.</span></span> <span data-ttu-id="dd86b-113">Dies kann zu einem Deadlock führen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-113">This might result in a deadlock.</span></span> <span data-ttu-id="dd86b-114">Synchronisieren Sie stattdessen den Zugriff auf statische Daten, indem Sie `static` ein privates Objekt Sperren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-114">Instead, synchronize access to static data by locking a private `static` object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-115">Eine abgeleitete Klasse kann auf geschützte Member der Basisklassen des aufrufenden Codes zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-115">A derived class can access protected members of the calling code's base classes.</span></span> <span data-ttu-id="dd86b-116">Außerdem ist der Zugriff auf Assemblymember der Assembly des aufrufenden Codes zulässig.</span><span class="sxs-lookup"><span data-stu-id="dd86b-116">Also, access is allowed to assembly members of the calling code's assembly.</span></span> <span data-ttu-id="dd86b-117">Wenn Sie in früh gebundenem Code Zugriff auf den Zugriff haben, können Sie als Regel auch in spät gebundenem Code auf den Zugriff zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-117">As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-118">Schnittstellen, die andere Schnittstellen erweitern, erben nicht die Methoden, die in den erweiterten Schnittstellen definiert sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-118">Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</span></span>  
  
 <span data-ttu-id="dd86b-119">In diesem Abschnitt</span><span class="sxs-lookup"><span data-stu-id="dd86b-119">In this section:</span></span>  
  
 <span data-ttu-id="dd86b-120">[Welche Typen stellt ein Typobjekt dar?](#WhatTypes) </span><span class="sxs-lookup"><span data-stu-id="dd86b-120">[What types does a Type object represent?](#WhatTypes) </span></span>  
 <span data-ttu-id="dd86b-121">[Abrufen eines Typobjekts](#Retrieve) </span><span class="sxs-lookup"><span data-stu-id="dd86b-121">[Retrieving a Type object](#Retrieve) </span></span>  
 [<span data-ttu-id="dd86b-122">Vergleichen von Typobjekten auf Gleichheit</span><span class="sxs-lookup"><span data-stu-id="dd86b-122">Comparing type objects for equality</span></span>](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a><span data-ttu-id="dd86b-123">Welche Typen stellt ein Typobjekt dar?</span><span class="sxs-lookup"><span data-stu-id="dd86b-123">What types does a Type object represent?</span></span>  
 <span data-ttu-id="dd86b-124">Diese Klasse ist Thread sicher. mehrere Threads können gleichzeitig aus einer Instanz dieses Typs gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-124">This class is thread safe; multiple threads can concurrently read from an instance of this type.</span></span> <span data-ttu-id="dd86b-125">Eine Instanz der <xref:System.Type> -Klasse kann einen der folgenden Typen darstellen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-125">An instance of the <xref:System.Type> class can represent any of the following types:</span></span>  
  
-   <span data-ttu-id="dd86b-126">Klassen</span><span class="sxs-lookup"><span data-stu-id="dd86b-126">Classes</span></span>  
  
-   <span data-ttu-id="dd86b-127">Werttypen</span><span class="sxs-lookup"><span data-stu-id="dd86b-127">Value types</span></span>  
  
-   <span data-ttu-id="dd86b-128">Arrays</span><span class="sxs-lookup"><span data-stu-id="dd86b-128">Arrays</span></span>  
  
-   <span data-ttu-id="dd86b-129">Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="dd86b-129">Interfaces</span></span>  
  
-   <span data-ttu-id="dd86b-130">Enumerationen</span><span class="sxs-lookup"><span data-stu-id="dd86b-130">Enumerations</span></span>  
  
-   <span data-ttu-id="dd86b-131">Delegaten</span><span class="sxs-lookup"><span data-stu-id="dd86b-131">Delegates</span></span>  
  
-   <span data-ttu-id="dd86b-132">Konstruierte generische Typen und generische Typdefinitionen</span><span class="sxs-lookup"><span data-stu-id="dd86b-132">Constructed generic types and generic type definitions</span></span>  
  
-   <span data-ttu-id="dd86b-133">Typargumente und Typparameter von konstruierten generischen Typen, generischen Typdefinitionen und generischen Methoden Definitionen</span><span class="sxs-lookup"><span data-stu-id="dd86b-133">Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</span></span>  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a><span data-ttu-id="dd86b-134">Abrufen eines Typobjekts</span><span class="sxs-lookup"><span data-stu-id="dd86b-134">Retrieving a Type object</span></span>  
 <span data-ttu-id="dd86b-135">Das <xref:System.Type> -Objekt, das einem bestimmten Typ zugeordnet ist, kann wie folgt abgerufen werden:</span><span class="sxs-lookup"><span data-stu-id="dd86b-135">The <xref:System.Type> object associated with a particular type can be obtained in the following ways:</span></span>  
  
-   <span data-ttu-id="dd86b-136">Die Instanzmethode <xref:System.Object.GetType%2A?displayProperty=nameWithType> gibt <xref:System.Type> ein-Objekt zurück, das den Typ einer-Instanz darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-136">The instance <xref:System.Object.GetType%2A?displayProperty=nameWithType> method returns a <xref:System.Type> object that represents the type of an instance.</span></span> <span data-ttu-id="dd86b-137">Da alle verwalteten Typen von <xref:System.Object>abgeleitet werden, kann die <xref:System.Object.GetType%2A> -Methode für eine Instanz eines beliebigen Typs aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-137">Because all managed types derive from <xref:System.Object>, the <xref:System.Object.GetType%2A> method can be called on an instance of any type.</span></span>  
  
     <span data-ttu-id="dd86b-138">Im folgenden Beispiel wird die <xref:System.Object.GetType%2A?displayProperty=nameWithType> -Methode aufgerufen, um den Lauf Zeittyp der einzelnen Objekte in einem Objekt Array zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-138">The following example calls the <xref:System.Object.GetType%2A?displayProperty=nameWithType> method to determine the runtime type of each object in an object array.</span></span>  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   <span data-ttu-id="dd86b-139">Die statischen <xref:System.Type.GetType%2A?displayProperty=nameWithType> -Methoden geben <xref:System.Type> ein-Objekt zurück, das einen durch seinen voll qualifizierten Namen angegebenen Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-139">The static <xref:System.Type.GetType%2A?displayProperty=nameWithType> methods return a <xref:System.Type> object that represents a type specified by its fully qualified name.</span></span>  
  
-   <span data-ttu-id="dd86b-140">Die <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>Methoden <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, und <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> geben- `Type` Objekte zurück, die die in einem Modul definierten Typen darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-140">The <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> methods return `Type` objects that represent the types defined in a module.</span></span> <span data-ttu-id="dd86b-141">Die erste Methode kann zum Abrufen eines Arrays von <xref:System.Type> -Objekten für alle in einem Modul definierten öffentlichen und privaten Typen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-141">The first method can be used to obtain an array of <xref:System.Type> objects for all the public and private types defined in a module.</span></span> <span data-ttu-id="dd86b-142">(Sie können `Module` eine Instanz von über die <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> -Methode <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> oder die-Methode oder <xref:System.Type.Module%2A?displayProperty=nameWithType> die-Eigenschaft abrufen.)</span><span class="sxs-lookup"><span data-stu-id="dd86b-142">(You can obtain an instance of `Module` through the <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> method, or through the <xref:System.Type.Module%2A?displayProperty=nameWithType> property.)</span></span>  
  
-   <span data-ttu-id="dd86b-143">Das <xref:System.Reflection.Assembly?displayProperty=nameWithType> -Objekt enthält eine Reihe von Methoden zum Abrufen der Klassen, die in einer Assembly <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>definiert sind, <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>einschließlich, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>und.</span><span class="sxs-lookup"><span data-stu-id="dd86b-143">The <xref:System.Reflection.Assembly?displayProperty=nameWithType> object contains a number of methods to retrieve the classes defined in an assembly, including <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="dd86b-144">Die <xref:System.Type.FindInterfaces%2A> Methode gibt eine gefilterte Liste von Schnittstellentypen zurück, die von einem Typ unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-144">The <xref:System.Type.FindInterfaces%2A> method returns a filtered list of interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="dd86b-145">Die <xref:System.Type.GetElementType%2A> -Methode gibt `Type` ein-Objekt zurück, das das-Element darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-145">The <xref:System.Type.GetElementType%2A> method returns a `Type` object that represents the element.</span></span>  
  
-   <span data-ttu-id="dd86b-146">Die <xref:System.Type.GetInterfaces%2A> Methoden <xref:System.Type.GetInterface%2A> und geben <xref:System.Type> -Objekte zurück, die die von einem-Typ unterstützten Schnittstellentypen darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-146">The <xref:System.Type.GetInterfaces%2A> and <xref:System.Type.GetInterface%2A> methods return <xref:System.Type> objects representing the interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="dd86b-147">Die <xref:System.Type.GetTypeArray%2A> -Methode gibt ein Array <xref:System.Type> von-Objekten zurück, die die durch einen beliebigen Satz von-Objekten angegebenen Typen darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-147">The <xref:System.Type.GetTypeArray%2A> method returns an array of <xref:System.Type> objects representing the types specified by an arbitrary set of objects.</span></span> <span data-ttu-id="dd86b-148">Die-Objekte werden mit einem Array vom Typ <xref:System.Object>angegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-148">The objects are specified with an array of type <xref:System.Object>.</span></span>  
  
-   <span data-ttu-id="dd86b-149">Die <xref:System.Type.GetTypeFromProgID%2A> - <xref:System.Type.GetTypeFromCLSID%2A> und-Methoden werden für die COM-Interoperabilität bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-149">The <xref:System.Type.GetTypeFromProgID%2A> and <xref:System.Type.GetTypeFromCLSID%2A> methods are provided for COM interoperability.</span></span> <span data-ttu-id="dd86b-150">Sie geben ein <xref:System.Type> -Objekt zurück, das den Typ darstellt `ProgID` , `CLSID`der von oder angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-150">They return a <xref:System.Type> object that represents the type specified by a `ProgID` or `CLSID`.</span></span>  
  
-   <span data-ttu-id="dd86b-151">Die <xref:System.Type.GetTypeFromHandle%2A> -Methode wird für die Interoperabilität bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-151">The <xref:System.Type.GetTypeFromHandle%2A> method is provided for interoperability.</span></span> <span data-ttu-id="dd86b-152">Es wird ein `Type` -Objekt zurückgegeben, das den durch ein Klassen handle angegebenen Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-152">It returns a `Type` object that represents the type specified by a class handle.</span></span>  
  
-   <span data-ttu-id="dd86b-153">C# `typeid` `Type` `GetType` Der-Operator, C++ der-Operator und der Visual Basic-Operator rufen das-Objekt für einen Typ ab. `typeof`</span><span class="sxs-lookup"><span data-stu-id="dd86b-153">The C# `typeof` operator, the C++ `typeid` operator, and the Visual Basic `GetType` operator obtain the `Type` object for a type.</span></span>  
  
-   <span data-ttu-id="dd86b-154">Die <xref:System.Type.MakeGenericType%2A> -Methode gibt <xref:System.Type> ein-Objekt zurück, das einen konstruierten generischen Typ darstellt, bei <xref:System.Type.ContainsGenericParameters%2A> dem es `true`sich um einen geöffneten konstruierten Typ handelt, wenn die-Eigenschaft zurückgibt, und andernfalls</span><span class="sxs-lookup"><span data-stu-id="dd86b-154">The <xref:System.Type.MakeGenericType%2A> method returns a <xref:System.Type> object representing a constructed generic type, which is an open constructed type if its <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, and a closed constructed type otherwise.</span></span> <span data-ttu-id="dd86b-155">Ein generischer Typ kann nur instanziiert werden, wenn er geschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-155">A generic type can be instantiated only if it is closed.</span></span>  
  
-   <span data-ttu-id="dd86b-156">Die <xref:System.Type.MakeArrayType%2A>Methoden <xref:System.Type.MakePointerType%2A>, <xref:System.Type> `ref` und <xref:System.Type.MakeByRefType%2A> geben Objekte zurück, die bzw. ein Array eines bestimmten Typs, einen Zeiger auf einen angegebenen Typ und den Typ eines Verweis Parameters (in C# )darstellen.`ByRef` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="dd86b-156">The <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, and <xref:System.Type.MakeByRefType%2A> methods return <xref:System.Type> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (`ref` in C#, `ByRef` in Visual Basic).</span></span>  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a><span data-ttu-id="dd86b-157">Vergleichen von Typobjekten auf Gleichheit</span><span class="sxs-lookup"><span data-stu-id="dd86b-157">Comparing type objects for equality</span></span>  
 <span data-ttu-id="dd86b-158">Ein <xref:System.Type> -Objekt, das einen Typ darstellt, ist eindeutig, d <xref:System.Type> . h., dass zwei Objekt Verweise auf dasselbe Objekt verweisen, wenn Sie denselben Typ darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-158">A <xref:System.Type> object that represents a type is unique; that is, two <xref:System.Type> object references refer to the same object if and only if they represent the same type.</span></span> <span data-ttu-id="dd86b-159">Dies ermöglicht den Vergleich von <xref:System.Type> Objekten mithilfe von Verweis Gleichheit.</span><span class="sxs-lookup"><span data-stu-id="dd86b-159">This allows for comparison of <xref:System.Type> objects using reference equality.</span></span> <span data-ttu-id="dd86b-160">Im folgenden Beispiel werden die <xref:System.Type> Objekte, die eine Reihe von ganzzahligen Werten darstellen, verglichen, um zu bestimmen, ob Sie denselben Typ haben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-160">The following example compares the <xref:System.Type> objects that represent a number of integer values to determine whether they are of the same type.</span></span>  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-161">Das folgende Beispiel zeigt einige repräsentative Features von <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-161">The following example shows a few representative features of <xref:System.Type>.</span></span> <span data-ttu-id="dd86b-162">Der C# `typeof` Operator (`GetType` Operator in Visual Basic) wird verwendet, um ein <xref:System.Type> -Objekt <xref:System.String>zu erhalten, das darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-162">The C# `typeof` operator (`GetType` operator in Visual Basic) is used to get a <xref:System.Type> object representing <xref:System.String>.</span></span> <span data-ttu-id="dd86b-163">Von diesem <xref:System.Type> -Objekt wird <xref:System.Type.GetMethod%2A> die-Methode verwendet, um <xref:System.Reflection.MethodInfo> ein- <xref:System.String.Substring%2A?displayProperty=nameWithType> Objekt zu erhalten, das die Überladung darstellt, die eine Startposition und eine Länge annimmt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-163">From this <xref:System.Type> object, the <xref:System.Type.GetMethod%2A> method is used to get a <xref:System.Reflection.MethodInfo> representing the <xref:System.String.Substring%2A?displayProperty=nameWithType> overload that takes a starting location and a length.</span></span>
  
 <span data-ttu-id="dd86b-164">Zum Identifizieren der Überladungs Signatur erstellt das Codebeispiel ein temporäres Array, <xref:System.Type> das zwei `int` -`Integer` Objekte enthält, die (in Visual Basic) darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-164">To identify the overload signature, the code example creates a temporary array containing two <xref:System.Type> objects representing `int` (`Integer` in Visual Basic).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-165">Um genau zu sein, enthält das Array zwei Verweise auf die Instanz <xref:System.Type> von, `int` die in der aktuellen Anwendungsdomäne darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-165">To be precise, the array contains two references to the instance of <xref:System.Type> that represents `int` in the current application domain.</span></span> <span data-ttu-id="dd86b-166">Für jeden Typ gibt es nur eine Instanz von <xref:System.Type> pro Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="dd86b-166">For any type, there is only one instance of <xref:System.Type> per application domain.</span></span>  
  
 <span data-ttu-id="dd86b-167">Im Codebeispiel wird verwendet <xref:System.Reflection.MethodInfo> , um die <xref:System.String.Substring%2A> -Methode für die Zeichenfolge "Hello, World!" aufzurufen, und das Ergebnis wird angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-167">The code example uses the <xref:System.Reflection.MethodInfo> to invoke the <xref:System.String.Substring%2A> method on the string "Hello, World!", and displays the result.</span></span>  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="dd86b-168">Dieser Typ ist threadsicher.</span><span class="sxs-lookup"><span data-stu-id="dd86b-168">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides"><para><span data-ttu-id="dd86b-169">Wenn Sie von <see langword="Type" />erben, müssen Sie die folgenden Member überschreiben:</span><span class="sxs-lookup"><span data-stu-id="dd86b-169">When you inherit from <see langword="Type" />, you must override the following members:</span></span> 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md"><span data-ttu-id="dd86b-170">Anzeigen von Typinformationen</span><span class="sxs-lookup"><span data-stu-id="dd86b-170">Viewing Type Information</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-171">Initialisiert eine neue Instanz der <see cref="T:System.Type" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="dd86b-171">Initializes a new instance of the <see cref="T:System.Type" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-172">Dieser Konstruktor wird von abgeleiteten Klassen während der Erstellung von Type-Objekten aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-172">This constructor is invoked by derived classes during the construction of type objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-173">Ruft die <see cref="T:System.Reflection.Assembly" /> ab, in der der Typ deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-173">Gets the <see cref="T:System.Reflection.Assembly" /> in which the type is declared.</span></span> <span data-ttu-id="dd86b-174">Ruft bei generischen Typen die <see cref="T:System.Reflection.Assembly" /> ab, in der der generische Typ definiert ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-174">For generic types, gets the <see cref="T:System.Reflection.Assembly" /> in which the generic type is defined.</span></span></summary>
        <value><span data-ttu-id="dd86b-175">Eine <see cref="T:System.Reflection.Assembly" />-Instanz, die die Assembly mit dem aktuellen Typ beschreibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-175">An <see cref="T:System.Reflection.Assembly" /> instance that describes the assembly containing the current type.</span></span> <span data-ttu-id="dd86b-176">Bei generischen Typen beschreibt die Instanz die Assembly, die die generische Typdefinition enthält, nicht die Assembly, in der ein bestimmter konstruierter Typ erstellt und verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-176">For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-177">Wenn das aktuelle <xref:System.Type> -Objekt einen konstruierten generischen Typ darstellt, gibt diese Eigenschaft die Assembly zurück, die die generische Typdefinition enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-177">If the current <xref:System.Type> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.</span></span> <span data-ttu-id="dd86b-178">Nehmen Sie beispielsweise an, Sie erstellen `MyGenericStack<T>` eine Assembly `generic<T> ref class MyGenericStack` mit C++dem Namen MyGenerics. dll, die die`MyGenericStack(Of T)` generische Typdefinition enthält (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="dd86b-178">For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic, `generic<T> ref class MyGenericStack` in C++).</span></span> <span data-ttu-id="dd86b-179">Wenn Sie eine Instanz `MyGenericStack<int>` von (`MyGenericStack(Of Integer)` in Visual Basic) in einer anderen Assembly erstellen, <xref:System.Type.Assembly%2A> gibt die-Eigenschaft für den konstruierten Typ ein <xref:System.Reflection.Assembly> -Objekt zurück, das MyGenerics. dll darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-179">If you create an instance of `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in another assembly, the <xref:System.Type.Assembly%2A> property for the constructed type returns an <xref:System.Reflection.Assembly> object that represents MyGenerics.dll.</span></span>  
  
 <span data-ttu-id="dd86b-180">Wenn das aktuelle <xref:System.Type> -Objekt einen nicht zugewiesenen generischen Parameter `T`darstellt, gibt diese Eigenschaft die Assembly zurück, die den generischen Typ `T`enthält, der definiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-180">Similarly, if the current <xref:System.Type> object represents an unassigned generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
 <span data-ttu-id="dd86b-181">Wenn die <xref:System.Type.Assembly%2A?displayProperty=nameWithType> Eigenschaft für eine bestimmte .NET-Implementierung, wie z. b. .net Core oder die universelle Windows-Plattform, nicht <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> verfügbar ist, verwenden Sie stattdessen die-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-181">If the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property is not available on a particular .NET implementation, such as .NET Core or the Universal Windows Platform, use the <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> property instead.</span></span>      
  
 <span data-ttu-id="dd86b-182">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-182">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-183">Im folgenden Beispiel wird der AssemblyName, der der-Klasse zugeordnet ist, und der voll qualifizierte Name des-Typs angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-183">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-184">Ruft den durch die Assembly qualifizierten Namen des Typs ab, der den Namen der Assembly enthält, aus der der <see cref="T:System.Type" /> geladen wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-184">Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <see cref="T:System.Type" /> object was loaded.</span></span></summary>
        <value><span data-ttu-id="dd86b-185">Der durch die Assembly qualifizierte Name des <see cref="T:System.Type" />, der den Namen der Assembly enthält, aus der der <see cref="T:System.Type" /> geladen wurde, oder <see langword="null" />, wenn die aktuelle Instanz einen generischen Typparameter darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-185">The assembly-qualified name of the <see cref="T:System.Type" />, which includes the name of the assembly from which the <see cref="T:System.Type" /> was loaded, or <see langword="null" /> if the current instance represents a generic type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-186">Der durch die Assembly qualifizierte Name eines Typs besteht aus dem Typnamen, einschließlich des Namespace, gefolgt von einem Komma und dem anzeigen amen der Assembly.</span><span class="sxs-lookup"><span data-stu-id="dd86b-186">The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.</span></span> <span data-ttu-id="dd86b-187">Der Anzeige Name einer Assembly wird mithilfe der <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> -Eigenschaft abgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-187">The display name of an assembly is obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-188">In der .NET Framework Version 2,0 wird die Prozessorarchitektur der Assemblyidentität hinzugefügt und kann als Teil der assemblynamenszeichenfolgen angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-188">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="dd86b-189">Beispiel: "ProcessorArchitecture = msil".</span><span class="sxs-lookup"><span data-stu-id="dd86b-189">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="dd86b-190">Aus Kompatibilitätsgründen ist Sie jedoch nicht in der Zeichenfolge <xref:System.Type.AssemblyQualifiedName%2A> enthalten, die von der-Eigenschaft zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-190">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="dd86b-191">Siehe <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-191">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="dd86b-192">Alle Compiler, die die Common Language Runtime unterstützen, geben den einfachen Namen einer geschachtelten Klasse aus, und die Reflektion erstellt bei der Abfrage einen geschachtelten Namen in Übereinstimmung mit den folgenden Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-192">All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
|<span data-ttu-id="dd86b-193">Trennzeichen</span><span class="sxs-lookup"><span data-stu-id="dd86b-193">Delimiter</span></span>|<span data-ttu-id="dd86b-194">Bedeutung</span><span class="sxs-lookup"><span data-stu-id="dd86b-194">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="dd86b-195">Umgekehrter Schrägstrich (\\)</span><span class="sxs-lookup"><span data-stu-id="dd86b-195">Backslash (\\)</span></span>|<span data-ttu-id="dd86b-196">Escapezeichen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-196">Escape character.</span></span>|  
|<span data-ttu-id="dd86b-197">Komma (,)</span><span class="sxs-lookup"><span data-stu-id="dd86b-197">Comma (,)</span></span>|<span data-ttu-id="dd86b-198">Geht vor dem Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-198">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="dd86b-199">Plus Zeichen (+)</span><span class="sxs-lookup"><span data-stu-id="dd86b-199">Plus sign (+)</span></span>|<span data-ttu-id="dd86b-200">Geht einer-Klasse vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-200">Precedes a nested class.</span></span>|  
|<span data-ttu-id="dd86b-201">Punkt (.)</span><span class="sxs-lookup"><span data-stu-id="dd86b-201">Period (.)</span></span>|<span data-ttu-id="dd86b-202">Bezeichnet Namespace Bezeichner.</span><span class="sxs-lookup"><span data-stu-id="dd86b-202">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="dd86b-203">Eckige Klammern ([])</span><span class="sxs-lookup"><span data-stu-id="dd86b-203">Brackets ([])</span></span>|<span data-ttu-id="dd86b-204">Nach einem Typnamen steht für ein Array dieses Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-204">After a type name, denotes an array of that type.</span></span><br /><br /> <span data-ttu-id="dd86b-205">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-205">-or-</span></span><br /><br /> <span data-ttu-id="dd86b-206">Schließt für einen generischen Typ die Argumentliste des generischen Typs ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-206">For a generic type, encloses the generic type argument list.</span></span><br /><br /> <span data-ttu-id="dd86b-207">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-207">-or-</span></span><br /><br /> <span data-ttu-id="dd86b-208">Schließt innerhalb einer Typargument Liste einen von der Assembly qualifizierten Typ ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-208">Within a type argument list, encloses an assembly-qualified type.</span></span>|  
  
 <span data-ttu-id="dd86b-209">Der durch die Assembly qualifizierte Name für eine Klasse könnte beispielsweise wie folgt aussehen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-209">For example, the assembly-qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 <span data-ttu-id="dd86b-210">Wenn der Namespace ein Pluszeichen enthielt (z. b. TopNamespace. Sub + Namespace), wird dem Pluszeichen (+) ein Escapezeichen (\\) vorangestellt, um zu verhindern, dass es als Schachtelungs Trennzeichen interpretiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-210">If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="dd86b-211">Die Reflektion gibt diese Zeichenfolge wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="dd86b-211">Reflection would emit this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 <span data-ttu-id="dd86b-212">Ein "+ +" wird zu\\"\\\\+\\+", und "" wird zu "\\".</span><span class="sxs-lookup"><span data-stu-id="dd86b-212">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="dd86b-213">Dieser qualifizierte Name kann persistent gespeichert und später zum Laden <xref:System.Type>von verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-213">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="dd86b-214">Um nach einem <xref:System.Type>zu suchen und zu laden <xref:System.Type.GetType%2A> , verwenden Sie entweder mit dem Typnamen oder mit dem qualifizierten Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-214">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="dd86b-215"><xref:System.Type.GetType%2A>beim Typnamen wird nur <xref:System.Type> in der Assembly des Aufrufers und dann in der Systemassembly nach gesucht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-215"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="dd86b-216"><xref:System.Type.GetType%2A>mit dem qualifizierten Assemblynamen für die Assembly <xref:System.Type> wird in beliebiger Assembly nach gesucht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-216"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="dd86b-217">Typnamen können nachfolgende Zeichen enthalten, die zusätzliche Informationen über den Typ angeben, z. b. ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-217">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="dd86b-218">Um den Typnamen ohne diese nachfolgenden Zeichen abzurufen, `t.GetElementType().ToString()`verwenden Sie `t` , wobei der-Typ ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-218">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="dd86b-219">Leerzeichen sind in allen Typnamen Komponenten mit Ausnahme des Assemblynamens relevant.</span><span class="sxs-lookup"><span data-stu-id="dd86b-219">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="dd86b-220">Im Assemblynamen sind Leerzeichen vor dem Trennzeichen ', ' relevant, Leerzeichen nach dem Trennzeichen ', ' werden jedoch ignoriert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-220">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="dd86b-221">Generische Argumente generischer Typen werden selbst anhand des Assemblynamens qualifiziert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-221">Generic arguments of generic types are themselves qualified by assembly name.</span></span> <span data-ttu-id="dd86b-222">Beispielsweise `int` wird im durch die Assembly qualifizierten Typnamen für `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) auf den durch die Assembly qualifizierten Typnamen für <xref:System.Int32>erweitert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-222">For example, in the assembly-qualified type name for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` is expanded to the assembly-qualified type name for <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="dd86b-223">Wenn das aktuelle <xref:System.Type> -Objekt einen generischen Parameter darstellt, gibt `null`diese Eigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-223">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-224">Im folgenden Beispiel wird der AssemblyName, der der-Klasse zugeordnet ist, und der voll qualifizierte Name des-Typs angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-224">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 <span data-ttu-id="dd86b-225">Im folgenden Beispiel werden die von <xref:System.Type.ToString%2A> der-Methode zurückgegebenen Zeichen folgen und die <xref:System.Type.AssemblyQualifiedName%2A> `Name`Eigenschaften, <xref:System.Type.FullName%2A>und verglichen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-225">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="dd86b-226">Angeben vollständig gekennzeichneter Typnamen</span><span class="sxs-lookup"><span data-stu-id="dd86b-226">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-227">Ruft die dem <see cref="T:System.Type" /> zugeordneten Attribute ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-227">Gets the attributes associated with the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="dd86b-228">Ein <see cref="T:System.Reflection.TypeAttributes" />-Objekt, das die Attributgruppe von <see cref="T:System.Type" /> darstellt. Falls <see cref="T:System.Type" /> jedoch einen generischen Typparameter darstellt, ist der Wert nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-228">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />, unless the <see cref="T:System.Type" /> represents a generic type parameter, in which case the value is unspecified.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-229">Einige Member der <xref:System.Reflection.TypeAttributes> -Enumeration sind Masken, die eine Gruppe von Werten darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-229">Some members of the <xref:System.Reflection.TypeAttributes> enumeration are masks that represent a group of values.</span></span> <span data-ttu-id="dd86b-230">Jede Gruppe enthält einen Member, dessen zugrunde liegender Wert NULL ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-230">Each group includes one member whose underlying value is zero.</span></span> <span data-ttu-id="dd86b-231">Beispielsweise ist der zugrunde liegende Wert des <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> -Members in <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> der-Gruppe 0 (null) <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> , ebenso wie <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> der-Member in der-Gruppe.</span><span class="sxs-lookup"><span data-stu-id="dd86b-231">For example, the underlying value of the <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> group is zero, as is the <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> group.</span></span> <span data-ttu-id="dd86b-232">Aus diesem Grund müssen Sie die Maske verwenden, bevor Sie diese Werte testen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-232">Because of this, you must use the mask before testing for those values.</span></span> <span data-ttu-id="dd86b-233">Dies wird im Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-233">The example provides an illustration.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="dd86b-234">In den meisten Fällen sind Eigenschaften <xref:System.Type.IsClass%2A>wie<xref:System.Type.IsAutoLayout%2A>, und <xref:System.Type.IsSpecialName%2A> einfacher zu verwenden als Typattribute.</span><span class="sxs-lookup"><span data-stu-id="dd86b-234">For most purposes, properties like <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, and <xref:System.Type.IsSpecialName%2A> are easier to use than type attributes.</span></span>  
  
 <span data-ttu-id="dd86b-235">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Eigenschaft die Attribute der generischen Typdefinition zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-235">If the current <xref:System.Type> represents a constructed generic type, this property returns the attributes of the generic type definition.</span></span> <span data-ttu-id="dd86b-236">Beispielsweise sind die Attribute, die `MyGenericClass<int>` für`MyGenericClass(Of Integer)` (in Visual Basic) zurückgegeben werden `MyGenericClass<T>` ,`MyGenericClass(Of T)` die Attribute von (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="dd86b-236">For example, the attributes returned for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) are the attributes of `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="dd86b-237">, Wenn der <xref:System.Type> aktuelle einen generischen Typparameter darstellt, d. h <xref:System.Type.IsGenericParameter%2A> ., `true` wenn die <xref:System.Reflection.TypeAttributes> -Eigenschaft zurückgibt. der von dieser Eigenschaft zurückgegebene Wert ist nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-237">If the current <xref:System.Type> represents a generic type parameter - that is, if the <xref:System.Type.IsGenericParameter%2A> property returns `true` - the <xref:System.Reflection.TypeAttributes> value returned by this property is unspecified.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-238">Im folgenden Beispiel wird die <xref:System.Type.Attributes%2A> -Eigenschaft verwendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-238">The following example uses the <xref:System.Type.Attributes%2A> property.</span></span>  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-239">Ruft den Typ ab, von dem der aktuelle <see cref="T:System.Type" /> direkt vererbt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-239">Gets the type from which the current <see cref="T:System.Type" /> directly inherits.</span></span></summary>
        <value><span data-ttu-id="dd86b-240">Der <see cref="T:System.Type" />, von dem der aktuelle <see cref="T:System.Type" /> direkt erbt, oder <see langword="null" />, wenn der aktuelle <see langword="Type" /> die <see cref="T:System.Object" />-Klasse oder eine Schnittstelle darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-240">The <see cref="T:System.Type" /> from which the current <see cref="T:System.Type" /> directly inherits, or <see langword="null" /> if the current <see langword="Type" /> represents the <see cref="T:System.Object" /> class or an interface.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-241">Der Basistyp ist der Typ, von dem der aktuelle Typ direkt erbt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-241">The base type is the type from which the current type directly inherits.</span></span> <span data-ttu-id="dd86b-242"><xref:System.Object>ist der einzige Typ, der keinen Basistyp hat und daher `null` als Basistyp von <xref:System.Object>zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-242"><xref:System.Object> is the only type that does not have a base type, therefore `null` is returned as the base type of <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="dd86b-243">Schnittstellen erben von NULL oder mehr Basis Schnittstellen. Daher gibt diese Eigenschaft zurück `null` , wenn `Type` das-Objekt eine-Schnittstelle darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-243">Interfaces inherit from zero or more base interfaces; therefore, this property returns `null` if the `Type` object represents an interface.</span></span> <span data-ttu-id="dd86b-244">Die Basis Schnittstellen können mit <xref:System.Type.GetInterfaces%2A> oder <xref:System.Type.FindInterfaces%2A>bestimmt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-244">The base interfaces can be determined with <xref:System.Type.GetInterfaces%2A> or <xref:System.Type.FindInterfaces%2A>.</span></span>  
  
 <span data-ttu-id="dd86b-245">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt der Basistyp die generischen Argumente wieder.</span><span class="sxs-lookup"><span data-stu-id="dd86b-245">If the current <xref:System.Type> represents a constructed generic type, the base type reflects the generic arguments.</span></span> <span data-ttu-id="dd86b-246">Betrachten Sie beispielsweise die folgenden Deklarationen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-246">For example, consider the following declarations:</span></span>  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="dd86b-247">Für den konstruierten `C<int>` Typ`C(Of Integer)` (in Visual Basic) gibt <xref:System.Type.BaseType%2A> die- `B<int>`Eigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-247">For the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the <xref:System.Type.BaseType%2A> property returns `B<int>`.</span></span>  
  
 <span data-ttu-id="dd86b-248">Wenn der aktuelle <xref:System.Type> einen Typparameter einer generischen Typdefinition darstellt, <xref:System.Type.BaseType%2A> gibt die Klassen Einschränkung zurück, d. h. die Klasse, die der Typparameter erben muss.</span><span class="sxs-lookup"><span data-stu-id="dd86b-248">If the current <xref:System.Type> represents a type parameter of a generic type definition, <xref:System.Type.BaseType%2A> returns the class constraint, that is, the class the type parameter must inherit.</span></span> <span data-ttu-id="dd86b-249">Wenn keine Klassen Einschränkung vorhanden ist, <xref:System.Type.BaseType%2A> wird <xref:System.Object?displayProperty=nameWithType>zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-249">If there is no class constraint, <xref:System.Type.BaseType%2A> returns <xref:System.Object?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="dd86b-250">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-250">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-251">Im folgenden Beispiel wird die Verwendung <xref:System.Type.BaseType%2A> der-Eigenschaft veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-251">The following example demonstrates using the <xref:System.Type.BaseType%2A> property.</span></span>  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 <span data-ttu-id="dd86b-252">Im folgenden Beispiel wird Rekursion verwendet, um die vollständige Vererbungs Hierarchie der einzelnen in einer Assembly gefundenen Klassen aufzulisten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-252">The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly.</span></span> <span data-ttu-id="dd86b-253">Im Beispiel `C` `B`wird eine Klasse mit dem Namen definiert, die von einer Klasse mit dem Namen abgeleitet wird, die wiederum von `A`einer Klasse mit dem Namen abgeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-253">The example defines a class named `C` that derives from a class named `B`, which, in turn, derives from a class named `A`.</span></span>  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="dd86b-254">Reflektion und generische Typen</span><span class="sxs-lookup"><span data-stu-id="dd86b-254">Reflection and Generic Types</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-255">Ruft einen Wert ab, der angibt, ob das aktuelle <see cref="T:System.Type" />-Objekt über Typparameter verfügt, die nicht durch bestimmte Typen ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-255">Gets a value indicating whether the current <see cref="T:System.Type" /> object has type parameters that have not been replaced by specific types.</span></span></summary>
        <value><span data-ttu-id="dd86b-256"><see langword="true" />, wenn das <see cref="T:System.Type" />-Objekt selbst ein generischer Parametertyp ist oder über Typparameter verfügt, für die keine bestimmten Typen angegeben wurden, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-256"><see langword="true" /> if the <see cref="T:System.Type" /> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-257">Um eine Instanz eines Typs zu erstellen, darf es keine generischen Typdefinitionen oder offenen konstruierten Typen in den Typargumenten des Typs selbst, in allen einschließenden generischen Typen oder in beliebigen Elementen des Typs geben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-257">In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.</span></span> <span data-ttu-id="dd86b-258">Eine andere Möglichkeit zu sagen, dass der Typ bei rekursiver unter Prüfung keine generischen Typparameter enthalten muss.</span><span class="sxs-lookup"><span data-stu-id="dd86b-258">Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</span></span>  
  
 <span data-ttu-id="dd86b-259">Da Typen beliebig komplex sein können, ist diese Bestimmung schwierig.</span><span class="sxs-lookup"><span data-stu-id="dd86b-259">Since types can be arbitrarily complex, making this determination is difficult.</span></span> <span data-ttu-id="dd86b-260">Um die Wahrscheinlichkeit von Fehlern zu verringern, stellt die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft eine Standardmethode zur Unterscheidung zwischen geschlossenen konstruierten Typen, die instanziiert werden können, und geöffneten erstellten Typen dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-260">For convenience and to reduce the chance of error, the <xref:System.Type.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.</span></span> <span data-ttu-id="dd86b-261">Wenn die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft `true`zurückgibt, kann der Typ nicht instanziiert werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-261">If the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, the type cannot be instantiated.</span></span>  
  
 <span data-ttu-id="dd86b-262">Die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft sucht rekursiv nach Typparametern.</span><span class="sxs-lookup"><span data-stu-id="dd86b-262">The <xref:System.Type.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="dd86b-263">Er gibt z. b `true` . für ein Array zurück, dessen `A<T>` Elemente`A(Of T)` Type (in Visual Basic) sind, auch wenn das Array nicht selbst generisch ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-263">For example, it returns `true` for an array whose elements are type `A<T>` (`A(Of T)` in Visual Basic), even though the array is not itself generic.</span></span> <span data-ttu-id="dd86b-264">Vergleichen Sie dies mit dem Verhalten <xref:System.Type.IsGenericType%2A> der-Eigenschaft, die für Arrays zurückgibt. `false`</span><span class="sxs-lookup"><span data-stu-id="dd86b-264">Contrast this with the behavior of the <xref:System.Type.IsGenericType%2A> property, which returns `false` for arrays.</span></span>  
  
 <span data-ttu-id="dd86b-265">Eine Reihe von Beispiel Klassen und eine Tabelle mit den Werten <xref:System.Type.ContainsGenericParameters%2A> der-Eigenschaft finden <xref:System.Type.IsGenericType%2A>Sie unter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-265">For a set of example classes and a table showing the values of the <xref:System.Type.ContainsGenericParameters%2A> property, see <xref:System.Type.IsGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-266">Im folgenden Beispiel wird eine generische Klasse mit zwei Typparametern definiert, und anschließend wird eine zweite generische Klasse definiert, die von der ersten Klasse abgeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-266">The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="dd86b-267">Die Basisklasse der abgeleiteten Klasse hat zwei Typargumente: <xref:System.Int32> die erste ist, und die zweite ist ein Typparameter des abgeleiteten Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-267">The derived class's base class has two type arguments: the first is <xref:System.Int32> and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="dd86b-268">Das Beispiel zeigt Informationen zu diesen generischen Klassen, einschließlich der von der <xref:System.Type.GenericParameterPosition%2A> -Eigenschaft gemeldeten Positionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-268">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="dd86b-269">Reflektion und generische Typen</span><span class="sxs-lookup"><span data-stu-id="dd86b-269">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="dd86b-270">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</span><span class="sxs-lookup"><span data-stu-id="dd86b-270">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-271">Ruft eine <see cref="T:System.Reflection.MethodBase" /> ab, die die deklarierende Methode darstellt, wenn der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Methode darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-271">Gets a <see cref="T:System.Reflection.MethodBase" /> that represents the declaring method, if the current <see cref="T:System.Type" /> represents a type parameter of a generic method.</span></span></summary>
        <value><span data-ttu-id="dd86b-272">Wenn der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Methode darstellt, eine <see cref="T:System.Reflection.MethodBase" />, die die deklarierende Methode darstellt, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-272">If the current <see cref="T:System.Type" /> represents a type parameter of a generic method, a <see cref="T:System.Reflection.MethodBase" /> that represents declaring method; otherwise, <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-273">Bei der deklarierenden Methode handelt es sich um eine generische Methoden Definition.</span><span class="sxs-lookup"><span data-stu-id="dd86b-273">The declaring method is a generic method definition.</span></span> <span data-ttu-id="dd86b-274">Das heißt, wenn <xref:System.Type.DeclaringMethod%2A> nicht zurück `null`gibt, `DeclaringMethod.IsGenericMethodDefinition` gibt zurück `true`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-274">That is, if <xref:System.Type.DeclaringMethod%2A> does not return `null`, then `DeclaringMethod.IsGenericMethodDefinition` returns `true`.</span></span>  
  
 <span data-ttu-id="dd86b-275">Die <xref:System.Type.DeclaringType%2A> Eigenschaften <xref:System.Type.DeclaringMethod%2A> und identifizieren die generische Typdefinition oder generische Methoden Definition, in der der generische Typparameter ursprünglich definiert wurde:</span><span class="sxs-lookup"><span data-stu-id="dd86b-275">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="dd86b-276">, Wenn <xref:System.Type.DeclaringMethod%2A> die-Eigenschaft <xref:System.Reflection.MethodInfo>ein- <xref:System.Reflection.MethodInfo> Objekt zurückgibt, das eine generische Methoden Definition <xref:System.Type> darstellt, und das aktuelle-Objekt einen Typparameter dieser generischen Methoden Definition darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-276">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="dd86b-277">Wenn die <xref:System.Type.DeclaringMethod%2A> -Eigenschaft `null`zurückgibt, <xref:System.Type.DeclaringType%2A> gibt die-Eigenschaft <xref:System.Type> immer ein-Objekt zurück, das eine generische Typdefinition darstellt, und das aktuelle <xref:System.Type> -Objekt stellt einen Typparameter dieses generischen Typs dar. Definition.</span><span class="sxs-lookup"><span data-stu-id="dd86b-277">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="dd86b-278">Das erhalten <xref:System.Type.DeclaringMethod%2A> der Eigenschaft für einen Typ <xref:System.Type.IsGenericParameter%2A> , dessen `false` -Eigenschaft <xref:System.InvalidOperationException>eine auslöst.</span><span class="sxs-lookup"><span data-stu-id="dd86b-278">Getting the <xref:System.Type.DeclaringMethod%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="dd86b-279">Der <xref:System.Reflection.MethodBase> , der von der <xref:System.Type.DeclaringMethod%2A> -Eigenschaft zurückgegeben wird <xref:System.Reflection.MethodInfo> , ist im Fall einer generischen Methode ein oder <xref:System.Reflection.ConstructorInfo> ein im Fall eines generischen Konstruktors.</span><span class="sxs-lookup"><span data-stu-id="dd86b-279">The <xref:System.Reflection.MethodBase> that is returned by the <xref:System.Type.DeclaringMethod%2A> property is either a <xref:System.Reflection.MethodInfo> in the case of a generic method, or a <xref:System.Reflection.ConstructorInfo> in the case of a generic constructor.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-280">In der .NET Framework Version 2,0 werden generische Konstruktoren nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-280">In the .NET Framework version 2.0, generic constructors are not supported.</span></span>  
  
 <span data-ttu-id="dd86b-281">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-281">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-282">Im folgenden Codebeispiel wird eine-Klasse definiert, die über eine generische-Methode verfügt, der-Methode ein Typargument zuweist und die resultierende konstruierte generische Methode aufruft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-282">The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method.</span></span> <span data-ttu-id="dd86b-283">Außerdem werden Informationen zur generischen Methoden Definition und der konstruierten Methode angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-283">It also displays information about the generic method definition and the constructed method.</span></span> <span data-ttu-id="dd86b-284">Beim Anzeigen von Informationen über die Typparameter der generischen Methoden Definition zeigt der `DisplayGenericMethodInfo` Beispielcode in der-Methode den Wert <xref:System.Type.DeclaringMethod%2A> der-Eigenschaft für den generischen Typparameter der Methode an.</span><span class="sxs-lookup"><span data-stu-id="dd86b-284">When displaying information about the type parameters of the generic method definition, in the `DisplayGenericMethodInfo` method, the example code shows the value of the <xref:System.Type.DeclaringMethod%2A> property for the method's generic type parameter.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="dd86b-285">Reflektion und generische Typen</span><span class="sxs-lookup"><span data-stu-id="dd86b-285">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="dd86b-286">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</span><span class="sxs-lookup"><span data-stu-id="dd86b-286">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-287">Ruft den Typ ab, der den aktuellen geschachtelten oder generischen Typparameter deklariert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-287">Gets the type that declares the current nested type or generic type parameter.</span></span></summary>
        <value><span data-ttu-id="dd86b-288">Ein <see cref="T:System.Type" />-Objekt, das den einschließenden Typ darstellt, wenn es sich bei dem aktuellen Typ um einen geschachtelten Typ handelt. Die generische Typdefinition, wenn es sich bei dem aktuellen Typ um einen Typparameter eines generischen Typs handelt. Der Typ, der die generische Methode deklariert, wenn es sich bei dem aktuellen Typ um einen Typparameter einer generischen Methode handelt. Andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-288">A <see cref="T:System.Type" /> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-289">Wenn das aktuelle <xref:System.Type> -Objekt einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft die generische Typdefinition zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-289">If the current <xref:System.Type> object represents a type parameter of a generic type, this property returns the generic type definition.</span></span>  
  
 <span data-ttu-id="dd86b-290">Wenn das aktuelle <xref:System.Type> -Objekt einen Typparameter einer generischen Methode darstellt, gibt diese Eigenschaft den Typ zurück, der die generische Methoden Definition enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-290">If the current <xref:System.Type> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.</span></span> <span data-ttu-id="dd86b-291">Wenn der Typ generisch ist, wird die generische Typdefinition zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-291">If the type is generic, the generic type definition is returned.</span></span> <span data-ttu-id="dd86b-292">Das heißt, der folgende Code gibt die generische Typdefinition der <xref:System.Collections.Generic.List%601> generischen-Klasse zurück, die die <xref:System.Collections.Generic.List%601.ConvertAll%2A> generische-Methode enthält:</span><span class="sxs-lookup"><span data-stu-id="dd86b-292">That is, the following code returns the generic type definition of the <xref:System.Collections.Generic.List%601> generic class, which contains the <xref:System.Collections.Generic.List%601.ConvertAll%2A> generic method:</span></span>  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="dd86b-293">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt <xref:System.Type.DeclaringType%2A> , <xref:System.Type.DeclaringMethod%2A> identifizieren die-Eigenschaft und die-Eigenschaft die generische Typdefinition oder generische Methoden Definition, in der der generische Typparameter wurde ursprünglich definiert:</span><span class="sxs-lookup"><span data-stu-id="dd86b-293">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, the <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="dd86b-294">, Wenn <xref:System.Type.DeclaringMethod%2A> die-Eigenschaft <xref:System.Reflection.MethodInfo>ein- <xref:System.Reflection.MethodInfo> Objekt zurückgibt, das eine generische Methoden Definition <xref:System.Type> darstellt, und das aktuelle-Objekt einen Typparameter dieser generischen Methoden Definition darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-294">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="dd86b-295">Wenn die <xref:System.Type.DeclaringMethod%2A> -Eigenschaft `null`zurückgibt, <xref:System.Type.DeclaringType%2A> gibt die-Eigenschaft <xref:System.Type> immer ein-Objekt zurück, das eine generische Typdefinition darstellt, und das aktuelle <xref:System.Type> -Objekt stellt einen Typparameter dieses generischen Typs dar. Definition.</span><span class="sxs-lookup"><span data-stu-id="dd86b-295">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="dd86b-296">Das erhalten <xref:System.Type.DeclaringType%2A> der Eigenschaft für einen Typ <xref:System.Type.IsGenericParameter%2A> , dessen `false` -Eigenschaft <xref:System.InvalidOperationException>eine auslöst.</span><span class="sxs-lookup"><span data-stu-id="dd86b-296">Getting the <xref:System.Type.DeclaringType%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-297">Dieses Beispiel zeigt den deklarierenden Typ einer Methode in einer abgeleiteten Klasse.</span><span class="sxs-lookup"><span data-stu-id="dd86b-297">This example displays the declaring type of a method in a derived class.</span></span>  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-298">Ruft einen Verweis auf den Standardbinder ab, der interne Regeln für die Auswahl der passenden Member implementiert, die von <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> aufgerufen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-298">Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span></summary>
        <value><span data-ttu-id="dd86b-299">Ein Verweis auf den vom System verwendeten Standardbinder.</span><span class="sxs-lookup"><span data-stu-id="dd86b-299">A reference to the default binder used by the system.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-300">Der Standard Binder, der mit dem Common Language Runtime bereitgestellt wird, gilt nur für die spezielleren Umstände.</span><span class="sxs-lookup"><span data-stu-id="dd86b-300">The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.</span></span> <span data-ttu-id="dd86b-301">Wenn Sie einen Binder benötigen, der auf Regeln folgt, die sich von denen des bereitgestellten Standard Binders unterscheiden, definieren <xref:System.Reflection.Binder> Sie einen von der-Klasse abgeleiteten Typ, `binder` und übergeben Sie mithilfe des <xref:System.Type.InvokeMember%2A> -Parameters einer der-über Ladungen eine Instanz dieses Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-301">If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <xref:System.Reflection.Binder> class and pass an instance of that type using the `binder` parameter of one of the <xref:System.Type.InvokeMember%2A> overloads.</span></span>  
  
 <span data-ttu-id="dd86b-302">Reflektion modelliert die Zugriffsregeln für das allgemeine Typsystem.</span><span class="sxs-lookup"><span data-stu-id="dd86b-302">Reflection models the accessibility rules of the common type system.</span></span> <span data-ttu-id="dd86b-303">Wenn sich der Aufrufer z. b. in derselben Assembly befindet, benötigt der Aufrufer keine speziellen Berechtigungen für interne Member.</span><span class="sxs-lookup"><span data-stu-id="dd86b-303">For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</span></span> <span data-ttu-id="dd86b-304">Andernfalls benötigt <xref:System.Security.Permissions.ReflectionPermission>der Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="dd86b-304">Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="dd86b-305">Dies entspricht der Suche nach Elementen, die geschützt, privat sind usw.</span><span class="sxs-lookup"><span data-stu-id="dd86b-305">This is consistent with lookup of members that are protected, private, and so on.</span></span>  
  
 <span data-ttu-id="dd86b-306">Das allgemeine Prinzip ist, <xref:System.Reflection.Binder.ChangeType%2A> dass nur erweiternde Konvertierungen durchführen soll, bei denen Daten niemals verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-306">The general principle is that <xref:System.Reflection.Binder.ChangeType%2A> should perform only widening conversions, which never lose data.</span></span> <span data-ttu-id="dd86b-307">Ein Beispiel für eine erweiternde Konvertierung ist das Konvertieren eines Werts, bei dem es sich um eine 32-Bit-Ganzzahl mit Vorzeichen handelt, in einen Wert, bei dem es sich um eine 64</span><span class="sxs-lookup"><span data-stu-id="dd86b-307">An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</span></span> <span data-ttu-id="dd86b-308">Dies unterscheidet sich von einer einschränkenden Konvertierung, bei der Daten verloren gehen können.</span><span class="sxs-lookup"><span data-stu-id="dd86b-308">This is distinguished from a narrowing conversion, which may lose data.</span></span> <span data-ttu-id="dd86b-309">Ein Beispiel für eine einschränkende Konvertierung ist das Konvertieren einer 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-309">An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</span></span>  
  
 <span data-ttu-id="dd86b-310">In der folgenden Tabelle sind die Konvertierungen aufgeführt, die vom Standard Binder unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-310">The following table lists the conversions supported by the default binder.</span></span>  
  
|<span data-ttu-id="dd86b-311">Quelltyp</span><span class="sxs-lookup"><span data-stu-id="dd86b-311">Source Type</span></span>|<span data-ttu-id="dd86b-312">Zieltyp</span><span class="sxs-lookup"><span data-stu-id="dd86b-312">Target Type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="dd86b-313">Beliebiger Typ</span><span class="sxs-lookup"><span data-stu-id="dd86b-313">Any type</span></span>|<span data-ttu-id="dd86b-314">Der Basistyp.</span><span class="sxs-lookup"><span data-stu-id="dd86b-314">Its base type.</span></span>|  
|<span data-ttu-id="dd86b-315">Beliebiger Typ</span><span class="sxs-lookup"><span data-stu-id="dd86b-315">Any type</span></span>|<span data-ttu-id="dd86b-316">Die Schnittstelle, die implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-316">The interface it implements.</span></span>|  
|<span data-ttu-id="dd86b-317">Char</span><span class="sxs-lookup"><span data-stu-id="dd86b-317">Char</span></span>|<span data-ttu-id="dd86b-318">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="dd86b-318">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="dd86b-319">Byte</span><span class="sxs-lookup"><span data-stu-id="dd86b-319">Byte</span></span>|<span data-ttu-id="dd86b-320">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="dd86b-320">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="dd86b-321">SByte</span><span class="sxs-lookup"><span data-stu-id="dd86b-321">SByte</span></span>|<span data-ttu-id="dd86b-322">Int16, Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="dd86b-322">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="dd86b-323">UInt16</span><span class="sxs-lookup"><span data-stu-id="dd86b-323">UInt16</span></span>|<span data-ttu-id="dd86b-324">UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="dd86b-324">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="dd86b-325">Int16</span><span class="sxs-lookup"><span data-stu-id="dd86b-325">Int16</span></span>|<span data-ttu-id="dd86b-326">Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="dd86b-326">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="dd86b-327">UInt32</span><span class="sxs-lookup"><span data-stu-id="dd86b-327">UInt32</span></span>|<span data-ttu-id="dd86b-328">UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="dd86b-328">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="dd86b-329">Int32</span><span class="sxs-lookup"><span data-stu-id="dd86b-329">Int32</span></span>|<span data-ttu-id="dd86b-330">Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="dd86b-330">Int64, Single, Double</span></span>|  
|<span data-ttu-id="dd86b-331">UInt64</span><span class="sxs-lookup"><span data-stu-id="dd86b-331">UInt64</span></span>|<span data-ttu-id="dd86b-332">Single, Double</span><span class="sxs-lookup"><span data-stu-id="dd86b-332">Single, Double</span></span>|  
|<span data-ttu-id="dd86b-333">Int64</span><span class="sxs-lookup"><span data-stu-id="dd86b-333">Int64</span></span>|<span data-ttu-id="dd86b-334">Single, Double</span><span class="sxs-lookup"><span data-stu-id="dd86b-334">Single, Double</span></span>|  
|<span data-ttu-id="dd86b-335">Single</span><span class="sxs-lookup"><span data-stu-id="dd86b-335">Single</span></span>|<span data-ttu-id="dd86b-336">Double</span><span class="sxs-lookup"><span data-stu-id="dd86b-336">Double</span></span>|  
|<span data-ttu-id="dd86b-337">Nicht Verweis</span><span class="sxs-lookup"><span data-stu-id="dd86b-337">Non-reference</span></span>|<span data-ttu-id="dd86b-338">Nach Verweis.</span><span class="sxs-lookup"><span data-stu-id="dd86b-338">By-reference.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-339">Im folgenden Beispiel wird der Standard Binder aus der `DefaultBinder` -Eigenschaft abgerufen und ein Member von MyClass aufgerufen, indem `DefaultBinder` der-Wert als Parameter <xref:System.Type.InvokeMember%2A>an übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-339">The following example gets the default binder from the `DefaultBinder` property, and invokes a member of MyClass by passing the `DefaultBinder` value as a parameter to <xref:System.Type.InvokeMember%2A>.</span></span>  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-340">Trennt Namen im Namespace des <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-340">Separates names in the namespace of the <see cref="T:System.Type" />.</span></span> <span data-ttu-id="dd86b-341">Dieses Feld ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-341">This field is read-only.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-342">Stellt ein leeres Array vom <see cref="T:System.Type" />-Typ dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-342">Represents an empty array of type <see cref="T:System.Type" />.</span></span> <span data-ttu-id="dd86b-343">Dieses Feld ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-343">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="dd86b-344">Das folgende Codebeispiel zeigt das `EmptyTypes` -Feld, das in einer `GetConstructor` der-Methoden verwendet wird, um einen Konstruktor zu erhalten, der keine Parameter annimmt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-344">The following code example shows the `EmptyTypes` field used in one of the `GetConstructor` methods to get a constructor that takes no parameters.</span></span>  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-345">Bestimmt, ob der zugrunde liegende Systemtyp des aktuellen <see cref="T:System.Type" /> mit dem zugrunde liegende Systemtyp des angegebenen <see cref="T:System.Object" /> oder <see cref="T:System.Type" /> übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-345">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Object" /> or <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="dd86b-346">Das Objekt, dessen zugrunde liegender Systemtyp mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-346">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span></span> <span data-ttu-id="dd86b-347"><paramref name="o" /> muss in ein Objekt vom Typ <see cref="T:System.Type" /> umgewandelt oder konvertiert werden können, damit der Vergleich erfolgreich durchgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-347">For the comparison to succeed, <paramref name="o" /> must be able to be cast or converted to an object of type   <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="dd86b-348">Bestimmt, ob der zugrunde liegende Systemtyp des aktuellen <see cref="T:System.Type" />-Objekts mit dem zugrunde liegenden Systemtyp des angegebenen <see cref="T:System.Object" />-Objekts übereinstimmt</span><span class="sxs-lookup"><span data-stu-id="dd86b-348">Determines if the underlying system type of the current <see cref="T:System.Type" /> object is the same as the underlying system type of the specified <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-349"><see langword="true" />, wenn der zugrunde liegende Systemtyp von <paramref name="o" /> mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-349"><see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="dd86b-350">Diese Methode gibt auch <see langword="false" /> zurück, wenn:</span><span class="sxs-lookup"><span data-stu-id="dd86b-350">This method also returns <see langword="false" /> if: .</span></span>  
  <span data-ttu-id="dd86b-351">
-   <paramref name="o" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-351">
-   <paramref name="o" /> is <see langword="null" />.</span></span>  
  <span data-ttu-id="dd86b-352">
-   <paramref name="o" /> nicht in ein <see cref="T:System.Type" />-Objekt umgewandelt oder konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-352">
-   <paramref name="o" /> cannot be cast or converted to a <see cref="T:System.Type" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-353">Diese Methode überschreibt <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-353">This method overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="dd86b-354">Sie wandelt <xref:System.Type> <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> in ein Objekt vom Typ um und ruft die-Methode auf. `o`</span><span class="sxs-lookup"><span data-stu-id="dd86b-354">It casts `o` to an object of type <xref:System.Type> and calls the <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-355">Im folgenden Beispiel wird <xref:System.Type.Equals%28System.Object%29> verwendet, um <xref:System.Type> verschiedene Objektinstanzen mit <xref:System.Object> verschiedenen-Instanzen zu vergleichen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-355">The following example uses <xref:System.Type.Equals%28System.Object%29> to compare various <xref:System.Type> object instances with various <xref:System.Object> instances.</span></span>  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 <span data-ttu-id="dd86b-356">Zwei Punkte sind besonders erwähnenswert:</span><span class="sxs-lookup"><span data-stu-id="dd86b-356">Two things are particularly worth noting about the example:</span></span>  
  
-   <span data-ttu-id="dd86b-357">Der Vergleich <xref:System.Type> eines-Objekts, das eine Ganzzahl mit <xref:System.Reflection.TypeInfo> einem-Objekt darstellt, das `true` eine ganzzahlige <xref:System.Type>Rückgabe darstellt, da <xref:System.Reflection.TypeInfo> von abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-357">The comparison of a <xref:System.Type> object that represents an integer with a <xref:System.Reflection.TypeInfo> object that represents an integer return `true` because <xref:System.Reflection.TypeInfo> is derived from <xref:System.Type>.</span></span>  
  
-   <span data-ttu-id="dd86b-358">Der Vergleich eines <xref:System.Type> -Objekts, das ein <xref:System.Collections.Generic.IList%601> -Objekt (ein offener generischer Typ) `List(Of String)` mit einem-Objekt (ein geschlossener generischer Typ) darstellt, gibt zurück `false`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-358">The comparison of a  <xref:System.Type> object that represents a <xref:System.Collections.Generic.IList%601> object (an open generic type) with a `List(Of String)` object (a closed generic type) returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="dd86b-359">Das Objekt, dessen zugrunde liegender Systemtyp mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-359">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="dd86b-360">Bestimmt, ob der zugrunde liegende Systemtyp des aktuellen <see cref="T:System.Type" /> mit dem zugrunde liegenden Systemtyp des angegebenen <see cref="T:System.Type" /> übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-360">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-361"><see langword="true" />, wenn der zugrunde liegende Systemtyp von <paramref name="o" /> mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-361"><see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="dd86b-362">Im folgenden Beispiel wird `Equals` verwendet, um zwei Typen zu vergleichen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-362">The following example uses `Equals` to compare two types.</span></span>  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-363">Stellt den für Attribute verwendeten Memberfilter dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-363">Represents the member filter used on attributes.</span></span> <span data-ttu-id="dd86b-364">Dieses Feld ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-364">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-365">Dieses Feld enthält einen Verweis auf den Delegaten, der <xref:System.Type.FindMembers%2A> von der-Methode verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-365">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="dd86b-366">Die von diesem Delegaten gekapselte Methode erfordert zwei Parameter: <xref:System.Reflection.MemberInfo> das erste ist ein-Objekt `Object`, und das zweite ist ein-Objekt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-366">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="dd86b-367">Die-Methode bestimmt, `MemberInfo` ob das-Objekt `Object`mit den von angegebenen Kriterien übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-367">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="dd86b-368">Dem `Object` kann der Wert eines der Felder in den Klassen <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>oder <xref:System.Reflection.MethodImplAttributes>zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-368">The `Object` may be assigned the value of any one of the fields on the classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes>.</span></span>  
  
 <span data-ttu-id="dd86b-369">So kann z. b. der Wert eines Felds aus `FieldAttributes` der Form public zugewiesen werden. `Object`</span><span class="sxs-lookup"><span data-stu-id="dd86b-369">For example, the `Object` can be assigned the value of a field from `FieldAttributes` such as Public.</span></span> <span data-ttu-id="dd86b-370">Wenn der `FilterAttribute` Delegat aufgerufen wird, wird er nur dann zurückgegeben `true` , wenn die durch das `MemberInfo` -Objekt dargestellte Methode in den Metadaten mit dem öffentlichen Feld Attribut versehen wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-370">In that case, when the `FilterAttribute` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object is decorated with the public field attribute in metadata.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-371">Im folgenden Beispiel wird der `FilterAttribute` -Delegat abgerufen, als Parameter an die <xref:System.Type.FindMembers%2A> -Methode übergeben und die angegebenen Elemente und deren Attribute angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-371">The following example gets the `FilterAttribute` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the specified members and their attributes.</span></span>  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-372">Stellt den für Namen verwendeten Memberfilter mit Beachtung der Groß-/Kleinschreibung dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-372">Represents the case-sensitive member filter used on names.</span></span> <span data-ttu-id="dd86b-373">Dieses Feld ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-373">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-374">Dieses Feld enthält einen Verweis auf den Delegaten, der <xref:System.Type.FindMembers%2A> von der-Methode verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-374">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="dd86b-375">Die von diesem Delegaten gekapselte Methode erfordert zwei Parameter: <xref:System.Reflection.MemberInfo> das erste ist ein-Objekt `Object`, und das zweite ist ein-Objekt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-375">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="dd86b-376">Die-Methode bestimmt, `MemberInfo` ob das-Objekt `Object`mit den von angegebenen Kriterien übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-376">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="dd86b-377">Dem `Object` wird ein Zeichen folgen Wert zugewiesen, der möglicherweise ein nachfolgendes "\*"-Platzhalter Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-377">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="dd86b-378">Nur Platzhalter-Zeichen folgen Vergleiche werden unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-378">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="dd86b-379">Dem `Object` kann z. b. der Wert "Byte \*" zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-379">For example, the `Object` may be assigned the value "Byte\*".</span></span> <span data-ttu-id="dd86b-380">Wenn der `FilterName` Delegat aufgerufen wird, wird er nur dann zurückgegeben `true` , wenn die durch das `MemberInfo` -Objekt dargestellte Methode einen Namen hat, der mit "Byte" beginnt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-380">In that case, when the `FilterName` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object has a name that begins with "Byte".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-381">Im folgenden Codebeispiel werden die dem benutzerdefinierten `Application` Typ zugeordneten Methoden abgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-381">The following code example gets the methods associated with the user-defined `Application` type.</span></span>  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-382">Stellt den für Namen verwendeten Memberfilter ohne Beachtung der Groß-/Kleinschreibung dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-382">Represents the case-insensitive member filter used on names.</span></span> <span data-ttu-id="dd86b-383">Dieses Feld ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-383">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-384">Dieses Feld enthält einen Verweis auf den Delegaten, der <xref:System.Type.FindMembers%2A> von der-Methode verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-384">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="dd86b-385">Die von diesem Delegaten gekapselte Methode erfordert zwei Parameter: <xref:System.Reflection.MemberInfo> das erste ist ein-Objekt `Object`, und das zweite ist ein-Objekt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-385">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="dd86b-386">Die-Methode bestimmt, `MemberInfo` ob das-Objekt `Object`mit den von angegebenen Kriterien übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-386">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="dd86b-387">Dem `Object` wird ein Zeichen folgen Wert zugewiesen, der möglicherweise ein nachfolgendes "\*"-Platzhalter Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-387">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="dd86b-388">Nur Platzhalter-Zeichen folgen Vergleiche werden unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-388">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="dd86b-389">Dem `Object` kann z. b. der Wert "ByTe \*" zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-389">For example, the `Object` may be assigned the value "ByTe\*".</span></span> <span data-ttu-id="dd86b-390">Wenn in diesem Fall der `FilterName` Delegat aufgerufen wird, gibt er nur dann true zurück, wenn die durch das `MemberInfo` -Objekt dargestellte Methode einen Namen hat, der mit "Byte" beginnt, und die Groß-/Kleinschreibung ignoriert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-390">In that case, when the `FilterName` delegate is invoked, it will return true only if the method represented by the `MemberInfo` object has a name that begins with "byte", ignoring case.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-391">Das folgende Beispiel ruft den `MemberFilter` Delegaten ab, übergibt ihn als Parameter an <xref:System.Type.FindMembers%2A> die-Methode und zeigt die Methoden `String` und deren Attribute der-Klasse an, die mit dem Buchstaben "c" beginnen, wobei die Groß-/Kleinschreibung nicht beachtet wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-391">The following example gets the `MemberFilter` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the methods and their attributes of the `String` class that begin with the letter "c", disregarding the case.</span></span>  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="filter"><span data-ttu-id="dd86b-392">Der Delegat, der die Schnittstellen anhand der <paramref name="filterCriteria" /> vergleicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-392">The delegate that compares the interfaces against <paramref name="filterCriteria" />.</span></span></param>
        <param name="filterCriteria"><span data-ttu-id="dd86b-393">Die Suchkriterien, die bestimmen, ob eine Schnittstelle in das zurückgegebene Array aufgenommen wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-393">The search criteria that determines whether an interface should be included in the returned array.</span></span></param>
        <summary><span data-ttu-id="dd86b-394">Gibt ein Array von <see cref="T:System.Type" />-Objekten zurück, die eine gefilterte Liste von Schnittstellen darstellen, die vom aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-394">Returns an array of <see cref="T:System.Type" /> objects representing a filtered list of interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-395">Ein Array von <see cref="T:System.Type" />-Objekten, das eine gefilterte Liste von Schnittstellen darstellt, die durch den aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurden, oder ein leeres Array, wenn der aktuelle <see cref="T:System.Type" /> keine dem Filter entsprechende Schnittstellen implementiert oder erbt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-395">An array of <see cref="T:System.Type" /> objects representing a filtered list of the interfaces implemented or inherited by the current <see cref="T:System.Type" />, or an empty array if no interfaces matching the filter are implemented or inherited by the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-396">Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-396">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="dd86b-397">Die <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> - <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> und-Delegaten <xref:System.Reflection.Module?displayProperty=nameWithType> , die von der-Klasse bereitgestellt werden, <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> können auch anstelle des Delegaten verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-397">The <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> and <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegates supplied by the <xref:System.Reflection.Module?displayProperty=nameWithType> class may also be used, in lieu of the <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegate.</span></span>  
  
 <span data-ttu-id="dd86b-398">Alle von dieser Klasse implementierten Schnittstellen werden während der Suche berücksichtigt, unabhängig davon, ob Sie von einer Basisklasse oder dieser Klasse deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-398">All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</span></span>  
  
 <span data-ttu-id="dd86b-399">Diese Methode durchsucht die Basisklassen Hierarchie und gibt alle übereinstimmenden Schnittstellen zurück, die von jeder Klasse implementiert werden, sowie alle übereinstimmenden Schnittstellen, die diese Schnittstellen implementieren (das heißt, die transitiv Schließung der übereinstimmenden Schnittstellen wird zurückgegeben).</span><span class="sxs-lookup"><span data-stu-id="dd86b-399">This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).</span></span> <span data-ttu-id="dd86b-400">Doppelte Schnittstellen werden nicht zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-400">No duplicate interfaces are returned.</span></span>  
  
 <span data-ttu-id="dd86b-401">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode <xref:System.Type.FindInterfaces%2A> darstellt, durchsucht alle Schnittstellen, die in den Einschränkungen für den Typparameter deklariert sind, und alle Schnittstellen, die über die Schnittstellen geerbt wurden. in den Einschränkungen deklariert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-401">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, <xref:System.Type.FindInterfaces%2A> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.</span></span> <span data-ttu-id="dd86b-402">Wenn der aktuelle <xref:System.Type> ein Typargument eines generischen Typs <xref:System.Type.FindInterfaces%2A> darstellt, durchsucht alle durch den Typ implementierten Schnittstellen, unabhängig davon, ob diese Einschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-402">If the current <xref:System.Type> represents a type argument of a generic type, <xref:System.Type.FindInterfaces%2A> searches all the interfaces implemented by the type, whether or not they match constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-403"><xref:System.Type.FindInterfaces%2A>kann generische Schnittstellen zurückgeben, auch bei Typen, die nicht generisch sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-403"><xref:System.Type.FindInterfaces%2A> can return generic interfaces, even on types that are not generic.</span></span> <span data-ttu-id="dd86b-404">Beispielsweise kann ein nicht generischer Typ ( `IEnumerable<int>` `IEnumerable(Of Integer)` in Visual Basic) implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-404">For example, a nongeneric type might implement `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-405">Im folgenden Beispiel wird die angegebene, vom angegebenen Typ implementierte oder geerbte Schnittstelle gesucht, und dann werden die Schnittstellennamen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-405">The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.</span></span>  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-406"><paramref name="filter" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-406"><paramref name="filter" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="dd86b-407">Ein statischer Initialisierer wird aufgerufen und löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-407">A static initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="memberType"><span data-ttu-id="dd86b-408">Eine bitweise Kombination von Enumerationswerten, die angibt, welcher Membertyp gesucht werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-408">A bitwise combination of the enumeration values that indicates the type of member to search for.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="dd86b-409">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-409">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-410">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-410">-or-</span></span> 
 <span data-ttu-id="dd86b-411"><see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-411"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="filter"><span data-ttu-id="dd86b-412">Der Delegat, der die Vergleiche durchführt. Der Rückgabewert ist <see langword="true" />, wenn der gerade betrachtete Member den <paramref name="filterCriteria" /> entspricht, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-412">The delegate that does the comparisons, returning <see langword="true" /> if the member currently being inspected matches the <paramref name="filterCriteria" /> and <see langword="false" /> otherwise.</span></span></param>
        <param name="filterCriteria"><span data-ttu-id="dd86b-413">Die Suchkriterien, die bestimmen, ob ein Member im Array von <see langword="MemberInfo" />-Objekten zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-413">The search criteria that determines whether a member is returned in the array of <see langword="MemberInfo" /> objects.</span></span>  
  
<span data-ttu-id="dd86b-414">Die Felder von <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> und <see langword="MethodImplAttributes" /> können zusammen mit dem <see langword="FilterAttribute" />-Delegaten dieser Klasse verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-414">The fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> can be used in conjunction with the <see langword="FilterAttribute" /> delegate supplied by this class.</span></span></param>
        <summary><span data-ttu-id="dd86b-415">Gibt ein gefiltertes Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten mit dem angegebenen Membertyp zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-415">Returns a filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-416">Ein gefiltertes Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten vom angegebenen Membertyp.</span><span class="sxs-lookup"><span data-stu-id="dd86b-416">A filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span></span>  
  
<span data-ttu-id="dd86b-417">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-417">-or-</span></span> 
<span data-ttu-id="dd86b-418">Ein leeres Array, wenn der aktuelle <see cref="T:System.Type" /> keine den Filterkriterien entsprechenden Member vom <paramref name="memberType" />-Typ besitzt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-418">An empty array if the current <see cref="T:System.Type" /> does not have members of type <paramref name="memberType" /> that match the filter criteria.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="dd86b-419">Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-419">This method can be overridden by a derived class.</span></span>  
  
<span data-ttu-id="dd86b-420">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse usw.</span><span class="sxs-lookup"><span data-stu-id="dd86b-420">Members include properties, methods, fields, events, and so on.</span></span>  

<span data-ttu-id="dd86b-421">Damit die `FindMembers` -Methode Element Informationen erfolgreich abrufen kann, `bindingAttr` muss das-Argument mindestens einen von <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>sowie mindestens einen von <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>enthalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-421">For the `FindMembers` method to successfully retrieve member information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> 

 <span data-ttu-id="dd86b-422">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Elemente in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-422">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-423">Geben `BindingFlags.Instance` Sie an, um Instanzmember in die Suche einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-423">Specify `BindingFlags.Instance` to include instance members in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-424">Geben `BindingFlags.Static` Sie an, dass statische Member in die Suche einbezogen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-424">Specify `BindingFlags.Static` to include static members in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-425">Geben `BindingFlags.Public` Sie an, dass öffentliche Member in die Suche einbezogen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-425">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-426">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Member in die Suche eingeschlossen werden sollen (d. h. private, interne und geschützte Member).</span><span class="sxs-lookup"><span data-stu-id="dd86b-426">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
 <span data-ttu-id="dd86b-427">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-427">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="dd86b-428">`BindingFlags.DeclaredOnly`, um nur die Member zu durchsuchen <xref:System.Type>, die auf dem deklariert sind, nicht Elemente, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-428">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="dd86b-429">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-429">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
<span data-ttu-id="dd86b-430">Um mithilfe dieser Methode den Klasseninitialisierer (statischer Konstruktor) zu erhalten, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> müssen<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> Sie ( &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-430">To get the class initializer (static constructor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="dd86b-431">Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A> -Eigenschaft erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-431">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
<span data-ttu-id="dd86b-432">Wenn der aktuelle <xref:System.Type> einen Typparameter eines generischen Typs oder einer generischen Methode <xref:System.Type.FindMembers%2A> darstellt, verarbeitet alle Member, die von der Klassen Einschränkung deklariert werden, und die Schnittstellen Einschränkungen des Typparameters.</span><span class="sxs-lookup"><span data-stu-id="dd86b-432">If the current <xref:System.Type> represents a type parameter of a generic type or generic method, <xref:System.Type.FindMembers%2A> processes any members declared by the class constraint and the interface constraints of the type parameter.</span></span>  

<span data-ttu-id="dd86b-433">Das `filter` Argument kann ein benutzerdefinierter Delegat vom <xref:System.Reflection.MemberFilter>Typ sein, oder es kann sich um einen der folgenden vordefinierten Delegaten handeln:</span><span class="sxs-lookup"><span data-stu-id="dd86b-433">The `filter` argument can be a custom delegate of type <xref:System.Reflection.MemberFilter>, or it can be one of the following  predefined delegates:</span></span>

- <span data-ttu-id="dd86b-434"><xref:System.Type.FilterAttribute?displayProperty=nameWithType>, das eine<xref:System.Reflection.FieldAttributes>-, <xref:System.Reflection.MethodAttributes>-oder <xref:System.Reflection.MethodImplAttributes> -Bitmaske `filterCriteria` als-Wert verwendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-434"><xref:System.Type.FilterAttribute?displayProperty=nameWithType>, which uses a<xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes> bitmask as the `filterCriteria` value.</span></span>

- <span data-ttu-id="dd86b-435"><xref:System.Type.FilterName?displayProperty=nameWithType>, bei dem ein Vergleich der einzelnen Elementnamen mit Berücksichtigung der `filterCriteria`groß-und Kleinschreibung durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-435"><xref:System.Type.FilterName?displayProperty=nameWithType>, which performs a case-sensitive comparison of each member name with the string passed to `filterCriteria`.</span></span>

- <span data-ttu-id="dd86b-436"><xref:System.Type.FilterNameIgnoreCase?displayProperty=nameWithType>, der einen Vergleich der einzelnen Elementnamen ohne Beachtung der Groß-und Kleinschreibung mit `filterCriteria`der an übergebenen Zeichenfolge ausführt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-436"><xref:System.Type.FilterNameIgnoreCase?displayProperty=nameWithType>, which performs a case-insensitive comparison of each member name with the string passed to `filterCriteria`.</span></span>

## Examples  
 <span data-ttu-id="dd86b-437">Im folgenden Beispiel werden alle Member einer Klasse gesucht, die den angegebenen Suchkriterien entsprechen, und anschließend werden die übereinstimmenden Member angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-437">The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.</span></span>  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-438"><paramref name="filter" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-438"><paramref name="filter" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-439">Ruft den voll vollqualifizierten Namen des Typs ab. Dies beinhaltet den Namespace, nicht jedoch die Assembly.</span><span class="sxs-lookup"><span data-stu-id="dd86b-439">Gets the fully qualified name of the type, including its namespace but not its assembly.</span></span></summary>
        <value><span data-ttu-id="dd86b-440">Der vollqualifizierte Name des Typs, einschließlich des Namespace, jedoch ausschließlich der Assembly, oder <see langword="null" />, wenn die aktuelle Instanz einen auf einem Typparameter basierenden generischen Typparameter, Arraytyp, Zeigertyp oder <see langword="byref" />-Typ oder einen generischen Typ darstellt, der keine generische Typdefinition ist, jedoch nicht aufgelöste Typparameter enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-440">The fully qualified name of the type, including its namespace but not its assembly; or <see langword="null" /> if the current instance represents a generic type parameter, an array type, pointer type, or <see langword="byref" /> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-441">Beispielsweise lautet <xref:System.String> `System.String`der voll qualifizierte Name des Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-441">For example, the fully qualified name of the <xref:System.String> type is `System.String`.</span></span> <span data-ttu-id="dd86b-442">Vergleichen Sie dies mit dem von der <xref:System.Type.AssemblyQualifiedName%2A> -Eigenschaft zurückgegebenen assemblyqualifizierten Namen, der aus dem vollständigen Namen und dem vollständigen Assemblynamen besteht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-442">Contrast this with the assembly-qualified name returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, which consists of the full name plus the full assembly name.</span></span>  
  
 <span data-ttu-id="dd86b-443">Wenn der aktuelle Typ einen geschlossenen generischen Typ darstellt, werden die Typargumente in der <xref:System.Type.FullName%2A> Zeichenfolge, die von der-Eigenschaft zurückgegeben wird, durch den vollständigen Assemblynamen qualifiziert, auch wenn die Zeichen folgen Darstellung des generischen Typs selbst nicht durch den vollständigen AssemblyName.</span><span class="sxs-lookup"><span data-stu-id="dd86b-443">If the current type represents a closed generic type, the type arguments in the string returned by the <xref:System.Type.FullName%2A> property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.</span></span> <span data-ttu-id="dd86b-444">Das folgende Beispiel veranschaulicht den Unterschied in der FullName-Eigenschaft für einen Typ, der die generische Typdefinition darstellt, und einen Typ, der einen geschlossenen generischen Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-444">The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.</span></span>  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 <span data-ttu-id="dd86b-445">Diese Eigenschaft gibt `null` zurück, wenn:</span><span class="sxs-lookup"><span data-stu-id="dd86b-445">This property returns `null` if:</span></span>  
  
-   <span data-ttu-id="dd86b-446">Das aktuelle <xref:System.Type> -Objekt stellt einen Typparameter eines generischen Typs dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-446">The current <xref:System.Type> object represents a type parameter of a generic type.</span></span>  
  
     <span data-ttu-id="dd86b-447">Im folgenden Beispiel wird der Typparameter des <xref:System.Nullable%601> Typs abgerufen, und es <xref:System.Type.FullName%2A> wird versucht, die zugehörige-Eigenschaft anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-447">The following example retrieves the type parameter of the <xref:System.Nullable%601> type and attempts to display its <xref:System.Type.FullName%2A> property.</span></span>  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   <span data-ttu-id="dd86b-448">Das aktuelle <xref:System.Type> -Objekt stellt einen Arraytyp, einen Zeigertyp `byref` oder einen Typ dar, der auf einem generischen Typparameter basiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-448">The current <xref:System.Type> object represents an array type, a pointer  type, or a `byref` type that is based on a generic type parameter.</span></span>  
  
     <span data-ttu-id="dd86b-449">Im folgenden Beispiel wird ein generischer Typ `Generictype1<T>`,, mit drei Methoden `Display(T[])`definiert:, einem Array vom Typ T; , dem ein t-Objekt und ein t `ChangeValue(ref T)`-Objekt als Verweis übermittelt werden. `HandleT(T)`</span><span class="sxs-lookup"><span data-stu-id="dd86b-449">The following example defines a generic type, `Generictype1<T>`, with three methods: `Display(T[])`, which is passed an array of type T; `HandleT(T)`, which is passed a T object; and `ChangeValue(ref T)`, which is passed a T object by reference.</span></span> <span data-ttu-id="dd86b-450">Da C# in und Visual Basic T nicht als Zeiger in der `HandleT` -Methode definiert werden kann, muss die <xref:System.Type.MakePointerType%2A> -Methode für das <xref:System.Type> Objekt, das den Parametertyp der Methode darstellt, aufgerufen werden, um einen Zeiger auf einen generischen Typ zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-450">Because C# and Visual Basic do not allow us to define T as a pointer in the `HandleT` method, we have to call the <xref:System.Type.MakePointerType%2A> method on the <xref:System.Type> object that represents the method's parameter type to create a pointer to a generic type.</span></span> <span data-ttu-id="dd86b-451">Die Ausgabe des Beispiels zeigt, dass die- <xref:System.Type.FullName%2A> `null`Eigenschaft in allen drei Fällen den Wert hat.</span><span class="sxs-lookup"><span data-stu-id="dd86b-451">The output from the example shows that in all three cases, the <xref:System.Type.FullName%2A> property is `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   <span data-ttu-id="dd86b-452">Der aktuelle Typ enthält generische Typparameter, die nicht durch bestimmte Typen ersetzt wurden (d. h. <xref:System.Type.ContainsGenericParameters%2A> , die `true`-Eigenschaft gibt zurück), aber der Typ ist keine generische Typdefinition (d <xref:System.Type.IsGenericTypeDefinition%2A> . h., die-Eigenschaft gibt zurück).`false`</span><span class="sxs-lookup"><span data-stu-id="dd86b-452">The current type contains generic type parameters that have not been replaced by specific types (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`), but the type is not a generic type definition (that is, the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `false`</span></span>  
  
     <span data-ttu-id="dd86b-453">Im folgenden Beispiel `Derived<T>` erbt von `Base<T>`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-453">In the following example, `Derived<T>` inherits from `Base<T>`.</span></span> <span data-ttu-id="dd86b-454">Die <xref:System.Type.BaseType%2A> -Eigenschaft ruft <xref:System.Type> das-Objekt ab, das den `Derived<T>` <xref:System.Type.FullName%2A> Basistyp von darstellt, `null`und die-Eigenschaft gibt zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-454">The <xref:System.Type.BaseType%2A> property obtains the  <xref:System.Type> object that represents the base type of `Derived<T>`, and its <xref:System.Type.FullName%2A> property returns `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     <span data-ttu-id="dd86b-455">Um einen <xref:System.Type.FullName%2A> -Wert zu erhalten `null`, der nicht ist <xref:System.Type.GetGenericTypeDefinition%2A> , können Sie die-Methode verwenden, um die generische Typdefinition zu erhalten, wie im Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-455">To get a <xref:System.Type.FullName%2A> that is not `null`, you can use the <xref:System.Type.GetGenericTypeDefinition%2A> method to get the generic type definition, as the example illustrates.</span></span>  
  
 <span data-ttu-id="dd86b-456">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-456">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-457">Im folgenden Beispiel wird der vollständige Name des angegebenen Typs angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-457">The following example displays the full name of the specified type.</span></span>  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 <span data-ttu-id="dd86b-458">Im folgenden Beispiel werden die von <xref:System.Type.ToString%2A> der-Methode zurückgegebenen Zeichen folgen und die <xref:System.Type.AssemblyQualifiedName%2A> `Name`Eigenschaften, <xref:System.Type.FullName%2A>und verglichen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-458">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="dd86b-459">Angeben vollständig gekennzeichneter Typnamen</span><span class="sxs-lookup"><span data-stu-id="dd86b-459">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-460">Ruft eine Kombination von <see cref="T:System.Reflection.GenericParameterAttributes" />-Flags ab, die die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters beschreiben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-460">Gets a combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> flags that describe the covariance and special constraints of the current generic type parameter.</span></span></summary>
        <value><span data-ttu-id="dd86b-461">Eine bitweise Kombination von <see cref="T:System.Reflection.GenericParameterAttributes" />-Werten, die die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters beschreiben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-461">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-462">Der Wert dieser Eigenschaft enthält Flags, die beschreiben, ob der aktuelle generische Typparameter kovariant ist, und Flags, die alle besonderen Einschränkungen beschreiben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-462">The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.</span></span> <span data-ttu-id="dd86b-463">Verwenden Sie <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> den Wert, um die Kovarianz Flags auszuwählen, <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> und verwenden Sie den Wert, um die Einschränkungs Flags auszuwählen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-463">Use the <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> value to select the covariance flags, and use the <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> value to select the constraint flags.</span></span>  
  
 <span data-ttu-id="dd86b-464">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-464">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-465">Im folgenden Codebeispiel wird ein generischer `Test` Typ mit zwei Typparametern definiert, die unterschiedliche Einschränkungen aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-465">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="dd86b-466">Wenn das Programm ausgeführt wird, werden die Einschränkungen mithilfe der <xref:System.Type.GenericParameterAttributes%2A> -Eigenschaft und <xref:System.Type.GetGenericParameterConstraints%2A> der-Methode untersucht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-466">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd86b-467">Das aktuelle <see cref="T:System.Type" />-Objekt ist kein generischer Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-467">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span></span> <span data-ttu-id="dd86b-468">Das bedeutet, dass die <see cref="P:System.Type.IsGenericParameter" />-Eigenschaft <see langword="false" /> zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-468">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd86b-469">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-469">The invoked method is not supported in the base class.</span></span></exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="dd86b-470">Reflektion und generische Typen</span><span class="sxs-lookup"><span data-stu-id="dd86b-470">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="dd86b-471">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</span><span class="sxs-lookup"><span data-stu-id="dd86b-471">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-472">Ruft die Position des Typparameters in der Typparameterliste des generischen Typs oder der Methode ab, der bzw. die den Parameter deklariert hat, wenn das <see cref="T:System.Type" />-Objekt einen Typparameter eines generischen Typs oder einer generischen Methode darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-472">Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <see cref="T:System.Type" /> object represents a type parameter of a generic type or a generic method.</span></span></summary>
        <value><span data-ttu-id="dd86b-473">Die Position eines Typparameters in der Typparameterliste des generischen Typs oder der generischen Methode, der bzw. die den Parameter definiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-473">The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.</span></span> <span data-ttu-id="dd86b-474">Die Positionsnummern beginnen mit 0.</span><span class="sxs-lookup"><span data-stu-id="dd86b-474">Position numbers begin at 0.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-475">Die <xref:System.Type.GenericParameterPosition%2A> -Eigenschaft gibt die Position eines Typparameters in der Parameterliste der generischen Typdefinition oder der generischen Methoden Definition zurück, in der der Typparameter ursprünglich definiert wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-475">The <xref:System.Type.GenericParameterPosition%2A> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.</span></span> <span data-ttu-id="dd86b-476">Die <xref:System.Type.DeclaringType%2A> Eigenschaften <xref:System.Type.DeclaringMethod%2A> und identifizieren den generischen Typ oder die Definition der Methode:</span><span class="sxs-lookup"><span data-stu-id="dd86b-476">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type or method definition:</span></span>  
  
-   <span data-ttu-id="dd86b-477">, Wenn <xref:System.Type.DeclaringMethod%2A> die-Eigenschaft <xref:System.Reflection.MethodInfo>ein- <xref:System.Reflection.MethodInfo> Objekt zurückgibt, das eine generische Methoden Definition <xref:System.Type> darstellt, und das aktuelle-Objekt einen Typparameter dieser generischen Methoden Definition darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-477">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="dd86b-478">Wenn die <xref:System.Type.DeclaringMethod%2A> -Eigenschaft `null`zurückgibt, <xref:System.Type.DeclaringType%2A> gibt die-Eigenschaft <xref:System.Type> immer ein-Objekt zurück, das eine generische Typdefinition darstellt, und das aktuelle <xref:System.Type> -Objekt stellt einen Typparameter dieses generischen Typs dar. Definition.</span><span class="sxs-lookup"><span data-stu-id="dd86b-478">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
 <span data-ttu-id="dd86b-479">Um den korrekten Kontext für den Wert der <xref:System.Type.GenericParameterPosition%2A> -Eigenschaft bereitzustellen, müssen Sie den generischen Typ oder die Methode identifizieren, zu der ein Typparameter gehört.</span><span class="sxs-lookup"><span data-stu-id="dd86b-479">To provide the correct context for the value of the <xref:System.Type.GenericParameterPosition%2A> property, it is necessary to identify the generic type or method a type parameter belongs to.</span></span> <span data-ttu-id="dd86b-480">Sehen Sie sich beispielsweise den Rückgabewert der generischen `GetSomething` -Methode im folgenden Code an:</span><span class="sxs-lookup"><span data-stu-id="dd86b-480">For example, consider the return value of the generic method `GetSomething` in the following code:</span></span>  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 <span data-ttu-id="dd86b-481">Der Typ, der `GetSomething` von zurückgegeben wird, hängt von den `A` Typargumenten ab, die für die Klasse und `GetSomething`</span><span class="sxs-lookup"><span data-stu-id="dd86b-481">The type returned by `GetSomething` depends on the type arguments supplied to class `A` and to `GetSomething` itself.</span></span> <span data-ttu-id="dd86b-482">Sie können einen <xref:System.Reflection.MethodInfo> für `GetSomething`und den Rückgabetyp abrufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-482">You can obtain a <xref:System.Reflection.MethodInfo> for `GetSomething`, and from that you can obtain the return type.</span></span> <span data-ttu-id="dd86b-483">Wenn Sie die Typparameter des Rückgabe Typs überprüfen, <xref:System.Type.GenericParameterPosition%2A> gibt 0 für beides zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-483">When you examine the type parameters of the return type, <xref:System.Type.GenericParameterPosition%2A> returns 0 for both.</span></span> <span data-ttu-id="dd86b-484">Die Position von `V` ist 0, `V` da der erste Typparameter in der Typparameter Liste für die `A`-Klasse ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-484">The position of `V` is 0 because `V` is the first type parameter in the type parameter list for class `A`.</span></span> <span data-ttu-id="dd86b-485">Die Position von `X` ist 0, `X` da der erste Typparameter in der Typparameter Liste für `GetSomething`ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-485">The position of `X` is 0 because `X` is the first type parameter in the type parameter list for `GetSomething`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-486">Wenn Sie <xref:System.Type.GenericParameterPosition%2A> die-Eigenschaft aufrufen, wird eine <xref:System.Type> Ausnahme ausgelöst, wenn der aktuelle keinen Typparameter darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-486">Calling the <xref:System.Type.GenericParameterPosition%2A> property causes an exception if the current <xref:System.Type> does not represent a type parameter.</span></span> <span data-ttu-id="dd86b-487">Wenn Sie die Typargumente eines geöffneten konstruierten Typs überprüfen <xref:System.Type.IsGenericParameter%2A> , verwenden Sie die-Eigenschaft, um zu ermitteln, welche Typparameter und welche Typen sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-487">When you examine the type arguments of an open constructed type, use the <xref:System.Type.IsGenericParameter%2A> property to tell which are type parameters and which are types.</span></span> <span data-ttu-id="dd86b-488">Die <xref:System.Type.IsGenericParameter%2A> -Eigenschaft `true` gibt für einen Typparameter zurück. Sie können dann <xref:System.Type.GenericParameterPosition%2A> die-Methode verwenden, um Ihre Position <xref:System.Type.DeclaringMethod%2A> abzurufen <xref:System.Type.DeclaringType%2A> , und die-Eigenschaft und die-Eigenschaft verwenden, um die generische Methode oder Typdefinition zu bestimmen .</span><span class="sxs-lookup"><span data-stu-id="dd86b-488">The <xref:System.Type.IsGenericParameter%2A> property returns `true` for a type parameter; you can then use the <xref:System.Type.GenericParameterPosition%2A> method to obtain its position and use the <xref:System.Type.DeclaringMethod%2A> and <xref:System.Type.DeclaringType%2A> properties to determine the generic method or type definition that defines it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-489">Im folgenden Beispiel wird eine generische Klasse mit zwei Typparametern definiert und eine zweite generische Klasse definiert, die von der ersten Klasse abgeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-489">The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="dd86b-490">Die Basisklasse der abgeleiteten Klasse hat zwei Typargumente: <xref:System.Int32>die erste ist, und die zweite ist ein Typparameter des abgeleiteten Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-490">The derived class's base class has two type arguments: the first is <xref:System.Int32>, and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="dd86b-491">Das Beispiel zeigt Informationen zu diesen generischen Klassen, einschließlich der von der <xref:System.Type.GenericParameterPosition%2A> -Eigenschaft gemeldeten Positionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-491">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd86b-492">Der aktuelle Typ stellt keinen Typparameter dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-492">The current type does not represent a type parameter.</span></span> <span data-ttu-id="dd86b-493">Das heißt, <see cref="P:System.Type.IsGenericParameter" /> gibt <see langword="false" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-493">That is, <see cref="P:System.Type.IsGenericParameter" /> returns <see langword="false" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="dd86b-494">Reflektion und generische Typen</span><span class="sxs-lookup"><span data-stu-id="dd86b-494">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="dd86b-495">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</span><span class="sxs-lookup"><span data-stu-id="dd86b-495">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-496">Ruft ein Array von generischen Typargumenten für diesen Typ ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-496">Gets an array of the generic type arguments for this type.</span></span></summary>
        <value><span data-ttu-id="dd86b-497">Ein Array von generischen Typargumenten für diesen Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-497">An array of the generic type arguments for this type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-498">Diese Eigenschaft ruft nur die generischen Typargumente ab. Das heißt, die Typen, die für die generischen Typparameter des aktuellen Typs angegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-498">This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.</span></span> <span data-ttu-id="dd86b-499">Wenn es sich bei dem aktuellen Typ um eine generische Typdefinition handelt, gibt diese Eigenschaft ein leeres Array zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-499">If the current type is a generic type definition, this property returns an empty array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-500">Wenn ein generischer Typ in einer generischen Methode oder einem anderen generischen Typ verwendet wird, sind einige seiner generischen Typargumente möglicherweise generische Typparameter der einschließenden Methode oder des einschließenden Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-500">If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.</span></span>  
  
 <span data-ttu-id="dd86b-501">Verwenden Sie die <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> -Eigenschaft, um die generischen Typparameter eines Typs zu erhalten, der eine generische Typdefinition darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-501">To get the generic type parameters of a type that represents a generic type definition, use the <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="dd86b-502">Um ein <xref:System.Reflection.TypeInfo> -Objekt für das aktuelle <xref:System.Type> -Objekt zu erhalten <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> , verwenden Sie die-Erweiterungsmethode.</span><span class="sxs-lookup"><span data-stu-id="dd86b-502">To get a <xref:System.Reflection.TypeInfo> object for the current <xref:System.Type> object, use the <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> extension method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-503">Ruft die Anzahl der Dimensionen eines Arrays ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-503">Gets the number of dimensions in an array.</span></span></summary>
        <returns><span data-ttu-id="dd86b-504">Eine Ganzzahl, die die Anzahl der Dimensionen im aktuellen Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-504">An integer that contains the number of dimensions in the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="dd86b-505">Im folgenden Beispiel wird die Anzahl der Dimensionen in einem Array angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-505">The following example displays the number of dimensions in an array.</span></span>  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd86b-506">Die Funktionalität dieser Methode wird in der Basisklasse nicht unterstützt und muss stattdessen in einer abgeleiteten Klasse implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-506">The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-507">Der aktuelle Typ ist kein Array.</span><span class="sxs-lookup"><span data-stu-id="dd86b-507">The current type is not an array.</span></span></exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-508">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.Attributes" />-Eigenschaft und ruft eine bitweise Kombination von Enumerationswerten ab, die die <see cref="T:System.Type" /> zugeordneten Attribute anzeigen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-508">When overridden in a derived class, implements the <see cref="P:System.Type.Attributes" /> property and gets a bitwise combination of enumeration values that indicate the attributes associated with the <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-509">Ein <see cref="T:System.Reflection.TypeAttributes" />-Objekt, das die Attributgruppe von <see cref="T:System.Type" /> darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-509">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-510">Ruft einen bestimmten Konstruktor des aktuellen <see cref="T:System.Type" /> ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-510">Gets a specific constructor of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="types"><span data-ttu-id="dd86b-511">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter des abzurufenden Konstruktors darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-511">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the desired constructor.</span></span>  
  
<span data-ttu-id="dd86b-512">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-512">-or-</span></span> 
<span data-ttu-id="dd86b-513">Ein leeres Array von <see cref="T:System.Type" />-Objekten zum Abrufen eines Konstruktors ohne Parameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-513">An empty array of <see cref="T:System.Type" /> objects, to get a constructor that takes no parameters.</span></span> <span data-ttu-id="dd86b-514">Das <see langword="static" />-Feld <see cref="F:System.Type.EmptyTypes" /> stellt ein entsprechendes leeres Array bereit.</span><span class="sxs-lookup"><span data-stu-id="dd86b-514">Such an empty array is provided by the <see langword="static" /> field <see cref="F:System.Type.EmptyTypes" />.</span></span></param>
        <summary><span data-ttu-id="dd86b-515">Sucht einen öffentlichen Instanzkonstruktor, dessen Parameter den Typen im angegebenen Array entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-515">Searches for a public instance constructor whose parameters match the types in the specified array.</span></span></summary>
        <returns><span data-ttu-id="dd86b-516">Ein Objekt, das den öffentlichen Instanzkonstruktor darstellt, dessen Parameter den Typen im Parametertyparray entsprechen, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-516">An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-517">Diese Methoden Überladung sucht nach öffentlichen Instanzkonstruktoren und kann nicht verwendet werden, um einen Klasseninitialisierer (statischer Konstruktor) abzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-517">This method overload looks for public instance constructors and cannot be used to obtain a class initializer (static constructor).</span></span> <span data-ttu-id="dd86b-518">Um einen Klasseninitialisierer zu erhalten, verwenden Sie eine <xref:System.Reflection.BindingFlags>Überladung, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> die<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> annimmt und ( &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) angibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-518">To get a class initializer, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="dd86b-519">Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A> -Eigenschaft erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-519">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="dd86b-520">Wenn der angeforderte Konstruktor nicht öffentlich ist, gibt diese Methode `null`zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-520">If the requested constructor is non-public, this method returns `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-521">Sie können Parameter nicht weglassen, wenn Sie Konstruktoren und Methoden suchen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-521">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="dd86b-522">Beim Aufrufen von können Sie nur Parameter weglassen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-522">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="dd86b-523">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.ConstructorInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-523">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="dd86b-524">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `null`Methode immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-524">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-525">Im folgenden Beispiel wird der Typ von `MyClass`abgerufen, das <xref:System.Reflection.ConstructorInfo> -Objekt abgerufen und die Konstruktorsignatur angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-525">The following example obtains the type of `MyClass`, gets the <xref:System.Reflection.ConstructorInfo> object, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-526"><paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-526"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-527">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-527">-or-</span></span> 
<span data-ttu-id="dd86b-528">Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-528">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-529"><paramref name="types" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-529"><paramref name="types" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="dd86b-530">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-530">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-531">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-531">-or-</span></span> 
 <span data-ttu-id="dd86b-532"><see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-532"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="dd86b-533">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span><span class="sxs-lookup"><span data-stu-id="dd86b-533">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="dd86b-534">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-534">-or-</span></span> 
<span data-ttu-id="dd86b-535">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-535">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="types"><span data-ttu-id="dd86b-536">Ein Array von <see cref="T:System.Type" />-Objekten, das Anzahl, Reihenfolge und Typ der Parameter des abzurufenden Konstruktors darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-536">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="dd86b-537">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-537">-or-</span></span> 
<span data-ttu-id="dd86b-538">Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-538">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span>  
  
<span data-ttu-id="dd86b-539">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-539">-or-</span></span> 
 <span data-ttu-id="dd86b-540"><see cref="F:System.Type.EmptyTypes" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-540"><see cref="F:System.Type.EmptyTypes" />.</span></span></param>
        <param name="modifiers"><span data-ttu-id="dd86b-541">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im Parametertyparray zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-541">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the parameter type array.</span></span> <span data-ttu-id="dd86b-542">Der Standardbinder verarbeitet diesen Parameter nicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-542">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="dd86b-543">Sucht einen Konstruktor, dessen Parameter unter Verwendung der angegebenen Bindungseinschränkungen den angegebenen Argumenttypen und -modifizierern entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-543">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="dd86b-544">Ein <see cref="T:System.Reflection.ConstructorInfo" />-Objekt, das den Konstruktor darstellt, der den angegebenen Anforderungen entspricht, oder <see langword="null" />, wenn kein entsprechender Konstruktor gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-544">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-545">Wenn keine genaue Entsprechung vorhanden ist, versucht `binder` , die `types` im Array angegebenen Parametertypen umzuleiten, damit eine Entsprechung ausgewählt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-545">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="dd86b-546">Wenn keine Entsprechung ausgewählt `null` werden kann, wird zurückgegeben. `binder`</span><span class="sxs-lookup"><span data-stu-id="dd86b-546">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="dd86b-547">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Konstruktoren in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-547">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-548">Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-548">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="dd86b-549">Geben `BindingFlags.Public` Sie an, um öffentliche Konstruktoren in die Suche einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-549">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-550">Geben `BindingFlags.NonPublic` Sie an, um nicht öffentliche Konstruktoren (d. h. private, interne und geschützte Konstruktoren) in die Suche einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-550">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="dd86b-551">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-551">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="dd86b-552">Um den Klasseninitialisierer (statischer Konstruktor) mithilfe dieser Methoden Überladung zu erhalten <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> ,<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> müssen Sie ( &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-552">To get the class initializer (static constructor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="dd86b-553">Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A> -Eigenschaft erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-553">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-554">Sie können Parameter nicht weglassen, wenn Sie Konstruktoren und Methoden suchen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-554">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="dd86b-555">Beim Aufrufen von können Sie nur Parameter weglassen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-555">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="dd86b-556">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.ConstructorInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-556">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="dd86b-557">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `null`Methode immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-557">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-558">Das folgende Programm ruft den Typ der `MyClass1` Klasse ab, ruft <xref:System.Reflection.ConstructorInfo> das Objekt ab, das mit den angegebenen Bindungsflags übereinstimmt, und zeigt die Signatur des Konstruktors an.</span><span class="sxs-lookup"><span data-stu-id="dd86b-558">The following program obtains the type of `MyClass1` class, gets the <xref:System.Reflection.ConstructorInfo> object matching the specified binding flags, and displays the signature of the constructor.</span></span>  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-559"><paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-559"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-560">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-560">-or-</span></span> 
<span data-ttu-id="dd86b-561">Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-561">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-562"><paramref name="types" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-562"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="dd86b-563">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-563">-or-</span></span> 
 <span data-ttu-id="dd86b-564"><paramref name="modifiers" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-564"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="dd86b-565">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-565">-or-</span></span> 
 <span data-ttu-id="dd86b-566"><paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</span><span class="sxs-lookup"><span data-stu-id="dd86b-566"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="dd86b-567">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-567">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-568">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-568">-or-</span></span> 
 <span data-ttu-id="dd86b-569"><see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-569"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="dd86b-570">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span><span class="sxs-lookup"><span data-stu-id="dd86b-570">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="dd86b-571">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-571">-or-</span></span> 
<span data-ttu-id="dd86b-572">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-572">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="dd86b-573">Das Objekt, das die Regeln für die Reihenfolge und das Layout von Argumenten, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-573">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="dd86b-574">Ein Array von <see cref="T:System.Type" />-Objekten, das Anzahl, Reihenfolge und Typ der Parameter des abzurufenden Konstruktors darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-574">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="dd86b-575">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-575">-or-</span></span> 
<span data-ttu-id="dd86b-576">Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-576">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="dd86b-577">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-577">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="dd86b-578">Der Standardbinder verarbeitet diesen Parameter nicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-578">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="dd86b-579">Sucht einen Konstruktor, dessen Parameter den angegebenen Argumenttypen und -modifizierern entsprechen, und berücksichtigt dabei die angegebenen Bindungseinschränkungen und die angegebene Aufrufkonvention.</span><span class="sxs-lookup"><span data-stu-id="dd86b-579">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="dd86b-580">Ein Objekt, das den Konstruktor darstellt, der den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-580">An object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-581">Obwohl der Standard <xref:System.Reflection.ParameterModifier> Binder nicht verarbeitet (der `modifiers` -Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> -Klasse verwenden, um einen benutzerdefinierten Binder zu `modifiers`schreiben, der verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-581">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="dd86b-582">`ParameterModifier`wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-582">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="dd86b-583">Wenn keine genaue Entsprechung vorhanden ist, versucht `binder` , die `types` im Array angegebenen Parametertypen umzuleiten, damit eine Entsprechung ausgewählt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-583">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="dd86b-584">Wenn keine Entsprechung ausgewählt `null` werden kann, wird zurückgegeben. `binder`</span><span class="sxs-lookup"><span data-stu-id="dd86b-584">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="dd86b-585">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Konstruktoren in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-585">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-586">Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-586">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="dd86b-587">Geben `BindingFlags.Public` Sie an, um öffentliche Konstruktoren in die Suche einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-587">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-588">Geben `BindingFlags.NonPublic` Sie an, um nicht öffentliche Konstruktoren (d. h. private, interne und geschützte Konstruktoren) in die Suche einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-588">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="dd86b-589">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-589">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="dd86b-590">Um mithilfe dieser Methode den Klasseninitialisierer (statischer Konstruktor) zu erhalten, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> müssen<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> Sie ( &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-590">To get the class initializer (static constructor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="dd86b-591">Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A> -Eigenschaft erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-591">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="dd86b-592">In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-592">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="dd86b-593">Memberart</span><span class="sxs-lookup"><span data-stu-id="dd86b-593">Member Type</span></span>|<span data-ttu-id="dd86b-594">Statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-594">Static</span></span>|<span data-ttu-id="dd86b-595">Nicht statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-595">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="dd86b-596">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="dd86b-596">Constructor</span></span>|<span data-ttu-id="dd86b-597">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-597">No</span></span>|<span data-ttu-id="dd86b-598">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-598">No</span></span>|  
|<span data-ttu-id="dd86b-599">Feld</span><span class="sxs-lookup"><span data-stu-id="dd86b-599">Field</span></span>|<span data-ttu-id="dd86b-600">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-600">No</span></span>|<span data-ttu-id="dd86b-601">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-601">Yes.</span></span> <span data-ttu-id="dd86b-602">Ein Feld wird immer nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-602">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-603">event</span><span class="sxs-lookup"><span data-stu-id="dd86b-603">Event</span></span>|<span data-ttu-id="dd86b-604">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-604">Not applicable</span></span>|<span data-ttu-id="dd86b-605">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-605">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-606">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-606">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-607">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-607">See note 2 below.</span></span>|  
|<span data-ttu-id="dd86b-608">Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-608">Method</span></span>|<span data-ttu-id="dd86b-609">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-609">No</span></span>|<span data-ttu-id="dd86b-610">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-610">Yes.</span></span> <span data-ttu-id="dd86b-611">Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-611">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-612">Der Typ "Typ"</span><span class="sxs-lookup"><span data-stu-id="dd86b-612">Nested Type</span></span>|<span data-ttu-id="dd86b-613">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-613">No</span></span>|<span data-ttu-id="dd86b-614">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-614">No</span></span>|  
|<span data-ttu-id="dd86b-615">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="dd86b-615">Property</span></span>|<span data-ttu-id="dd86b-616">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-616">Not applicable</span></span>|<span data-ttu-id="dd86b-617">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-617">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-618">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-618">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-619">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-619">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="dd86b-620">"Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-620">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="dd86b-621">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-621">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="dd86b-622">Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-622">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-623">Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-623">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="dd86b-624">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="dd86b-624">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-625">Sie können Parameter nicht weglassen, wenn Sie Konstruktoren und Methoden suchen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-625">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="dd86b-626">Beim Aufrufen von können Sie nur Parameter weglassen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-626">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="dd86b-627">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.ConstructorInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-627">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="dd86b-628">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `null`Methode immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-628">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-629">Im folgenden Beispiel wird der Typ von `MyClass1`abgerufen, das <xref:System.Reflection.ConstructorInfo> -Objekt abgerufen, das mit den angegebenen Bindungsflags übereinstimmt, und die Konstruktorsignatur wird angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-629">The following example obtains the type of `MyClass1`, gets the <xref:System.Reflection.ConstructorInfo> object that matches the specified binding flags, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-630"><paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-630"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-631">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-631">-or-</span></span> 
<span data-ttu-id="dd86b-632">Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-632">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-633"><paramref name="types" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-633"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="dd86b-634">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-634">-or-</span></span> 
 <span data-ttu-id="dd86b-635"><paramref name="modifiers" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-635"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="dd86b-636">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-636">-or-</span></span> 
 <span data-ttu-id="dd86b-637"><paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</span><span class="sxs-lookup"><span data-stu-id="dd86b-637"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="dd86b-638">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-638">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-639">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-639">-or-</span></span> 
<span data-ttu-id="dd86b-640"><see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-640"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="dd86b-641">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span><span class="sxs-lookup"><span data-stu-id="dd86b-641">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="dd86b-642">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-642">-or-</span></span> 
<span data-ttu-id="dd86b-643">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-643">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="dd86b-644">Das Objekt, das die Regeln für die Reihenfolge und das Layout von Argumenten, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-644">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="dd86b-645">Ein Array von <see cref="T:System.Type" />-Objekten, das Anzahl, Reihenfolge und Typ der Parameter des abzurufenden Konstruktors darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-645">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="dd86b-646">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-646">-or-</span></span> 
<span data-ttu-id="dd86b-647">Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-647">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="dd86b-648">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-648">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="dd86b-649">Der Standardbinder verarbeitet diesen Parameter nicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-649">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="dd86b-650">Sucht beim Überschreiben in einer abgeleiteten Klasse, unter Verwendung der angegebenen Bindungseinschränkungen und der angegebenen Aufrufkonvention, nach einem Konstruktor, dessen Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-650">When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="dd86b-651">Ein <see cref="T:System.Reflection.ConstructorInfo" />-Objekt, das den Konstruktor darstellt, der den angegebenen Anforderungen entspricht, oder <see langword="null" />, wenn kein entsprechender Konstruktor gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-651">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-652">Obwohl der Standard <xref:System.Reflection.ParameterModifier> Binder nicht verarbeitet (der `modifiers` -Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> -Klasse verwenden, um einen benutzerdefinierten Binder zu `modifiers`schreiben, der verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-652">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="dd86b-653">`ParameterModifier`wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-653">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="dd86b-654">Wenn keine genaue Entsprechung vorhanden ist, versucht `binder` , die `types` im Array angegebenen Parametertypen umzuleiten, damit eine Entsprechung ausgewählt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-654">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="dd86b-655">Wenn keine Entsprechung ausgewählt `null` werden kann, wird zurückgegeben. `binder`</span><span class="sxs-lookup"><span data-stu-id="dd86b-655">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="dd86b-656">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Konstruktoren in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-656">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-657">Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-657">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="dd86b-658">Geben `BindingFlags.Public` Sie an, um öffentliche Konstruktoren in die Suche einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-658">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-659">Geben `BindingFlags.NonPublic` Sie an, um nicht öffentliche Konstruktoren (d. h. private, interne und geschützte Konstruktoren) in die Suche einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-659">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="dd86b-660">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-660">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="dd86b-661">Diese Methode implementiert <xref:System.Type.GetConstructor%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-661">This method implements <xref:System.Type.GetConstructor%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-662"><paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-662"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-663">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-663">-or-</span></span> 
<span data-ttu-id="dd86b-664">Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-664">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-665"><paramref name="types" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-665"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="dd86b-666">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-666">-or-</span></span> 
 <span data-ttu-id="dd86b-667"><paramref name="modifiers" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-667"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="dd86b-668">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-668">-or-</span></span> 
 <span data-ttu-id="dd86b-669"><paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</span><span class="sxs-lookup"><span data-stu-id="dd86b-669"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd86b-670">Der aktuelle Typ ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" /> oder <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-670">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-671">Ruft die Konstruktoren des aktuellen <see cref="T:System.Type" /> ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-671">Gets the constructors of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-672">Gibt alle öffentlichen Konstruktoren zurück, die für den aktuellen <see cref="T:System.Type" /> definiert sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-672">Returns all the public constructors defined for the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-673">Ein Array von <see cref="T:System.Reflection.ConstructorInfo" /> -Objekten, die alle für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Instanzkonstruktoren mit Ausnahme des Typinitialisierers (statischer Konstruktor) darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-673">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all the public instance constructors defined for the current <see cref="T:System.Type" />, but not including the type initializer (static constructor).</span></span> <span data-ttu-id="dd86b-674">Wenn für den aktuellen <see cref="T:System.Type" /> keine öffentlichen Instanzkonstruktoren definiert sind oder der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Typ- oder Methodendefinition darstellt, wird ein leeres Array vom Typ <see cref="T:System.Reflection.ConstructorInfo" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-674">If no public instance constructors are defined for the current <see cref="T:System.Type" />, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-675">Die <xref:System.Type.GetConstructors%2A> Methode gibt keine Konstruktoren in einer bestimmten Reihenfolge zurück, z. b. in der Reihenfolge der Deklaration</span><span class="sxs-lookup"><span data-stu-id="dd86b-675">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="dd86b-676">Der Code darf nicht von der Reihenfolge abhängen, in der Konstruktoren zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-676">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="dd86b-677">In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-677">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="dd86b-678">Memberart</span><span class="sxs-lookup"><span data-stu-id="dd86b-678">Member Type</span></span>|<span data-ttu-id="dd86b-679">Statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-679">Static</span></span>|<span data-ttu-id="dd86b-680">Nicht statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-680">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="dd86b-681">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="dd86b-681">Constructor</span></span>|<span data-ttu-id="dd86b-682">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-682">No</span></span>|<span data-ttu-id="dd86b-683">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-683">No</span></span>|  
|<span data-ttu-id="dd86b-684">Feld</span><span class="sxs-lookup"><span data-stu-id="dd86b-684">Field</span></span>|<span data-ttu-id="dd86b-685">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-685">No</span></span>|<span data-ttu-id="dd86b-686">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-686">Yes.</span></span> <span data-ttu-id="dd86b-687">Ein Feld wird immer nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-687">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-688">event</span><span class="sxs-lookup"><span data-stu-id="dd86b-688">Event</span></span>|<span data-ttu-id="dd86b-689">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-689">Not applicable</span></span>|<span data-ttu-id="dd86b-690">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-690">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-691">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-691">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-692">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-692">See note 2 below.</span></span>|  
|<span data-ttu-id="dd86b-693">Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-693">Method</span></span>|<span data-ttu-id="dd86b-694">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-694">No</span></span>|<span data-ttu-id="dd86b-695">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-695">Yes.</span></span> <span data-ttu-id="dd86b-696">Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-696">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-697">Der Typ "Typ"</span><span class="sxs-lookup"><span data-stu-id="dd86b-697">Nested Type</span></span>|<span data-ttu-id="dd86b-698">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-698">No</span></span>|<span data-ttu-id="dd86b-699">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-699">No</span></span>|  
|<span data-ttu-id="dd86b-700">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="dd86b-700">Property</span></span>|<span data-ttu-id="dd86b-701">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-701">Not applicable</span></span>|<span data-ttu-id="dd86b-702">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-702">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-703">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-703">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-704">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-704">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="dd86b-705">"Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-705">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="dd86b-706">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-706">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="dd86b-707">Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-707">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-708">Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-708">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="dd86b-709">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="dd86b-709">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="dd86b-710">Diese Methoden Überladung ruft <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> die-Methoden Überladung<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> mit &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> (`Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in Visual Basic) auf.</span><span class="sxs-lookup"><span data-stu-id="dd86b-710">This method overload calls the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="dd86b-711">Klasseninitialisierer (statischer Konstruktor) werden nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-711">It will not find class initializers (static constructor).</span></span> <span data-ttu-id="dd86b-712">Um Klasseninitialisierer zu finden, verwenden Sie eine <xref:System.Reflection.BindingFlags>Überladung, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> die<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> annimmt und ( &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) angibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-712">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="dd86b-713">Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A> -Eigenschaft erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-713">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="dd86b-714">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.ConstructorInfo> Methode die Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-714">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="dd86b-715">Wenn z. b. `C<T>` die Klasse über einen `C(T t1)` Konstruktor (`Sub New(ByVal t1 As T)` in Visual Basic `C(int t1)` ) <xref:System.Type.GetConstructors%2A> verfügt `C<int>` , gibt <xref:System.Reflection.ConstructorInfo> der Aufruf von C# für`Sub New(ByVal t1 As Integer)` einen zurück, der in (in Visual Standard).</span><span class="sxs-lookup"><span data-stu-id="dd86b-715">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="dd86b-716">Wenn der aktuelle <xref:System.Type> einen generischen Typparameter darstellt, <xref:System.Type.GetConstructors%2A> gibt die Methode ein leeres Array zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-716">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-717">Dieses Beispiel zeigt die Ausgabe der über <xref:System.Type.GetConstructors%2A> Ladung von einer Klasse, die über zwei Instanzkonstruktoren und einen statischen Konstruktor verfügt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-717">This example shows the output of the <xref:System.Type.GetConstructors%2A> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="dd86b-718">Die Ausgabe dieses Codes lautet wie folgt:</span><span class="sxs-lookup"><span data-stu-id="dd86b-718">The output of this code is:</span></span>  
  
 <span data-ttu-id="dd86b-719">2</span><span class="sxs-lookup"><span data-stu-id="dd86b-719">2</span></span>  
  
 <span data-ttu-id="dd86b-720">False</span><span class="sxs-lookup"><span data-stu-id="dd86b-720">False</span></span>  
  
 <span data-ttu-id="dd86b-721">False</span><span class="sxs-lookup"><span data-stu-id="dd86b-721">False</span></span>  
  
 <span data-ttu-id="dd86b-722">Da die <xref:System.Type.GetConstructors> -Überladung <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> nur <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>und verwendet, wird der `for` statische Konstruktor weder vom Ausdruck gezählt noch von `IsStatic`ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-722">Because the <xref:System.Type.GetConstructors> overload uses only <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="dd86b-723">Um statische Konstruktoren zu finden, verwenden <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> Sie die-Überladung, und übergeben Sie die <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>Kombination ( <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>logisch `OR`) von, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>,,, wie im folgenden Codebeispiel gezeigt:</span><span class="sxs-lookup"><span data-stu-id="dd86b-723">To find static constructors, use the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> overload, and pass the combination (logical `OR`) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="dd86b-724">Nun lautet die Ausgabe wie folgt:</span><span class="sxs-lookup"><span data-stu-id="dd86b-724">Now the output is:</span></span>  
  
 <span data-ttu-id="dd86b-725">3</span><span class="sxs-lookup"><span data-stu-id="dd86b-725">3</span></span>  
  
 <span data-ttu-id="dd86b-726">False</span><span class="sxs-lookup"><span data-stu-id="dd86b-726">False</span></span>  
  
 <span data-ttu-id="dd86b-727">True</span><span class="sxs-lookup"><span data-stu-id="dd86b-727">True</span></span>  
  
 <span data-ttu-id="dd86b-728">False</span><span class="sxs-lookup"><span data-stu-id="dd86b-728">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="dd86b-729">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-729">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-730">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-730">-or-</span></span> 
<span data-ttu-id="dd86b-731"><see cref="F:System.Reflection.BindingFlags.Default" />, um ein leeres Array zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-731"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="dd86b-732">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen <see cref="T:System.Type" /> die für den aktuellen <see langword="BindingFlags" /> definierten Konstruktoren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-732">When overridden in a derived class, searches for the constructors defined for the current <see cref="T:System.Type" />, using the specified <see langword="BindingFlags" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-733">Ein Array von <see cref="T:System.Reflection.ConstructorInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten Konstruktoren, einschließlich eines ggf. definierten Typinitialisierers, darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-733">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all constructors defined for the current <see cref="T:System.Type" /> that match the specified binding constraints, including the type initializer if it is defined.</span></span> <span data-ttu-id="dd86b-734">Gibt ein leeres Array vom Typ <see cref="T:System.Reflection.ConstructorInfo" /> zurück, wenn für den aktuellen <see cref="T:System.Type" /> keine Konstruktoren definiert sind, keiner der definierten Konstruktoren den Bindungseinschränkungen entspricht oder der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Typ- oder Methodendefinition darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-734">Returns an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> if no constructors are defined for the current <see cref="T:System.Type" />, if none of the defined constructors match the binding constraints, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="dd86b-735">`bindingAttr`kann verwendet werden, um anzugeben, ob nur öffentliche Konstruktoren oder sowohl öffentliche als auch nicht öffentliche Konstruktoren zurückgegeben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-735">`bindingAttr` can be used to specify whether to return only public constructors or both public and non-public constructors.</span></span>  
  
<span data-ttu-id="dd86b-736">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Konstruktoren in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-736">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
- <span data-ttu-id="dd86b-737">Geben `BindingFlags.Static` Sie zusammen `BindingFlags.NonPublic` mit an, um den Klasseninitialisierer (statischer Konstruktor) abzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-737">Specify `BindingFlags.Static` along with `BindingFlags.NonPublic` to retrieve the class initializer (static constructor).</span></span> <span data-ttu-id="dd86b-738">Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A> -Eigenschaft erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-738">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>

- <span data-ttu-id="dd86b-739">Geben `BindingFlags.Instance` Sie zusammen mit einem oder beiden `BindingFlags.Public` und `BindingFlags.NonPublic` zum Abrufen von Instanzkonstruktoren an.</span><span class="sxs-lookup"><span data-stu-id="dd86b-739">Specify `BindingFlags.Instance` along with one or both of `BindingFlags.Public` and `BindingFlags.NonPublic` to retrieve instance constructors.</span></span>   
  
<span data-ttu-id="dd86b-740">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-740">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  

<span data-ttu-id="dd86b-741">Die <xref:System.Type.GetConstructors%2A> Methode gibt keine Konstruktoren in einer bestimmten Reihenfolge zurück, z. b. in der Reihenfolge der Deklaration</span><span class="sxs-lookup"><span data-stu-id="dd86b-741">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="dd86b-742">Der Code darf nicht von der Reihenfolge abhängen, in der Konstruktoren zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-742">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  

<span data-ttu-id="dd86b-743">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.ConstructorInfo> Methode die Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-743">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="dd86b-744">Wenn z. b. `C<T>` die Klasse über einen `C(T t1)` Konstruktor (`Sub New(ByVal t1 As T)` in Visual Basic `C(int t1)` ) <xref:System.Type.GetConstructors%2A> verfügt `C<int>` , gibt <xref:System.Reflection.ConstructorInfo> der Aufruf von C# für`Sub New(ByVal t1 As Integer)` einen zurück, der in (in Visual Standard).</span><span class="sxs-lookup"><span data-stu-id="dd86b-744">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
<span data-ttu-id="dd86b-745">Wenn der aktuelle <xref:System.Type> einen generischen Typparameter darstellt, <xref:System.Type.GetConstructors%2A> gibt die Methode ein leeres Array zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-745">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
## Examples  

<span data-ttu-id="dd86b-746">Dieses Beispiel zeigt die Ausgabe der über <xref:System.Type.GetConstructors> Ladung von einer Klasse, die über zwei Instanzkonstruktoren und einen statischen Konstruktor verfügt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-746">This example shows the output of the <xref:System.Type.GetConstructors> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="dd86b-747">Die Ausgabe dieses Codes lautet wie folgt:</span><span class="sxs-lookup"><span data-stu-id="dd86b-747">The output of this code is:</span></span>  
  
 <span data-ttu-id="dd86b-748">2</span><span class="sxs-lookup"><span data-stu-id="dd86b-748">2</span></span>  
  
 <span data-ttu-id="dd86b-749">False</span><span class="sxs-lookup"><span data-stu-id="dd86b-749">False</span></span>  
  
 <span data-ttu-id="dd86b-750">False</span><span class="sxs-lookup"><span data-stu-id="dd86b-750">False</span></span>  
  
 <span data-ttu-id="dd86b-751">Da die <xref:System.Type.GetConstructors%2A> -Überladung <xref:System.Reflection.BindingFlags.Public> nur <xref:System.Reflection.BindingFlags.Instance>und verwendet, wird der `for` statische Konstruktor weder vom Ausdruck gezählt noch von `IsStatic`ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-751">Because the <xref:System.Type.GetConstructors%2A> overload uses only <xref:System.Reflection.BindingFlags.Public> and <xref:System.Reflection.BindingFlags.Instance>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="dd86b-752">Wenn Sie statische Konstruktoren suchen möchten, <xref:System.Type.GetConstructors%2A> verwenden Sie die-Überladung, und übergeben Sie die Kombi <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>Nation (logisches <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>or) von, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>,,, wie im folgenden Codebeispiel gezeigt:</span><span class="sxs-lookup"><span data-stu-id="dd86b-752">To find static constructors, use the <xref:System.Type.GetConstructors%2A> overload, and pass it the combination (logical OR) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="dd86b-753">Nun lautet die Ausgabe wie folgt:</span><span class="sxs-lookup"><span data-stu-id="dd86b-753">Now the output is:</span></span>  
  
 <span data-ttu-id="dd86b-754">3</span><span class="sxs-lookup"><span data-stu-id="dd86b-754">3</span></span>  
  
 <span data-ttu-id="dd86b-755">False</span><span class="sxs-lookup"><span data-stu-id="dd86b-755">False</span></span>  
  
 <span data-ttu-id="dd86b-756">True</span><span class="sxs-lookup"><span data-stu-id="dd86b-756">True</span></span>  
  
 <span data-ttu-id="dd86b-757">False</span><span class="sxs-lookup"><span data-stu-id="dd86b-757">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-758">Sucht nach den für den aktuellen <see cref="T:System.Type" /> definierten Membern, deren <see cref="T:System.Reflection.DefaultMemberAttribute" /> festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-758">Searches for the members defined for the current <see cref="T:System.Type" /> whose <see cref="T:System.Reflection.DefaultMemberAttribute" /> is set.</span></span></summary>
        <returns><span data-ttu-id="dd86b-759">Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die alle Standardmember des aktuellen <see cref="T:System.Type" /> darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-759">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all default members of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="dd86b-760">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-760">-or-</span></span> 
<span data-ttu-id="dd86b-761">Ein leeres Array vom <see cref="T:System.Reflection.MemberInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Standardmember besitzt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-761">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have default members.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-762">Die <xref:System.Type.GetDefaultMembers%2A> -Methode gibt keine Member in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklaration.</span><span class="sxs-lookup"><span data-stu-id="dd86b-762">The <xref:System.Type.GetDefaultMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="dd86b-763">Der Code darf nicht von der Reihenfolge abhängen, in der Elemente zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-763">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="dd86b-764">Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-764">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="dd86b-765">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse usw.</span><span class="sxs-lookup"><span data-stu-id="dd86b-765">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="dd86b-766">In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-766">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="dd86b-767">Memberart</span><span class="sxs-lookup"><span data-stu-id="dd86b-767">Member Type</span></span>|<span data-ttu-id="dd86b-768">Statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-768">Static</span></span>|<span data-ttu-id="dd86b-769">Nicht statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-769">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="dd86b-770">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="dd86b-770">Constructor</span></span>|<span data-ttu-id="dd86b-771">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-771">No</span></span>|<span data-ttu-id="dd86b-772">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-772">No</span></span>|  
|<span data-ttu-id="dd86b-773">Feld</span><span class="sxs-lookup"><span data-stu-id="dd86b-773">Field</span></span>|<span data-ttu-id="dd86b-774">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-774">No</span></span>|<span data-ttu-id="dd86b-775">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-775">Yes.</span></span> <span data-ttu-id="dd86b-776">Ein Feld wird immer nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-776">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-777">event</span><span class="sxs-lookup"><span data-stu-id="dd86b-777">Event</span></span>|<span data-ttu-id="dd86b-778">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-778">Not applicable</span></span>|<span data-ttu-id="dd86b-779">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-779">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-780">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-780">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-781">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-781">See note 2 below.</span></span>|  
|<span data-ttu-id="dd86b-782">Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-782">Method</span></span>|<span data-ttu-id="dd86b-783">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-783">No</span></span>|<span data-ttu-id="dd86b-784">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-784">Yes.</span></span> <span data-ttu-id="dd86b-785">Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-785">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-786">Der Typ "Typ"</span><span class="sxs-lookup"><span data-stu-id="dd86b-786">Nested Type</span></span>|<span data-ttu-id="dd86b-787">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-787">No</span></span>|<span data-ttu-id="dd86b-788">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-788">No</span></span>|  
|<span data-ttu-id="dd86b-789">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="dd86b-789">Property</span></span>|<span data-ttu-id="dd86b-790">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-790">Not applicable</span></span>|<span data-ttu-id="dd86b-791">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-791">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-792">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-792">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-793">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-793">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="dd86b-794">"Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-794">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="dd86b-795">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-795">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="dd86b-796">Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-796">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-797">Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-797">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="dd86b-798">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="dd86b-798">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="dd86b-799">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.MemberInfo> Methode die Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-799">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="dd86b-800">Wenn z. b. `C<T>` die-Klasse `P` eine-Eigenschaft aufweist, die zurück C# gibt`Property P As Integer` `T`, gibt der Aufruf <xref:System.Type.GetDefaultMembers%2A> von `C<int>` in (in Visual Basic) zurück `int P` .</span><span class="sxs-lookup"><span data-stu-id="dd86b-800">For example, if class `C<T>` has a property `P` that returns `T`, calling <xref:System.Type.GetDefaultMembers%2A> on `C<int>` returns `int P` in C# (`Property P As Integer` in Visual Basic).</span></span>  
  
 <span data-ttu-id="dd86b-801">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Member der Klassen Einschränkung oder die Member <xref:System.Object> von, wenn keine Klassen Einschränkung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-801">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-802">Im folgenden Beispiel werden die Standardelement Informationen von `MyClass` abgerufen und die Standardmember angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-802">The following example obtains the default member information of `MyClass` and displays the default members.</span></span>  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-803">Gibt beim Überschreiben in einer abgeleiteten Klasse den <see cref="T:System.Type" /> des Objekts zurück, das der aktuelle Array-, Zeiger- oder Verweistyp einschließt bzw. auf das er verweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-803">When overridden in a derived class, returns the <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or reference type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-804">Der <see cref="T:System.Type" /> des eingeschlossenen Objekts bzw. des Objekts, auf das durch den aktuellen Array-, Zeiger- oder Verweistyp verwiesen wird, oder <see langword="null" />, wenn der aktuelle <see cref="T:System.Type" /> kein Array oder Zeiger ist, nicht als Verweis übergeben wurde oder einen generischen Typ oder Typparameter einer generischen Typ- oder Methodendefinition darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-804">The <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer, or reference type, or <see langword="null" /> if the current <see cref="T:System.Type" /> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-805">Diese Methode gibt `null` für die <xref:System.Array> -Klasse zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-805">This method returns `null` for the <xref:System.Array> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-806">Im folgenden Beispiel wird die Verwendung `GetElementType` der-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-806">The following example demonstrates using the `GetElementType` method.</span></span>  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dd86b-807">Der Wert, dessen Name abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-807">The value whose name is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="dd86b-808">Gibt den Namen der Konstanten für den aktuellen Enumerationstyp zurück, die den angegebenen Wert aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-808">Returns the name of the constant that has the specified value, for the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-809">Der Name des Members des aktuellen Enumerationstyps, der über den angegebenen Wert verfügt, oder<see langword="null" />, wenn keine solche Konstante gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-809">The name of the member of the current enumeration type that has the specified value, or <see langword="null" /> if no such constant is found.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-810">Der aktuelle Typ ist keine Enumeration.</span><span class="sxs-lookup"><span data-stu-id="dd86b-810">The current type is not an enumeration.</span></span>  
  
<span data-ttu-id="dd86b-811">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-811">-or-</span></span> 
 <span data-ttu-id="dd86b-812"><paramref name="value" /> ist nicht vom aktuellen Typ und weist auch nicht den gleichen zugrunde liegenden Typ wie der aktuelle Typ auf.</span><span class="sxs-lookup"><span data-stu-id="dd86b-812"><paramref name="value" /> is neither of the current type nor does it have the same underlying type as the current type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-813"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-813"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-814">Gibt die Namen der Member des aktuellen Enumerationstyps zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-814">Returns the names of the members of the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-815">Ein Array, das die Namen der Member der Enumeration enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-815">An array that contains the names of the members of the enumeration.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-816">Die Elemente des Rückgabewert Arrays werden nach den binären Werten (d. h. den nicht signierten Werten) der Enumerationskonstanten sortiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-816">The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.</span></span> <span data-ttu-id="dd86b-817">Wenn das Array Enumerationskonstanten mit dem gleichen Wert enthält, ist die Reihenfolge ihrer entsprechenden Namen nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-817">If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-818">Der aktuelle Typ ist keine Enumeration.</span><span class="sxs-lookup"><span data-stu-id="dd86b-818">The current type is not an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-819">Gibt den zugrunde liegenden Typ des aktuellen Enumerationstyps zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-819">Returns the underlying type of the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-820">Der zugrunde liegende Typ der aktuellen Enumeration.</span><span class="sxs-lookup"><span data-stu-id="dd86b-820">The underlying type of the current enumeration.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-821">Standardmäßig ist <xref:System.Int32>der zugrunde liegende Typ einer Enumeration in C# und Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="dd86b-821">By default, the underlying type of an enumeration in C# and Visual Basic is <xref:System.Int32>.</span></span> <span data-ttu-id="dd86b-822">Andere ganzzahlige Typen können angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-822">Other integer types can be specified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-823">Der aktuelle Typ ist keine Enumeration.</span><span class="sxs-lookup"><span data-stu-id="dd86b-823">The current type is not an enumeration.</span></span>  
  
 <span data-ttu-id="dd86b-824">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-824">-or-</span></span>  
  
 <span data-ttu-id="dd86b-825">Der Enumerationstyp ist ungültig, da er mehr als ein Instanzfeld enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-825">The enumeration type is not valid, because it contains more than one instance field.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-826">Gibt ein Array mit den Werten der Konstanten im aktuellen Enumerationstyp zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-826">Returns an array of the values of the constants in the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-827">Ein Array, das die Werte enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-827">An array that contains the values.</span></span> <span data-ttu-id="dd86b-828">Die Elemente des Arrays sind nach den Binärwerten (den Werten ohne Vorzeichen) der Enumerationskonstanten sortiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-828">The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-829">Der aktuelle Typ ist keine Enumeration.</span><span class="sxs-lookup"><span data-stu-id="dd86b-829">The current type is not an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-830">Ruft ein bestimmtes Ereignis ab, das vom aktuellen <see cref="T:System.Type" /> deklariert oder geerbt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-830">Gets a specific event declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-831">Die Zeichenfolge, die den Namen eines vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisses enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-831">The string containing the name of an event that is declared or inherited by the current <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="dd86b-832">Gibt das <see cref="T:System.Reflection.EventInfo" />-Objekt zurück, das das angegebene öffentliche Ereignis darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-832">Returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified public event.</span></span></summary>
        <returns><span data-ttu-id="dd86b-833">Das Objekt, das das angegebene, vom aktuellen <see cref="T:System.Type" /> deklarierte oder geerbte öffentliche Ereignis darstellt, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-833">The object representing the specified public event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-834">Ein Ereignis gilt als öffentlich für Reflektion, wenn es mindestens eine öffentliche Methode oder einen öffentlichen Accessor hat.</span><span class="sxs-lookup"><span data-stu-id="dd86b-834">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="dd86b-835">Andernfalls wird das Ereignis als privat angesehen, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (in Visual Basic die Werte mit &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or`) verwenden, um es zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-835">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="dd86b-836">Beim Suchen nach `name` wird die Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-836">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="dd86b-837">Die Suche umfasst Ereignisse für öffentliche statische Ereignisse und öffentliche Instanzen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-837">The search includes public static and public instance events.</span></span>  
  
 <span data-ttu-id="dd86b-838">In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-838">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="dd86b-839">Memberart</span><span class="sxs-lookup"><span data-stu-id="dd86b-839">Member Type</span></span>|<span data-ttu-id="dd86b-840">Statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-840">Static</span></span>|<span data-ttu-id="dd86b-841">Nicht statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-841">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="dd86b-842">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="dd86b-842">Constructor</span></span>|<span data-ttu-id="dd86b-843">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-843">No</span></span>|<span data-ttu-id="dd86b-844">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-844">No</span></span>|  
|<span data-ttu-id="dd86b-845">Feld</span><span class="sxs-lookup"><span data-stu-id="dd86b-845">Field</span></span>|<span data-ttu-id="dd86b-846">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-846">No</span></span>|<span data-ttu-id="dd86b-847">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-847">Yes.</span></span> <span data-ttu-id="dd86b-848">Ein Feld wird immer nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-848">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-849">event</span><span class="sxs-lookup"><span data-stu-id="dd86b-849">Event</span></span>|<span data-ttu-id="dd86b-850">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-850">Not applicable</span></span>|<span data-ttu-id="dd86b-851">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-851">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-852">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-852">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-853">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-853">See note 2 below.</span></span>|  
|<span data-ttu-id="dd86b-854">Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-854">Method</span></span>|<span data-ttu-id="dd86b-855">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-855">No</span></span>|<span data-ttu-id="dd86b-856">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-856">Yes.</span></span> <span data-ttu-id="dd86b-857">Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-857">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-858">Der Typ "Typ"</span><span class="sxs-lookup"><span data-stu-id="dd86b-858">Nested Type</span></span>|<span data-ttu-id="dd86b-859">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-859">No</span></span>|<span data-ttu-id="dd86b-860">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-860">No</span></span>|  
|<span data-ttu-id="dd86b-861">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="dd86b-861">Property</span></span>|<span data-ttu-id="dd86b-862">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-862">Not applicable</span></span>|<span data-ttu-id="dd86b-863">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-863">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-864">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-864">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-865">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-865">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="dd86b-866">"Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-866">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="dd86b-867">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-867">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="dd86b-868">Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-868">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-869">Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-869">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="dd86b-870">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="dd86b-870">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="dd86b-871">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.EventInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-871">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-872">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Ereignisse der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-872">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-873">Im folgenden Beispiel wird ein <xref:System.Reflection.EventInfo> -Objekt erstellt und das-Ereignis für eine Schaltflächen Klasse für das angegebene Ereignis abgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-873">The following example creates an <xref:System.Reflection.EventInfo> object and gets the event for a button class for the specified event.</span></span>  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-874"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-874"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-875">Die Zeichenfolge, die den Namen eines vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisses enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-875">The string containing the name of an event which is declared or inherited by the current <see cref="T:System.Type" />.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="dd86b-876">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-876">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-877">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-877">-or-</span></span> 
 <span data-ttu-id="dd86b-878"><see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-878"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="dd86b-879">Gibt beim Überschreiben in einer abgeleiteten Klasse das <see cref="T:System.Reflection.EventInfo" />-Objekt zurück, das das angegebene Ereignis unter Verwendung der angegebenen Bindungseinschränkungen darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-879">When overridden in a derived class, returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified event, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="dd86b-880">Das Objekt, das das angegebene vom aktuellen <see cref="T:System.Type" /> deklarierte oder geerbte Ereignis darstellt, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-880">The object representing the specified event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-881">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Ereignisse in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-881">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-882">Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-882">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="dd86b-883">Geben `BindingFlags.Public` Sie an, um öffentliche Ereignisse in die Suche einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-883">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-884">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Ereignisse (d. h. private, interne und geschützte Ereignisse) in der Suche enthalten sein sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-884">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-885">Legen `BindingFlags.FlattenHierarchy` `protected` Sie`public` fest, dass und statische Member in der Hierarchie nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-885">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="dd86b-886">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-886">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="dd86b-887">`BindingFlags.IgnoreCase`, wenn der Fall von `name`ignoriert werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-887">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="dd86b-888">`BindingFlags.DeclaredOnly`, um nur die Ereignisse zu durchsuchen <xref:System.Type>, die auf dem deklariert sind, nicht Ereignisse, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-888">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="dd86b-889">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-889">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="dd86b-890">Ein Ereignis gilt als öffentlich für Reflektion, wenn es mindestens eine öffentliche Methode oder einen öffentlichen Accessor hat.</span><span class="sxs-lookup"><span data-stu-id="dd86b-890">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="dd86b-891">Andernfalls wird das Ereignis als privat angesehen, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (in Visual Basic die Werte mit &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or`) verwenden, um es zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-891">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="dd86b-892">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.EventInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-892">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-893">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Ereignisse der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-893">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-894">Im folgenden Codebeispiel wird die <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> -Methode verwendet, um einen Typ nach einem öffentlichen oder nicht öffentlichen Ereignis namens "Click" zu suchen `static` ,`Shared` das nicht ist (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="dd86b-894">The following code example uses the <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> method to search a type for a public or non-public event named "Click" that is not `static` (`Shared` in Visual Basic).</span></span>  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-895"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-895"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-896">Ruft die vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisse ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-896">Gets the events that are declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-897">Gibt sämtliche vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten öffentlichen Ereignisse zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-897">Returns all the public events that are declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-898">Gibt ein Array von <see cref="T:System.Reflection.EventInfo" />-Objekten zurück, die sämtliche vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten öffentlichen Ereignisse darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-898">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events which are declared or inherited by the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="dd86b-899">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-899">-or-</span></span> 
<span data-ttu-id="dd86b-900">Ein leeres Array vom <see cref="T:System.Reflection.EventInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine öffentlichen Ereignisse besitzt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-900">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have public events.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-901">Ein Ereignis gilt als öffentlich für Reflektion, wenn es mindestens eine öffentliche Methode oder einen öffentlichen Accessor hat.</span><span class="sxs-lookup"><span data-stu-id="dd86b-901">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="dd86b-902">Andernfalls wird das Ereignis als privat angesehen, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (in Visual Basic die Werte mit &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or`) verwenden, um es zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-902">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="dd86b-903">Die <xref:System.Type.GetEvents%2A> Methode gibt keine Ereignisse in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-903">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="dd86b-904">Der Code darf nicht von der Reihenfolge abhängen, in der Ereignisse zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-904">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="dd86b-905">Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-905">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="dd86b-906">In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-906">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="dd86b-907">Memberart</span><span class="sxs-lookup"><span data-stu-id="dd86b-907">Member Type</span></span>|<span data-ttu-id="dd86b-908">Statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-908">Static</span></span>|<span data-ttu-id="dd86b-909">Nicht statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-909">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="dd86b-910">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="dd86b-910">Constructor</span></span>|<span data-ttu-id="dd86b-911">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-911">No</span></span>|<span data-ttu-id="dd86b-912">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-912">No</span></span>|  
|<span data-ttu-id="dd86b-913">Feld</span><span class="sxs-lookup"><span data-stu-id="dd86b-913">Field</span></span>|<span data-ttu-id="dd86b-914">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-914">No</span></span>|<span data-ttu-id="dd86b-915">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-915">Yes.</span></span> <span data-ttu-id="dd86b-916">Ein Feld wird immer nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-916">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-917">event</span><span class="sxs-lookup"><span data-stu-id="dd86b-917">Event</span></span>|<span data-ttu-id="dd86b-918">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-918">Not applicable</span></span>|<span data-ttu-id="dd86b-919">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-919">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-920">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-920">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-921">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-921">See note 2 below.</span></span>|  
|<span data-ttu-id="dd86b-922">Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-922">Method</span></span>|<span data-ttu-id="dd86b-923">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-923">No</span></span>|<span data-ttu-id="dd86b-924">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-924">Yes.</span></span> <span data-ttu-id="dd86b-925">Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-925">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-926">Der Typ "Typ"</span><span class="sxs-lookup"><span data-stu-id="dd86b-926">Nested Type</span></span>|<span data-ttu-id="dd86b-927">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-927">No</span></span>|<span data-ttu-id="dd86b-928">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-928">No</span></span>|  
|<span data-ttu-id="dd86b-929">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="dd86b-929">Property</span></span>|<span data-ttu-id="dd86b-930">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-930">Not applicable</span></span>|<span data-ttu-id="dd86b-931">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-931">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-932">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-932">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-933">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-933">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="dd86b-934">"Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-934">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="dd86b-935">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-935">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="dd86b-936">Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-936">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-937">Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-937">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="dd86b-938">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="dd86b-938">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="dd86b-939">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.EventInfo> Methode die Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-939">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-940">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Ereignisse der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-940">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-941">Im folgenden Beispiel wird ein Array von <xref:System.Reflection.EventInfo> -Objekten abgerufen, alle Ereignisse für eine `Button` Klasse abgerufen und die Ereignis Namen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-941">The following example obtains an array of <xref:System.Reflection.EventInfo> objects, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="dd86b-942">Um das Visual Basic Beispiel zu kompilieren, verwenden Sie die folgende Befehlszeile:</span><span class="sxs-lookup"><span data-stu-id="dd86b-942">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="dd86b-943">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-943">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="dd86b-944">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-944">-or-</span></span>

 <span data-ttu-id="dd86b-945"><see cref="F:System.Reflection.BindingFlags.Default" />, um ein leeres Array zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-945"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="dd86b-946">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen nach vom aktuellen <see cref="T:System.Type" /> definierten oder geerbten Ereignissen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-946">When overridden in a derived class, searches for events that are declared or inherited by the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="dd86b-947">Ein Array von <see cref="T:System.Reflection.EventInfo" />-Objekten, die sämtliche vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisse darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-947">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all events that are declared or inherited by the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="dd86b-948">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-948">-or-</span></span> 
<span data-ttu-id="dd86b-949">Ein leeres Array vom <see cref="T:System.Reflection.EventInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Ereignisse besitzt oder keines der Ereignisse den Bindungseinschränkungen entspricht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-949">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have events, or if none of the events match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-950">Die <xref:System.Type.GetEvents%2A> Methode gibt keine Ereignisse in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-950">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="dd86b-951">Der Code darf nicht von der Reihenfolge abhängen, in der Ereignisse zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-951">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="dd86b-952">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Ereignisse in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-952">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-953">Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-953">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="dd86b-954">Geben `BindingFlags.Public` Sie an, um öffentliche Ereignisse in die Suche einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-954">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-955">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Ereignisse (d. h. private, interne und geschützte Ereignisse) in der Suche enthalten sein sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-955">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span> <span data-ttu-id="dd86b-956">Es werden nur geschützte und interne Ereignisse für Basisklassen zurückgegeben. Private Ereignisse für Basisklassen werden nicht zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-956">Only protected and internal events on base classes are returned; private events on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="dd86b-957">Legen `BindingFlags.FlattenHierarchy` `protected` Sie`public` fest, dass und statische Member in der Hierarchie nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-957">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="dd86b-958">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-958">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="dd86b-959">`BindingFlags.DeclaredOnly`, um nur die Ereignisse zu durchsuchen <xref:System.Type>, die auf dem deklariert sind, nicht Ereignisse, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-959">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="dd86b-960">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-960">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="dd86b-961">Ein Ereignis gilt als öffentlich für Reflektion, wenn es mindestens eine öffentliche Methode oder einen öffentlichen Accessor hat.</span><span class="sxs-lookup"><span data-stu-id="dd86b-961">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="dd86b-962">Andernfalls wird das Ereignis als privat angesehen, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (in Visual Basic die Werte mit &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or`) verwenden, um es zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-962">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="dd86b-963">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.EventInfo> Methode die Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-963">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-964">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Ereignisse der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-964">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-965">Im folgenden Beispiel wird ein Array von <xref:System.Reflection.EventInfo> -Objekten abgerufen, die den angegebenen Bindungsflags entsprechen, alle Ereignisse `Button` für eine Klasse abrufen und die Ereignis Namen anzeigen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-965">The following example obtains an array of <xref:System.Reflection.EventInfo> objects that match the specified binding flags, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="dd86b-966">Um das Visual Basic Beispiel zu kompilieren, verwenden Sie die folgende Befehlszeile:</span><span class="sxs-lookup"><span data-stu-id="dd86b-966">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-967">Ruft ein bestimmtes Feld des aktuellen <see cref="T:System.Type" /> ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-967">Gets a specific field of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-968">Die Zeichenfolge, die den Namen des abzurufenden Datenfelds enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-968">The string containing the name of the data field to get.</span></span></param>
        <summary><span data-ttu-id="dd86b-969">Sucht das öffentliche Feld mit dem angegebenen Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-969">Searches for the public field with the specified name.</span></span></summary>
        <returns><span data-ttu-id="dd86b-970">Ein Objekt, das das öffentliche Feld mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-970">An object representing the public field with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-971">Beim Suchen nach `name` wird die Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-971">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="dd86b-972">Die Suche umfasst öffentliche, statische und öffentliche Instanzfelder.</span><span class="sxs-lookup"><span data-stu-id="dd86b-972">The search includes public static and public instance fields.</span></span>  
  
 <span data-ttu-id="dd86b-973">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.FieldInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-973">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-974">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Felder der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-974">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-975">Im folgenden Beispiel wird das `Type` -Objekt für die angegebene Klasse abgerufen, <xref:System.Reflection.FieldInfo> das-Objekt für das Feld abgerufen und der Wert des-Felds angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-975">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-976"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-976"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd86b-977">Bei diesem <see cref="T:System.Type" />-Objekt handelt es sich um einen <see cref="T:System.Reflection.Emit.TypeBuilder" />, dessen <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />-Methode noch nicht aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-977">This <see cref="T:System.Type" /> object is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> whose <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has not yet been called.</span></span></exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-978">Die Zeichenfolge, die den Namen des abzurufenden Datenfelds enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-978">The string containing the name of the data field to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="dd86b-979">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-979">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-980">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-980">-or-</span></span> 
 <span data-ttu-id="dd86b-981"><see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-981"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="dd86b-982">Sucht das angegebene Feld unter Verwendung der angegebenen Bindungseinschränkungen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-982">Searches for the specified field, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="dd86b-983">Ein Objekt, das das Feld darstellt, das den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-983">An object representing the field that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-984">In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-984">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="dd86b-985">Memberart</span><span class="sxs-lookup"><span data-stu-id="dd86b-985">Member Type</span></span>|<span data-ttu-id="dd86b-986">Statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-986">Static</span></span>|<span data-ttu-id="dd86b-987">Nicht statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-987">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="dd86b-988">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="dd86b-988">Constructor</span></span>|<span data-ttu-id="dd86b-989">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-989">No</span></span>|<span data-ttu-id="dd86b-990">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-990">No</span></span>|  
|<span data-ttu-id="dd86b-991">Feld</span><span class="sxs-lookup"><span data-stu-id="dd86b-991">Field</span></span>|<span data-ttu-id="dd86b-992">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-992">No</span></span>|<span data-ttu-id="dd86b-993">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-993">Yes.</span></span> <span data-ttu-id="dd86b-994">Ein Feld wird immer nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-994">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-995">event</span><span class="sxs-lookup"><span data-stu-id="dd86b-995">Event</span></span>|<span data-ttu-id="dd86b-996">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-996">Not applicable</span></span>|<span data-ttu-id="dd86b-997">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-997">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-998">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-998">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-999">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-999">See note 2 below.</span></span>|  
|<span data-ttu-id="dd86b-1000">Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-1000">Method</span></span>|<span data-ttu-id="dd86b-1001">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1001">No</span></span>|<span data-ttu-id="dd86b-1002">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1002">Yes.</span></span> <span data-ttu-id="dd86b-1003">Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1003">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-1004">Der Typ "Typ"</span><span class="sxs-lookup"><span data-stu-id="dd86b-1004">Nested Type</span></span>|<span data-ttu-id="dd86b-1005">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1005">No</span></span>|<span data-ttu-id="dd86b-1006">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1006">No</span></span>|  
|<span data-ttu-id="dd86b-1007">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="dd86b-1007">Property</span></span>|<span data-ttu-id="dd86b-1008">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-1008">Not applicable</span></span>|<span data-ttu-id="dd86b-1009">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1009">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-1010">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-1010">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1011">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1011">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="dd86b-1012">"Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1012">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="dd86b-1013">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1013">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="dd86b-1014">Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1014">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1015">Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1015">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="dd86b-1016">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1016">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="dd86b-1017">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Felder in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1017">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-1018">Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1018">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="dd86b-1019">Geben `BindingFlags.Public` Sie an, dass öffentliche Felder in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1019">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-1020">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Felder (d. h. private, interne und geschützte Felder) in der Suche enthalten sein sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1020">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-1021">Legen `BindingFlags.FlattenHierarchy` `protected` Sie`public` fest, dass und statische Member in der Hierarchie nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1021">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="dd86b-1022">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1022">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="dd86b-1023">`BindingFlags.IgnoreCase`, wenn der Fall von `name`ignoriert werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1023">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="dd86b-1024">`BindingFlags.DeclaredOnly`, um nur die Felder zu durchsuchen <xref:System.Type>, die in deklariert sind, nicht Felder, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1024">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="dd86b-1025">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1025">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="dd86b-1026">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.FieldInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1026">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1027">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Felder der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1027">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1028">Im folgenden Beispiel wird das `Type` -Objekt für die angegebene Klasse abgerufen, <xref:System.Reflection.FieldInfo> das-Objekt für das Feld abgerufen, das mit den angegebenen Bindungsflags übereinstimmt, und der Wert des Felds wird angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1028">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field that matches the specified binding flags, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-1029"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1029"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-1030">Ruft die Felder des aktuellen <see cref="T:System.Type" /> ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1030">Gets the fields of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-1031">Gibt sämtliche öffentlichen Felder des aktuellen <see cref="T:System.Type" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1031">Returns all the public fields of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1032">Ein Array von <see cref="T:System.Reflection.FieldInfo" />-Objekten, die alle für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Felder darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1032">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all the public fields defined for the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="dd86b-1033">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1033">-or-</span></span> 
<span data-ttu-id="dd86b-1034">Ein leeres Array vom <see cref="T:System.Reflection.FieldInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine öffentlichen Felder definiert sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1034">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no public fields are defined for the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1035">Die <xref:System.Type.GetFields%2A> Methode gibt keine Felder in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1035">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="dd86b-1036">Der Code darf nicht von der Reihenfolge abhängen, in der Felder zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1036">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="dd86b-1037">In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1037">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="dd86b-1038">Memberart</span><span class="sxs-lookup"><span data-stu-id="dd86b-1038">Member Type</span></span>|<span data-ttu-id="dd86b-1039">Statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-1039">Static</span></span>|<span data-ttu-id="dd86b-1040">Nicht statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-1040">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="dd86b-1041">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="dd86b-1041">Constructor</span></span>|<span data-ttu-id="dd86b-1042">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1042">No</span></span>|<span data-ttu-id="dd86b-1043">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1043">No</span></span>|  
|<span data-ttu-id="dd86b-1044">Feld</span><span class="sxs-lookup"><span data-stu-id="dd86b-1044">Field</span></span>|<span data-ttu-id="dd86b-1045">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1045">No</span></span>|<span data-ttu-id="dd86b-1046">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1046">Yes.</span></span> <span data-ttu-id="dd86b-1047">Ein Feld wird immer nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1047">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-1048">event</span><span class="sxs-lookup"><span data-stu-id="dd86b-1048">Event</span></span>|<span data-ttu-id="dd86b-1049">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-1049">Not applicable</span></span>|<span data-ttu-id="dd86b-1050">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1050">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-1051">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-1051">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1052">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1052">See note 2 below.</span></span>|  
|<span data-ttu-id="dd86b-1053">Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-1053">Method</span></span>|<span data-ttu-id="dd86b-1054">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1054">No</span></span>|<span data-ttu-id="dd86b-1055">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1055">Yes.</span></span> <span data-ttu-id="dd86b-1056">Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1056">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-1057">Der Typ "Typ"</span><span class="sxs-lookup"><span data-stu-id="dd86b-1057">Nested Type</span></span>|<span data-ttu-id="dd86b-1058">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1058">No</span></span>|<span data-ttu-id="dd86b-1059">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1059">No</span></span>|  
|<span data-ttu-id="dd86b-1060">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="dd86b-1060">Property</span></span>|<span data-ttu-id="dd86b-1061">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-1061">Not applicable</span></span>|<span data-ttu-id="dd86b-1062">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1062">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-1063">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-1063">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1064">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1064">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="dd86b-1065">"Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1065">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="dd86b-1066">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1066">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="dd86b-1067">Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1067">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1068">Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1068">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="dd86b-1069">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1069">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="dd86b-1070">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.FieldInfo> Methode die Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1070">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1071">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die öffentlichen Felder der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1071">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1072">Im folgenden Beispiel wird die `GetFields()` Verwendung der-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1072">The following example shows a use of the `GetFields()` method.</span></span>  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="dd86b-1073">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1073">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="dd86b-1074">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1074">-or-</span></span>

 <span data-ttu-id="dd86b-1075"><see cref="F:System.Reflection.BindingFlags.Default" />, um ein leeres Array zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1075"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="dd86b-1076">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die für den aktuellen <see cref="T:System.Type" /> definierten Felder.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1076">When overridden in a derived class, searches for the fields defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1077">Ein Array von <see cref="T:System.Reflection.FieldInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Felder darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1077">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all fields defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="dd86b-1078">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1078">-or-</span></span> 
<span data-ttu-id="dd86b-1079">Ein leeres Array vom <see cref="T:System.Reflection.FieldInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine Felder definiert sind oder keines der definierten Felder den Bindungseinschränkungen entspricht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1079">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no fields are defined for the current <see cref="T:System.Type" />, or if none of the defined fields match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="dd86b-1080">Damit die `GetFields(BindingFlags)` -Überladung Eigenschaften Informationen erfolgreich abrufen kann `bindingAttr` , muss das-Argument mindestens eine <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> von <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>und enthalten, zusammen mit mindestens einem <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> von <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>und.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1080">For the `GetFields(BindingFlags)` overload to successfully retrieve property information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="dd86b-1081">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Felder in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1081">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
- <span data-ttu-id="dd86b-1082">Geben `BindingFlags.Instance` Sie an, um Instanzmethoden einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1082">Specify `BindingFlags.Instance` to include instance methods.</span></span> 

- <span data-ttu-id="dd86b-1083">Geben `BindingFlags.Static` Sie an, um statische Methoden einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1083">Specify `BindingFlags.Static` to include static methods.</span></span> 
    
- <span data-ttu-id="dd86b-1084">Geben `BindingFlags.Public` Sie an, dass öffentliche Felder in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1084">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
- <span data-ttu-id="dd86b-1085">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Felder (d. h. private, interne und geschützte Felder) in der Suche enthalten sein sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1085">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span> <span data-ttu-id="dd86b-1086">Es werden nur geschützte und interne Felder für Basisklassen zurückgegeben. private Felder für Basisklassen werden nicht zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1086">Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</span></span>  
  
- <span data-ttu-id="dd86b-1087">Legen `BindingFlags.FlattenHierarchy` `protected` Sie`public` fest, dass und statische Member in der Hierarchie nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1087">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  

- <span data-ttu-id="dd86b-1088">Geben `BindingFlags.Default` Sie allein an, um <xref:System.Reflection.PropertyInfo> ein leeres Array zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1088">Specify `BindingFlags.Default` alone to return an empty <xref:System.Reflection.PropertyInfo> array.</span></span>

<span data-ttu-id="dd86b-1089">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1089">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
- <span data-ttu-id="dd86b-1090">`BindingFlags.DeclaredOnly`, um nur die Felder zu durchsuchen <xref:System.Type>, die in deklariert sind, nicht Felder, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1090">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
<span data-ttu-id="dd86b-1091">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1091">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
<span data-ttu-id="dd86b-1092">Die <xref:System.Type.GetFields%2A> Methode gibt keine Felder in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1092">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="dd86b-1093">Der Code darf nicht von der Reihenfolge abhängen, in der Felder zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1093">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  

 <span data-ttu-id="dd86b-1094">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.FieldInfo> Methode die Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1094">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1095">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die öffentlichen Felder der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1095">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
## Examples  
 <span data-ttu-id="dd86b-1096">Im folgenden Beispiel wird die `GetFields(BindingFlags)` Verwendung der-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1096">The following example shows a use of the `GetFields(BindingFlags)` method.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-1097">Gibt ein Array von <see cref="T:System.Type" />-Objekten zurück, die die Typargumente eines geschlossenen generischen Typs oder die Typparameter einer generischen Typdefinition darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1097">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1098">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typargumente eines generischen Typs darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1098">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type.</span></span> <span data-ttu-id="dd86b-1099">Gibt ein leeres Array zurück, wenn der aktuelle Typ kein generischer Typ ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1099">Returns an empty array if the current type is not a generic type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1100">Die Array Elemente werden in der Reihenfolge zurückgegeben, in der Sie in der Liste der Typargumente für den generischen Typ angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1100">The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</span></span>  
  
-   <span data-ttu-id="dd86b-1101">Wenn es sich bei dem aktuellen Typ um einen geschlossenen konstruierten Typ handelt <xref:System.Type.ContainsGenericParameters%2A> (d `false`. h., die-Eigenschaft <xref:System.Type.GetGenericArguments%2A> gibt zurück), enthält das von der-Methode zurückgegebene Array die Typen, die den generischen Typparametern der generischen Typdefinition zugewiesen wurden. .</span><span class="sxs-lookup"><span data-stu-id="dd86b-1101">If the current type is a closed constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Type.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic type definition.</span></span>  
  
-   <span data-ttu-id="dd86b-1102">Wenn der aktuelle Typ eine generische Typdefinition ist, enthält das Array die Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1102">If the current type is a generic type definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="dd86b-1103">Wenn der aktuelle Typ ein offener konstruierter Typ ist (d. h <xref:System.Type.ContainsGenericParameters%2A> . die `true`-Eigenschaft gibt zurück), in der bestimmte Typen nicht allen Typparametern und Typparametern von einschließenden generischen Typen oder Methoden zugewiesen wurden, enthält das Array Beide Typen und Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1103">If the current type is an open constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.</span></span> <span data-ttu-id="dd86b-1104">Verwenden Sie <xref:System.Type.IsGenericParameter%2A> die-Eigenschaft, um sie voneinander zu informieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1104">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="dd86b-1105">Eine Demonstration dieses Szenarios finden Sie im Codebeispiel für die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1105">For a demonstration of this scenario, see the code example for the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="dd86b-1106">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1106">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1107">Im folgenden Codebeispiel wird die <xref:System.Type.GetGenericArguments%2A> -Methode verwendet, um die Typargumente eines konstruierten Typs und die Typparameter der generischen Typdefinition anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1107">The following code example uses the <xref:System.Type.GetGenericArguments%2A> method to display the type arguments of a constructed type and the type parameters of its generic type definition.</span></span>  
  
 <span data-ttu-id="dd86b-1108">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Type.IsGenericTypeDefinition%2A> -Eigenschaft bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1108">This code example is part of a larger example provided for the <xref:System.Type.IsGenericTypeDefinition%2A> property.</span></span> <span data-ttu-id="dd86b-1109">Weitere Informationen finden Sie unter Beispielausgabe.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1109">See the larger example for sample output.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd86b-1110">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1110">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="dd86b-1111">Abgeleitete Klassen müssen eine Implementation angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1111">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="dd86b-1112">Reflektion und generische Typen</span><span class="sxs-lookup"><span data-stu-id="dd86b-1112">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="dd86b-1113">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</span><span class="sxs-lookup"><span data-stu-id="dd86b-1113">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-1114">Gibt ein Array von <see cref="T:System.Type" />-Objekten zurück, die die Einschränkungen für den aktuellen generischen Typparameter darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1114">Returns an array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1115">Ein Array von <see cref="T:System.Type" />-Objekten, die die Einschränkungen für den aktuellen generischen Typparameter darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1115">An array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1116">Jede Einschränkung für einen generischen Typparameter wird als <xref:System.Type> -Objekt ausgedrückt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1116">Each constraint on a generic type parameter is expressed as a <xref:System.Type> object.</span></span> <span data-ttu-id="dd86b-1117">Verwenden Sie <xref:System.Type.IsClass%2A> die-Eigenschaft, um zu bestimmen, ob eine Einschränkung die Basisklassen Einschränkung ist `false`. wenn die-Eigenschaft zurückgibt, ist die Einschränkung eine Schnittstellen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1117">Use the <xref:System.Type.IsClass%2A> property to determine whether a constraint is the base class constraint; if the property returns `false`, the constraint is an interface constraint.</span></span> <span data-ttu-id="dd86b-1118">Wenn ein Typparameter keine Klassen Einschränkung und keine Schnittstellen Einschränkungen aufweist, wird ein leeres Array zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1118">If a type parameter has no class constraint and no interface constraints, an empty array is returned.</span></span>  
  
 <span data-ttu-id="dd86b-1119">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1119">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1120">Im folgenden Codebeispiel wird ein generischer `Test` Typ mit zwei Typparametern definiert, die unterschiedliche Einschränkungen aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1120">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="dd86b-1121">Wenn das Programm ausgeführt wird, werden die Einschränkungen mithilfe der <xref:System.Type.GenericParameterAttributes%2A> -Eigenschaft und <xref:System.Type.GetGenericParameterConstraints%2A> der-Methode untersucht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1121">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd86b-1122">Das aktuelle <see cref="T:System.Type" />-Objekt ist kein generischer Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1122">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span></span> <span data-ttu-id="dd86b-1123">Das bedeutet, dass die <see cref="P:System.Type.IsGenericParameter" />-Eigenschaft <see langword="false" /> zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1123">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span></span></exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="dd86b-1124">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</span><span class="sxs-lookup"><span data-stu-id="dd86b-1124">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-1125">Gibt ein <see cref="T:System.Type" />-Objekt zurück, das eine generische Typdefinition darstellt, aus der der aktuelle generische Typ konstruiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1125">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current generic type can be constructed.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1126">Ein <see cref="T:System.Type" />-Objekt, das einen generischen Typ darstellt, aus dem der aktuelle Typ konstruiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1126">A <see cref="T:System.Type" /> object representing a generic type from which the current type can be constructed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1127">Eine generische Typdefinition ist eine Vorlage, von der andere Typen erstellt werden können.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1127">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="dd86b-1128">Beispielsweise aus der generischen Typdefinition `G<T>` (ausgedrückt in C# Syntax). `G<int>` `G(Of Integer)` in Visual Basic oder `generic <typename T> ref class G` in C++) können Sie den-Typ (in Visual Basic) erstellen und instanziieren. `G(Of T)`</span><span class="sxs-lookup"><span data-stu-id="dd86b-1128">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic).</span></span> <span data-ttu-id="dd86b-1129">Bei einem <xref:System.Type> -Objekt, das diesen konstruierten <xref:System.Type.GetGenericTypeDefinition%2A> Typ darstellt, gibt die Methode die generische Typdefinition zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1129">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the generic type definition.</span></span>  
  
 <span data-ttu-id="dd86b-1130">Wenn zwei konstruierte Typen aus der gleichen generischen Typdefinition erstellt werden, wobei die gleichen Typargumente verwendet werden, <xref:System.Type> gibt die <xref:System.Type.GetGenericTypeDefinition%2A> -Methode das gleiche-Objekt für beide Typen zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1130">If two constructed types are created from the same generic type definition, using the same type arguments, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the same <xref:System.Type> object for both types.</span></span>  
  
 <span data-ttu-id="dd86b-1131">Wenn Sie die <xref:System.Type.GetGenericTypeDefinition%2A> -Methode für ein <xref:System.Type> -Objekt aufzurufen, das bereits eine generische Typdefinition darstellt, <xref:System.Type>wird das aktuelle-Objekt zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1131">If you call the <xref:System.Type.GetGenericTypeDefinition%2A> method on a <xref:System.Type> object that already represents a generic type definition, it returns the current <xref:System.Type>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="dd86b-1132">Ein Array generischer Typen ist nicht selbst generisch.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1132">An array of generic types is not itself generic.</span></span> <span data-ttu-id="dd86b-1133">Im C# Code `A<int>[] v;` -oder Visual Basic Code `Dim v() As A(Of Integer)`ist der Typ der Variablen `v` nicht generisch.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1133">In the C# code `A<int>[] v;` or the Visual Basic code `Dim v() As A(Of Integer)`, the type of variable `v` is not generic.</span></span> <span data-ttu-id="dd86b-1134">Verwenden <xref:System.Type.IsGenericType%2A> Sie, um zu bestimmen, ob ein Typ <xref:System.Type.GetGenericTypeDefinition%2A>generisch ist, bevor aufgerufen</span><span class="sxs-lookup"><span data-stu-id="dd86b-1134">Use <xref:System.Type.IsGenericType%2A> to determine whether a type is generic before calling <xref:System.Type.GetGenericTypeDefinition%2A>.</span></span>  
  
 <span data-ttu-id="dd86b-1135">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1135">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1136">Im folgenden Codebeispiel wird eine Instanz eines konstruierten Typs mithilfe der Erstellung der normalen Instanz erstellt und dann <xref:System.Type.GetType%2A> die <xref:System.Type.GetGenericTypeDefinition%2A> -Methode und die-Methode verwendet, um den konstruierten Typ und die generische Typdefinition abzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1136">The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <xref:System.Type.GetType%2A> and <xref:System.Type.GetGenericTypeDefinition%2A> methods to retrieve the constructed type and the generic type definition.</span></span> <span data-ttu-id="dd86b-1137">In diesem Beispiel wird der <xref:System.Collections.Generic.Dictionary%602> generische Typ verwendet. der konstruierte Typ <xref:System.Collections.Generic.Dictionary%602> stellt `Test` eine von Objekten mit Zeichen folgen Schlüsseln dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1137">This example uses the generic <xref:System.Collections.Generic.Dictionary%602> type; the constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd86b-1138">Der aktuelle Typ ist kein generischer Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1138">The current type is not a generic type.</span></span>  <span data-ttu-id="dd86b-1139">Das heißt, <see cref="P:System.Type.IsGenericType" /> gibt <see langword="false" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1139">That is, <see cref="P:System.Type.IsGenericType" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd86b-1140">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1140">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="dd86b-1141">Abgeleitete Klassen müssen eine Implementation angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1141">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="dd86b-1142">Reflektion und generische Typen</span><span class="sxs-lookup"><span data-stu-id="dd86b-1142">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="dd86b-1143">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</span><span class="sxs-lookup"><span data-stu-id="dd86b-1143">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-1144">Gibt den Hashcode für diese Instanz zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1144">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1145">Der Hashcode für diese Instanz.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1145">The hash code for this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1146">Diese Methode überschreibt <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1146">This method overrides <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1147">Im folgenden Beispiel wird der Hashcode der `System.Windows.Forms.Button` -Klasse angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1147">The following example displays the hash code of the `System.Windows.Forms.Button` class.</span></span>  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-1148">Ruft eine bestimmte Schnittstelle ab, die vom aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1148">Gets a specific interface implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-1149">Die Zeichenfolge, die den Namen der abzurufenden Schnittstelle enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1149">The string containing the name of the interface to get.</span></span> <span data-ttu-id="dd86b-1150">Bei generischen Schnittstellen ist dies der ergänzte Name.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1150">For generic interfaces, this is the mangled name.</span></span></param>
        <summary><span data-ttu-id="dd86b-1151">Sucht die Schnittstelle mit dem angegebenen Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1151">Searches for the interface with the specified name.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1152">Ein Objekt, das die vom aktuellen <see cref="T:System.Type" /> implementierte oder geerbte Schnittstelle mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1152">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1153">Beim Suchen nach `name` wird die Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1153">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="dd86b-1154">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Type> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1154">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1155">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Schnittstellen Einschränkungen und alle Schnittstellen, die von Klassen-oder Schnittstellen Einschränkungen geerbt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1155">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1156">Bei generischen Schnittstellen `name` ist der-Parameter der ergänzte Name und endet mit einem großen Akzent\`() und der Anzahl der Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1156">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="dd86b-1157">Dies gilt sowohl für generische Schnittstellendefinitionen als auch für konstruierte generische Schnittstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1157">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="dd86b-1158">`IExample<T>` Wenn Sie z ``"IExample`1"``. b.`IExample(Of T)` (in Visual Basic) `IExample<string>` oder`IExample(Of String)` (in Visual Basic) suchen möchten, suchen Sie nach.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1158">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for ``"IExample`1"``.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1159">Im folgenden Codebeispiel wird die <xref:System.Type.GetInterface%28System.String%29> -Methode verwendet, <xref:System.Collections.Hashtable> um die- <xref:System.Runtime.Serialization.IDeserializationCallback> Klasse nach der-Schnittstelle zu durchsuchen und die Methoden der-Schnittstelle zu auflisten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1159">The following code example uses the <xref:System.Type.GetInterface%28System.String%29> method to search the <xref:System.Collections.Hashtable> class for the <xref:System.Runtime.Serialization.IDeserializationCallback> interface, and lists the methods of the interface.</span></span>  
  
 <span data-ttu-id="dd86b-1160">Das Codebeispiel veranschaulicht auch die <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> -Methoden Überladung <xref:System.Type.GetInterfaceMap%2A> und die-Methode.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1160">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-1161"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1161"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-1162">Der aktuelle <see cref="T:System.Type" /> stellt einen Typ dar, der dieselbe generische Schnittstelle mit unterschiedlichen Typargumenten implementiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1162">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-1163">Die Zeichenfolge, die den Namen der abzurufenden Schnittstelle enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1163">The string containing the name of the interface to get.</span></span> <span data-ttu-id="dd86b-1164">Bei generischen Schnittstellen ist dies der ergänzte Name.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1164">For generic interfaces, this is the mangled name.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="dd86b-1165"><see langword="true" />, wenn die Groß-/Kleinschreibung dieses Teils von <paramref name="name" />, der den einfachen Schnittstellennamen angibt, ignoriert werden soll. (Bei der Namespaceangabe im Namen muss die Groß-/Kleinschreibung immer beachtet werden.)</span><span class="sxs-lookup"><span data-stu-id="dd86b-1165"><see langword="true" /> to ignore the case of that part of <paramref name="name" /> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</span></span>  
  
<span data-ttu-id="dd86b-1166">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1166">-or-</span></span> 
 <span data-ttu-id="dd86b-1167"><see langword="false" />, wenn nach allen Teilen von <paramref name="name" /> mit Beachtung der Groß-/Kleinschreibung gesucht werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1167"><see langword="false" /> to perform a case-sensitive search for all parts of <paramref name="name" />.</span></span></param>
        <summary><span data-ttu-id="dd86b-1168">Sucht beim Überschreiben in einer abgeleiteten Klasse die angegebene Schnittstelle, wobei festgelegt wird, ob bei der Suche des Schnittstellennamens die Groß-/Kleinschreibung beachtet wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1168">When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1169">Ein Objekt, das die vom aktuellen <see cref="T:System.Type" /> implementierte oder geerbte Schnittstelle mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1169">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1170">Der `ignoreCase` -Parameter gilt nur für den einfachen Schnittstellennamen, nicht für den-Namespace.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1170">The `ignoreCase` parameter applies only to the simple interface name, not to the namespace.</span></span> <span data-ttu-id="dd86b-1171">Der Teil von `name` , der den Namespace angibt, muss die richtige Groß-/Kleinschreibung aufweisen, oder die Schnittstelle wird nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1171">The portion of `name` that specifies the namespace must have the correct case, or the interface will not be found.</span></span> <span data-ttu-id="dd86b-1172">Die Zeichenfolge "System. ivergleichbare" findet z. b <xref:System.IComparable> . die-Schnittstelle, die Zeichenfolge "System. ivergleichbare" jedoch nicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1172">For example, the string "System.icomparable" finds the <xref:System.IComparable> interface, but the string "system.icomparable" does not.</span></span>  
  
 <span data-ttu-id="dd86b-1173">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Type> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1173">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1174">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Schnittstellen Einschränkungen und alle Schnittstellen, die von Klassen-oder Schnittstellen Einschränkungen geerbt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1174">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1175">Bei generischen Schnittstellen `name` ist der-Parameter der ergänzte Name und endet mit einem großen Akzent\`() und der Anzahl der Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1175">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="dd86b-1176">Dies gilt sowohl für generische Schnittstellendefinitionen als auch für konstruierte generische Schnittstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1176">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="dd86b-1177">Um `IExample<T>` beispielsweise `"IExample`(`IExample(Of T)` in Visual Basic) oder `IExample<string>` (`IExample(Of String)` in Visual Basic) zu suchen, suchen Sie nach 1 "".</span><span class="sxs-lookup"><span data-stu-id="dd86b-1177">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for `"IExample`1"\`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1178">Im folgenden Codebeispiel wird die <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> -Methode verwendet, um die Groß-/Kleinschreibung bei der <xref:System.Collections.IEnumerable> Suche <xref:System.Collections.Hashtable> nach der-Klasse für die-Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="dd86b-1178">The following code example uses the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method to perform a case-insensitive search of the <xref:System.Collections.Hashtable> class for the <xref:System.Collections.IEnumerable> interface.</span></span>  
  
 <span data-ttu-id="dd86b-1179">Das Codebeispiel veranschaulicht auch die <xref:System.Type.GetInterface%28System.String%29> -Methoden Überladung <xref:System.Type.GetInterfaceMap%2A> und die-Methode.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1179">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-1180"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1180"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-1181">Der aktuelle <see cref="T:System.Type" /> stellt einen Typ dar, der dieselbe generische Schnittstelle mit unterschiedlichen Typargumenten implementiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1181">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="interfaceType"><span data-ttu-id="dd86b-1182">Der Schnittstellentyp, für den eine Zuordnung abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1182">The interface type to retrieve a mapping for.</span></span></param>
        <summary><span data-ttu-id="dd86b-1183">Gibt eine Schnittstellenzuordnung für den angegebenen Schnittstellentyp zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1183">Returns an interface mapping for the specified interface type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1184">Ein Objekt, das die Schnittstellenzuordnung für <paramref name="interfaceType" /> darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1184">An object that represents the interface mapping for <paramref name="interfaceType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1185">Die Schnittstellen Zuordnung gibt an, wie eine Schnittstelle den tatsächlichen Membern einer Klasse zugeordnet wird, die diese Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1185">The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.</span></span>  
  
 <span data-ttu-id="dd86b-1186">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, werden Typparameter durch die entsprechenden Typargumente in den <xref:System.Reflection.InterfaceMapping> Elementen von ersetzt, die von dieser Methode zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1186">If the current <xref:System.Type> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <xref:System.Reflection.InterfaceMapping> returned by this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1187">Im folgenden Beispiel wird die <xref:System.Type.GetInterfaceMap%2A> -Methode aufgerufen, um <xref:System.IFormatProvider> zu bestimmen, <xref:System.Globalization.CultureInfo> wie die-Schnittstelle <xref:System.IAppDomainSetup> Methoden zugeordnet wird <xref:System.AppDomainSetup> und wie die-Schnittstelle Eigenschaften zugeordnet wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1187">The following example calls the <xref:System.Type.GetInterfaceMap%2A> method to determine how the <xref:System.IFormatProvider> interface maps to <xref:System.Globalization.CultureInfo> methods, and how the <xref:System.IAppDomainSetup> interface maps to <xref:System.AppDomainSetup> properties.</span></span> <span data-ttu-id="dd86b-1188">Beachten Sie, dass das <xref:System.IAppDomainSetup> zurückgegebene <xref:System.Reflection.InterfaceMapping> Objekt separate <xref:System.Reflection.MethodInfo> Objekte für Get-und Set-Accessoren einer Eigenschaft enthält, da die Schnittstelle eine Reihe von Eigenschaften definiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1188">Note that, because the <xref:System.IAppDomainSetup> interface defines a set of properties, the returned <xref:System.Reflection.InterfaceMapping> object includes separate <xref:System.Reflection.MethodInfo> objects for a property's get and set accessors.</span></span>  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-1189"><paramref name="interfaceType" /> ist nicht durch den aktuellen Typ implementiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1189"><paramref name="interfaceType" /> is not implemented by the current type.</span></span>  
  
<span data-ttu-id="dd86b-1190">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1190">-or-</span></span> 
<span data-ttu-id="dd86b-1191">Das <paramref name="interfaceType" />-Argument verweist nicht auf eine Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1191">The <paramref name="interfaceType" /> argument does not refer to an interface.</span></span>  
  
<span data-ttu-id="dd86b-1192">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1192">-or-</span></span>

<span data-ttu-id="dd86b-1193">Die aktuelle Instanz oder das <paramref name="interfaceType" />-Argument sind offene generische Typen, d.h. die <see cref="P:System.Type.ContainsGenericParameters" />-Eigenschaft gibt <see langword="true" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1193">The current instance or <paramref name="interfaceType" /> argument is an open generic type; that is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span>

<span data-ttu-id="dd86b-1194">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1194">-or-</span></span>


 <span data-ttu-id="dd86b-1195"><paramref name="interfaceType" /> ist eine generische Schnittstelle, und der aktuelle Typ ist ein Arraytyp.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1195"><paramref name="interfaceType" /> is a generic interface, and the current type is an array type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-1196"><paramref name="interfaceType" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1196"><paramref name="interfaceType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd86b-1197">Der aktuelle <see cref="T:System.Type" /> entspricht einem generischen Typparameter, d. h., <see cref="P:System.Type.IsGenericParameter" /> ist gleich <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1197">The current <see cref="T:System.Type" /> represents a generic type parameter; that is, <see cref="P:System.Type.IsGenericParameter" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd86b-1198">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1198">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="dd86b-1199">Abgeleitete Klassen müssen eine Implementation angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1199">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-1200">Ruft beim Überschreiben in einer abgeleiteten Klasse sämtliche Schnittstellen ab, die vom aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1200">When overridden in a derived class, gets all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1201">Ein Array von <see cref="T:System.Type" />-Objekten, die sämtliche vom aktuellen <see cref="T:System.Type" /> implementierten oder geerbten Schnittstellen darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1201">An array of <see cref="T:System.Type" /> objects representing all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="dd86b-1202">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1202">-or-</span></span> 
<span data-ttu-id="dd86b-1203">Ein leeres Array vom <see cref="T:System.Type" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Schnittstellen implementiert oder geerbt hat.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1203">An empty array of type <see cref="T:System.Type" />, if no interfaces are implemented or inherited by the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1204">Die <xref:System.Type.GetInterfaces%2A> -Methode gibt keine Schnittstellen in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklaration.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1204">The <xref:System.Type.GetInterfaces%2A> method does not return interfaces in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="dd86b-1205">Der Code darf nicht von der Reihenfolge abhängen, in der Schnittstellen zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1205">Your code must not depend on the order in which interfaces are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="dd86b-1206">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Type> Methode die Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1206">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1207">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Schnittstellen Einschränkungen und alle Schnittstellen, die von Klassen-oder Schnittstellen Einschränkungen geerbt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1207">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1208">Im folgenden Beispiel wird der Typ der angegebenen Klasse abgerufen, und es werden alle Schnittstellen angezeigt, die vom Typ implementiert oder geerbt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1208">The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits.</span></span> <span data-ttu-id="dd86b-1209">Um das Visual Basic Beispiel zu kompilieren, verwenden Sie die folgenden Compilerbefehle:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1209">To compile the Visual Basic example, use the following compiler commands:</span></span>  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="dd86b-1210">Ein statischer Initialisierer wird aufgerufen und löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1210">A static initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-1211">Ruft die angegebenen Member des aktuellen <see cref="T:System.Type" /> ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1211">Gets the specified members of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-1212">Die Zeichenfolge, die den Namen des abzurufenden öffentlichen Members enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1212">The string containing the name of the public members to get.</span></span></param>
        <summary><span data-ttu-id="dd86b-1213">Sucht die öffentlichen Member mit dem angegebenen Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1213">Searches for the public members with the specified name.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1214">Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die die öffentlichen Member mit dem angegebenen Namen darstellen, sofern gefunden, andernfalls ein leeres Array.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1214">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1215">Beim Suchen nach `name` wird die Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1215">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="dd86b-1216">Die Suche umfasst öffentliche statische und öffentliche Instanzmember.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1216">The search includes public static and public instance members.</span></span>  
  
 <span data-ttu-id="dd86b-1217">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse usw.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1217">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="dd86b-1218">Die <xref:System.Type.GetMember%2A> -Methode gibt keine Member in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklaration.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1218">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="dd86b-1219">Der Code darf nicht von der Reihenfolge abhängen, in der Elemente zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1219">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="dd86b-1220">Diese Methoden Überladung findet keine Klasseninitialisierer (statischer Konstruktor).</span><span class="sxs-lookup"><span data-stu-id="dd86b-1220">This method overload will not find class initializers (static constructor).</span></span> <span data-ttu-id="dd86b-1221">Um Klasseninitialisierer zu finden, verwenden Sie eine <xref:System.Reflection.BindingFlags>Überladung, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> die<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> annimmt und ( &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) angibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1221">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="dd86b-1222">Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A> -Eigenschaft erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1222">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="dd86b-1223">In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1223">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="dd86b-1224">Memberart</span><span class="sxs-lookup"><span data-stu-id="dd86b-1224">Member Type</span></span>|<span data-ttu-id="dd86b-1225">Statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-1225">Static</span></span>|<span data-ttu-id="dd86b-1226">Nicht statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-1226">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="dd86b-1227">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="dd86b-1227">Constructor</span></span>|<span data-ttu-id="dd86b-1228">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1228">No</span></span>|<span data-ttu-id="dd86b-1229">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1229">No</span></span>|  
|<span data-ttu-id="dd86b-1230">Feld</span><span class="sxs-lookup"><span data-stu-id="dd86b-1230">Field</span></span>|<span data-ttu-id="dd86b-1231">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1231">No</span></span>|<span data-ttu-id="dd86b-1232">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1232">Yes.</span></span> <span data-ttu-id="dd86b-1233">Ein Feld wird immer nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1233">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-1234">event</span><span class="sxs-lookup"><span data-stu-id="dd86b-1234">Event</span></span>|<span data-ttu-id="dd86b-1235">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-1235">Not applicable</span></span>|<span data-ttu-id="dd86b-1236">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1236">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-1237">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-1237">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1238">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1238">See note 2 below.</span></span>|  
|<span data-ttu-id="dd86b-1239">Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-1239">Method</span></span>|<span data-ttu-id="dd86b-1240">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1240">No</span></span>|<span data-ttu-id="dd86b-1241">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1241">Yes.</span></span> <span data-ttu-id="dd86b-1242">Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1242">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-1243">Der Typ "Typ"</span><span class="sxs-lookup"><span data-stu-id="dd86b-1243">Nested Type</span></span>|<span data-ttu-id="dd86b-1244">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1244">No</span></span>|<span data-ttu-id="dd86b-1245">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1245">No</span></span>|  
|<span data-ttu-id="dd86b-1246">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="dd86b-1246">Property</span></span>|<span data-ttu-id="dd86b-1247">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-1247">Not applicable</span></span>|<span data-ttu-id="dd86b-1248">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1248">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-1249">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-1249">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1250">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1250">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="dd86b-1251">"Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1251">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="dd86b-1252">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1252">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="dd86b-1253">Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1253">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1254">Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1254">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="dd86b-1255">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1255">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="dd86b-1256">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.MemberInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1256">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1257">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Member der Klassen Einschränkung oder die Member <xref:System.Object> von, wenn keine Klassen Einschränkung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1257">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1258">Fügen Sie bei generischen Methoden nicht die Typargumente in `name`ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1258">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="dd86b-1259">C# Der Code `GetMember("MyMethod<int>")` sucht z. b. nach einem Member mit dem Textnamen`MyMethod<int>`"" und nicht nach einer Methode mit `MyMethod` dem Namen, die ein generisches `int`Argument vom Typ aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1259">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1260">Im folgenden Beispiel werden alle Member der `String` -Klasse angezeigt, die mit dem Buchstaben C beginnen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1260">The following example displays all the members of the `String` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-1261"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1261"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-1262">Die Zeichenfolge, die den Namen der abzurufenden Member enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1262">The string containing the name of the members to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="dd86b-1263">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1263">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-1264">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1264">-or-</span></span> 
 <span data-ttu-id="dd86b-1265"><see cref="F:System.Reflection.BindingFlags.Default" />, um ein leeres Array zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1265"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="dd86b-1266">Sucht die angegebenen Member unter Verwendung der angegebenen Bindungseinschränkungen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1266">Searches for the specified members, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1267">Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die die öffentlichen Member mit dem angegebenen Namen darstellen, sofern gefunden, andernfalls ein leeres Array.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1267">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1268">Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1268">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="dd86b-1269">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse usw.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1269">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="dd86b-1270">Die <xref:System.Type.GetMember%2A> -Methode gibt keine Member in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklaration.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1270">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="dd86b-1271">Der Code darf nicht von der Reihenfolge abhängen, in der Elemente zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1271">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="dd86b-1272">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Elemente in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1272">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-1273">Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1273">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="dd86b-1274">Geben `BindingFlags.Public` Sie an, dass öffentliche Member in die Suche einbezogen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1274">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-1275">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Member in die Suche eingeschlossen werden sollen (d. h. private, interne und geschützte Member).</span><span class="sxs-lookup"><span data-stu-id="dd86b-1275">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-1276">Legen `BindingFlags.FlattenHierarchy` `protected` Sie`public` fest, dass und statische Member in der Hierarchie nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1276">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="dd86b-1277">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1277">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="dd86b-1278">`BindingFlags.IgnoreCase`, wenn der Fall von `name`ignoriert werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1278">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="dd86b-1279">`BindingFlags.DeclaredOnly`, um nur die Member zu durchsuchen <xref:System.Type>, die auf dem deklariert sind, nicht Elemente, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1279">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="dd86b-1280">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1280">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="dd86b-1281">Um den Klasseninitialisierer (statischer Konstruktor) mithilfe dieser Methoden Überladung zu erhalten, müssen Sie "statischer `name`Konstruktor <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> "<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> für &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> und (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) für angeben. `bindingAttr`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1281">To get the class initializer (static constructor) using this method overload, you must specify "static constructor" for `name`, and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="dd86b-1282">Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A> -Eigenschaft erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1282">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="dd86b-1283">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.MemberInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1283">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1284">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Member der Klassen Einschränkung oder die Member <xref:System.Object> von, wenn keine Klassen Einschränkung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1284">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1285">Fügen Sie bei generischen Methoden nicht die Typargumente in `name`ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1285">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="dd86b-1286">C# Der Code `GetMember("MyMethod<int>")` sucht z. b. nach einem Member mit dem Textnamen`MyMethod<int>`"" und nicht nach einer Methode mit `MyMethod` dem Namen, die ein generisches `int`Argument vom Typ aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1286">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1287">Im folgenden Beispiel werden alle öffentlichen statischen Member der `myString` -Klasse angezeigt, die mit dem Buchstaben C beginnen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1287">The following example displays all the public static members of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-1288"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1288"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-1289">Die Zeichenfolge, die den Namen der abzurufenden Member enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1289">The string containing the name of the members to get.</span></span></param>
        <param name="type"><span data-ttu-id="dd86b-1290">Der zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1290">The value to search for.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="dd86b-1291">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1291">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-1292">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1292">-or-</span></span> 
 <span data-ttu-id="dd86b-1293"><see cref="F:System.Reflection.BindingFlags.Default" />, um ein leeres Array zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1293"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="dd86b-1294">Sucht die angegebenen Member des angegebenen Membertyps unter Verwendung der angegebenen Bindungseinschränkungen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1294">Searches for the specified members of the specified member type, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1295">Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die die öffentlichen Member mit dem angegebenen Namen darstellen, sofern gefunden, andernfalls ein leeres Array.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1295">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1296">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse usw.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1296">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="dd86b-1297">Die <xref:System.Type.GetMember%2A> -Methode gibt keine Member in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklaration.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1297">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="dd86b-1298">Der Code darf nicht von der Reihenfolge abhängen, in der Elemente zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1298">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="dd86b-1299">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Elemente in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1299">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-1300">Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1300">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="dd86b-1301">Geben `BindingFlags.Public` Sie an, dass öffentliche Member in die Suche einbezogen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1301">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-1302">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Member in die Suche eingeschlossen werden sollen (d. h. private, interne und geschützte Member).</span><span class="sxs-lookup"><span data-stu-id="dd86b-1302">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-1303">Legen `BindingFlags.FlattenHierarchy` `protected` Sie`public` fest, dass und statische Member in der Hierarchie nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1303">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="dd86b-1304">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1304">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="dd86b-1305">`BindingFlags.IgnoreCase`, wenn der Fall von `name`ignoriert werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1305">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="dd86b-1306">`BindingFlags.DeclaredOnly`, um nur die Member zu durchsuchen <xref:System.Type>, die auf dem deklariert sind, nicht Elemente, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1306">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="dd86b-1307">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1307">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="dd86b-1308">Um den Klasseninitialisierer (statischer Konstruktor) mithilfe dieser Methoden Überladung zu erhalten, müssen Sie "statischer `name`Konstruktor `type`" für <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> ,<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> für und &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> angeben (`Or`in Visual Basic) für `bindingAttr`. <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="dd86b-1308">To get the class initializer (static constructor) using this method overload, you must specify "static constructor" for `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> for `type`, and  <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="dd86b-1309">Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A> -Eigenschaft erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1309">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="dd86b-1310">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.MemberInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1310">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1311">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Member der Klassen Einschränkung oder die Member <xref:System.Object> von, wenn keine Klassen Einschränkung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1311">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1312">Fügen Sie bei generischen Methoden nicht die Typargumente in `name`ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1312">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="dd86b-1313">C# Der Code `GetMember("MyMethod<int>")` sucht z. b. nach einem Member mit dem Textnamen`MyMethod<int>`"" und nicht nach einer Methode mit `MyMethod` dem Namen, die ein generisches `int`Argument vom Typ aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1313">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1314">Im folgenden Beispiel werden alle Methoden der `myString` -Klasse angezeigt, die mit dem Buchstaben C beginnen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1314">The following example displays all the methods of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-1315"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1315"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd86b-1316">Eine abgeleitete Klasse muss eine Implementierung bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1316">A derived class must provide an implementation.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-1317">Ruft die Member (Eigenschaften, Methoden, Felder, Ereignisse usw.) des aktuellen <see cref="T:System.Type" /> ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1317">Gets the members (properties, methods, fields, events, and so on) of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-1318">Gibt sämtliche öffentlichen Member des aktuellen <see cref="T:System.Type" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1318">Returns all the public members of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1319">Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die sämtliche öffentlichen Member des aktuellen <see cref="T:System.Type" /> darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1319">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all the public members of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="dd86b-1320">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1320">-or-</span></span> 
<span data-ttu-id="dd86b-1321">Ein leeres Array vom <see cref="T:System.Reflection.MemberInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Standardmember besitzt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1321">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have public members.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="dd86b-1322">Zu den Membern zählen Eigenschaften, Methoden, Konstruktoren, Felder, Ereignisse und Untertypen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1322">Members include properties, methods, constructors, fields, events, and nested types.</span></span>
  
 <span data-ttu-id="dd86b-1323">Die <xref:System.Type.GetMembers%2A> -Methode gibt keine Member in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklaration.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1323">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="dd86b-1324">Der Code darf nicht von der Reihenfolge abhängen, in der Elemente zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1324">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="dd86b-1325">Diese Methoden Überladung ruft <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> die-Methoden Überladung<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> mit &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> (`Or` inVisualBasic`Or` ) auf.<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="dd86b-1325">This method overload calls the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="dd86b-1326">Klasseninitialisierer (statische Konstruktoren) werden nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1326">It will not find class initializers (static constructors).</span></span> <span data-ttu-id="dd86b-1327">Um Klasseninitialisierer zu suchen, <xref:System.Type.GetMembers(System.Reflection.BindingFlags)> müssen Sie die- <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> über<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> Ladung aufrufen und &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1327">To find class initializers, call the <xref:System.Type.GetMembers(System.Reflection.BindingFlags)> overload, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="dd86b-1328">Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A> -Eigenschaft erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1328">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="dd86b-1329">In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1329">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="dd86b-1330">Memberart</span><span class="sxs-lookup"><span data-stu-id="dd86b-1330">Member Type</span></span>|<span data-ttu-id="dd86b-1331">Statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-1331">Static</span></span>|<span data-ttu-id="dd86b-1332">Nicht statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-1332">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="dd86b-1333">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="dd86b-1333">Constructor</span></span>|<span data-ttu-id="dd86b-1334">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1334">No</span></span>|<span data-ttu-id="dd86b-1335">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1335">No</span></span>|  
|<span data-ttu-id="dd86b-1336">Feld</span><span class="sxs-lookup"><span data-stu-id="dd86b-1336">Field</span></span>|<span data-ttu-id="dd86b-1337">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1337">No</span></span>|<span data-ttu-id="dd86b-1338">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1338">Yes.</span></span> <span data-ttu-id="dd86b-1339">Ein Feld wird immer nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1339">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-1340">event</span><span class="sxs-lookup"><span data-stu-id="dd86b-1340">Event</span></span>|<span data-ttu-id="dd86b-1341">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-1341">Not applicable</span></span>|<span data-ttu-id="dd86b-1342">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1342">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-1343">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-1343">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1344">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1344">See note 2 below.</span></span>|  
|<span data-ttu-id="dd86b-1345">Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-1345">Method</span></span>|<span data-ttu-id="dd86b-1346">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1346">No</span></span>|<span data-ttu-id="dd86b-1347">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1347">Yes.</span></span> <span data-ttu-id="dd86b-1348">Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1348">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-1349">Der Typ "Typ"</span><span class="sxs-lookup"><span data-stu-id="dd86b-1349">Nested Type</span></span>|<span data-ttu-id="dd86b-1350">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1350">No</span></span>|<span data-ttu-id="dd86b-1351">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1351">No</span></span>|  
|<span data-ttu-id="dd86b-1352">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="dd86b-1352">Property</span></span>|<span data-ttu-id="dd86b-1353">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-1353">Not applicable</span></span>|<span data-ttu-id="dd86b-1354">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1354">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-1355">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-1355">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1356">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1356">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="dd86b-1357">"Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1357">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="dd86b-1358">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1358">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="dd86b-1359">Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1359">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1360">Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1360">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="dd86b-1361">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1361">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="dd86b-1362">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.MemberInfo> Methode die Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1362">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1363">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Member der Klassen Einschränkung oder die Member <xref:System.Object> von, wenn keine Klassen Einschränkung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1363">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span> 
  
## Examples  
 <span data-ttu-id="dd86b-1364">Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Type.GetMembers> -Methoden Überladung verwendet wird, um Informationen über alle öffentlichen Member einer bestimmten Klasse zu sammeln.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1364">The following code example demonstrates how to use the <xref:System.Type.GetMembers> method overload to collect information about all public members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="dd86b-1365">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1365">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-1366">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1366">-or-</span></span> 
 <span data-ttu-id="dd86b-1367"><see cref="F:System.Reflection.BindingFlags.Default" />, um ein leeres Array zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1367"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="dd86b-1368">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die für den aktuellen <see cref="T:System.Type" /> definierten Member.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1368">When overridden in a derived class, searches for the members defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1369">Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Member darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1369">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all members defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="dd86b-1370">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1370">-or-</span></span> 
<span data-ttu-id="dd86b-1371">Ein leeres Array, wenn für den aktuellen <see cref="T:System.Type" /> keine Member definiert sind oder keiner der definierten Member den Bindungseinschränkungen entspricht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1371">An empty array if no members are defined for the current <see cref="T:System.Type" />, or if none of the defined members match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="dd86b-1372">Zu den Membern zählen Eigenschaften, Methoden, Konstruktoren, Felder, Ereignisse und Untertypen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1372">Members include properties, methods, constructors, fields, events, and nested types.</span></span>

<span data-ttu-id="dd86b-1373">Damit die `GetMethods(BindingFlags)` -Überladung Methoden Informationen erfolgreich abrufen kann `bindingAttr` , muss das-Argument mindestens einen <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> von <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>und sowie mindestens einen von <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>enthalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1373">For the `GetMethods(BindingFlags)` overload to successfully retrieve method information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> <span data-ttu-id="dd86b-1374">Die einzige Ausnahme ist ein Methoden aufrufmit <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, der Element Informationen zu den Typen von Typen zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1374">The sole exception is a method call with <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, which returns member information about nested types.</span></span>

<span data-ttu-id="dd86b-1375">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Elemente in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1375">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span> 

- <span data-ttu-id="dd86b-1376">Geben `BindingFlags.Instance` Sie an, um Instanzmethoden einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1376">Specify `BindingFlags.Instance` to include instance methods.</span></span> 

- <span data-ttu-id="dd86b-1377">Geben `BindingFlags.Static` Sie an, um statische Methoden einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1377">Specify `BindingFlags.Static` to include static methods.</span></span> 
  
- <span data-ttu-id="dd86b-1378">Geben `BindingFlags.Public` Sie an, um öffentliche Methoden in die Suche einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1378">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
- <span data-ttu-id="dd86b-1379">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1379">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span> <span data-ttu-id="dd86b-1380">Es werden nur geschützte und interne Methoden für Basisklassen zurückgegeben. Private Methoden für Basisklassen werden nicht zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1380">Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</span></span>  
  
- <span data-ttu-id="dd86b-1381">Legen `BindingFlags.FlattenHierarchy` `protected` Sie`public` fest, dass und statische Member in der Hierarchie nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1381">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  

- <span data-ttu-id="dd86b-1382">Geben `BindingFlags.Default` Sie allein an, um <xref:System.Reflection.MethodInfo> ein leeres Array zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1382">Specify `BindingFlags.Default` alone to return an empty <xref:System.Reflection.MethodInfo> array.</span></span>

<span data-ttu-id="dd86b-1383">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1383">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
- <span data-ttu-id="dd86b-1384">`BindingFlags.DeclaredOnly`, um nur die Member zu durchsuchen <xref:System.Type>, die auf dem deklariert sind, nicht Elemente, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1384">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
<span data-ttu-id="dd86b-1385">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1385">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  

<span data-ttu-id="dd86b-1386">Die <xref:System.Type.GetMembers%2A> -Methode gibt keine Member in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklaration.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1386">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="dd86b-1387">Der Code darf nicht von der Reihenfolge abhängen, in der Elemente zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1387">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  

 <span data-ttu-id="dd86b-1388">Um den Klasseninitialisierer (statischer Konstruktor) mithilfe dieser Methoden Überladung zu erhalten <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> ,<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> müssen Sie ( &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1388">To get the class initializer (static constructor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="dd86b-1389">Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A> -Eigenschaft erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1389">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="dd86b-1390">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.MemberInfo> Methode die Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1390">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1391">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Member der Klassen Einschränkung oder die Member <xref:System.Object> von, wenn keine Klassen Einschränkung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1391">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  

## Examples  
 <span data-ttu-id="dd86b-1392">Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> -Methoden Überladung verwendet wird, um Informationen über alle öffentlichen Instanzmember einer bestimmten Klasse zu sammeln.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1392">The following code example demonstrates how to use the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload to collect information about all public instance members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-1393">Ruft eine bestimmte Methode des aktuellen <see cref="T:System.Type" /> ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1393">Gets a specific method of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-1394">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1394">The string containing the name of the public method to get.</span></span></param>
        <summary><span data-ttu-id="dd86b-1395">Sucht die öffentliche Methode mit dem angegebenen Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1395">Searches for the public method with the specified name.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1396">Ein Objekt, das die öffentliche Methode mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1396">An object that represents the public method with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1397">Beim Suchen nach `name` wird die Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1397">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="dd86b-1398">Die Suche umfasst öffentliche statische und öffentliche Instanzmethoden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1398">The search includes public static and public instance methods.</span></span>  
  
 <span data-ttu-id="dd86b-1399">Wenn eine Methode überladen wird und mehr als eine öffentliche Methode enthält, <xref:System.Type.GetMethod%28System.String%29> löst die Methode <xref:System.Reflection.AmbiguousMatchException> eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1399">If a method is overloaded and has more than one public method, the <xref:System.Type.GetMethod%28System.String%29> method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="dd86b-1400">Im folgenden Beispiel wird eine Ausnahme ausgelöst, da mehrere öffentliche über Ladungen der <xref:System.Int32.ToString%2A?displayProperty=nameWithType> -Methode vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1400">In the following example, an exception is thrown because there is more than one public overload of the <xref:System.Int32.ToString%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="dd86b-1401">Andererseits `Person.ToString` kann die <xref:System.Object.ToString%2A?displayProperty=nameWithType> - <xref:System.Type.GetMethod%28System.String%29> Methode das <xref:System.Reflection.MethodInfo> -Objekt abrufen, da die-Methode überschreibt und daher nicht überladen ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1401">On the other hand, because the `Person.ToString` method overrides  <xref:System.Object.ToString%2A?displayProperty=nameWithType> and therefore is not overloaded, the <xref:System.Type.GetMethod%28System.String%29> method is able to retrieve the <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 <span data-ttu-id="dd86b-1402">Sie können eine der folgenden Aktionen ausführen, um eine bestimmte Methode abzurufen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1402">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="dd86b-1403">Nennen Sie <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> die-Methode, `bindingAttr` und geben Sie ein Argument an, das die Methode eindeutig identifiziert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1403">Call the <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> method and specify a `bindingAttr` argument that uniquely identifies the method.</span></span> <span data-ttu-id="dd86b-1404">Wenn z. b. die Ausnahme ausgelöst wird, weil ein Typ über eine statische und eine instanzüberladung verfügt `bindingAttr` , können <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>Sie ein-Argument von `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1404">For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  `bindingAttr` argument  of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="dd86b-1405">Aufrufen einer über <xref:System.Type.GetMethod%2A> Ladung der-Methode, die `types` einen-Parameter enthält, der die Typen der Parameter der Methode definiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1405">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="dd86b-1406">Rufen Sie <xref:System.Type.GetMethods> die-Methode auf, um ein Array mit allen öffentlichen Methoden abzurufen, die zu einem Typ gehören.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1406">Call the <xref:System.Type.GetMethods> method to retrieve an array containing all of the public methods belonging to a type.</span></span> <span data-ttu-id="dd86b-1407">Anschließend können Sie Sie durchlaufen, um die doppelten Methoden mit `name`dem Namen zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1407">You can then iterate it to identify the duplicate methods named `name`.</span></span>  
  
 <span data-ttu-id="dd86b-1408">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.MethodInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1408">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1409">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Methoden der Klassen Einschränkung oder die Methoden <xref:System.Object> von, wenn keine Klassen Einschränkung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1409">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1410">Fügen Sie bei generischen Methoden nicht die Typargumente in `name`ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1410">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="dd86b-1411">C# Der Code `GetMember("MyMethod<int>")` sucht z. b. nach einem Member mit dem Textnamen`MyMethod<int>`"" und nicht nach einer Methode mit `MyMethod` dem Namen, die ein generisches `int`Argument vom Typ aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1411">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1412">Im folgenden Beispiel wird eine Methode mit `MethodA`dem Namen abgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1412">The following example gets a method named `MethodA`.</span></span>  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-1413">Es wurden mehrere Methoden mit dem angegebenen Namen gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1413">More than one method is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-1414"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1414"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-1415">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1415">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="dd86b-1416">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1416">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-1417">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1417">-or-</span></span> 
 <span data-ttu-id="dd86b-1418"><see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1418"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="dd86b-1419">Sucht die angegebene Methode unter Verwendung der angegebenen Bindungseinschränkungen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1419">Searches for the specified method, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1420">Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1420">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1421">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Methoden in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1421">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-1422">Sie müssen entweder <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> oder <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> angeben, um eine Rückgabe zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1422">You must specify either <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in order to get a return.</span></span>  
  
-   <span data-ttu-id="dd86b-1423">Geben <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> Sie an, um öffentliche Methoden in die Suche einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1423">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-1424">Geben <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Sie an, dass nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1424">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-1425">Legen <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> `protected` Sie`public` fest, dass und statische Member in der Hierarchie nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1425">Specify <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="dd86b-1426">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1426">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="dd86b-1427"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType>, wenn der Fall von `name`ignoriert werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1427"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="dd86b-1428"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>um nur die Methoden zu durchsuchen <xref:System.Type>, die in deklariert sind, und nicht die Methoden, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1428"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="dd86b-1429">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1429">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="dd86b-1430">Wenn eine Methode überladen wird und mehr als eine Überladung die durch das `bindingAttr` Argument angegebenen Einschränkungen erfüllt, löst die Methode eine <xref:System.Reflection.AmbiguousMatchException> Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1430">If a method is overloaded and more than one overload meets the constraints specified by the `bindingAttr` argument, the method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="dd86b-1431">Im folgenden Beispiel wird eine Ausnahme ausgelöst:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1431">In the following example, an exception is thrown because:</span></span>  
  
-   <span data-ttu-id="dd86b-1432">Der `TestClass` -Typ verfügt über zwei öffentliche Instanzüberladungen `DisplayValue` der `DisplayValue(String)` - `DisplayValue(String, Object[])`Methode, und.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1432">The `TestClass` type has two public instance overloads of the `DisplayValue` method, `DisplayValue(String)` and `DisplayValue(String, Object[])`.</span></span>  
  
-   <span data-ttu-id="dd86b-1433">Der `TestClass` -Typ verfügt über zwei öffentliche Instanzüberladungen `Equals` der-Methode, <xref:System.Object>von denen einer geerbt `Equals(TestClass)` wird `Equals(Object)`: und.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1433">The `TestClass` type has two public instance overloads of the `Equals` method,  one of which is inherited from <xref:System.Object>: `Equals(TestClass)` and `Equals(Object)`.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 <span data-ttu-id="dd86b-1434">Sie können eine der folgenden Aktionen ausführen, um eine bestimmte Methode abzurufen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1434">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="dd86b-1435">Ändern Sie die Bindungs Einschränkungen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1435">Change the binding constraints.</span></span> <span data-ttu-id="dd86b-1436">Im vorherigen Beispiel wird beim Versuch, eine öffentliche Instanzmethode `Equals` abzurufen, die vom-Typ deklariert und nicht geerbt wurde, erfolgreich `Equals(TestClass)`abgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1436">In the previous example, attempting to retrieve a public instance `Equals` method that is declared by the type and not inherited successfully retrieves `Equals(TestClass)`.</span></span>  
  
-   <span data-ttu-id="dd86b-1437">Aufrufen einer über <xref:System.Type.GetMethod%2A> Ladung der-Methode, die `types` einen-Parameter enthält, der die Typen der Parameter der Methode definiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1437">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="dd86b-1438">Rufen Sie <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> die-Methode auf, um ein Array abzurufen, das alle Methoden enthält, die zu einem Typ gehören, der über die angegebenen Bindungs Attribute verfügt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1438">Call the <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.</span></span> <span data-ttu-id="dd86b-1439">Anschließend können Sie Sie durchlaufen, um die doppelten Methoden mit `name`dem Namen zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1439">You can then iterate it to identify the duplicate methods named `name`.</span></span> <span data-ttu-id="dd86b-1440">Diese Vorgehensweise wird im vorherigen Beispiel Handler für die <xref:System.Reflection.AmbiguousMatchException> Ausnahme veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1440">This approach is illustrated in the previous example's handler for the <xref:System.Reflection.AmbiguousMatchException> exception.</span></span>  
  
 <span data-ttu-id="dd86b-1441">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.MethodInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1441">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1442">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Methoden der Klassen Einschränkung oder die Methoden <xref:System.Object> von, wenn keine Klassen Einschränkung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1442">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1443">Fügen Sie bei generischen Methoden nicht die Typargumente in `name`ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1443">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="dd86b-1444">C# Der Code `GetMember("MyMethod<int>")` sucht z. b. nach einem Member mit dem Textnamen`MyMethod<int>`"" und nicht nach einer Methode mit `MyMethod` dem Namen, die ein generisches `int`Argument vom Typ aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1444">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1445">Im folgenden Beispiel wird die Methode abgerufen, die mit den angegebenen Bindungsflags übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1445">The following example gets the method that matches the specified binding flags.</span></span>  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-1446">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1446">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-1447"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1447"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-1448">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1448">The string containing the name of the public method to get.</span></span></param>
        <param name="types"><span data-ttu-id="dd86b-1449">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1449">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="dd86b-1450">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1450">-or-</span></span> 
<span data-ttu-id="dd86b-1451">Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1451">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <summary><span data-ttu-id="dd86b-1452">Sucht die angegebene öffentliche Methode, deren Parameter den angegebenen Argumenttypen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1452">Searches for the specified public method whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1453">Ein Objekt, das die öffentliche Methode darstellt, deren Parameter den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1453">An object representing the public method whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1454">Beim Suchen nach `name` wird die Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1454">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="dd86b-1455">Die Suche umfasst öffentliche statische und öffentliche Instanzmethoden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1455">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1456">Sie können Parameter nicht weglassen, wenn Sie Konstruktoren und Methoden suchen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1456">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="dd86b-1457">Beim Aufrufen von können Sie nur Parameter weglassen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1457">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="dd86b-1458">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.MethodInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1458">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1459">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Methoden der Klassen Einschränkung oder die Methoden <xref:System.Object> von, wenn keine Klassen Einschränkung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1459">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1460">Der `name` -Parameter darf keine Typargumente enthalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1460">The `name` parameter cannot include type arguments.</span></span> <span data-ttu-id="dd86b-1461">C# Der Code `GetMethod("MyGenericMethod<int>")` sucht beispielsweise nach einer Methode mit dem Textnamen "`MyGenericMethod<int>`" und nicht nach einer Methode mit dem Namen `MyGenericMethod` , die ein generisches Argument vom `int`Typ aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1461">For example, the C# code `GetMethod("MyGenericMethod<int>")` searches for a method with the text name "`MyGenericMethod<int>`", rather than for a method named `MyGenericMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="dd86b-1462">Verwenden `GetMethod("MyGenericMethod")` Sie stattdessen mit dem entsprechenden Parameter `types` im Array.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1462">Instead, use `GetMethod("MyGenericMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1463">Im folgenden Beispiel werden bestimmte über Ladungen von `MethodA`ermittelt, wobei eine Vielzahl von Argument Typen angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1463">The following example finds specific overloads of `MethodA`, specifying a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1464">Das [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Beispiel erfordert die `/unsafe` -Compileroption.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1464">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 <span data-ttu-id="dd86b-1465"><xref:System.Reflection.MethodInfo> Im folgenden Beispiel werden Objekte abgerufen, die die `Add` Methoden eines nicht generischen Typs (der <xref:System.Collections.ArrayList> -Klasse), ein offener generischer Typ ( <xref:System.Collections.Generic.List%601> die-Klasse) und ein geschlossener generischer Typ `List(Of String)` (der-Typ) darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1465">The following example retrieves <xref:System.Reflection.MethodInfo> objects that represent the `Add` methods  of a non-generic type (the <xref:System.Collections.ArrayList> class), an open generic type (the <xref:System.Collections.Generic.List%601> class), and a closed generic type (the `List(Of String)` type.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 <span data-ttu-id="dd86b-1466">Im Beispiel wird eine `GetAddMethod` -Methode definiert, die das <xref:System.Reflection.MethodInfo> entsprechende-Objekt abruft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1466">The example defines a `GetAddMethod` method that retrieves the appropriate <xref:System.Reflection.MethodInfo> object.</span></span> <span data-ttu-id="dd86b-1467">Um das `types` Argument für einen offenen generischen Typ bereitzustellen, wird <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> die-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1467">To provide the `types` argument for an open generic type, it calls the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="dd86b-1468">Um das `types` Argument für einen geschlossenen generischen Typ bereitzustellen, ruft es den Wert <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> der-Eigenschaft ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1468">To provide the `types` argument for a closed generic type, it retrieves the value of the <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-1469">Es wurden mehrere Methoden mit dem angegebenen Namen und den angegebenen Parametern gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1469">More than one method is found with the specified name and specified parameters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-1470"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1470"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-1471">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1471">-or-</span></span> 
 <span data-ttu-id="dd86b-1472"><paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1472"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-1473">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1473">-or-</span></span> 
<span data-ttu-id="dd86b-1474">Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1474">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-1475"><paramref name="types" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1475"><paramref name="types" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-1476">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1476">The string containing the name of the public method to get.</span></span></param>
        <param name="types"><span data-ttu-id="dd86b-1477">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1477">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="dd86b-1478">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1478">-or-</span></span> 
<span data-ttu-id="dd86b-1479">Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1479">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="dd86b-1480">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1480">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="dd86b-1481">Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1481">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="dd86b-1482">Der Standardbinder verarbeitet diesen Parameter nicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1482">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="dd86b-1483">Sucht die angegebene öffentliche Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1483">Searches for the specified public method whose parameters match the specified argument types and modifiers.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1484">Ein Objekt, das die öffentliche Methode darstellt, die den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1484">An object representing the public method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1485">Obwohl der Standard <xref:System.Reflection.ParameterModifier> Binder nicht verarbeitet (der `modifiers` -Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> -Klasse verwenden, um einen benutzerdefinierten Binder zu `modifiers`schreiben, der verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1485">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="dd86b-1486">`ParameterModifier`wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1486">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="dd86b-1487">Beim Suchen nach `name` wird die Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1487">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="dd86b-1488">Die Suche umfasst öffentliche statische und öffentliche Instanzmethoden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1488">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1489">Sie können Parameter nicht weglassen, wenn Sie Konstruktoren und Methoden suchen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1489">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="dd86b-1490">Beim Aufrufen von können Sie nur Parameter weglassen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1490">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="dd86b-1491">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.MethodInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1491">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1492">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Methoden der Klassen Einschränkung oder die Methoden <xref:System.Object> von, wenn keine Klassen Einschränkung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1492">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1493">Fügen Sie bei generischen Methoden nicht die Typargumente in `name`ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1493">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="dd86b-1494">C# Der Code `GetMethod("MyMethod<int>")` sucht z. b. nach einem Member mit dem Textnamen`MyMethod<int>`"" und nicht nach einer Methode mit `MyMethod` dem Namen, die ein generisches `int`Argument vom Typ aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1494">For example, the C# code `GetMethod("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="dd86b-1495">Verwenden `GetMethod("MyMethod")` Sie stattdessen mit dem entsprechenden Parameter `types` im Array.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1495">Instead, use `GetMethod("MyMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-1496">Es wurden mehrere Methoden mit dem angegebenen Namen und den angegebenen Parametern gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1496">More than one method is found with the specified name and specified parameters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-1497"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1497"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-1498">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1498">-or-</span></span> 
 <span data-ttu-id="dd86b-1499"><paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1499"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-1500">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1500">-or-</span></span> 
<span data-ttu-id="dd86b-1501">Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1501">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-1502"><paramref name="types" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1502"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="dd86b-1503">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1503">-or-</span></span> 
 <span data-ttu-id="dd86b-1504"><paramref name="modifiers" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1504"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-1505">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1505">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="dd86b-1506">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1506">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-1507">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1507">-or-</span></span> 
 <span data-ttu-id="dd86b-1508"><see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1508"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="dd86b-1509">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1509">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="dd86b-1510">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1510">-or-</span></span> 
<span data-ttu-id="dd86b-1511">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" />verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1511">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="types"><span data-ttu-id="dd86b-1512">Ein Array von <see cref="T:System.Type" /> -Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1512">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="dd86b-1513">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1513">-or-</span></span> 
<span data-ttu-id="dd86b-1514">Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1514">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="dd86b-1515">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1515">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="dd86b-1516">Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1516">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="dd86b-1517">Der Standardbinder verarbeitet diesen Parameter nicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1517">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="dd86b-1518">Sucht unter Verwendung der angegebenen Bindungseinschränkungen nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1518">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1519">Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1519">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1520">Obwohl der Standard <xref:System.Reflection.ParameterModifier> Binder nicht verarbeitet (der `modifiers` -Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> -Klasse verwenden, um einen benutzerdefinierten Binder zu `modifiers`schreiben, der verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1520">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="dd86b-1521">`ParameterModifier`wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1521">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="dd86b-1522">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Methoden in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1522">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-1523">Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1523">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="dd86b-1524">Geben `BindingFlags.Public` Sie an, um öffentliche Methoden in die Suche einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1524">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-1525">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1525">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-1526">Legen `BindingFlags.FlattenHierarchy` `protected` Sie`public` fest, dass und statische Member in der Hierarchie nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1526">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="dd86b-1527">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1527">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="dd86b-1528">`BindingFlags.IgnoreCase`, wenn der Fall von `name`ignoriert werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1528">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="dd86b-1529">`BindingFlags.DeclaredOnly`um nur die Methoden zu durchsuchen <xref:System.Type>, die in deklariert sind, und nicht die Methoden, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1529">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="dd86b-1530">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1530">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1531">Sie können Parameter nicht weglassen, wenn Sie Konstruktoren und Methoden suchen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1531">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="dd86b-1532">Beim Aufrufen von können Sie nur Parameter weglassen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1532">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="dd86b-1533">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.MethodInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1533">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1534">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Methoden der Klassen Einschränkung oder die Methoden <xref:System.Object> von, wenn keine Klassen Einschränkung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1534">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1535">Fügen Sie bei generischen Methoden nicht die Typargumente in `name`ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1535">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="dd86b-1536">C# Der Code `GetMember("MyMethod<int>")` sucht z. b. nach einem Member mit dem Textnamen`MyMethod<int>`"" und nicht nach einer Methode mit `MyMethod` dem Namen, die ein generisches `int`Argument vom Typ aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1536">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1537">Im folgenden Beispiel werden bestimmte über Ladungen von `MethodA`ermittelt, und es werden Bindungs Einschränkungen und verschiedene Argument Typen angegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1537">The following example finds specific overloads of `MethodA`, specifying binding constraints and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1538">Das [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Beispiel erfordert die `/unsafe` -Compileroption.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1538">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-1539">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1539">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-1540"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1540"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-1541">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1541">-or-</span></span> 
 <span data-ttu-id="dd86b-1542"><paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1542"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-1543">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1543">-or-</span></span> 
<span data-ttu-id="dd86b-1544">Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1544">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-1545"><paramref name="types" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1545"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="dd86b-1546">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1546">-or-</span></span> 
 <span data-ttu-id="dd86b-1547"><paramref name="modifiers" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1547"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-1548">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1548">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="dd86b-1549">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1549">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-1550">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1550">-or-</span></span> 
 <span data-ttu-id="dd86b-1551"><see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1551"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="dd86b-1552">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1552">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="dd86b-1553">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1553">-or-</span></span> 
<span data-ttu-id="dd86b-1554">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1554">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="dd86b-1555">Das Objekt, das die Regeln für Reihenfolge und Layout der Argumente, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1555">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="dd86b-1556">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1556">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="dd86b-1557">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1557">-or-</span></span> 
<span data-ttu-id="dd86b-1558">Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1558">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="dd86b-1559">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1559">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="dd86b-1560">Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1560">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="dd86b-1561">Der Standardbinder verarbeitet diesen Parameter nicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1561">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="dd86b-1562">Sucht nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen, und verwendet dabei die angegebenen Bindungseinschränkungen und die angegebene Aufrufkonvention.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1562">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1563">Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1563">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1564">Obwohl der Standard <xref:System.Reflection.ParameterModifier> Binder nicht verarbeitet (der `modifiers` -Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> -Klasse verwenden, um einen benutzerdefinierten Binder zu `modifiers`schreiben, der verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1564">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="dd86b-1565">`ParameterModifier`wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1565">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="dd86b-1566">In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `GetXXX` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1566">The following table shows what members of a base class are returned by the `GetXXX` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="dd86b-1567">Memberart</span><span class="sxs-lookup"><span data-stu-id="dd86b-1567">Member Type</span></span>|<span data-ttu-id="dd86b-1568">Statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-1568">Static</span></span>|<span data-ttu-id="dd86b-1569">Nicht statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-1569">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="dd86b-1570">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="dd86b-1570">Constructor</span></span>|<span data-ttu-id="dd86b-1571">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1571">No</span></span>|<span data-ttu-id="dd86b-1572">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1572">No</span></span>|  
|<span data-ttu-id="dd86b-1573">Feld</span><span class="sxs-lookup"><span data-stu-id="dd86b-1573">Field</span></span>|<span data-ttu-id="dd86b-1574">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1574">No</span></span>|<span data-ttu-id="dd86b-1575">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1575">Yes.</span></span> <span data-ttu-id="dd86b-1576">Ein Feld wird immer nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1576">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-1577">event</span><span class="sxs-lookup"><span data-stu-id="dd86b-1577">Event</span></span>|<span data-ttu-id="dd86b-1578">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-1578">Not applicable</span></span>|<span data-ttu-id="dd86b-1579">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1579">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-1580">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-1580">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1581">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1581">See note 2 below.</span></span>|  
|<span data-ttu-id="dd86b-1582">Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-1582">Method</span></span>|<span data-ttu-id="dd86b-1583">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1583">No</span></span>|<span data-ttu-id="dd86b-1584">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1584">Yes.</span></span> <span data-ttu-id="dd86b-1585">Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1585">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-1586">Der Typ "Typ"</span><span class="sxs-lookup"><span data-stu-id="dd86b-1586">Nested Type</span></span>|<span data-ttu-id="dd86b-1587">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1587">No</span></span>|<span data-ttu-id="dd86b-1588">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1588">No</span></span>|  
|<span data-ttu-id="dd86b-1589">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="dd86b-1589">Property</span></span>|<span data-ttu-id="dd86b-1590">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-1590">Not applicable</span></span>|<span data-ttu-id="dd86b-1591">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1591">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-1592">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-1592">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1593">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1593">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="dd86b-1594">"Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1594">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="dd86b-1595">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1595">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="dd86b-1596">Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1596">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1597">Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1597">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="dd86b-1598">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1598">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="dd86b-1599">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Methoden in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1599">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-1600">Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1600">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="dd86b-1601">Geben `BindingFlags.Public` Sie an, um öffentliche Methoden in die Suche einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1601">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-1602">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1602">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-1603">Legen `BindingFlags.FlattenHierarchy` `protected` Sie`public` fest, dass und statische Member in der Hierarchie nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1603">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="dd86b-1604">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1604">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="dd86b-1605">`BindingFlags.IgnoreCase`, wenn der Fall von `name`ignoriert werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1605">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="dd86b-1606">`BindingFlags.DeclaredOnly`um nur die Methoden zu durchsuchen <xref:System.Type>, die in deklariert sind, und nicht die Methoden, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1606">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="dd86b-1607">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1607">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1608">Sie können Parameter nicht weglassen, wenn Sie Konstruktoren und Methoden suchen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1608">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="dd86b-1609">Beim Aufrufen von können Sie nur Parameter weglassen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1609">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="dd86b-1610">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.MethodInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1610">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1611">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Methoden der Klassen Einschränkung oder die Methoden <xref:System.Object> von, wenn keine Klassen Einschränkung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1611">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1612">Fügen Sie bei generischen Methoden nicht die Typargumente in `name`ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1612">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="dd86b-1613">C# Der Code `GetMember("MyMethod<int>")` sucht z. b. nach einem Member mit dem Textnamen`MyMethod<int>`"" und nicht nach einer Methode mit `MyMethod` dem Namen, die ein generisches `int`Argument vom Typ aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1613">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1614">Im folgenden Beispiel werden bestimmte über Ladungen von `MethodA`gesucht, die Bindungs Einschränkungen, Aufruf Konventionen und eine Vielzahl von Argument Typen angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1614">The following example finds specific overloads of `MethodA`, specifying binding constraints, calling conventions, and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1615">Das [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Beispiel erfordert die `/unsafe` -Compileroption.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1615">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-1616">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1616">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-1617"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1617"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-1618">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1618">-or-</span></span> 
 <span data-ttu-id="dd86b-1619"><paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1619"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-1620">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1620">-or-</span></span> 
<span data-ttu-id="dd86b-1621">Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1621">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-1622"><paramref name="types" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1622"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="dd86b-1623">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1623">-or-</span></span> 
 <span data-ttu-id="dd86b-1624"><paramref name="modifiers" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1624"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-1625">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1625">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="dd86b-1626">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1626">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-1627">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1627">-or-</span></span> 
 <span data-ttu-id="dd86b-1628"><see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1628"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="dd86b-1629">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1629">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="dd86b-1630">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1630">-or-</span></span> 
<span data-ttu-id="dd86b-1631">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" />verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1631">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="dd86b-1632">Das Objekt, das die Regeln für Reihenfolge und Layout der Argumente, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und den Prozess angibt, der den Stapel bereinigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1632">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</span></span></param>
        <param name="types"><span data-ttu-id="dd86b-1633">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1633">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="dd86b-1634">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1634">-or-</span></span> 
<span data-ttu-id="dd86b-1635">Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer Methode, die keine Parameter akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1635">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</span></span>  
  
<span data-ttu-id="dd86b-1636">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1636">-or-</span></span> 
 <span data-ttu-id="dd86b-1637"><see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1637"><see langword="null" />.</span></span> <span data-ttu-id="dd86b-1638">Wenn <paramref name="types" /> <see langword="null" /> ist, wird keine Übereinstimmung von Argumenten überprüft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1638">If <paramref name="types" /> is <see langword="null" />, arguments are not matched.</span></span></param>
        <param name="modifiers"><span data-ttu-id="dd86b-1639">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1639">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="dd86b-1640">Der Standardbinder verarbeitet diesen Parameter nicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1640">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="dd86b-1641">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen und der angegebenen Aufrufkonvention nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1641">When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1642">Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1642">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1643">Obwohl der Standard <xref:System.Reflection.ParameterModifier> Binder nicht verarbeitet (der `modifiers` -Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> -Klasse verwenden, um einen benutzerdefinierten Binder zu `modifiers`schreiben, der verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1643">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="dd86b-1644">`ParameterModifier`wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1644">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="dd86b-1645">Wenn `types` `null` ist, wird keine Übereinstimmung von Argumenten überprüft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1645">If `types` is `null`, arguments are not matched.</span></span>  
  
 <span data-ttu-id="dd86b-1646">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Methoden in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1646">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-1647">Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1647">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="dd86b-1648">Geben `BindingFlags.Public` Sie an, um öffentliche Methoden in die Suche einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1648">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-1649">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1649">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-1650">Legen `BindingFlags.FlattenHierarchy` `protected` Sie`public` fest, dass und statische Member in der Hierarchie nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1650">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="dd86b-1651">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1651">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="dd86b-1652">`BindingFlags.IgnoreCase`, wenn der Fall von `name`ignoriert werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1652">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="dd86b-1653">`BindingFlags.DeclaredOnly`um nur die Methoden zu durchsuchen <xref:System.Type>, die in deklariert sind, und nicht die Methoden, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1653">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="dd86b-1654">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1654">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-1655">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1655">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-1656"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1656"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-1657"><paramref name="types" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1657"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="dd86b-1658">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1658">-or-</span></span> 
 <span data-ttu-id="dd86b-1659"><paramref name="modifiers" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1659"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="dd86b-1660">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1660">-or-</span></span> 
 <span data-ttu-id="dd86b-1661"><paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1661"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd86b-1662">Der aktuelle Typ ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" /> oder <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1662">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-1663">Ruft die Methoden des aktuellen <see cref="T:System.Type" /> ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1663">Gets the methods of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-1664">Gibt sämtliche öffentlichen Methoden des aktuellen <see cref="T:System.Type" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1664">Returns all the public methods of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1665">Ein Array von <see cref="T:System.Reflection.MethodInfo" />-Objekten, die alle für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Member darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1665">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the public methods defined for the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="dd86b-1666">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1666">-or-</span></span> 
<span data-ttu-id="dd86b-1667">Ein leeres Array vom <see cref="T:System.Reflection.MethodInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine öffentlichen Methoden definiert sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1667">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no public methods are defined for the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="dd86b-1668">Die <xref:System.Type.GetMethods%2A> Methode gibt keine Methoden in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1668">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="dd86b-1669">Der Code darf nicht von der Reihenfolge abhängen, in der Methoden zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1669">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="dd86b-1670">Konstruktoren sind nicht in dem Array von Methoden enthalten, die von diesem-Befehl zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1670">Constructors are not included in the array of methods returned by this call.</span></span> <span data-ttu-id="dd86b-1671">Erstellen Sie einen separaten- `GetConstructors()` Befehl, um die Konstruktormethoden abzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1671">Make a separate call to `GetConstructors()` to get the constructor methods.</span></span>  
  
 <span data-ttu-id="dd86b-1672">In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1672">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="dd86b-1673">Memberart</span><span class="sxs-lookup"><span data-stu-id="dd86b-1673">Member Type</span></span>|<span data-ttu-id="dd86b-1674">Statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-1674">Static</span></span>|<span data-ttu-id="dd86b-1675">Nicht statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-1675">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="dd86b-1676">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="dd86b-1676">Constructor</span></span>|<span data-ttu-id="dd86b-1677">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1677">No</span></span>|<span data-ttu-id="dd86b-1678">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1678">No</span></span>|  
|<span data-ttu-id="dd86b-1679">Feld</span><span class="sxs-lookup"><span data-stu-id="dd86b-1679">Field</span></span>|<span data-ttu-id="dd86b-1680">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1680">No</span></span>|<span data-ttu-id="dd86b-1681">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1681">Yes.</span></span> <span data-ttu-id="dd86b-1682">Ein Feld wird immer nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1682">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-1683">event</span><span class="sxs-lookup"><span data-stu-id="dd86b-1683">Event</span></span>|<span data-ttu-id="dd86b-1684">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-1684">Not applicable</span></span>|<span data-ttu-id="dd86b-1685">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1685">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-1686">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-1686">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1687">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1687">See note 2 below.</span></span>|  
|<span data-ttu-id="dd86b-1688">Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-1688">Method</span></span>|<span data-ttu-id="dd86b-1689">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1689">No</span></span>|<span data-ttu-id="dd86b-1690">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1690">Yes.</span></span> <span data-ttu-id="dd86b-1691">Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1691">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-1692">Der Typ "Typ"</span><span class="sxs-lookup"><span data-stu-id="dd86b-1692">Nested Type</span></span>|<span data-ttu-id="dd86b-1693">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1693">No</span></span>|<span data-ttu-id="dd86b-1694">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1694">No</span></span>|  
|<span data-ttu-id="dd86b-1695">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="dd86b-1695">Property</span></span>|<span data-ttu-id="dd86b-1696">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-1696">Not applicable</span></span>|<span data-ttu-id="dd86b-1697">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1697">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-1698">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-1698">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1699">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1699">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="dd86b-1700">"Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1700">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="dd86b-1701">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1701">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="dd86b-1702">Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1702">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1703">Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1703">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="dd86b-1704">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1704">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1705">Sie können Parameter nicht weglassen, wenn Sie Konstruktoren und Methoden suchen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1705">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="dd86b-1706">Beim Aufrufen von können Sie nur Parameter weglassen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1706">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="dd86b-1707">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.MethodInfo> Methode die Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1707">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1708">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Methoden der Klassen Einschränkung oder die Methoden <xref:System.Object> von, wenn keine Klassen Einschränkung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1708">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="dd86b-1709">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1709">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="dd86b-1710">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1710">-or-</span></span>

 <span data-ttu-id="dd86b-1711"><see cref="F:System.Reflection.BindingFlags.Default" />, um ein leeres Array zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1711"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="dd86b-1712">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die für den aktuellen <see cref="T:System.Type" /> definierten Methoden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1712">When overridden in a derived class, searches for the methods defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1713">Ein Array von <see cref="T:System.Reflection.MethodInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Methoden darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1713">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all methods defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="dd86b-1714">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1714">-or-</span></span> 
<span data-ttu-id="dd86b-1715">Ein leeres Array vom <see cref="T:System.Reflection.MethodInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine Methoden definiert sind oder keine der definierten Methoden den Bindungseinschränkungen entspricht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1715">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no methods are defined for the current <see cref="T:System.Type" />, or if none of the defined methods match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="dd86b-1716">Damit die `GetMethods(BindingFlags)` -Überladung Methoden Informationen erfolgreich abrufen kann `bindingAttr` , muss das-Argument mindestens einen <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> von <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>und sowie mindestens einen von <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>enthalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1716">For the `GetMethods(BindingFlags)` overload to successfully retrieve method information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> 
  
 <span data-ttu-id="dd86b-1717">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Methoden in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1717">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
- <span data-ttu-id="dd86b-1718">Geben `BindingFlags.Instance` Sie an, um Instanzmethoden einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1718">Specify `BindingFlags.Instance` to include instance methods.</span></span> 

- <span data-ttu-id="dd86b-1719">Geben `BindingFlags.Static` Sie an, um statische Methoden einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1719">Specify `BindingFlags.Static` to include static methods.</span></span> 
  
- <span data-ttu-id="dd86b-1720">Geben `BindingFlags.Public` Sie an, um öffentliche Methoden in die Suche einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1720">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
- <span data-ttu-id="dd86b-1721">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1721">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span> <span data-ttu-id="dd86b-1722">Es werden nur geschützte und interne Methoden für Basisklassen zurückgegeben. Private Methoden für Basisklassen werden nicht zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1722">Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</span></span>  
  
- <span data-ttu-id="dd86b-1723">Legen `BindingFlags.FlattenHierarchy` `protected` Sie`public` fest, dass und statische Member in der Hierarchie nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1723">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  

- <span data-ttu-id="dd86b-1724">Geben `BindingFlags.Default` Sie allein an, um <xref:System.Reflection.MethodInfo> ein leeres Array zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1724">Specify `BindingFlags.Default` alone to return an empty <xref:System.Reflection.MethodInfo> array.</span></span>
  
 <span data-ttu-id="dd86b-1725">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1725">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
- <span data-ttu-id="dd86b-1726">`BindingFlags.DeclaredOnly`um nur die Methoden zu durchsuchen <xref:System.Type>, die in deklariert sind, und nicht die Methoden, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1726">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="dd86b-1727">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1727">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  

<span data-ttu-id="dd86b-1728">Die <xref:System.Type.GetMethods%2A> Methode gibt keine Methoden in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1728">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="dd86b-1729">Der Code darf nicht von der Reihenfolge abhängen, in der Methoden zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1729">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  

<span data-ttu-id="dd86b-1730">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.MethodInfo> Methode die Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1730">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
<span data-ttu-id="dd86b-1731">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Methoden der Klassen Einschränkung oder die Methoden <xref:System.Object> von, wenn keine Klassen Einschränkung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1731">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span> 
  
## Examples  
 <span data-ttu-id="dd86b-1732">Im folgenden Beispiel wird eine-Klasse mit zwei öffentlichen Methoden und einer geschützten Methode erstellt, `Type` ein-Objekt `MyTypeClass`erstellt, das entspricht, alle öffentlichen und nicht öffentlichen Methoden werden abgerufen, und ihre Namen werden angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1732">The following example creates a class with two public methods and one protected method, creates a `Type` object corresponding to `MyTypeClass`, gets all public and non-public methods, and displays their names.</span></span>  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-1733">Ruft einen bestimmten Typ ab, der im aktuellen <see cref="T:System.Type" /> geschachtelt ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1733">Gets a specific type nested within the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-1734">Die Zeichenfolge, die den Namen des abzurufenden geschachtelten Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1734">The string containing the name of the nested type to get.</span></span></param>
        <summary><span data-ttu-id="dd86b-1735">Sucht den öffentlichen geschachtelten Typ mit dem angegebenen Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1735">Searches for the public nested type with the specified name.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1736">Ein Objekt, das den öffentlichen geschachtelten Typ mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1736">An object representing the public nested type with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1737">Beim Suchen nach `name` wird die Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1737">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="dd86b-1738">Verwenden Sie den einfachen Namen der-Klasse für `name`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1738">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="dd86b-1739">Qualifizieren Sie diese nicht mit dem Namen der äußeren Klasse.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1739">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="dd86b-1740">Verwenden Sie für eine generische geschaltete Klasse den geschalteten Namen, d. h., fügen Sie einen schweren Akzent und die Anzahl der generischen Argumente an.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1740">For a generic nested class, use the mangled name - that is, append a grave accent and the number of generic arguments.</span></span> <span data-ttu-id="dd86b-1741">Verwenden Sie z. b. die Zeichen\`Folge "Inner 1", um die generische `Inner<T>` geschachtelte Klasse (`Inner(Of T)` in Visual Basic) zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1741">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="dd86b-1742">Fügen Sie keine sprachspezifische Syntax für Typparameter ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1742">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="dd86b-1743">In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1743">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="dd86b-1744">Memberart</span><span class="sxs-lookup"><span data-stu-id="dd86b-1744">Member Type</span></span>|<span data-ttu-id="dd86b-1745">Statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-1745">Static</span></span>|<span data-ttu-id="dd86b-1746">Nicht statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-1746">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="dd86b-1747">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="dd86b-1747">Constructor</span></span>|<span data-ttu-id="dd86b-1748">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1748">No</span></span>|<span data-ttu-id="dd86b-1749">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1749">No</span></span>|  
|<span data-ttu-id="dd86b-1750">Feld</span><span class="sxs-lookup"><span data-stu-id="dd86b-1750">Field</span></span>|<span data-ttu-id="dd86b-1751">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1751">No</span></span>|<span data-ttu-id="dd86b-1752">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1752">Yes.</span></span> <span data-ttu-id="dd86b-1753">Ein Feld wird immer nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1753">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-1754">event</span><span class="sxs-lookup"><span data-stu-id="dd86b-1754">Event</span></span>|<span data-ttu-id="dd86b-1755">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-1755">Not applicable</span></span>|<span data-ttu-id="dd86b-1756">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1756">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-1757">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-1757">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1758">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1758">See note 2 below.</span></span>|  
|<span data-ttu-id="dd86b-1759">Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-1759">Method</span></span>|<span data-ttu-id="dd86b-1760">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1760">No</span></span>|<span data-ttu-id="dd86b-1761">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1761">Yes.</span></span> <span data-ttu-id="dd86b-1762">Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1762">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-1763">Der Typ "Typ"</span><span class="sxs-lookup"><span data-stu-id="dd86b-1763">Nested Type</span></span>|<span data-ttu-id="dd86b-1764">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1764">No</span></span>|<span data-ttu-id="dd86b-1765">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1765">No</span></span>|  
|<span data-ttu-id="dd86b-1766">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="dd86b-1766">Property</span></span>|<span data-ttu-id="dd86b-1767">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-1767">Not applicable</span></span>|<span data-ttu-id="dd86b-1768">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1768">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-1769">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-1769">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1770">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1770">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="dd86b-1771">"Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1771">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="dd86b-1772">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1772">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="dd86b-1773">Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1773">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1774">Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1774">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="dd86b-1775">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1775">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="dd86b-1776">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Untertypen der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1776">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="dd86b-1777">Wenn ein ngenerischer Typ generisch ist, gibt diese Methode die generische Typdefinition zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1777">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="dd86b-1778">Dies gilt auch, wenn der umschließende generische Typ ein geschlossener konstruierter Typ ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1778">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1779">Wenn der aktuelle <xref:System.Type> einen generischen Typ darstellt, C#der in, Visual Basic C++oder definiert ist, sind die zugehörigen Typen generisch, auch wenn Sie über keine eigenen generischen Parameter verfügen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1779">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="dd86b-1780">Dies trifft nicht unbedingt auf in dynamischen Assemblys definierte, in dynamischen Assemblys definierte oder mit [Ilasm. exe (Il-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md)kompilierte Typen zu.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1780">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="dd86b-1781">Informationen zu den generischen generischen Typen und zum Erstellen von generischen generischen Typen aus ihren generischen Typdefinitionen finden <xref:System.Type.MakeGenericType%2A>Sie unter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1781">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-1782"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1782"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-1783">Die Zeichenfolge, die den Namen des abzurufenden geschachtelten Typs enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1783">The string containing the name of the nested type to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="dd86b-1784">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1784">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-1785">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1785">-or-</span></span> 
 <span data-ttu-id="dd86b-1786"><see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1786"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="dd86b-1787">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen den angegebenen geschachtelten Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1787">When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1788">Ein Objekt, das den geschachtelten Typ darstellt, der den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls<see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1788">An object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1789">Verwenden Sie den einfachen Namen der-Klasse für `name`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1789">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="dd86b-1790">Qualifizieren Sie diese nicht mit dem Namen der äußeren Klasse.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1790">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="dd86b-1791">Verwenden Sie für eine generische geschaltete Klasse den geschalteten Namen, d. h., fügen Sie einen schweren Akzent und die Anzahl der generischen Parameter an.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1791">For a generic nested class, use the mangled name - that is, append a grave accent and the number of generic parameters.</span></span> <span data-ttu-id="dd86b-1792">Verwenden Sie z. b. die Zeichen\`Folge "Inner 1", um die generische `Inner<T>` geschachtelte Klasse (`Inner(Of T)` in Visual Basic) zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1792">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="dd86b-1793">Fügen Sie keine sprachspezifische Syntax für Typparameter ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1793">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="dd86b-1794">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche in die Suche einzuschließenden Untertypen eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1794">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-1795">Sie müssen entweder <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> oder <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> angeben, um eine Rückgabe zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1795">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="dd86b-1796">Gibt <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> an, dass öffentliche, in die Suche eingefügte Typen eingeschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1796">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-1797">Geben <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Sie an, dass nicht öffentliche, nicht öffentliche Typen in die Suche einschließen sollen (d. h. private, interne und geschützte Typen).</span><span class="sxs-lookup"><span data-stu-id="dd86b-1797">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="dd86b-1798">Diese Methode gibt nur die Untertypen des aktuellen Typs zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1798">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="dd86b-1799">Die Basisklassen des aktuellen Typs werden nicht durchsucht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1799">It does not search the base classes of the current type.</span></span> <span data-ttu-id="dd86b-1800">Um Typen zu suchen, die in Basisklassen eingebettet sind, müssen Sie die Vererbungs Hierarchie <xref:System.Type.GetNestedType%2A> durchlaufen, indem Sie auf jeder Ebene aufrufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1800">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedType%2A> at each level.</span></span>  
  
 <span data-ttu-id="dd86b-1801"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> werden ignoriert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1801"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="dd86b-1802">Wenn diese Methode nur mit dem <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> -Flag oder nur <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> mit dem-Flag aufgerufen wird, werden die angegebenen Untertypen zurückgegeben, und es sind keine anderen Flags erforderlich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1802">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="dd86b-1803">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1803">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="dd86b-1804">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Untertypen der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1804">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="dd86b-1805">Wenn ein ngenerischer Typ generisch ist, gibt diese Methode die generische Typdefinition zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1805">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="dd86b-1806">Dies gilt auch, wenn der umschließende generische Typ ein geschlossener konstruierter Typ ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1806">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1807">Wenn der aktuelle <xref:System.Type> einen generischen Typ darstellt, C#der in, Visual Basic C++oder definiert ist, sind die zugehörigen Typen generisch, auch wenn Sie über keine eigenen generischen Parameter verfügen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1807">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="dd86b-1808">Dies trifft nicht unbedingt auf in dynamischen Assemblys definierte, in dynamischen Assemblys definierte oder mit [Ilasm. exe (Il-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md)kompilierte Typen zu.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1808">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="dd86b-1809">Informationen zu den generischen generischen Typen und zum Erstellen von generischen generischen Typen aus ihren generischen Typdefinitionen finden <xref:System.Type.MakeGenericType%2A>Sie unter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1809">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-1810"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1810"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-1811">Ruft die im aktuellen <see cref="T:System.Type" /> geschachtelten Typen ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1811">Gets the types nested within the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-1812">Gibt die im aktuellen <see cref="T:System.Type" /> geschachtelten öffentlichen Typen zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1812">Returns the public types nested in the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1813">Ein Array von <see cref="T:System.Type" />-Objekten, das die im aktuellen <see cref="T:System.Type" /> geschachtelten öffentlichen Typen darstellt (die Suche ist nicht rekursiv) oder ein leeres Array vom Typ <see cref="T:System.Type" />, wenn im aktuellen <see cref="T:System.Type" /> keine öffentlichen Typen geschachtelt sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1813">An array of <see cref="T:System.Type" /> objects representing the public types nested in the current <see cref="T:System.Type" /> (the search is not recursive), or an empty array of type <see cref="T:System.Type" /> if no public types are nested in the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1814">Die <xref:System.Type.GetNestedTypes%2A> Methode gibt keine Typen in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1814">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="dd86b-1815">Der Code darf nicht von der Reihenfolge abhängen, in der Typen zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1815">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="dd86b-1816">Es werden nur die öffentlichen Typen zurückgegeben, die sofort im aktuellen Typ eingefügt werden. die Suche ist nicht rekursiv.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1816">Only the public types immediately nested in the current type are returned; the search is not recursive.</span></span>  
  
 <span data-ttu-id="dd86b-1817">In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1817">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="dd86b-1818">Memberart</span><span class="sxs-lookup"><span data-stu-id="dd86b-1818">Member Type</span></span>|<span data-ttu-id="dd86b-1819">Statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-1819">Static</span></span>|<span data-ttu-id="dd86b-1820">Nicht statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-1820">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="dd86b-1821">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="dd86b-1821">Constructor</span></span>|<span data-ttu-id="dd86b-1822">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1822">No</span></span>|<span data-ttu-id="dd86b-1823">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1823">No</span></span>|  
|<span data-ttu-id="dd86b-1824">Feld</span><span class="sxs-lookup"><span data-stu-id="dd86b-1824">Field</span></span>|<span data-ttu-id="dd86b-1825">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1825">No</span></span>|<span data-ttu-id="dd86b-1826">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1826">Yes.</span></span> <span data-ttu-id="dd86b-1827">Ein Feld wird immer nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1827">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-1828">event</span><span class="sxs-lookup"><span data-stu-id="dd86b-1828">Event</span></span>|<span data-ttu-id="dd86b-1829">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-1829">Not applicable</span></span>|<span data-ttu-id="dd86b-1830">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1830">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-1831">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-1831">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1832">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1832">See note 2 below.</span></span>|  
|<span data-ttu-id="dd86b-1833">Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-1833">Method</span></span>|<span data-ttu-id="dd86b-1834">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1834">No</span></span>|<span data-ttu-id="dd86b-1835">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1835">Yes.</span></span> <span data-ttu-id="dd86b-1836">Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1836">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-1837">Der Typ "Typ"</span><span class="sxs-lookup"><span data-stu-id="dd86b-1837">Nested Type</span></span>|<span data-ttu-id="dd86b-1838">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1838">No</span></span>|<span data-ttu-id="dd86b-1839">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1839">No</span></span>|  
|<span data-ttu-id="dd86b-1840">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="dd86b-1840">Property</span></span>|<span data-ttu-id="dd86b-1841">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-1841">Not applicable</span></span>|<span data-ttu-id="dd86b-1842">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1842">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-1843">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-1843">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1844">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1844">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="dd86b-1845">"Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1845">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="dd86b-1846">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1846">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="dd86b-1847">Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1847">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1848">Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1848">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="dd86b-1849">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1849">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="dd86b-1850">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Untertypen der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1850">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="dd86b-1851">Wenn ein ngenerischer Typ generisch ist, gibt diese Methode die generische Typdefinition zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1851">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="dd86b-1852">Dies gilt auch, wenn der umschließende generische Typ ein geschlossener konstruierter Typ ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1852">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1853">Wenn der aktuelle <xref:System.Type> einen generischen Typ darstellt, C#der in, Visual Basic C++oder definiert ist, sind die zugehörigen Typen generisch, auch wenn Sie über keine eigenen generischen Parameter verfügen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1853">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="dd86b-1854">Dies trifft nicht unbedingt auf in dynamischen Assemblys definierte, in dynamischen Assemblys definierte oder mit [Ilasm. exe (Il-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md)kompilierte Typen zu.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1854">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="dd86b-1855">Informationen zu den generischen generischen Typen und zum Erstellen von generischen generischen Typen aus ihren generischen Typdefinitionen finden <xref:System.Type.MakeGenericType%2A>Sie unter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1855">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1856">Im folgenden Beispiel werden eine-Klasse und eine `struct` -Klasse in `MyClass`definiert `MyClass`. Anschließend werden die Objekte der mit dem Typ verwendeten Typen abgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1856">The following example defines a nested class and a `struct` in `MyClass`, and then obtains objects of the nested types using the type of `MyClass`.</span></span>  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="dd86b-1857">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1857">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-1858">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1858">-or-</span></span> 
 <span data-ttu-id="dd86b-1859"><see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1859"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="dd86b-1860">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die im aktuellen <see cref="T:System.Type" /> geschachtelten Typen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1860">When overridden in a derived class, searches for the types nested in the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1861">Ein Array von <see cref="T:System.Type" />-Objekten, das alle im aktuellen <see cref="T:System.Type" /> geschachtelten Typen darstellt, die mit den angegebenen Bindungseinschränkungen übereinstimmen (die Suche ist nicht rekursiv) oder ein leeres Array vom Typ <see cref="T:System.Type" />, wenn keine geschachtelten Typen gefunden werden, die mit den Bindungseinschränkungen übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1861">An array of <see cref="T:System.Type" /> objects representing all the types nested in the current <see cref="T:System.Type" /> that match the specified binding constraints (the search is not recursive), or an empty array of type <see cref="T:System.Type" />, if no nested types are found that match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1862">Die Suche nach nicht-Typen ist rekursiv.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1862">The search for nested types is not recursive.</span></span>  
  
 <span data-ttu-id="dd86b-1863">Die <xref:System.Type.GetNestedTypes%2A> Methode gibt keine Typen in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1863">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="dd86b-1864">Der Code darf nicht von der Reihenfolge abhängen, in der Typen zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1864">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="dd86b-1865">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche in die Suche einzuschließenden Untertypen eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1865">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-1866">Sie müssen entweder <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> oder <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> angeben, um eine Rückgabe zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1866">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="dd86b-1867">Gibt <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> an, dass öffentliche, in die Suche eingefügte Typen eingeschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1867">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-1868">Geben <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Sie an, dass nicht öffentliche, nicht öffentliche Typen in die Suche einschließen sollen (d. h. private, interne und geschützte Typen).</span><span class="sxs-lookup"><span data-stu-id="dd86b-1868">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="dd86b-1869">Diese Methode gibt nur die Untertypen des aktuellen Typs zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1869">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="dd86b-1870">Die Basisklassen des aktuellen Typs werden nicht durchsucht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1870">It does not search the base classes of the current type.</span></span> <span data-ttu-id="dd86b-1871">Um Typen zu suchen, die in Basisklassen eingebettet sind, müssen Sie die Vererbungs Hierarchie <xref:System.Type.GetNestedTypes%2A> durchlaufen, indem Sie auf jeder Ebene aufrufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1871">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedTypes%2A> at each level.</span></span>  
  
 <span data-ttu-id="dd86b-1872"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> werden ignoriert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1872"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="dd86b-1873">Wenn diese Methode nur mit dem <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> -Flag oder nur <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> mit dem-Flag aufgerufen wird, werden die angegebenen Untertypen zurückgegeben, und es sind keine anderen Flags erforderlich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1873">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="dd86b-1874">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1874">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="dd86b-1875">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Untertypen der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1875">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="dd86b-1876">Wenn ein ngenerischer Typ generisch ist, gibt diese Methode die generische Typdefinition zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1876">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="dd86b-1877">Dies gilt auch, wenn der umschließende generische Typ ein geschlossener konstruierter Typ ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1877">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-1878">Wenn der aktuelle <xref:System.Type> einen generischen Typ darstellt, C#der in, Visual Basic C++oder definiert ist, sind die zugehörigen Typen generisch, auch wenn Sie über keine eigenen generischen Parameter verfügen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1878">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="dd86b-1879">Dies trifft nicht unbedingt auf in dynamischen Assemblys definierte, in dynamischen Assemblys definierte oder mit [Ilasm. exe (Il-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md)kompilierte Typen zu.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1879">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="dd86b-1880">Informationen zu den generischen generischen Typen und zum Erstellen von generischen generischen Typen aus ihren generischen Typdefinitionen finden <xref:System.Type.MakeGenericType%2A>Sie unter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1880">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1881">Im folgenden Beispiel werden zwei eingefügte öffentliche Klassen und zwei in der Tabelle geschützte Klassen erstellt, und es werden Informationen für Klassen angezeigt, die den angegebenen Bindungs Einschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1881">The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-1882">Ruft die Eigenschaften des aktuellen <see cref="T:System.Type" /> ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1882">Gets the properties of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-1883">Gibt sämtliche öffentlichen Eigenschaften des aktuellen <see cref="T:System.Type" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1883">Returns all the public properties of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1884">Ein Array von <see cref="T:System.Reflection.PropertyInfo" />-Objekten, die alle öffentlichen Eigenschaften des aktuellen <see cref="T:System.Type" /> darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1884">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all public properties of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="dd86b-1885">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1885">-or-</span></span> 
<span data-ttu-id="dd86b-1886">Ein leeres Array vom <see cref="T:System.Reflection.PropertyInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine öffentlichen Eigenschaften besitzt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1886">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have public properties.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1887">Das Aufrufen dieser Überladung entspricht dem Aufrufen <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> der-über `bindingAttr` Ladung mit einem `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` - C# Argument `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` , das in und in Visual Basic gleich ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1887">Calling this overload is equivalent to calling the <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> overload with a `bindingAttr` argument equal to `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# and  `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic.</span></span> <span data-ttu-id="dd86b-1888">Sie gibt alle öffentlichen Instanzen und statischen Eigenschaften zurück, sowohl die durch den Typ, der durch das <xref:System.Type> aktuelle-Objekt dargestellt wird, als auch die, die von den zugehörigen Basis Typen geerbt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1888">It returns all public instance and static properties, both those defined by the type represented by the current <xref:System.Type> object as well as those inherited from its base types.</span></span>  
  
 <span data-ttu-id="dd86b-1889">Eine Eigenschaft gilt als öffentlich für Reflektion, wenn Sie über mindestens einen öffentlichen Accessor verfügt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1889">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="dd86b-1890">Andernfalls wird die-Eigenschaft als privat betrachtet, und Sie <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> müssen (in Visual Basic die Werte mit &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or`) verwenden, um Sie zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1890">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="dd86b-1891">Die <xref:System.Type.GetProperties%2A> Methode gibt keine Eigenschaften in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1891">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="dd86b-1892">Der Code darf nicht von der Reihenfolge abhängen, in der Eigenschaften zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1892">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="dd86b-1893">In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1893">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="dd86b-1894">Memberart</span><span class="sxs-lookup"><span data-stu-id="dd86b-1894">Member Type</span></span>|<span data-ttu-id="dd86b-1895">Statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-1895">Static</span></span>|<span data-ttu-id="dd86b-1896">Nicht statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-1896">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="dd86b-1897">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="dd86b-1897">Constructor</span></span>|<span data-ttu-id="dd86b-1898">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1898">No</span></span>|<span data-ttu-id="dd86b-1899">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1899">No</span></span>|  
|<span data-ttu-id="dd86b-1900">Feld</span><span class="sxs-lookup"><span data-stu-id="dd86b-1900">Field</span></span>|<span data-ttu-id="dd86b-1901">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1901">No</span></span>|<span data-ttu-id="dd86b-1902">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1902">Yes.</span></span> <span data-ttu-id="dd86b-1903">Ein Feld wird immer nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1903">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-1904">event</span><span class="sxs-lookup"><span data-stu-id="dd86b-1904">Event</span></span>|<span data-ttu-id="dd86b-1905">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-1905">Not applicable</span></span>|<span data-ttu-id="dd86b-1906">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1906">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-1907">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-1907">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1908">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1908">See note 2 below.</span></span>|  
|<span data-ttu-id="dd86b-1909">Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-1909">Method</span></span>|<span data-ttu-id="dd86b-1910">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1910">No</span></span>|<span data-ttu-id="dd86b-1911">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1911">Yes.</span></span> <span data-ttu-id="dd86b-1912">Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1912">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-1913">Der Typ "Typ"</span><span class="sxs-lookup"><span data-stu-id="dd86b-1913">Nested Type</span></span>|<span data-ttu-id="dd86b-1914">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1914">No</span></span>|<span data-ttu-id="dd86b-1915">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-1915">No</span></span>|  
|<span data-ttu-id="dd86b-1916">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="dd86b-1916">Property</span></span>|<span data-ttu-id="dd86b-1917">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-1917">Not applicable</span></span>|<span data-ttu-id="dd86b-1918">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1918">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-1919">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-1919">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1920">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1920">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="dd86b-1921">"Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1921">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="dd86b-1922">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1922">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="dd86b-1923">Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1923">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-1924">Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1924">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="dd86b-1925">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1925">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="dd86b-1926">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.PropertyInfo> Methode die Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1926">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1927">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Eigenschaften der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1927">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1928">Im folgenden Beispiel wird die Verwendung der `GetProperties`-Methode gezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1928">The following example demonstrates the use of the `GetProperties` method.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="dd86b-1929">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1929">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>

<span data-ttu-id="dd86b-1930">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1930">-or-</span></span>

 <span data-ttu-id="dd86b-1931"><see cref="F:System.Reflection.BindingFlags.Default" />, um ein leeres Array zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1931"><see cref="F:System.Reflection.BindingFlags.Default" /> to return an empty array.</span></span></param>
        <summary><span data-ttu-id="dd86b-1932">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die Eigenschaften des aktuellen <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1932">When overridden in a derived class, searches for the properties of the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1933">Ein Array von Objekten, die sämtliche Eigenschaften des aktuellen <see cref="T:System.Type" /> darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1933">An array of objects representing all properties of the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="dd86b-1934">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1934">-or-</span></span> 
<span data-ttu-id="dd86b-1935">Ein leeres Array vom <see cref="T:System.Reflection.PropertyInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Eigenschaften besitzt oder keine der Eigenschaften den Bindungseinschränkungen entspricht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1935">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have properties, or if none of the properties match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="dd86b-1936">Damit die `GetProperties(BindingFlags)` -Überladung Eigenschaften Informationen erfolgreich abrufen kann `bindingAttr` , muss das-Argument mindestens eine <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> von <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>und enthalten, zusammen mit mindestens einem <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> von <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>und.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1936">For the `GetProperties(BindingFlags)` overload to successfully retrieve property information, the `bindingAttr` argument must include at least one of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, along with at least one of <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="dd86b-1937">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Eigenschaften in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1937">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
- <span data-ttu-id="dd86b-1938">Geben `BindingFlags.Instance` Sie an, um Instanzmethoden einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1938">Specify `BindingFlags.Instance` to include instance methods.</span></span> 

- <span data-ttu-id="dd86b-1939">Geben `BindingFlags.Static` Sie an, um statische Methoden einzubeziehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1939">Specify `BindingFlags.Static` to include static methods.</span></span> 
  
- <span data-ttu-id="dd86b-1940">Geben `BindingFlags.Public` Sie an, dass öffentliche Eigenschaften in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1940">Specify `BindingFlags.Public` to include public properties in the search.</span></span> <span data-ttu-id="dd86b-1941">Eine Eigenschaft gilt als öffentlich für Reflektion, wenn Sie über mindestens einen öffentlichen Accessor verfügt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1941">A property is considered public to reflection if it has at least one accessor that is public.</span></span> 
  
- <span data-ttu-id="dd86b-1942">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Eigenschaften (d. h. private, interne und geschützte Eigenschaften) in der Suche enthalten sein sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1942">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span> <span data-ttu-id="dd86b-1943">Es werden nur geschützte und interne Eigenschaften für Basisklassen zurückgegeben. private Eigenschaften für Basisklassen werden nicht zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1943">Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</span></span>  
  
- <span data-ttu-id="dd86b-1944">Legen `BindingFlags.FlattenHierarchy` `protected` Sie`public` fest, dass und statische Member in der Hierarchie nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1944">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  

- <span data-ttu-id="dd86b-1945">Geben `BindingFlags.Default` Sie allein an, um <xref:System.Reflection.PropertyInfo> ein leeres Array zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1945">Specify `BindingFlags.Default` alone to return an empty <xref:System.Reflection.PropertyInfo> array.</span></span>

 <span data-ttu-id="dd86b-1946">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1946">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
- <span data-ttu-id="dd86b-1947">`BindingFlags.DeclaredOnly`um nur die Eigenschaften zu durchsuchen, <xref:System.Type>die auf dem deklariert sind, und keine Eigenschaften, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1947">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="dd86b-1948">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1948">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
<span data-ttu-id="dd86b-1949">Die <xref:System.Type.GetProperties%2A> Methode gibt keine Eigenschaften in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1949">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="dd86b-1950">Der Code darf nicht von der Reihenfolge abhängen, in der Eigenschaften zurückgegeben werden, da diese Reihenfolge variiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1950">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  

 <span data-ttu-id="dd86b-1951">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.PropertyInfo> Methode die Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1951">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1952">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Eigenschaften der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1952">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1953">Im folgenden Beispiel wird eine Klasse mit `PropertyClass` dem Namen definiert, die sechs Eigenschaften enthält: zwei sind Public, eine ist privat, eine ist geschützt,`Friend` eine ist intern (in Visual Basic), und eine`Protected Friend` ist intern geschützt (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="dd86b-1953">The following example defines a class named `PropertyClass` that includes six properties: two are public, one is private, one is protected, one is internal (`Friend` in Visual Basic), and one is protected internal (`Protected Friend` in Visual Basic).</span></span> <span data-ttu-id="dd86b-1954">Anschließend werden einige grundlegende Eigenschafts Informationen (Name und Typ der Eigenschaft, ob Sie Lese-/Schreibzugriff haben, und `get` die `set` Sichtbarkeit der zugehörigen-und-Accessoren) für die Eigenschaften angezeigt, die den angegebenen Bindungs Einschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1954">It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its `get` and `set` accessors) for the properties that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-1955">Ruft eine bestimmte Eigenschaft des aktuellen <see cref="T:System.Type" /> ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1955">Gets a specific property of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-1956">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1956">The string containing the name of the public property to get.</span></span></param>
        <summary><span data-ttu-id="dd86b-1957">Sucht die öffentliche Eigenschaft mit dem angegebenen Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1957">Searches for the public property with the specified name.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1958">Ein Objekt, das die öffentliche Eigenschaft mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1958">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1959">Beim Suchen nach `name` wird die Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1959">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="dd86b-1960">Die Suche umfasst öffentliche statische und öffentliche Instanzeigenschaften.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1960">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="dd86b-1961">Eine Eigenschaft gilt als öffentlich für Reflektion, wenn Sie über mindestens einen öffentlichen Accessor verfügt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1961">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="dd86b-1962">Andernfalls wird die-Eigenschaft als privat betrachtet, und Sie <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> müssen (in Visual Basic die Werte mit &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or`) verwenden, um Sie zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1962">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="dd86b-1963">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.PropertyInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1963">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-1964">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Eigenschaften der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1964">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="dd86b-1965">Es treten Beispiels <xref:System.Reflection.AmbiguousMatchException> Weise folgende Situationen auf:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1965">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="dd86b-1966">Ein-Typ enthält zwei indizierte Eigenschaften, die denselben Namen, aber eine unterschiedliche Anzahl von Parametern aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1966">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="dd86b-1967">Um die Mehrdeutigkeit aufzulösen, verwenden Sie eine über <xref:System.Type.GetProperty%2A> Ladung der-Methode, die Parametertypen angibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1967">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="dd86b-1968">Ein abgeleiteter Typ deklariert eine Eigenschaft, die eine geerbte Eigenschaft mit demselben Namen verbirgt, `new` indem der-`Shadows` Modifizierer (in Visual Basic) verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1968">A derived type declares a property that hides an inherited property with the same name, by using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="dd86b-1969">Um die Mehrdeutigkeit aufzulösen, verwenden <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> Sie die-Methoden Überladung, und fügen Sie das <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> -Flag hinzu, um die Suche auf nicht geerbte Member einzuschränken.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1969">To resolve the ambiguity, use the <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> method overload and add the <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> flag to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="dd86b-1970">Indexer und Standardeigenschaften</span><span class="sxs-lookup"><span data-stu-id="dd86b-1970">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="dd86b-1971">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] und[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] verfügen über eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft als Standardwert für den Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1971">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="dd86b-1972">Wenn die Variable `myList` beispielsweise auf ein <xref:System.Collections.ArrayList>verweist, ruft die Syntax `myList[3]` (`myList(3)` in Visual Basic) das Element mit dem Index 3 ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1972">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="dd86b-1973">Sie können die-Eigenschaft überladen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1973">You can overload the property.</span></span>  
  
 <span data-ttu-id="dd86b-1974">In C#wird dieses Feature als Indexer bezeichnet und kann nicht anhand des Namens bezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1974">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="dd86b-1975">Standardmäßig wird ein C# Indexer in den Metadaten als indizierte Eigenschaft mit dem Namen "Item" angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1975">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="dd86b-1976">Ein Klassen Bibliotheks Entwickler kann jedoch das <xref:System.Runtime.CompilerServices.IndexerNameAttribute> -Attribut verwenden, um den Namen des Indexers in den Metadaten zu ändern.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1976">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="dd86b-1977">Beispielsweise verfügt die <xref:System.String> -Klasse über einen Indexer <xref:System.String.Chars%2A>mit dem Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1977">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="dd86b-1978">Indizierte Eigenschaften, die mit anderen C# Sprachen als erstellt wurden, können auch andere Namen als Item aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1978">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="dd86b-1979">Verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode, um zu bestimmen, ob ein Typ über eine Standard Eigenschaft <xref:System.Reflection.DefaultMemberAttribute> verfügt, um das Attribut zu testen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1979">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="dd86b-1980">Wenn der Typ ist <xref:System.Reflection.DefaultMemberAttribute>, gibt <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> die-Eigenschaft den Namen der Standard Eigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1980">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-1981">Im folgenden Beispiel wird das `Type` -Objekt einer benutzerdefinierten Klasse abgerufen, eine Eigenschaft dieser Klasse abgerufen und der Eigenschaften Name angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1981">The following example retrieves the `Type` object of a user-defined class, retrieves a property of that class, and displays the property name.</span></span>  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 <span data-ttu-id="dd86b-1982">Intern wird diese Eigenschaft in den Metadaten durch den Namen "Item" bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1982">Internally, this property is referred to in the metadata by the name "Item."</span></span> <span data-ttu-id="dd86b-1983">Bei jedem Versuch, `PropertyInfo` die Reflektion zu verwenden, muss dieser interne Name angegeben werden, `PropertyInfo` damit die Eigenschaft ordnungsgemäß zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1983">Any attempt to get `PropertyInfo` using reflection must specify this internal name in order to correctly return the `PropertyInfo` property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-1984">Es wurden mehrere Eigenschaften mit dem angegebenen Namen gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1984">More than one property is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-1985"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1985"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-1986">Die Zeichenfolge, die den Namen der abzurufenden Eigenschaft enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1986">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="dd86b-1987">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1987">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-1988">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-1988">-or-</span></span> 
<span data-ttu-id="dd86b-1989"><see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1989"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="dd86b-1990">Sucht die angegebene Eigenschaft unter Verwendung der angegebenen Bindungseinschränkungen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1990">Searches for the specified property, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="dd86b-1991">Ein Objekt, das die Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1991">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-1992">Eine Eigenschaft gilt als öffentlich für Reflektion, wenn Sie über mindestens einen öffentlichen Accessor verfügt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1992">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="dd86b-1993">Andernfalls wird die-Eigenschaft als privat betrachtet, und Sie <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> müssen (in Visual Basic die Werte mit &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or`) verwenden, um Sie zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1993">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="dd86b-1994">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Eigenschaften in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1994">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-1995">Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1995">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="dd86b-1996">Geben `BindingFlags.Public` Sie an, dass öffentliche Eigenschaften in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1996">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-1997">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Eigenschaften (d. h. private, interne und geschützte Eigenschaften) in der Suche enthalten sein sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1997">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-1998">Legen `BindingFlags.FlattenHierarchy` `protected` Sie`public` fest, dass und statische Member in der Hierarchie nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-1998">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="dd86b-1999">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-1999">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="dd86b-2000">`BindingFlags.IgnoreCase`, wenn der Fall von `name`ignoriert werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2000">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="dd86b-2001">`BindingFlags.DeclaredOnly`um nur die Eigenschaften zu durchsuchen, <xref:System.Type>die auf dem deklariert sind, und keine Eigenschaften, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2001">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="dd86b-2002">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2002">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="dd86b-2003">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.PropertyInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2003">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-2004">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Eigenschaften der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2004">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="dd86b-2005">Es treten Beispiels <xref:System.Reflection.AmbiguousMatchException> Weise folgende Situationen auf:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2005">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="dd86b-2006">Ein-Typ enthält zwei indizierte Eigenschaften, die denselben Namen, aber eine unterschiedliche Anzahl von Parametern aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2006">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="dd86b-2007">Um die Mehrdeutigkeit aufzulösen, verwenden Sie eine über <xref:System.Type.GetProperty%2A> Ladung der-Methode, die Parametertypen angibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2007">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="dd86b-2008">Ein abgeleiteter Typ deklariert eine Eigenschaft, die eine geerbte Eigenschaft mit dem gleichen Namen `new` verbirgt, wobei`Shadows` der-Modifizierer (in Visual Basic) verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2008">A derived type declares a property that hides an inherited property with the same name, using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="dd86b-2009">Um die Mehrdeutigkeit aufzulösen, <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> schließen Sie ein, um die Suche auf Member zu beschränken, die nicht vererbt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2009">To resolve the ambiguity, include <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="dd86b-2010">Indexer und Standardeigenschaften</span><span class="sxs-lookup"><span data-stu-id="dd86b-2010">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="dd86b-2011">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] und[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] verfügen über eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft als Standardwert für den Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2011">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="dd86b-2012">Wenn die Variable `myList` beispielsweise auf ein <xref:System.Collections.ArrayList>verweist, ruft die Syntax `myList[3]` (`myList(3)` in Visual Basic) das Element mit dem Index 3 ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2012">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="dd86b-2013">Sie können die-Eigenschaft überladen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2013">You can overload the property.</span></span>  
  
 <span data-ttu-id="dd86b-2014">In C#wird dieses Feature als Indexer bezeichnet und kann nicht anhand des Namens bezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2014">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="dd86b-2015">Standardmäßig wird ein C# Indexer in den Metadaten als indizierte Eigenschaft mit dem Namen "Item" angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2015">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="dd86b-2016">Ein Klassen Bibliotheks Entwickler kann jedoch das <xref:System.Runtime.CompilerServices.IndexerNameAttribute> -Attribut verwenden, um den Namen des Indexers in den Metadaten zu ändern.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2016">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="dd86b-2017">Beispielsweise verfügt die <xref:System.String> -Klasse über einen Indexer <xref:System.String.Chars%2A>mit dem Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2017">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="dd86b-2018">Indizierte Eigenschaften, die mit anderen C# Sprachen als erstellt wurden, können auch andere Namen als Item aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2018">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="dd86b-2019">Verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode, um zu bestimmen, ob ein Typ über eine Standard Eigenschaft <xref:System.Reflection.DefaultMemberAttribute> verfügt, um das Attribut zu testen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2019">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="dd86b-2020">Wenn der Typ ist <xref:System.Reflection.DefaultMemberAttribute>, gibt <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> die-Eigenschaft den Namen der Standard Eigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2020">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-2021">Das folgende Beispiel ruft den Typ einer benutzerdefinierten Klasse ab, ruft eine Eigenschaft dieser Klasse ab und zeigt den Eigenschaftsnamen in Übereinstimmung mit den angegebenen Bindungs Einschränkungen an.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2021">The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-2022">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2022">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-2023"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2023"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-2024">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2024">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="dd86b-2025">Der Rückgabetyp der Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2025">The return type of the property.</span></span></param>
        <summary><span data-ttu-id="dd86b-2026">Sucht die öffentliche Eigenschaft mit dem angegebenen Namen und Rückgabetyp.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2026">Searches for the public property with the specified name and return type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-2027">Ein Objekt, das die öffentliche Eigenschaft mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2027">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-2028">Eine Eigenschaft gilt als öffentlich für Reflektion, wenn Sie über mindestens einen öffentlichen Accessor verfügt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2028">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="dd86b-2029">Andernfalls wird die-Eigenschaft als privat betrachtet, und Sie <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> müssen (in Visual Basic die Werte mit &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or`) verwenden, um Sie zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2029">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="dd86b-2030">Beim Suchen nach `name` wird die Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2030">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="dd86b-2031">Die Suche umfasst öffentliche statische und öffentliche Instanzeigenschaften.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2031">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="dd86b-2032">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.PropertyInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2032">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-2033">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Eigenschaften der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2033">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="dd86b-2034">Indexer und Standardeigenschaften</span><span class="sxs-lookup"><span data-stu-id="dd86b-2034">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="dd86b-2035">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] und[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] verfügen über eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft als Standardwert für den Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2035">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="dd86b-2036">Wenn die Variable `myList` beispielsweise auf ein <xref:System.Collections.ArrayList>verweist, ruft die Syntax `myList[3]` (`myList(3)` in Visual Basic) das Element mit dem Index 3 ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2036">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="dd86b-2037">Sie können die-Eigenschaft überladen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2037">You can overload the property.</span></span>  
  
 <span data-ttu-id="dd86b-2038">In C#wird dieses Feature als Indexer bezeichnet und kann nicht anhand des Namens bezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2038">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="dd86b-2039">Standardmäßig wird ein C# Indexer in den Metadaten als indizierte Eigenschaft mit dem Namen "Item" angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2039">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="dd86b-2040">Ein Klassen Bibliotheks Entwickler kann jedoch das <xref:System.Runtime.CompilerServices.IndexerNameAttribute> -Attribut verwenden, um den Namen des Indexers in den Metadaten zu ändern.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2040">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="dd86b-2041">Beispielsweise verfügt die <xref:System.String> -Klasse über einen Indexer <xref:System.String.Chars%2A>mit dem Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2041">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="dd86b-2042">Indizierte Eigenschaften, die mit anderen C# Sprachen als erstellt wurden, können auch andere Namen als Item aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2042">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="dd86b-2043">Verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode, um zu bestimmen, ob ein Typ über eine Standard Eigenschaft <xref:System.Reflection.DefaultMemberAttribute> verfügt, um das Attribut zu testen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2043">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="dd86b-2044">Wenn der Typ ist <xref:System.Reflection.DefaultMemberAttribute>, gibt <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> die-Eigenschaft den Namen der Standard Eigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2044">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-2045">Im folgenden Beispiel wird eine-Klasse mit einer-Eigenschaft definiert, und der Name und der Typ der Eigenschaft werden abgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2045">The following example defines a class with one property and retrieves the name and type of the property.</span></span>  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-2046">Es wurden mehrere Eigenschaften mit dem angegebenen Namen gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2046">More than one property is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-2047"><paramref name="name" /> ist <see langword="null" />, oder <paramref name="returnType" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2047"><paramref name="name" /> is <see langword="null" />, or <paramref name="returnType" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-2048">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2048">The string containing the name of the public property to get.</span></span></param>
        <param name="types"><span data-ttu-id="dd86b-2049">Ein Array von <see cref="T:System.Type" /> -Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2049">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="dd86b-2050">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2050">-or-</span></span> 
<span data-ttu-id="dd86b-2051">Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2051">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <summary><span data-ttu-id="dd86b-2052">Sucht die angegebene öffentliche Eigenschaft, deren Parameter den angegebenen Argumenttypen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2052">Searches for the specified public property whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="dd86b-2053">Ein Objekt, das die öffentliche Eigenschaft darstellt, deren Parameter den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2053">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-2054">Eine Eigenschaft gilt als öffentlich für Reflektion, wenn Sie über mindestens einen öffentlichen Accessor verfügt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2054">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="dd86b-2055">Andernfalls wird die-Eigenschaft als privat betrachtet, und Sie <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> müssen (in Visual Basic die Werte mit &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or`) verwenden, um Sie zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2055">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="dd86b-2056">Beim Suchen nach `name` wird die Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2056">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="dd86b-2057">Die Suche umfasst öffentliche statische und öffentliche Instanzeigenschaften.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2057">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="dd86b-2058">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.PropertyInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2058">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-2059">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Eigenschaften der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2059">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="dd86b-2060">Indexer und Standardeigenschaften</span><span class="sxs-lookup"><span data-stu-id="dd86b-2060">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="dd86b-2061">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] und[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] verfügen über eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft als Standardwert für den Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2061">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="dd86b-2062">Wenn die Variable `myList` beispielsweise auf ein <xref:System.Collections.ArrayList>verweist, ruft die Syntax `myList[3]` (`myList(3)` in Visual Basic) das Element mit dem Index 3 ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2062">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="dd86b-2063">Sie können die-Eigenschaft überladen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2063">You can overload the property.</span></span>  
  
 <span data-ttu-id="dd86b-2064">In C#wird dieses Feature als Indexer bezeichnet und kann nicht anhand des Namens bezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2064">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="dd86b-2065">Standardmäßig wird ein C# Indexer in den Metadaten als indizierte Eigenschaft mit dem Namen "Item" angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2065">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="dd86b-2066">Ein Klassen Bibliotheks Entwickler kann jedoch das <xref:System.Runtime.CompilerServices.IndexerNameAttribute> -Attribut verwenden, um den Namen des Indexers in den Metadaten zu ändern.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2066">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="dd86b-2067">Beispielsweise verfügt die <xref:System.String> -Klasse über einen Indexer <xref:System.String.Chars%2A>mit dem Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2067">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="dd86b-2068">Indizierte Eigenschaften, die mit anderen C# Sprachen als erstellt wurden, können auch andere Namen als Item aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2068">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="dd86b-2069">Verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode, um zu bestimmen, ob ein Typ über eine Standard Eigenschaft <xref:System.Reflection.DefaultMemberAttribute> verfügt, um das Attribut zu testen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2069">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="dd86b-2070">Wenn der Typ ist <xref:System.Reflection.DefaultMemberAttribute>, gibt <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> die-Eigenschaft den Namen der Standard Eigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2070">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-2071">Das folgende Beispiel ruft das `Type` -Objekt einer benutzerdefinierten Klasse ab, ruft die-Eigenschaft dieser Klasse ab und zeigt den Eigenschaftsnamen und den Typ der Eigenschaft an, die von den an über `GetProperty`gegebenen Argumenten angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2071">The following example retrieves the `Type` object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to `GetProperty`.</span></span>  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-2072">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Argumenttypen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2072">More than one property is found with the specified name and matching the specified argument types.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-2073"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2073"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-2074">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2074">-or-</span></span> 
 <span data-ttu-id="dd86b-2075"><paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2075"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-2076"><paramref name="types" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2076"><paramref name="types" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="dd86b-2077">Ein Element von <paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2077">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-2078">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2078">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="dd86b-2079">Der Rückgabetyp der Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2079">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="dd86b-2080">Ein Array von <see cref="T:System.Type" /> -Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2080">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="dd86b-2081">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2081">-or-</span></span> 
<span data-ttu-id="dd86b-2082">Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2082">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <summary><span data-ttu-id="dd86b-2083">Sucht die angegebene öffentliche Eigenschaft, deren Parameter den angegebenen Argumenttypen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2083">Searches for the specified public property whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="dd86b-2084">Ein Objekt, das die öffentliche Eigenschaft darstellt, deren Parameter den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2084">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-2085">Eine Eigenschaft gilt als öffentlich für Reflektion, wenn Sie über mindestens einen öffentlichen Accessor verfügt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2085">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="dd86b-2086">Andernfalls wird die-Eigenschaft als privat betrachtet, und Sie <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> müssen (in Visual Basic die Werte mit &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or`) verwenden, um Sie zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2086">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="dd86b-2087">Beim Suchen nach `name` wird die Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2087">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="dd86b-2088">Die Suche umfasst öffentliche statische und öffentliche Instanzeigenschaften.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2088">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="dd86b-2089">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.PropertyInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2089">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-2090">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Eigenschaften der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2090">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="dd86b-2091">Indexer und Standardeigenschaften</span><span class="sxs-lookup"><span data-stu-id="dd86b-2091">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="dd86b-2092">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] und[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] verfügen über eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft als Standardwert für den Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2092">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="dd86b-2093">Wenn die Variable `myList` beispielsweise auf ein <xref:System.Collections.ArrayList>verweist, ruft die Syntax `myList[3]` (`myList(3)` in Visual Basic) das Element mit dem Index 3 ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2093">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="dd86b-2094">Sie können die-Eigenschaft überladen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2094">You can overload the property.</span></span>  
  
 <span data-ttu-id="dd86b-2095">In C#wird dieses Feature als Indexer bezeichnet und kann nicht anhand des Namens bezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2095">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="dd86b-2096">Standardmäßig wird ein C# Indexer in den Metadaten als indizierte Eigenschaft mit dem Namen "Item" angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2096">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="dd86b-2097">Ein Klassen Bibliotheks Entwickler kann jedoch das <xref:System.Runtime.CompilerServices.IndexerNameAttribute> -Attribut verwenden, um den Namen des Indexers in den Metadaten zu ändern.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2097">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="dd86b-2098">Beispielsweise verfügt die <xref:System.String> -Klasse über einen Indexer <xref:System.String.Chars%2A>mit dem Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2098">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="dd86b-2099">Indizierte Eigenschaften, die mit anderen C# Sprachen als erstellt wurden, können auch andere Namen als Item aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2099">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="dd86b-2100">Verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode, um zu bestimmen, ob ein Typ über eine Standard Eigenschaft <xref:System.Reflection.DefaultMemberAttribute> verfügt, um das Attribut zu testen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2100">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="dd86b-2101">Wenn der Typ ist <xref:System.Reflection.DefaultMemberAttribute>, gibt <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> die-Eigenschaft den Namen der Standard Eigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2101">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-2102">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Argumenttypen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2102">More than one property is found with the specified name and matching the specified argument types.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-2103"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2103"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-2104">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2104">-or-</span></span> 
 <span data-ttu-id="dd86b-2105"><paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2105"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-2106"><paramref name="types" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2106"><paramref name="types" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="dd86b-2107">Ein Element von <paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2107">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-2108">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2108">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="dd86b-2109">Der Rückgabetyp der Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2109">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="dd86b-2110">Ein Array von <see cref="T:System.Type" /> -Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2110">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="dd86b-2111">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2111">-or-</span></span> 
<span data-ttu-id="dd86b-2112">Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2112">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="dd86b-2113">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2113">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="dd86b-2114">Der Standardbinder verarbeitet diesen Parameter nicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2114">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="dd86b-2115">Sucht die angegebene öffentliche Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2115">Searches for the specified public property whose parameters match the specified argument types and modifiers.</span></span></summary>
        <returns><span data-ttu-id="dd86b-2116">Ein Objekt, das die öffentliche Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2116">An object representing the public property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-2117">Eine Eigenschaft gilt als öffentlich für Reflektion, wenn Sie über mindestens einen öffentlichen Accessor verfügt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2117">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="dd86b-2118">Andernfalls wird die-Eigenschaft als privat betrachtet, und Sie <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> müssen (in Visual Basic die Werte mit &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or`) verwenden, um Sie zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2118">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="dd86b-2119">Obwohl der Standard <xref:System.Reflection.ParameterModifier> Binder nicht verarbeitet (der `modifiers` -Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> -Klasse verwenden, um einen benutzerdefinierten Binder zu `modifiers`schreiben, der verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2119">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="dd86b-2120">`ParameterModifier`wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2120">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="dd86b-2121">Beim Suchen nach `name` wird die Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2121">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="dd86b-2122">Die Suche umfasst öffentliche statische und öffentliche Instanzeigenschaften.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2122">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="dd86b-2123">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.PropertyInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2123">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-2124">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Eigenschaften der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2124">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="dd86b-2125">Indexer und Standardeigenschaften</span><span class="sxs-lookup"><span data-stu-id="dd86b-2125">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="dd86b-2126">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] und[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] verfügen über eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft als Standardwert für den Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2126">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="dd86b-2127">Wenn die Variable `myList` beispielsweise auf ein <xref:System.Collections.ArrayList>verweist, ruft die Syntax `myList[3]` (`myList(3)` in Visual Basic) das Element mit dem Index 3 ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2127">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="dd86b-2128">Sie können die-Eigenschaft überladen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2128">You can overload the property.</span></span>  
  
 <span data-ttu-id="dd86b-2129">In C#wird dieses Feature als Indexer bezeichnet und kann nicht anhand des Namens bezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2129">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="dd86b-2130">Standardmäßig wird ein C# Indexer in den Metadaten als indizierte Eigenschaft mit dem Namen "Item" angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2130">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="dd86b-2131">Ein Klassen Bibliotheks Entwickler kann jedoch das <xref:System.Runtime.CompilerServices.IndexerNameAttribute> -Attribut verwenden, um den Namen des Indexers in den Metadaten zu ändern.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2131">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="dd86b-2132">Beispielsweise verfügt die <xref:System.String> -Klasse über einen Indexer <xref:System.String.Chars%2A>mit dem Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2132">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="dd86b-2133">Indizierte Eigenschaften, die mit anderen C# Sprachen als erstellt wurden, können auch andere Namen als Item aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2133">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="dd86b-2134">Verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode, um zu bestimmen, ob ein Typ über eine Standard Eigenschaft <xref:System.Reflection.DefaultMemberAttribute> verfügt, um das Attribut zu testen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2134">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="dd86b-2135">Wenn der Typ ist <xref:System.Reflection.DefaultMemberAttribute>, gibt <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> die-Eigenschaft den Namen der Standard Eigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2135">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-2136">Im folgenden Beispiel wird ein `Type` -Objekt abgerufen `MyPropertyClass`, das entspricht, und die indizierte-Eigenschaft dieser Klasse wird mithilfe der Argumente `GetProperty` abgerufen, die an die-Methode übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2136">The following example obtains a `Type` object corresponding to `MyPropertyClass`, and the indexed property of this class is retrieved using the arguments passed to the `GetProperty` method.</span></span>  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-2137">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Argumenttypen sowie Modifizierern entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2137">More than one property is found with the specified name and matching the specified argument types and modifiers.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-2138"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2138"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-2139">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2139">-or-</span></span> 
 <span data-ttu-id="dd86b-2140"><paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2140"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-2141"><paramref name="types" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2141"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="dd86b-2142">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2142">-or-</span></span> 
 <span data-ttu-id="dd86b-2143"><paramref name="modifiers" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2143"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="dd86b-2144">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2144">-or-</span></span> 
 <span data-ttu-id="dd86b-2145"><paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2145"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="dd86b-2146">Ein Element von <paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2146">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-2147">Die Zeichenfolge, die den Namen der abzurufenden Eigenschaft enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2147">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="dd86b-2148">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2148">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-2149">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2149">-or-</span></span> 
 <span data-ttu-id="dd86b-2150"><see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2150"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="dd86b-2151">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2151">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="dd86b-2152">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2152">-or-</span></span> 
<span data-ttu-id="dd86b-2153">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" />verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2153">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="dd86b-2154">Der Rückgabetyp der Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2154">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="dd86b-2155">Ein Array von <see cref="T:System.Type" /> -Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2155">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="dd86b-2156">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2156">-or-</span></span> 
<span data-ttu-id="dd86b-2157">Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2157">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="dd86b-2158">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2158">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="dd86b-2159">Der Standardbinder verarbeitet diesen Parameter nicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2159">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="dd86b-2160">Sucht anhand der angegebenen Bindungseinschränkungen nach der angegebenen Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2160">Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="dd86b-2161">Ein Objekt, das die Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2161">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-2162">Eine Eigenschaft gilt als öffentlich für Reflektion, wenn Sie über mindestens einen öffentlichen Accessor verfügt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2162">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="dd86b-2163">Andernfalls wird die-Eigenschaft als privat betrachtet, und Sie <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> müssen (in Visual Basic die Werte mit &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or`) verwenden, um Sie zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2163">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="dd86b-2164">Obwohl der Standard <xref:System.Reflection.ParameterModifier> Binder nicht verarbeitet (der `modifiers` -Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> -Klasse verwenden, um einen benutzerdefinierten Binder zu `modifiers`schreiben, der verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2164">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="dd86b-2165">`ParameterModifier`wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2165">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="dd86b-2166">In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2166">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="dd86b-2167">Memberart</span><span class="sxs-lookup"><span data-stu-id="dd86b-2167">Member Type</span></span>|<span data-ttu-id="dd86b-2168">Statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-2168">Static</span></span>|<span data-ttu-id="dd86b-2169">Nicht statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-2169">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="dd86b-2170">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="dd86b-2170">Constructor</span></span>|<span data-ttu-id="dd86b-2171">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2171">No</span></span>|<span data-ttu-id="dd86b-2172">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2172">No</span></span>|  
|<span data-ttu-id="dd86b-2173">Feld</span><span class="sxs-lookup"><span data-stu-id="dd86b-2173">Field</span></span>|<span data-ttu-id="dd86b-2174">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2174">No</span></span>|<span data-ttu-id="dd86b-2175">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2175">Yes.</span></span> <span data-ttu-id="dd86b-2176">Ein Feld wird immer nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2176">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-2177">event</span><span class="sxs-lookup"><span data-stu-id="dd86b-2177">Event</span></span>|<span data-ttu-id="dd86b-2178">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-2178">Not applicable</span></span>|<span data-ttu-id="dd86b-2179">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2179">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-2180">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-2180">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-2181">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2181">See note 2 below.</span></span>|  
|<span data-ttu-id="dd86b-2182">Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-2182">Method</span></span>|<span data-ttu-id="dd86b-2183">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2183">No</span></span>|<span data-ttu-id="dd86b-2184">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2184">Yes.</span></span> <span data-ttu-id="dd86b-2185">Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2185">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-2186">Der Typ "Typ"</span><span class="sxs-lookup"><span data-stu-id="dd86b-2186">Nested Type</span></span>|<span data-ttu-id="dd86b-2187">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2187">No</span></span>|<span data-ttu-id="dd86b-2188">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2188">No</span></span>|  
|<span data-ttu-id="dd86b-2189">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="dd86b-2189">Property</span></span>|<span data-ttu-id="dd86b-2190">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-2190">Not applicable</span></span>|<span data-ttu-id="dd86b-2191">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2191">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-2192">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-2192">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-2193">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2193">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="dd86b-2194">"Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2194">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="dd86b-2195">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2195">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="dd86b-2196">Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2196">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-2197">Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2197">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="dd86b-2198">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2198">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="dd86b-2199">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Eigenschaften in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2199">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-2200">Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2200">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="dd86b-2201">Geben `BindingFlags.Public` Sie an, dass öffentliche Eigenschaften in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2201">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-2202">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Eigenschaften (d. h. private, interne und geschützte Eigenschaften) in der Suche enthalten sein sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2202">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-2203">Legen `BindingFlags.FlattenHierarchy` `protected` Sie`public` fest, dass und statische Member in der Hierarchie nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2203">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="dd86b-2204">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2204">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="dd86b-2205">`BindingFlags.IgnoreCase`, wenn der Fall von `name`ignoriert werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2205">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="dd86b-2206">`BindingFlags.DeclaredOnly`um nur die Eigenschaften zu durchsuchen, <xref:System.Type>die auf dem deklariert sind, und keine Eigenschaften, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2206">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="dd86b-2207">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2207">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="dd86b-2208">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese <xref:System.Reflection.PropertyInfo> Methode den mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2208">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-2209">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Eigenschaften der Klassen Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2209">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="dd86b-2210">Indexer und Standardeigenschaften</span><span class="sxs-lookup"><span data-stu-id="dd86b-2210">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="dd86b-2211">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] und[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] verfügen über eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft als Standardwert für den Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2211">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="dd86b-2212">Wenn die Variable `myList` beispielsweise auf ein <xref:System.Collections.ArrayList>verweist, ruft die Syntax `myList[3]` (`myList(3)` in Visual Basic) das Element mit dem Index 3 ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2212">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="dd86b-2213">Sie können die-Eigenschaft überladen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2213">You can overload the property.</span></span>  
  
 <span data-ttu-id="dd86b-2214">In C#wird dieses Feature als Indexer bezeichnet und kann nicht anhand des Namens bezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2214">In C#, this feature is called an indexer and cannot be referred to by name.</span></span> <span data-ttu-id="dd86b-2215">Standardmäßig wird ein C# Indexer in den Metadaten als indizierte Eigenschaft mit dem Namen "Item" angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2215">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="dd86b-2216">Ein Klassen Bibliotheks Entwickler kann jedoch das <xref:System.Runtime.CompilerServices.IndexerNameAttribute> -Attribut verwenden, um den Namen des Indexers in den Metadaten zu ändern.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2216">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="dd86b-2217">Beispielsweise verfügt die <xref:System.String> -Klasse über einen Indexer <xref:System.String.Chars%2A>mit dem Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2217">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="dd86b-2218">Indizierte Eigenschaften, die mit anderen C# Sprachen als erstellt wurden, können auch andere Namen als Item aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2218">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="dd86b-2219">Verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode, um zu bestimmen, ob ein Typ über eine Standard Eigenschaft <xref:System.Reflection.DefaultMemberAttribute> verfügt, um das Attribut zu testen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2219">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="dd86b-2220">Wenn der Typ ist <xref:System.Reflection.DefaultMemberAttribute>, gibt <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> die-Eigenschaft den Namen der Standard Eigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2220">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-2221">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2221">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-2222"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2222"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-2223">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2223">-or-</span></span> 
 <span data-ttu-id="dd86b-2224"><paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2224"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-2225"><paramref name="types" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2225"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="dd86b-2226">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2226">-or-</span></span> 
 <span data-ttu-id="dd86b-2227"><paramref name="modifiers" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2227"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="dd86b-2228">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2228">-or-</span></span> 
 <span data-ttu-id="dd86b-2229"><paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2229"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="dd86b-2230">Ein Element von <paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2230">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-2231">Die Zeichenfolge, die den Namen der abzurufenden Eigenschaft enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2231">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="dd86b-2232">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2232">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="dd86b-2233">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2233">-or-</span></span> 
 <span data-ttu-id="dd86b-2234"><see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2234"><see cref="F:System.Reflection.BindingFlags.Default" /> to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="dd86b-2235">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl eines überladenen Members, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2235">An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="dd86b-2236">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2236">-or-</span></span> 
<span data-ttu-id="dd86b-2237">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" />verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2237">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="dd86b-2238">Der Rückgabetyp der Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2238">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="dd86b-2239">Ein Array von <see cref="T:System.Type" /> -Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2239">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="dd86b-2240">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2240">-or-</span></span> 
<span data-ttu-id="dd86b-2241">Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2241">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="dd86b-2242">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2242">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="dd86b-2243">Der Standardbinder verarbeitet diesen Parameter nicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2243">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="dd86b-2244">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen nach der angegebenen Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2244">When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="dd86b-2245">Ein Objekt, das die Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2245">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-2246">Obwohl der Standard <xref:System.Reflection.ParameterModifier> Binder nicht verarbeitet (der `modifiers` -Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> -Klasse verwenden, um einen benutzerdefinierten Binder zu `modifiers`schreiben, der verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2246">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="dd86b-2247">`ParameterModifier`wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2247">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="dd86b-2248">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Eigenschaften in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2248">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-2249">Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2249">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="dd86b-2250">Geben `BindingFlags.Public` Sie an, dass öffentliche Eigenschaften in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2250">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-2251">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Eigenschaften (d. h. private, interne und geschützte Eigenschaften) in der Suche enthalten sein sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2251">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-2252">Legen `BindingFlags.FlattenHierarchy` `protected` Sie`public` fest, dass und statische Member in der Hierarchie nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2252">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="dd86b-2253">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2253">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="dd86b-2254">`BindingFlags.IgnoreCase`, wenn der Fall von `name`ignoriert werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2254">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="dd86b-2255">`BindingFlags.DeclaredOnly`um nur die Eigenschaften zu durchsuchen, <xref:System.Type>die auf dem deklariert sind, und keine Eigenschaften, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2255">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="dd86b-2256">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2256">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-2257">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2257">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-2258"><paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2258"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-2259">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2259">-or-</span></span> 
 <span data-ttu-id="dd86b-2260"><paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2260"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-2261">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2261">-or-</span></span> 
<span data-ttu-id="dd86b-2262">Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2262">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-2263"><paramref name="types" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2263"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="dd86b-2264">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2264">-or-</span></span> 
 <span data-ttu-id="dd86b-2265"><paramref name="modifiers" /> ist mehrdimensional.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2265"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="dd86b-2266">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2266">-or-</span></span> 
 <span data-ttu-id="dd86b-2267"><paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2267"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd86b-2268">Der aktuelle Typ ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" /> oder <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2268">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-2269">Ruft ein <see cref="T:System.Type" />-Objekt ab, das den angegebenen Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2269">Gets a <see cref="T:System.Type" /> object that represents the specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-2270">Ruft den aktuellen <see cref="T:System.Type" /> ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2270">Gets the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-2271">Der aktuelle <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2271">The current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="dd86b-2272">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2272">A class initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="dd86b-2273">Angeben vollständig gekennzeichneter Typnamen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2273">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="dd86b-2274">Der durch die Assembly bezeichnete Name des abzurufenden Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2274">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="dd86b-2275">Siehe <see cref="P:System.Type.AssemblyQualifiedName" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2275">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="dd86b-2276">Wenn sich der Typ in der aktuell ausgeführten Assembly oder in Mscorlib.dll befindet, ist eine Angabe des Typnamens einschließlich des qualifizierenden Namespace ausreichend.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2276">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <summary><span data-ttu-id="dd86b-2277">Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Bei der Suche wird die Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2277">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="dd86b-2278">Der Typ mit dem angegebenen Namen, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2278">The type with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-2279">Mit der <xref:System.Type.GetType%2A> -Methode können Sie ein <xref:System.Type> -Objekt für einen Typ in einer anderen Assembly abrufen, wenn Sie den durch die Assembly qualifizierten Namen kennen, der <xref:System.Type.AssemblyQualifiedName>von abgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2279">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly if you know its assembly-qualified name, which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="dd86b-2280"><xref:System.Type.GetType%2A>bewirkt das Laden der in `typeName`angegebenen Assembly.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2280"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="dd86b-2281">Sie können eine Assembly <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> auch mit der-Methode laden und dann die-Methode oder <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> - <xref:System.Type> Methode verwenden, um-Objekte zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2281">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method, and then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method to get <xref:System.Type> objects.</span></span> <span data-ttu-id="dd86b-2282">Wenn ein Typ in einer Assembly ist, die dem Programm zur Kompilierzeit bekannt ist, ist es effizienter `typeof` , C# in oder `GetType` den-Operator in Visual Basic zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2282">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C# or the `GetType` operator in Visual Basic.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="dd86b-2283">Wenn `typeName` nicht gefunden werden kann, gibt der Rückruf <xref:System.Type.GetType%28System.String%29> der Methode `null`zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2283">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%29> method returns `null`.</span></span> <span data-ttu-id="dd86b-2284">Es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2284">It does not throw an exception.</span></span> <span data-ttu-id="dd86b-2285">Um zu steuern, ob eine Ausnahme ausgelöst wird, müssen Sie eine <xref:System.Type.GetType%2A> Überladung der- `throwOnError` Methode aufrufen, die über einen-Parameter verfügt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2285">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="dd86b-2286"><xref:System.Type.GetType%2A>funktioniert nur für Assemblys, die vom Datenträger geladen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2286"><xref:System.Type.GetType%2A> only works on assemblies loaded from disk.</span></span> <span data-ttu-id="dd86b-2287">Wenn Sie <xref:System.Type.GetType%2A> einen in einer dynamischen Assembly, die mithilfe der <xref:System.Reflection.Emit> Dienste definiert wurde, definierten Typ suchen, wird möglicherweise ein inkonsistentes Verhalten angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2287">If you call <xref:System.Type.GetType%2A> to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="dd86b-2288">Das Verhalten hängt davon ab, ob die dynamische Assembly permanent ist, d. h. `RunAndSave` mithilfe `Save` der Zugriffs Modi <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> oder der-Enumeration erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2288">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="dd86b-2289">Wenn die dynamische Assembly permanent ist und auf den Datenträger geschrieben wurde `GetType` , bevor aufgerufen wird, sucht das Lade Modul die gespeicherte Assembly auf dem Datenträger, lädt diese Assembly und ruft den Typ aus dieser Assembly ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2289">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="dd86b-2290">Wenn die Assembly nicht auf dem Datenträger gespeichert wurde `GetType` , wenn aufgerufen wird, gibt `null`die Methode zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2290">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="dd86b-2291">`GetType`versteht keine vorübergehenden dynamischen Assemblys. Daher gibt das `GetType` Aufrufen von zum Abrufen eines Typs in einer vorübergehenden dynamischen `null`Assembly zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2291">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="dd86b-2292">Abonnieren Sie `GetType` das Ereignis, und führen Sie vor dem <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> speichern einen Rückruf `GetType` aus, um in einem dynamischen Modul zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2292">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="dd86b-2293">Andernfalls erhalten Sie zwei Kopien der Assembly im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2293">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="dd86b-2294">In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2294">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="dd86b-2295">Memberart</span><span class="sxs-lookup"><span data-stu-id="dd86b-2295">Member Type</span></span>|<span data-ttu-id="dd86b-2296">Statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-2296">Static</span></span>|<span data-ttu-id="dd86b-2297">Nicht statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-2297">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="dd86b-2298">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="dd86b-2298">Constructor</span></span>|<span data-ttu-id="dd86b-2299">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2299">No</span></span>|<span data-ttu-id="dd86b-2300">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2300">No</span></span>|  
|<span data-ttu-id="dd86b-2301">Feld</span><span class="sxs-lookup"><span data-stu-id="dd86b-2301">Field</span></span>|<span data-ttu-id="dd86b-2302">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2302">No</span></span>|<span data-ttu-id="dd86b-2303">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2303">Yes.</span></span> <span data-ttu-id="dd86b-2304">Ein Feld wird immer nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2304">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-2305">event</span><span class="sxs-lookup"><span data-stu-id="dd86b-2305">Event</span></span>|<span data-ttu-id="dd86b-2306">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-2306">Not applicable</span></span>|<span data-ttu-id="dd86b-2307">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2307">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-2308">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-2308">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-2309">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2309">See note 2 below.</span></span>|  
|<span data-ttu-id="dd86b-2310">Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-2310">Method</span></span>|<span data-ttu-id="dd86b-2311">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2311">No</span></span>|<span data-ttu-id="dd86b-2312">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2312">Yes.</span></span> <span data-ttu-id="dd86b-2313">Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2313">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-2314">Der Typ "Typ"</span><span class="sxs-lookup"><span data-stu-id="dd86b-2314">Nested Type</span></span>|<span data-ttu-id="dd86b-2315">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2315">No</span></span>|<span data-ttu-id="dd86b-2316">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2316">No</span></span>|  
|<span data-ttu-id="dd86b-2317">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="dd86b-2317">Property</span></span>|<span data-ttu-id="dd86b-2318">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-2318">Not applicable</span></span>|<span data-ttu-id="dd86b-2319">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2319">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-2320">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-2320">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-2321">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2321">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="dd86b-2322">"Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2322">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="dd86b-2323">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2323">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="dd86b-2324">Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2324">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-2325">Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2325">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="dd86b-2326">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2326">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="dd86b-2327">Arrays oder COM-Typen werden nicht durchsucht, es sei denn, Sie wurden bereits in die Tabelle der verfügbaren Klassen geladen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2327">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="dd86b-2328">`typeName`kann der durch den Namespace qualifizierte Typname oder ein durch die Assembly qualifizierter Name sein, der eine Assemblynamensspezifikation enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2328">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="dd86b-2329">Siehe <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2329">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="dd86b-2330">Wenn `typeName` den Namespace, aber nicht den Assemblynamen enthält, durchsucht diese Methode nur die Assembly des aufrufenden Objekts und die Datei "mscorlib. dll" in dieser Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2330">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="dd86b-2331">Wenn tygtame vollständig mit dem Assemblynamen partiell oder vollständig qualifiziert ist, sucht diese Methode in der angegebenen Assembly.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2331">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="dd86b-2332">Wenn die Assembly einen starken Namen hat, ist ein vollständiger AssemblyName erforderlich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2332">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="dd86b-2333">Die <xref:System.Type.AssemblyQualifiedName%2A> -Eigenschaft gibt einen voll qualifizierten Typnamen zurück, einschließlich der-Typen, der Assemblynamen und der generischen Typargumente.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2333">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.</span></span> <span data-ttu-id="dd86b-2334">Alle Compiler, die die Common Language Runtime unterstützen, geben den einfachen Namen einer geschachtelten Klasse aus, und die Reflektion erstellt bei der Abfrage einen geschachtelten Namen in Übereinstimmung mit den folgenden Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2334">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-2335">In der .NET Framework Version 2,0 wird die Prozessorarchitektur der Assemblyidentität hinzugefügt und kann als Teil der assemblynamenszeichenfolgen angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2335">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="dd86b-2336">Beispiel: "ProcessorArchitecture = msil".</span><span class="sxs-lookup"><span data-stu-id="dd86b-2336">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="dd86b-2337">Aus Kompatibilitätsgründen ist Sie jedoch nicht in der Zeichenfolge <xref:System.Type.AssemblyQualifiedName%2A> enthalten, die von der-Eigenschaft zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2337">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="dd86b-2338">Sie können auch Typen laden, indem Sie <xref:System.Reflection.AssemblyName> ein-Objekt erstellen und es an eine entsprechende <xref:System.Reflection.Assembly.Load%2A> Überladung der-Methode übergeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2338">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="dd86b-2339">Sie können dann die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> -Methode verwenden, um Typen aus der Assembly zu laden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2339">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="dd86b-2340">Siehe auch <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2340">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="dd86b-2341">Trennzeichen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2341">Delimiter</span></span>|<span data-ttu-id="dd86b-2342">Bedeutung</span><span class="sxs-lookup"><span data-stu-id="dd86b-2342">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="dd86b-2343">Umgekehrter Schrägstrich (\\)</span><span class="sxs-lookup"><span data-stu-id="dd86b-2343">Backslash (\\)</span></span>|<span data-ttu-id="dd86b-2344">Escapezeichen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2344">Escape character.</span></span>|  
|<span data-ttu-id="dd86b-2345">Backtick (')</span><span class="sxs-lookup"><span data-stu-id="dd86b-2345">Backtick (\`)</span></span>|<span data-ttu-id="dd86b-2346">Geht einer oder mehreren Ziffern vorangestellt, die die Anzahl der Typparameter darstellen, die sich am Ende des Namens eines generischen Typs befinden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2346">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="dd86b-2347">Eckige Klammern ([])</span><span class="sxs-lookup"><span data-stu-id="dd86b-2347">Brackets ([])</span></span>|<span data-ttu-id="dd86b-2348">Umschließen einer generischen Typargument Liste für einen konstruierten generischen Typ; Schließen Sie in einer Typargument Liste einen assemblyqualifizierten Typ ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2348">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="dd86b-2349">Komma (,)</span><span class="sxs-lookup"><span data-stu-id="dd86b-2349">Comma (,)</span></span>|<span data-ttu-id="dd86b-2350">Geht vor dem Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2350">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="dd86b-2351">Punkt (.)</span><span class="sxs-lookup"><span data-stu-id="dd86b-2351">Period (.)</span></span>|<span data-ttu-id="dd86b-2352">Bezeichnet Namespace Bezeichner.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2352">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="dd86b-2353">Plus Zeichen (+)</span><span class="sxs-lookup"><span data-stu-id="dd86b-2353">Plus sign (+)</span></span>|<span data-ttu-id="dd86b-2354">Geht einer-Klasse vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2354">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="dd86b-2355">Der voll qualifizierte Name für eine Klasse könnte beispielsweise wie folgt aussehen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2355">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="dd86b-2356">Wenn der Namespace ein TopNamespace. Sub +-Namespace wäre, müsste die Zeichenfolge dem Pluszeichen (+) mit einem Escapezeichen (\\) vorangestellt werden, um zu verhindern, dass Sie als Schachtelungs Trennzeichen interpretiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2356">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="dd86b-2357">Die Reflektion gibt diese Zeichenfolge wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2357">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="dd86b-2358">Ein "+ +" wird zu\\"\\\\+\\+", und "" wird zu "\\".</span><span class="sxs-lookup"><span data-stu-id="dd86b-2358">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="dd86b-2359">Dieser qualifizierte Name kann persistent gespeichert und später zum Laden <xref:System.Type>von verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2359">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="dd86b-2360">Um nach einem <xref:System.Type>zu suchen und zu laden <xref:System.Type.GetType%2A> , verwenden Sie entweder mit dem Typnamen oder mit dem qualifizierten Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2360">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="dd86b-2361"><xref:System.Type.GetType%2A>beim Typnamen wird nur <xref:System.Type> in der Assembly des Aufrufers und dann in der Systemassembly nach gesucht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2361"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="dd86b-2362"><xref:System.Type.GetType%2A>mit dem qualifizierten Assemblynamen für die Assembly <xref:System.Type> wird in beliebiger Assembly nach gesucht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2362"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="dd86b-2363">Typnamen können nachfolgende Zeichen enthalten, die zusätzliche Informationen über den Typ angeben, z. b. ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2363">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="dd86b-2364">Um den Typnamen ohne diese nachfolgenden Zeichen abzurufen, `t.GetElementType().ToString()`verwenden Sie `t` , wobei der-Typ ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2364">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="dd86b-2365">Leerzeichen sind in allen Typnamen Komponenten mit Ausnahme des Assemblynamens relevant.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2365">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="dd86b-2366">Im Assemblynamen sind Leerzeichen vor dem Trennzeichen ', ' relevant, Leerzeichen nach dem Trennzeichen ', ' werden jedoch ignoriert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2366">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="dd86b-2367">Der Name eines generischen Typs endet mit einem Graviszeichen (\`) gefolgt von Ziffern, die die Anzahl der generischen Typargumente darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2367">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="dd86b-2368">Der Zweck dieses Namens besteht darin, Compiler die Unterstützung generischer Typen mit dem gleichen Namen, jedoch mit unterschiedlicher Anzahl von Typparametern, die im gleichen Bereich auftreten, zuzulassen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2368">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="dd86b-2369">Reflektion gibt beispielsweise das `Tuple`Tupel`\<T0, T1>` `Tuple<T>` `Tuple(Of T)` `2` mit dem` and `Namen 1 aus den generischen Methoden `Tuple(Of T0, T1)` und in Visual Basic oder und Tupel in Visual C#zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2369">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="dd86b-2370">Bei generischen Typen wird die Typargument Liste in eckige Klammern eingeschlossen, und die Typargumente werden durch Kommas getrennt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2370">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="dd86b-2371">Beispielsweise verfügt ein generisches <xref:System.Collections.Generic.Dictionary%602> über zwei Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2371">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="dd86b-2372">Eine <xref:System.Collections.Generic.Dictionary%602> <xref:System.String> von `MyType` mit Schlüsseln des Typs kann wie folgt dargestellt werden:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2372">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="dd86b-2373">Um einen durch die Assembly qualifizierten Typ innerhalb einer Typargument Liste anzugeben, schließen Sie den durch die Assembly qualifizierten Typ in eckige Klammern ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2373">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="dd86b-2374">Andernfalls werden die Kommas, die die Teile des durch die Assembly qualifizierten Namens trennen, als Grenzen zusätzlicher Typargumente interpretiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2374">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="dd86b-2375">Beispielsweise kann eine <xref:System.Collections.Generic.Dictionary%602> von `MyType` frommyassembly. dll mit Schlüsseln vom Typ <xref:System.String>wie folgt angegeben werden:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2375">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` fromMyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-2376">Ein durch eine Assembly qualifizierter Typ kann nur in eckige Klammern eingeschlossen werden, wenn er in einer Typparameter Liste angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2376">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="dd86b-2377">Die Regeln zum Durchsuchen von Assemblys für qualifizierte und nicht qualifizierte Typen in Typparameter Listen sind identisch mit den Regeln für qualifizierte und nicht qualifizierte nicht generische Typen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2377">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="dd86b-2378">Typen, die NULL-Werte zulassen, sind Sonderfälle von generischen Typen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2378">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="dd86b-2379">Beispielsweise wird ein Werte zulässt <xref:System.Int32> -Element durch die Zeichenfolge "System. Werte zulässt ' 1 [System. Int32]" dargestellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2379">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-2380">In C#, C++und Visual Basic Sie mit Typoperatoren auch Typen, die NULL-Werte zulassen, erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2380">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="dd86b-2381">Der Typ, der NULL- <xref:System.Boolean> Werte zulässt, wird z C#. b `Nullable<Boolean>::typeid` . C++von `typeof(Nullable<bool>)` in, `GetType(Nullable(Of Boolean))` von in und von in Visual Basic zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2381">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="dd86b-2382">Die folgende Tabelle zeigt die Syntax, die Sie `GetType` mit für verschiedene Typen verwenden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2382">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="dd86b-2383">So erhalten Sie</span><span class="sxs-lookup"><span data-stu-id="dd86b-2383">To Get</span></span>|<span data-ttu-id="dd86b-2384">Verwendung</span><span class="sxs-lookup"><span data-stu-id="dd86b-2384">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="dd86b-2385">Ein Werte zulässt<xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="dd86b-2385">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="dd86b-2386">Ein nicht verwalteter Zeiger auf`MyType`</span><span class="sxs-lookup"><span data-stu-id="dd86b-2386">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="dd86b-2387">Ein nicht verwalteter Zeiger auf einen Zeiger auf.`MyType`</span><span class="sxs-lookup"><span data-stu-id="dd86b-2387">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="dd86b-2388">Ein verwalteter Zeiger oder ein Verweis auf.`MyType`</span><span class="sxs-lookup"><span data-stu-id="dd86b-2388">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="dd86b-2389">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2389">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="dd86b-2390">Beachten Sie, dass Verweise im Gegensatz zu Zeigern auf eine Ebene beschränkt sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2390">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="dd86b-2391">Eine übergeordnete Klasse und eine nicht erbt Klasse</span><span class="sxs-lookup"><span data-stu-id="dd86b-2391">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="dd86b-2392">Ein eindimensionales Array mit einer unteren Grenze von 0.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2392">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyType[]")`|  
|<span data-ttu-id="dd86b-2393">Ein eindimensionales Array mit einer unbekannten unteren Grenze.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2393">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyType[*]")`|  
|<span data-ttu-id="dd86b-2394">Ein n-dimensionales Array</span><span class="sxs-lookup"><span data-stu-id="dd86b-2394">An n-dimensional array</span></span>|<span data-ttu-id="dd86b-2395">Ein Komma (,) innerhalb der eckige Klammern, das insgesamt n-1 Mal ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2395">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="dd86b-2396">Beispielsweise `System.Object[,,]` stellt ein dreidimensionales `Object` Array dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2396">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="dd86b-2397">Ein Array von eindimensionalen Arrays</span><span class="sxs-lookup"><span data-stu-id="dd86b-2397">An array of one-dimensional arrays</span></span>|`Type.GetType("MyType[][]")`|  
|<span data-ttu-id="dd86b-2398">Ein rechteckiges zweidimensionales Array mit unbekannten unteren Begrenzungen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2398">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyType[,]")`|  
|<span data-ttu-id="dd86b-2399">Ein generischer Typ mit einem Typargument.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2399">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="dd86b-2400">Ein generischer Typ mit zwei Typargumenten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2400">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="dd86b-2401">Ein generischer Typ mit zwei durch die Assembly qualifizierten Typargumenten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2401">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="dd86b-2402">Ein durch eine Assembly qualifizierter generischer Typ mit einem assemblyqualifizierten Typargument.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2402">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="dd86b-2403">Ein generischer Typ, dessen Typargument ein generischer Typ mit zwei Typargumenten ist</span><span class="sxs-lookup"><span data-stu-id="dd86b-2403">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-2404">Im folgenden Beispiel wird der Typ von `System.Int32` abgerufen und mithilfe dieses Type-Objekts die <xref:System.Type.FullName%2A> -Eigenschaft von `System.Int32`angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2404">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-2405"><paramref name="typeName" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2405"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="dd86b-2406">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2406">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-2407"><paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2407"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="dd86b-2408">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2408">-or-</span></span> 
 <span data-ttu-id="dd86b-2409"><paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2409"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="dd86b-2410">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2410">-or-</span></span> 
 <span data-ttu-id="dd86b-2411"><paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2411"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="dd86b-2412"><paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2412"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="dd86b-2413">Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.IO.IOException" /> ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2413">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="dd86b-2414">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2414">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="dd86b-2415">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2415">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="dd86b-2416">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2416">-or-</span></span>  
  
 <span data-ttu-id="dd86b-2417">Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und die Assembly wurde mit einer höheren Version kompiliert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2417">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="dd86b-2418">Angeben vollständig gekennzeichneter Typnamen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2418">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="dd86b-2419">Der durch die Assembly bezeichnete Name des abzurufenden Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2419">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="dd86b-2420">Siehe <see cref="P:System.Type.AssemblyQualifiedName" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2420">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="dd86b-2421">Wenn sich der Typ in der aktuell ausgeführten Assembly oder in Mscorlib.dll befindet, ist eine Angabe des Typnamens einschließlich des qualifizierenden Namespace ausreichend.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2421">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="dd86b-2422"><see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" />, damit <see langword="null" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2422"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="dd86b-2423">Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2423">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="dd86b-2424">Informationen finden Sie im Abschnitt für Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2424">See the Exceptions section.</span></span></param>
        <summary><span data-ttu-id="dd86b-2425">Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Bei der Suche wird die Groß-/Kleinschreibung beachtet. Dabei wird angegeben, ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2425">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</span></span></summary>
        <returns><span data-ttu-id="dd86b-2426">Der Typ mit dem angegebenen Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2426">The type with the specified name.</span></span> <span data-ttu-id="dd86b-2427">Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2427">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="dd86b-2428">In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2428">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="dd86b-2429">Informationen finden Sie im Abschnitt für Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2429">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-2430">Mit der <xref:System.Type.GetType%2A> -Methode können Sie ein <xref:System.Type> -Objekt für einen Typ in einer anderen Assembly abrufen, wenn Sie den durch die Assembly qualifizierten Namen kennen, der <xref:System.Type.AssemblyQualifiedName>von abgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2430">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly if you know its assembly-qualified name, which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="dd86b-2431"><xref:System.Type.GetType%2A>bewirkt das Laden der in `typeName`angegebenen Assembly.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2431"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="dd86b-2432">Sie können eine Assembly <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> auch mit der-Methode laden und dann die-Methode oder <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> - <xref:System.Type> Methode verwenden, um-Objekte zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2432">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method, and then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method to get <xref:System.Type> objects.</span></span> <span data-ttu-id="dd86b-2433">Wenn ein Typ in einer Assembly ist, die dem Programm zur Kompilierzeit bekannt ist, ist es effizienter `typeof` , C# in oder `GetType` den-Operator in Visual Basic zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2433">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C# or the `GetType` operator in Visual Basic.</span></span>
  
 <span data-ttu-id="dd86b-2434">`GetType`funktioniert nur für Assemblys, die vom Datenträger geladen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2434">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="dd86b-2435">Wenn Sie `GetType` einen in einer dynamischen Assembly, die mithilfe der <xref:System.Reflection.Emit> Dienste definiert wurde, definierten Typ suchen, wird möglicherweise ein inkonsistentes Verhalten angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2435">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="dd86b-2436">Das Verhalten hängt davon ab, ob die dynamische Assembly permanent ist, d. h. `RunAndSave` mithilfe `Save` der Zugriffs Modi <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> oder der-Enumeration erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2436">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="dd86b-2437">Wenn die dynamische Assembly permanent ist und auf den Datenträger geschrieben wurde `GetType` , bevor aufgerufen wird, sucht das Lade Modul die gespeicherte Assembly auf dem Datenträger, lädt diese Assembly und ruft den Typ aus dieser Assembly ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2437">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="dd86b-2438">Wenn die Assembly nicht auf dem Datenträger gespeichert wurde `GetType` , wenn aufgerufen wird, gibt `null`die Methode zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2438">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="dd86b-2439">`GetType`versteht keine vorübergehenden dynamischen Assemblys. Daher gibt das `GetType` Aufrufen von zum Abrufen eines Typs in einer vorübergehenden dynamischen `null`Assembly zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2439">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="dd86b-2440">Abonnieren Sie `GetType` das Ereignis, und führen Sie vor dem <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> speichern einen Rückruf `GetType` aus, um in einem dynamischen Modul zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2440">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="dd86b-2441">Andernfalls erhalten Sie zwei Kopien der Assembly im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2441">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="dd86b-2442">Der `throwOnError` -Parameter gibt an, was geschieht, wenn der Typ nicht gefunden wird, und unterdrückt auch bestimmte andere Ausnahmebedingungen, wie im Abschnitt Ausnahmen beschrieben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2442">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="dd86b-2443">Einige Ausnahmen werden unabhängig vom Wert von `throwOnError`ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2443">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="dd86b-2444">Wenn der Typ z. b. gefunden wurde, aber nicht geladen werden <xref:System.TypeLoadException> kann, wird auch `throwOnError` eine `false`ausgelöst, wenn gleich ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2444">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="dd86b-2445">In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2445">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="dd86b-2446">Memberart</span><span class="sxs-lookup"><span data-stu-id="dd86b-2446">Member Type</span></span>|<span data-ttu-id="dd86b-2447">Statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-2447">Static</span></span>|<span data-ttu-id="dd86b-2448">Nicht statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-2448">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="dd86b-2449">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="dd86b-2449">Constructor</span></span>|<span data-ttu-id="dd86b-2450">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2450">No</span></span>|<span data-ttu-id="dd86b-2451">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2451">No</span></span>|  
|<span data-ttu-id="dd86b-2452">Feld</span><span class="sxs-lookup"><span data-stu-id="dd86b-2452">Field</span></span>|<span data-ttu-id="dd86b-2453">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2453">No</span></span>|<span data-ttu-id="dd86b-2454">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2454">Yes.</span></span> <span data-ttu-id="dd86b-2455">Ein Feld wird immer nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2455">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-2456">event</span><span class="sxs-lookup"><span data-stu-id="dd86b-2456">Event</span></span>|<span data-ttu-id="dd86b-2457">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-2457">Not applicable</span></span>|<span data-ttu-id="dd86b-2458">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2458">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-2459">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-2459">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-2460">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2460">See note 2 below.</span></span>|  
|<span data-ttu-id="dd86b-2461">Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-2461">Method</span></span>|<span data-ttu-id="dd86b-2462">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2462">No</span></span>|<span data-ttu-id="dd86b-2463">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2463">Yes.</span></span> <span data-ttu-id="dd86b-2464">Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2464">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-2465">Der Typ "Typ"</span><span class="sxs-lookup"><span data-stu-id="dd86b-2465">Nested Type</span></span>|<span data-ttu-id="dd86b-2466">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2466">No</span></span>|<span data-ttu-id="dd86b-2467">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2467">No</span></span>|  
|<span data-ttu-id="dd86b-2468">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="dd86b-2468">Property</span></span>|<span data-ttu-id="dd86b-2469">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-2469">Not applicable</span></span>|<span data-ttu-id="dd86b-2470">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2470">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-2471">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-2471">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-2472">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2472">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="dd86b-2473">"Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2473">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="dd86b-2474">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2474">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="dd86b-2475">Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2475">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-2476">Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2476">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="dd86b-2477">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2477">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="dd86b-2478">Arrays oder COM-Typen werden nicht durchsucht, es sei denn, Sie wurden bereits in die Tabelle der verfügbaren Klassen geladen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2478">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="dd86b-2479">`typeName`kann der durch den Namespace qualifizierte Typname oder ein durch die Assembly qualifizierter Name sein, der eine Assemblynamensspezifikation enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2479">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="dd86b-2480">Siehe <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2480">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="dd86b-2481">Wenn `typeName` den Namespace, aber nicht den Assemblynamen enthält, durchsucht diese Methode nur die Assembly des aufrufenden Objekts und die Datei "mscorlib. dll" in dieser Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2481">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="dd86b-2482">Wenn tygtame vollständig mit dem Assemblynamen partiell oder vollständig qualifiziert ist, sucht diese Methode in der angegebenen Assembly.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2482">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="dd86b-2483">Wenn die Assembly einen starken Namen hat, ist ein vollständiger AssemblyName erforderlich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2483">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="dd86b-2484">Die <xref:System.Type.AssemblyQualifiedName%2A> -Eigenschaft gibt einen voll qualifizierten Typnamen zurück, einschließlich der-Typen, des Assemblynamens und der generischen Argumente.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2484">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.</span></span> <span data-ttu-id="dd86b-2485">Alle Compiler, die die Common Language Runtime unterstützen, geben den einfachen Namen einer geschachtelten Klasse aus, und die Reflektion erstellt bei der Abfrage einen geschachtelten Namen in Übereinstimmung mit den folgenden Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2485">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-2486">In der .NET Framework Version 2,0 wird die Prozessorarchitektur der Assemblyidentität hinzugefügt und kann als Teil der assemblynamenszeichenfolgen angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2486">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="dd86b-2487">Beispiel: "ProcessorArchitecture = msil".</span><span class="sxs-lookup"><span data-stu-id="dd86b-2487">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="dd86b-2488">Aus Kompatibilitätsgründen ist Sie jedoch nicht in der Zeichenfolge <xref:System.Type.AssemblyQualifiedName%2A> enthalten, die von der-Eigenschaft zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2488">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="dd86b-2489">Sie können auch Typen laden, indem Sie <xref:System.Reflection.AssemblyName> ein-Objekt erstellen und es an eine entsprechende <xref:System.Reflection.Assembly.Load%2A> Überladung der-Methode übergeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2489">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="dd86b-2490">Sie können dann die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> -Methode verwenden, um Typen aus der Assembly zu laden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2490">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="dd86b-2491">Siehe auch <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2491">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="dd86b-2492">Trennzeichen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2492">Delimiter</span></span>|<span data-ttu-id="dd86b-2493">Bedeutung</span><span class="sxs-lookup"><span data-stu-id="dd86b-2493">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="dd86b-2494">Umgekehrter Schrägstrich (\\)</span><span class="sxs-lookup"><span data-stu-id="dd86b-2494">Backslash (\\)</span></span>|<span data-ttu-id="dd86b-2495">Escapezeichen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2495">Escape character.</span></span>|  
|<span data-ttu-id="dd86b-2496">Backtick (')</span><span class="sxs-lookup"><span data-stu-id="dd86b-2496">Backtick (\`)</span></span>|<span data-ttu-id="dd86b-2497">Geht einer oder mehreren Ziffern vorangestellt, die die Anzahl der Typparameter darstellen, die sich am Ende des Namens eines generischen Typs befinden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2497">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="dd86b-2498">Eckige Klammern ([])</span><span class="sxs-lookup"><span data-stu-id="dd86b-2498">Brackets ([])</span></span>|<span data-ttu-id="dd86b-2499">Umschließen einer generischen Typargument Liste für einen konstruierten generischen Typ; Schließen Sie in einer Typargument Liste einen assemblyqualifizierten Typ ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2499">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="dd86b-2500">Komma (,)</span><span class="sxs-lookup"><span data-stu-id="dd86b-2500">Comma (,)</span></span>|<span data-ttu-id="dd86b-2501">Geht vor dem Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2501">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="dd86b-2502">Punkt (.)</span><span class="sxs-lookup"><span data-stu-id="dd86b-2502">Period (.)</span></span>|<span data-ttu-id="dd86b-2503">Bezeichnet Namespace Bezeichner.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2503">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="dd86b-2504">Plus Zeichen (+)</span><span class="sxs-lookup"><span data-stu-id="dd86b-2504">Plus sign (+)</span></span>|<span data-ttu-id="dd86b-2505">Geht einer-Klasse vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2505">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="dd86b-2506">Der voll qualifizierte Name für eine Klasse könnte beispielsweise wie folgt aussehen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2506">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="dd86b-2507">Wenn der Namespace ein TopNamespace. Sub +-Namespace wäre, müsste die Zeichenfolge dem Pluszeichen (+) mit einem Escapezeichen (\\) vorangestellt werden, um zu verhindern, dass Sie als Schachtelungs Trennzeichen interpretiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2507">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="dd86b-2508">Die Reflektion gibt diese Zeichenfolge wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2508">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="dd86b-2509">Ein "+ +" wird zu\\"\\\\+\\+", und "" wird zu "\\".</span><span class="sxs-lookup"><span data-stu-id="dd86b-2509">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="dd86b-2510">Dieser qualifizierte Name kann persistent gespeichert und später zum Laden <xref:System.Type>von verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2510">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="dd86b-2511">Um nach einem <xref:System.Type>zu suchen und zu laden <xref:System.Type.GetType%2A> , verwenden Sie entweder mit dem Typnamen oder mit dem qualifizierten Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2511">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="dd86b-2512"><xref:System.Type.GetType%2A>beim Typnamen wird nur <xref:System.Type> in der Assembly des Aufrufers und dann in der Systemassembly nach gesucht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2512"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="dd86b-2513"><xref:System.Type.GetType%2A>mit dem qualifizierten Assemblynamen für die Assembly <xref:System.Type> wird in beliebiger Assembly nach gesucht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2513"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="dd86b-2514">Typnamen können nachfolgende Zeichen enthalten, die zusätzliche Informationen über den Typ angeben, z. b. ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2514">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="dd86b-2515">Um den Typnamen ohne diese nachfolgenden Zeichen abzurufen, `t.GetElementType().ToString()`verwenden Sie `t` , wobei der-Typ ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2515">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="dd86b-2516">Leerzeichen sind in allen Typnamen Komponenten mit Ausnahme des Assemblynamens relevant.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2516">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="dd86b-2517">Im Assemblynamen sind Leerzeichen vor dem Trennzeichen ', ' relevant, Leerzeichen nach dem Trennzeichen ', ' werden jedoch ignoriert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2517">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="dd86b-2518">Der Name eines generischen Typs endet mit einem Graviszeichen (\`) gefolgt von Ziffern, die die Anzahl der generischen Typargumente darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2518">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="dd86b-2519">Der Zweck dieses Namens besteht darin, Compiler die Unterstützung generischer Typen mit dem gleichen Namen, jedoch mit unterschiedlicher Anzahl von Typparametern, die im gleichen Bereich auftreten, zuzulassen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2519">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="dd86b-2520">Reflektion gibt beispielsweise das `Tuple`Tupel`\<T0, T1>` `Tuple<T>` `Tuple(Of T)` `2` mit dem` and `Namen 1 aus den generischen Methoden `Tuple(Of T0, T1)` und in Visual Basic oder und Tupel in Visual C#zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2520">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="dd86b-2521">Bei generischen Typen wird die Typargument Liste in eckige Klammern eingeschlossen, und die Typargumente werden durch Kommas getrennt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2521">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="dd86b-2522">Beispielsweise verfügt ein generisches <xref:System.Collections.Generic.Dictionary%602> über zwei Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2522">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="dd86b-2523">Eine <xref:System.Collections.Generic.Dictionary%602> <xref:System.String> von `MyType` mit Schlüsseln des Typs kann wie folgt dargestellt werden:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2523">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="dd86b-2524">Um einen durch die Assembly qualifizierten Typ innerhalb einer Typargument Liste anzugeben, schließen Sie den durch die Assembly qualifizierten Typ in eckige Klammern ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2524">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="dd86b-2525">Andernfalls werden die Kommas, die die Teile des durch die Assembly qualifizierten Namens trennen, als Grenzen zusätzlicher Typargumente interpretiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2525">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="dd86b-2526">Beispielsweise kann eine <xref:System.Collections.Generic.Dictionary%602> von `MyType` aus MyAssembly. dll mit Schlüsseln vom Typ <xref:System.String>wie folgt angegeben werden:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2526">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-2527">Ein durch eine Assembly qualifizierter Typ kann nur in eckige Klammern eingeschlossen werden, wenn er in einer Typparameter Liste angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2527">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="dd86b-2528">Die Regeln zum Durchsuchen von Assemblys für qualifizierte und nicht qualifizierte Typen in Typparameter Listen sind identisch mit den Regeln für qualifizierte und nicht qualifizierte nicht generische Typen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2528">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="dd86b-2529">Typen, die NULL-Werte zulassen, sind Sonderfälle von generischen Typen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2529">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="dd86b-2530">Beispielsweise wird ein Werte zulässt <xref:System.Int32> -Element durch die Zeichenfolge "System. Werte zulässt ' 1 [System. Int32]" dargestellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2530">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-2531">In C#, C++und Visual Basic Sie mit Typoperatoren auch Typen, die NULL-Werte zulassen, erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2531">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="dd86b-2532">Der Typ, der NULL- <xref:System.Boolean> Werte zulässt, wird z C#. b `Nullable<Boolean>::typeid` . C++von `typeof(Nullable<bool>)` in, `GetType(Nullable(Of Boolean))` von in und von in Visual Basic zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2532">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="dd86b-2533">Die folgende Tabelle zeigt die Syntax, die Sie `GetType` mit für verschiedene Typen verwenden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2533">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="dd86b-2534">So erhalten Sie</span><span class="sxs-lookup"><span data-stu-id="dd86b-2534">To Get</span></span>|<span data-ttu-id="dd86b-2535">Verwendung</span><span class="sxs-lookup"><span data-stu-id="dd86b-2535">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="dd86b-2536">Ein Werte zulässt<xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="dd86b-2536">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="dd86b-2537">Ein nicht verwalteter Zeiger auf`MyType`</span><span class="sxs-lookup"><span data-stu-id="dd86b-2537">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="dd86b-2538">Ein nicht verwalteter Zeiger auf einen Zeiger auf.`MyType`</span><span class="sxs-lookup"><span data-stu-id="dd86b-2538">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="dd86b-2539">Ein verwalteter Zeiger oder ein Verweis auf.`MyType`</span><span class="sxs-lookup"><span data-stu-id="dd86b-2539">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="dd86b-2540">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2540">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="dd86b-2541">Beachten Sie, dass Verweise im Gegensatz zu Zeigern auf eine Ebene beschränkt sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2541">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="dd86b-2542">Eine übergeordnete Klasse und eine nicht erbt Klasse</span><span class="sxs-lookup"><span data-stu-id="dd86b-2542">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="dd86b-2543">Ein eindimensionales Array mit einer unteren Grenze von 0.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2543">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="dd86b-2544">Ein eindimensionales Array mit einer unbekannten unteren Grenze.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2544">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="dd86b-2545">Ein n-dimensionales Array</span><span class="sxs-lookup"><span data-stu-id="dd86b-2545">An n-dimensional array</span></span>|<span data-ttu-id="dd86b-2546">Ein Komma (,) innerhalb der eckige Klammern, das insgesamt n-1 Mal ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2546">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="dd86b-2547">Beispielsweise `System.Object[,,]` stellt ein dreidimensionales `Object` Array dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2547">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="dd86b-2548">Array eines zweidimensionalen Arrays</span><span class="sxs-lookup"><span data-stu-id="dd86b-2548">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="dd86b-2549">Ein rechteckiges zweidimensionales Array mit unbekannten unteren Begrenzungen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2549">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="dd86b-2550">Ein generischer Typ mit einem Typargument.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2550">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="dd86b-2551">Ein generischer Typ mit zwei Typargumenten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2551">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="dd86b-2552">Ein generischer Typ mit zwei durch die Assembly qualifizierten Typargumenten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2552">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="dd86b-2553">Ein durch eine Assembly qualifizierter generischer Typ mit einem assemblyqualifizierten Typargument.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2553">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="dd86b-2554">Ein generischer Typ, dessen Typargument ein generischer Typ mit zwei Typargumenten ist</span><span class="sxs-lookup"><span data-stu-id="dd86b-2554">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-2555">Im folgenden Beispiel wird der Typ von `System.Int32` abgerufen und mithilfe dieses Type-Objekts die <xref:System.Type.FullName%2A> -Eigenschaft von `System.Int32`angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2555">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span> <span data-ttu-id="dd86b-2556">Wenn ein Typobjekt auf eine Assembly verweist, die nicht vorhanden ist, wird in diesem Beispiel eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2556">If a type object refers to an assembly that does not exist, this example throws an exception.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-2557"><paramref name="typeName" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2557"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="dd86b-2558">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2558">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="dd86b-2559"><paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2559"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="dd86b-2560">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2560">-or-</span></span> 
 <span data-ttu-id="dd86b-2561"><paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2561"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="dd86b-2562">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2562">-or-</span></span> 
 <span data-ttu-id="dd86b-2563"><paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2563"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="dd86b-2564">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2564">-or-</span></span> 
 <span data-ttu-id="dd86b-2565"><paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2565"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="dd86b-2566">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2566">-or-</span></span> 
 <span data-ttu-id="dd86b-2567"><paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2567"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-2568"><paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax,</span><span class="sxs-lookup"><span data-stu-id="dd86b-2568"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span></span> <span data-ttu-id="dd86b-2569">beispielsweise "MyType[,\*,]".</span><span class="sxs-lookup"><span data-stu-id="dd86b-2569">For example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="dd86b-2570">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2570">-or-</span></span> 
 <span data-ttu-id="dd86b-2571"><paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2571"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="dd86b-2572">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2572">-or-</span></span> 
 <span data-ttu-id="dd86b-2573"><paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2573"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="dd86b-2574">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2574">-or-</span></span> 
 <span data-ttu-id="dd86b-2575"><paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2575"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="dd86b-2576"><paramref name="throwOnError" /> ist <see langword="true" /> und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2576"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="dd86b-2577">Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.IO.IOException" /> ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2577">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="dd86b-2578">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2578">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="dd86b-2579">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2579">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="dd86b-2580">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2580">-or-</span></span>  
  
 <span data-ttu-id="dd86b-2581">Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und die Assembly wurde mit einer höheren Version kompiliert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2581">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="dd86b-2582">Angeben vollständig gekennzeichneter Typnamen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2582">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="dd86b-2583">Der durch die Assembly bezeichnete Name des abzurufenden Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2583">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="dd86b-2584">Siehe <see cref="P:System.Type.AssemblyQualifiedName" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2584">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="dd86b-2585">Wenn sich der Typ in der aktuell ausgeführten Assembly oder in Mscorlib.dll befindet, ist eine Angabe des Typnamens einschließlich des qualifizierenden Namespace ausreichend.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2585">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="dd86b-2586"><see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" />, damit <see langword="null" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2586"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="dd86b-2587">Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2587">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="dd86b-2588">Informationen finden Sie im Abschnitt für Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2588">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="dd86b-2589"><see langword="true" />, um ohne Beachtung der Groß-/Kleinschreibung nach <paramref name="typeName" /> zu suchen, <see langword="false" />, um mit Beachtung der Groß-/Kleinschreibung nach <paramref name="typeName" /> zu suchen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2589"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />, <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="dd86b-2590">Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Dabei wird angegeben, ob bei der Suche Groß- und Kleinschreibung berücksichtigt werden soll und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2590">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="dd86b-2591">Der Typ mit dem angegebenen Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2591">The type with the specified name.</span></span> <span data-ttu-id="dd86b-2592">Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2592">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="dd86b-2593">In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2593">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="dd86b-2594">Informationen finden Sie im Abschnitt für Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2594">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-2595">Mit der <xref:System.Type.GetType%2A> -Methode können Sie ein <xref:System.Type> -Objekt für einen Typ in einer anderen Assembly abrufen, wenn Sie den durch die Assembly qualifizierten Namen kennen, der <xref:System.Type.AssemblyQualifiedName>von abgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2595">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly if you know its assembly-qualified name, which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="dd86b-2596"><xref:System.Type.GetType%2A>bewirkt das Laden der in `typeName`angegebenen Assembly.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2596"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="dd86b-2597">Sie können eine Assembly <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> auch mit der-Methode laden und dann die-Methode oder <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> - <xref:System.Type> Methode verwenden, um-Objekte zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2597">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method, and then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method to get <xref:System.Type> objects.</span></span> <span data-ttu-id="dd86b-2598">Wenn ein Typ in einer Assembly ist, die dem Programm zur Kompilierzeit bekannt ist, ist es effizienter `typeof` , C# in oder `GetType` den-Operator in Visual Basic zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2598">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C# or the `GetType` operator in Visual Basic.</span></span>
  
 <span data-ttu-id="dd86b-2599">`GetType`funktioniert nur für Assemblys, die vom Datenträger geladen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2599">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="dd86b-2600">Wenn Sie `GetType` einen in einer dynamischen Assembly, die mithilfe der <xref:System.Reflection.Emit> Dienste definiert wurde, definierten Typ suchen, wird möglicherweise ein inkonsistentes Verhalten angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2600">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="dd86b-2601">Das Verhalten hängt davon ab, ob die dynamische Assembly permanent ist, d. h. `RunAndSave` mithilfe `Save` der Zugriffs Modi <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> oder der-Enumeration erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2601">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="dd86b-2602">Wenn die dynamische Assembly permanent ist und auf den Datenträger geschrieben wurde `GetType` , bevor aufgerufen wird, sucht das Lade Modul die gespeicherte Assembly auf dem Datenträger, lädt diese Assembly und ruft den Typ aus dieser Assembly ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2602">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="dd86b-2603">Wenn die Assembly nicht auf dem Datenträger gespeichert wurde `GetType` , wenn aufgerufen wird, gibt `null`die Methode zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2603">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="dd86b-2604">`GetType`versteht keine vorübergehenden dynamischen Assemblys. Daher gibt das `GetType` Aufrufen von zum Abrufen eines Typs in einer vorübergehenden dynamischen `null`Assembly zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2604">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="dd86b-2605">Abonnieren Sie `GetType` das Ereignis, und führen Sie vor dem <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> speichern einen Rückruf `GetType` aus, um in einem dynamischen Modul zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2605">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="dd86b-2606">Andernfalls erhalten Sie zwei Kopien der Assembly im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2606">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="dd86b-2607">Der `throwOnError` -Parameter gibt an, was geschieht, wenn der Typ nicht gefunden wird, und unterdrückt auch bestimmte andere Ausnahmebedingungen, wie im Abschnitt Ausnahmen beschrieben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2607">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="dd86b-2608">Einige Ausnahmen werden unabhängig vom Wert von `throwOnError`ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2608">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="dd86b-2609">Wenn der Typ z. b. gefunden wurde, aber nicht geladen werden <xref:System.TypeLoadException> kann, wird auch `throwOnError` eine `false`ausgelöst, wenn gleich ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2609">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="dd86b-2610">In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2610">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="dd86b-2611">Memberart</span><span class="sxs-lookup"><span data-stu-id="dd86b-2611">Member Type</span></span>|<span data-ttu-id="dd86b-2612">Statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-2612">Static</span></span>|<span data-ttu-id="dd86b-2613">Nicht statisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-2613">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="dd86b-2614">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="dd86b-2614">Constructor</span></span>|<span data-ttu-id="dd86b-2615">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2615">No</span></span>|<span data-ttu-id="dd86b-2616">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2616">No</span></span>|  
|<span data-ttu-id="dd86b-2617">Feld</span><span class="sxs-lookup"><span data-stu-id="dd86b-2617">Field</span></span>|<span data-ttu-id="dd86b-2618">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2618">No</span></span>|<span data-ttu-id="dd86b-2619">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2619">Yes.</span></span> <span data-ttu-id="dd86b-2620">Ein Feld wird immer nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2620">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-2621">event</span><span class="sxs-lookup"><span data-stu-id="dd86b-2621">Event</span></span>|<span data-ttu-id="dd86b-2622">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-2622">Not applicable</span></span>|<span data-ttu-id="dd86b-2623">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2623">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-2624">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-2624">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-2625">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2625">See note 2 below.</span></span>|  
|<span data-ttu-id="dd86b-2626">Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-2626">Method</span></span>|<span data-ttu-id="dd86b-2627">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2627">No</span></span>|<span data-ttu-id="dd86b-2628">Ja.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2628">Yes.</span></span> <span data-ttu-id="dd86b-2629">Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2629">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="dd86b-2630">Der Typ "Typ"</span><span class="sxs-lookup"><span data-stu-id="dd86b-2630">Nested Type</span></span>|<span data-ttu-id="dd86b-2631">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2631">No</span></span>|<span data-ttu-id="dd86b-2632">Nein</span><span class="sxs-lookup"><span data-stu-id="dd86b-2632">No</span></span>|  
|<span data-ttu-id="dd86b-2633">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="dd86b-2633">Property</span></span>|<span data-ttu-id="dd86b-2634">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="dd86b-2634">Not applicable</span></span>|<span data-ttu-id="dd86b-2635">Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2635">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="dd86b-2636">Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur".</span><span class="sxs-lookup"><span data-stu-id="dd86b-2636">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-2637">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2637">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="dd86b-2638">"Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2638">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="dd86b-2639">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2639">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="dd86b-2640">Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2640">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="dd86b-2641">Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2641">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="dd86b-2642">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2642">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="dd86b-2643">Arrays oder COM-Typen werden nicht durchsucht, es sei denn, Sie wurden bereits in die Tabelle der verfügbaren Klassen geladen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2643">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="dd86b-2644">`typeName`kann der durch den Namespace qualifizierte Typname oder ein durch die Assembly qualifizierter Name sein, der eine Assemblynamensspezifikation enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2644">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="dd86b-2645">Siehe <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2645">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="dd86b-2646">Wenn `typeName` den Namespace, aber nicht den Assemblynamen enthält, durchsucht diese Methode nur die Assembly des aufrufenden Objekts und die Datei "mscorlib. dll" in dieser Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2646">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="dd86b-2647">Wenn tygtame vollständig mit dem Assemblynamen partiell oder vollständig qualifiziert ist, sucht diese Methode in der angegebenen Assembly.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2647">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="dd86b-2648">Wenn die Assembly einen starken Namen hat, ist ein vollständiger AssemblyName erforderlich.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2648">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="dd86b-2649">Die <xref:System.Type.AssemblyQualifiedName%2A> -Eigenschaft gibt einen voll qualifizierten Typnamen zurück, einschließlich der-Typen, des Assemblynamens und der Typargumente.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2649">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and type arguments.</span></span> <span data-ttu-id="dd86b-2650">Alle Compiler, die die Common Language Runtime unterstützen, geben den einfachen Namen einer geschachtelten Klasse aus, und die Reflektion erstellt bei der Abfrage einen geschachtelten Namen in Übereinstimmung mit den folgenden Konventionen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2650">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-2651">In der .NET Framework Version 2,0 wird die Prozessorarchitektur der Assemblyidentität hinzugefügt und kann als Teil der assemblynamenszeichenfolgen angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2651">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="dd86b-2652">Beispiel: "ProcessorArchitecture = msil".</span><span class="sxs-lookup"><span data-stu-id="dd86b-2652">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="dd86b-2653">Aus Kompatibilitätsgründen ist Sie jedoch nicht in der Zeichenfolge <xref:System.Type.AssemblyQualifiedName%2A> enthalten, die von der-Eigenschaft zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2653">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="dd86b-2654">Sie können auch Typen laden, indem Sie <xref:System.Reflection.AssemblyName> ein-Objekt erstellen und es an eine entsprechende <xref:System.Reflection.Assembly.Load%2A> Überladung der-Methode übergeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2654">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="dd86b-2655">Sie können dann die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> -Methode verwenden, um Typen aus der Assembly zu laden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2655">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="dd86b-2656">Siehe auch <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2656">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="dd86b-2657">Trennzeichen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2657">Delimiter</span></span>|<span data-ttu-id="dd86b-2658">Bedeutung</span><span class="sxs-lookup"><span data-stu-id="dd86b-2658">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="dd86b-2659">Umgekehrter Schrägstrich (\\)</span><span class="sxs-lookup"><span data-stu-id="dd86b-2659">Backslash (\\)</span></span>|<span data-ttu-id="dd86b-2660">Escapezeichen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2660">Escape character.</span></span>|  
|<span data-ttu-id="dd86b-2661">Backtick (')</span><span class="sxs-lookup"><span data-stu-id="dd86b-2661">Backtick (\`)</span></span>|<span data-ttu-id="dd86b-2662">Geht einer oder mehreren Ziffern vorangestellt, die die Anzahl der Typparameter darstellen, die sich am Ende des Namens eines generischen Typs befinden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2662">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="dd86b-2663">Eckige Klammern ([])</span><span class="sxs-lookup"><span data-stu-id="dd86b-2663">Brackets ([])</span></span>|<span data-ttu-id="dd86b-2664">Umschließen einer generischen Typargument Liste für einen konstruierten generischen Typ; Schließen Sie in einer Typargument Liste einen assemblyqualifizierten Typ ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2664">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="dd86b-2665">Komma (,)</span><span class="sxs-lookup"><span data-stu-id="dd86b-2665">Comma (,)</span></span>|<span data-ttu-id="dd86b-2666">Geht vor dem Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2666">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="dd86b-2667">Punkt (.)</span><span class="sxs-lookup"><span data-stu-id="dd86b-2667">Period (.)</span></span>|<span data-ttu-id="dd86b-2668">Bezeichnet Namespace Bezeichner.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2668">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="dd86b-2669">Plus Zeichen (+)</span><span class="sxs-lookup"><span data-stu-id="dd86b-2669">Plus sign (+)</span></span>|<span data-ttu-id="dd86b-2670">Geht einer-Klasse vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2670">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="dd86b-2671">Der voll qualifizierte Name für eine Klasse könnte beispielsweise wie folgt aussehen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2671">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="dd86b-2672">Wenn der Namespace ein TopNamespace. Sub +-Namespace wäre, müsste die Zeichenfolge dem Pluszeichen (+) mit einem Escapezeichen (\\) vorangestellt werden, um zu verhindern, dass Sie als Schachtelungs Trennzeichen interpretiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2672">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="dd86b-2673">Die Reflektion gibt diese Zeichenfolge wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2673">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="dd86b-2674">Ein "+ +" wird zu\\"\\\\+\\+", und "" wird zu "\\".</span><span class="sxs-lookup"><span data-stu-id="dd86b-2674">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="dd86b-2675">Dieser qualifizierte Name kann persistent gespeichert und später zum Laden <xref:System.Type>von verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2675">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="dd86b-2676">Um nach einem <xref:System.Type>zu suchen und zu laden <xref:System.Type.GetType%2A> , verwenden Sie entweder mit dem Typnamen oder mit dem qualifizierten Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2676">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="dd86b-2677"><xref:System.Type.GetType%2A>beim Typnamen wird nur <xref:System.Type> in der Assembly des Aufrufers und dann in der Systemassembly nach gesucht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2677"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="dd86b-2678"><xref:System.Type.GetType%2A>mit dem qualifizierten Assemblynamen für die Assembly <xref:System.Type> wird in beliebiger Assembly nach gesucht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2678"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="dd86b-2679">Typnamen können nachfolgende Zeichen enthalten, die zusätzliche Informationen über den Typ angeben, z. b. ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2679">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="dd86b-2680">Um den Typnamen ohne diese nachfolgenden Zeichen abzurufen, `t.GetElementType().ToString()`verwenden Sie `t` , wobei der-Typ ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2680">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="dd86b-2681">Leerzeichen sind in allen Typnamen Komponenten mit Ausnahme des Assemblynamens relevant.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2681">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="dd86b-2682">Im Assemblynamen sind Leerzeichen vor dem Trennzeichen ', ' relevant, Leerzeichen nach dem Trennzeichen ', ' werden jedoch ignoriert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2682">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="dd86b-2683">Der Name eines generischen Typs endet mit einem Graviszeichen (\`) gefolgt von Ziffern, die die Anzahl der generischen Typargumente darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2683">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="dd86b-2684">Der Zweck dieses Namens besteht darin, Compiler die Unterstützung generischer Typen mit dem gleichen Namen, jedoch mit unterschiedlicher Anzahl von Typparametern, die im gleichen Bereich auftreten, zuzulassen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2684">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="dd86b-2685">Reflektion gibt beispielsweise das `Tuple`Tupel`\<T0, T1>` `Tuple<T>` `Tuple(Of T)` `2` mit dem` and `Namen 1 aus den generischen Methoden `Tuple(Of T0, T1)` und in Visual Basic oder und Tupel in Visual C#zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2685">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="dd86b-2686">Bei generischen Typen wird die Typargument Liste in eckige Klammern eingeschlossen, und die Typargumente werden durch Kommas getrennt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2686">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="dd86b-2687">Beispielsweise verfügt ein generisches <xref:System.Collections.Generic.Dictionary%602> über zwei Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2687">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="dd86b-2688">Eine <xref:System.Collections.Generic.Dictionary%602> <xref:System.String> von `MyType` mit Schlüsseln des Typs kann wie folgt dargestellt werden:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2688">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="dd86b-2689">Um einen durch die Assembly qualifizierten Typ innerhalb einer Typargument Liste anzugeben, schließen Sie den durch die Assembly qualifizierten Typ in eckige Klammern ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2689">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="dd86b-2690">Andernfalls werden die Kommas, die die Teile des durch die Assembly qualifizierten Namens trennen, als Grenzen zusätzlicher Typargumente interpretiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2690">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="dd86b-2691">Beispielsweise kann eine <xref:System.Collections.Generic.Dictionary%602> von `MyType` aus MyAssembly. dll mit Schlüsseln vom Typ <xref:System.String>wie folgt angegeben werden:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2691">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-2692">Ein durch eine Assembly qualifizierter Typ kann nur in eckige Klammern eingeschlossen werden, wenn er in einer Typparameter Liste angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2692">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="dd86b-2693">Die Regeln zum Durchsuchen von Assemblys für qualifizierte und nicht qualifizierte Typen in Typparameter Listen sind identisch mit den Regeln für qualifizierte und nicht qualifizierte nicht generische Typen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2693">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="dd86b-2694">Typen, die NULL-Werte zulassen, sind Sonderfälle von generischen Typen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2694">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="dd86b-2695">Beispielsweise wird ein Werte zulässt <xref:System.Int32> -Element durch die Zeichenfolge "System. Werte zulässt ' 1 [System. Int32]" dargestellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2695">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-2696">In C#, C++und Visual Basic Sie mit Typoperatoren auch Typen, die NULL-Werte zulassen, erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2696">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="dd86b-2697">Der Typ, der NULL- <xref:System.Boolean> Werte zulässt, wird z C#. b `Nullable<Boolean>::typeid` . C++von `typeof(Nullable<bool>)` in, `GetType(Nullable(Of Boolean))` von in und von in Visual Basic zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2697">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="dd86b-2698">Die folgende Tabelle zeigt die Syntax, die Sie `GetType` mit für verschiedene Typen verwenden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2698">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="dd86b-2699">So erhalten Sie</span><span class="sxs-lookup"><span data-stu-id="dd86b-2699">To Get</span></span>|<span data-ttu-id="dd86b-2700">Verwendung</span><span class="sxs-lookup"><span data-stu-id="dd86b-2700">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="dd86b-2701">Ein Werte zulässt<xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="dd86b-2701">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="dd86b-2702">Ein nicht verwalteter Zeiger auf`MyType`</span><span class="sxs-lookup"><span data-stu-id="dd86b-2702">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="dd86b-2703">Ein nicht verwalteter Zeiger auf einen Zeiger auf.`MyType`</span><span class="sxs-lookup"><span data-stu-id="dd86b-2703">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="dd86b-2704">Ein verwalteter Zeiger oder ein Verweis auf.`MyType`</span><span class="sxs-lookup"><span data-stu-id="dd86b-2704">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="dd86b-2705">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2705">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="dd86b-2706">Beachten Sie, dass Verweise im Gegensatz zu Zeigern auf eine Ebene beschränkt sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2706">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="dd86b-2707">Eine übergeordnete Klasse und eine nicht erbt Klasse</span><span class="sxs-lookup"><span data-stu-id="dd86b-2707">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="dd86b-2708">Ein eindimensionales Array mit einer unteren Grenze von 0.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2708">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="dd86b-2709">Ein eindimensionales Array mit einer unbekannten unteren Grenze.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2709">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="dd86b-2710">Ein n-dimensionales Array</span><span class="sxs-lookup"><span data-stu-id="dd86b-2710">An n-dimensional array</span></span>|<span data-ttu-id="dd86b-2711">Ein Komma (,) innerhalb der eckige Klammern, das insgesamt n-1 Mal ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2711">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="dd86b-2712">Beispielsweise `System.Object[,,]` stellt ein dreidimensionales `Object` Array dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2712">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="dd86b-2713">Array eines zweidimensionalen Arrays</span><span class="sxs-lookup"><span data-stu-id="dd86b-2713">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="dd86b-2714">Ein rechteckiges zweidimensionales Array mit unbekannten unteren Begrenzungen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2714">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="dd86b-2715">Ein generischer Typ mit einem Typargument.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2715">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="dd86b-2716">Ein generischer Typ mit zwei Typargumenten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2716">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="dd86b-2717">Ein generischer Typ mit zwei durch die Assembly qualifizierten Typargumenten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2717">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="dd86b-2718">Ein durch eine Assembly qualifizierter generischer Typ mit einem assemblyqualifizierten Typargument.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2718">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="dd86b-2719">Ein generischer Typ, dessen Typargument ein generischer Typ mit zwei Typargumenten ist</span><span class="sxs-lookup"><span data-stu-id="dd86b-2719">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-2720"><paramref name="typeName" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2720"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="dd86b-2721">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2721">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="dd86b-2722"><paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2722"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="dd86b-2723">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2723">-or-</span></span> 
 <span data-ttu-id="dd86b-2724"><paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2724"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="dd86b-2725">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2725">-or-</span></span> 
 <span data-ttu-id="dd86b-2726"><paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2726"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="dd86b-2727">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2727">-or-</span></span> 
 <span data-ttu-id="dd86b-2728"><paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2728"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="dd86b-2729">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2729">-or-</span></span> 
 <span data-ttu-id="dd86b-2730"><paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2730"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-2731"><paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax,</span><span class="sxs-lookup"><span data-stu-id="dd86b-2731"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span></span> <span data-ttu-id="dd86b-2732">beispielsweise "MyType[,\*,]".</span><span class="sxs-lookup"><span data-stu-id="dd86b-2732">For example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="dd86b-2733">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2733">-or-</span></span> 
 <span data-ttu-id="dd86b-2734"><paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2734"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="dd86b-2735">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2735">-or-</span></span> 
 <span data-ttu-id="dd86b-2736"><paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2736"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="dd86b-2737">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2737">-or-</span></span> 
 <span data-ttu-id="dd86b-2738"><paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2738"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="dd86b-2739"><paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2739"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="dd86b-2740">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2740">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="dd86b-2741">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2741">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="dd86b-2742">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2742">-or-</span></span>  
  
 <span data-ttu-id="dd86b-2743">Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und die Assembly wurde mit einer höheren Version kompiliert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2743">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="dd86b-2744">Angeben vollständig gekennzeichneter Typnamen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2744">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="dd86b-2745">Der Name des abzurufenden Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2745">The name of the type to get.</span></span> <span data-ttu-id="dd86b-2746">Wenn der <paramref name="typeResolver" />-Parameter bereitgestellt wird, kann der Typname jede Zeichenfolge sein, die vom <paramref name="typeResolver" /> aufgelöst werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2746">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="dd86b-2747">Wenn der <paramref name="assemblyResolver" />-Parameter bereitgestellt wird oder wenn die Standardtypauflösung verwendet wird, muss der <paramref name="typeName" /> ein durch die Assembly qualifizierter Name (siehe <see cref="P:System.Type.AssemblyQualifiedName" />) sein, es sei denn, der Typ befindet sich in der gerade ausgeführten Assembly oder in der Datei Mscorlib.dll. In diesem Fall genügt es, den von seinem Namespace qualifizierten Typnamen anzugeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2747">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="dd86b-2748">Eine Methode, die die Assembly sucht und zurückgibt, die in <paramref name="typeName" /> angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2748">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="dd86b-2749">Der Assemblyname wird an den <paramref name="assemblyResolver" /> als ein <see cref="T:System.Reflection.AssemblyName" />-Objekt übergeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2749">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="dd86b-2750">Wenn <paramref name="typeName" /> keinen Namen einer Assembly enthält, wird der <paramref name="assemblyResolver" /> nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2750">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="dd86b-2751">Wenn der <paramref name="assemblyResolver" /> nicht angegeben wird, wird die Standardassemblyauflösung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2751">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="dd86b-2752">Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2752">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="dd86b-2753">Andernfalls könnten Berechtigungen für bösartigen Code erweitert werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2753">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="dd86b-2754">Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2754">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="dd86b-2755">Eine Methode, die den Typ sucht und zurückgibt, der von <paramref name="typeName" /> von der Assembly angegeben wird, die vom <paramref name="assemblyResolver" /> oder von der Standardassemblyauflösung zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2755">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="dd86b-2756">Wenn keine Assembly bereitgestellt wird, kann die <paramref name="typeResolver" />-Methode eine Assembly zur Verfügung stellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2756">If no assembly is provided, the <paramref name="typeResolver" /> method can provide one.</span></span> <span data-ttu-id="dd86b-2757">Die Methode nimmt auch einen Parameter an, der angibt, ob bei der Suche die Groß- und Kleinschreibung berücksichtigt werden soll; an diesen Parameter wird <see langword="false" /> übergeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2757">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="dd86b-2758">Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2758">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <summary><span data-ttu-id="dd86b-2759">Ruft den Typ mit dem angegebenen Namen ab und stellt optional benutzerdefinierte Methoden bereit, um die Assembly und den Typ aufzulösen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2759">Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-2760">Der Typ mit dem angegebenen Namen oder <see langword="null" />, wenn der Typ nicht gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2760">The type with the specified name, or <see langword="null" /> if the type is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-2761">Verwendungs Szenarien für diese Methode und Details zu den `assemblyResolver` para `typeResolver` Metern und finden Sie in der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> -Methoden Überladung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2761">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-2762">Wenn `typeName` nicht gefunden werden kann, gibt der Rückruf <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> der Methode `null`zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2762">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> method returns `null`.</span></span> <span data-ttu-id="dd86b-2763">Es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2763">It does not throw an exception.</span></span> <span data-ttu-id="dd86b-2764">Um zu steuern, ob eine Ausnahme ausgelöst wird, müssen Sie eine <xref:System.Type.GetType%2A> Überladung der- `throwOnError` Methode aufrufen, die über einen-Parameter verfügt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2764">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="dd86b-2765">Das Aufrufen dieser Methoden Überladung entspricht dem Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> -Methoden Überladung `false` und der `throwOnError` Angabe `ignoreCase` von für den-Parameter und den-Parameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2765">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `throwOnError` and `ignoreCase` parameters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-2766"><paramref name="typeName" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2766"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="dd86b-2767">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2767">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-2768">Ein Fehler tritt auf, wenn <paramref name="typeName" /> in einen Typnamen und einen Assemblynamen zerlegt wird (wenn z. B. der einfache Typname ein Sonderzeichen ohne Escapezeichen enthält).</span><span class="sxs-lookup"><span data-stu-id="dd86b-2768">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="dd86b-2769">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2769">-or-</span></span> 
 <span data-ttu-id="dd86b-2770"><paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2770"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="dd86b-2771">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2771">-or-</span></span> 
 <span data-ttu-id="dd86b-2772"><paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2772"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="dd86b-2773">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2773">-or-</span></span> 
 <span data-ttu-id="dd86b-2774"><paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2774"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="dd86b-2775"><paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2775"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="dd86b-2776">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2776">The assembly or one of its dependencies was found, but could not be loaded.</span></span>  
  
<span data-ttu-id="dd86b-2777">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2777">-or-</span></span> 
 <span data-ttu-id="dd86b-2778"><paramref name="typeName" /> enthält einen ungültigen Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2778"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="dd86b-2779">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2779">-or-</span></span> 
 <span data-ttu-id="dd86b-2780"><paramref name="typeName" /> ist ein gültiger Assemblyname ohne Typnamen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2780"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="dd86b-2781">Die Assembly oder eine der zugehörigen Abhängigkeiten ist nicht gültig.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2781">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="dd86b-2782">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2782">-or-</span></span>  
  
 <span data-ttu-id="dd86b-2783">Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2783">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="dd86b-2784">Der Name des abzurufenden Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2784">The name of the type to get.</span></span> <span data-ttu-id="dd86b-2785">Wenn der <paramref name="typeResolver" />-Parameter bereitgestellt wird, kann der Typname jede Zeichenfolge sein, die vom <paramref name="typeResolver" /> aufgelöst werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2785">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="dd86b-2786">Wenn der <paramref name="assemblyResolver" />-Parameter bereitgestellt wird oder wenn die Standardtypauflösung verwendet wird, muss der <paramref name="typeName" /> ein durch die Assembly qualifizierter Name (siehe <see cref="P:System.Type.AssemblyQualifiedName" />) sein, es sei denn, der Typ befindet sich in der gerade ausgeführten Assembly oder in der Datei Mscorlib.dll. In diesem Fall genügt es, den von seinem Namespace qualifizierten Typnamen anzugeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2786">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="dd86b-2787">Eine Methode, die die Assembly sucht und zurückgibt, die in <paramref name="typeName" /> angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2787">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="dd86b-2788">Der Assemblyname wird an den <paramref name="assemblyResolver" /> als ein <see cref="T:System.Reflection.AssemblyName" />-Objekt übergeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2788">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="dd86b-2789">Wenn <paramref name="typeName" /> keinen Namen einer Assembly enthält, wird der <paramref name="assemblyResolver" /> nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2789">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="dd86b-2790">Wenn der <paramref name="assemblyResolver" /> nicht angegeben wird, wird die Standardassemblyauflösung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2790">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="dd86b-2791">Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2791">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="dd86b-2792">Andernfalls könnten Berechtigungen für bösartigen Code erweitert werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2792">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="dd86b-2793">Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2793">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="dd86b-2794">Eine Methode, die den Typ sucht und zurückgibt, der von <paramref name="typeName" /> von der Assembly angegeben wird, die vom <paramref name="assemblyResolver" /> oder von der Standardassemblyauflösung zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2794">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="dd86b-2795">Wenn keine Assembly bereitgestellt wird, kann die Methode eine Assembly zur Verfügung stellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2795">If no assembly is provided, the method can provide one.</span></span> <span data-ttu-id="dd86b-2796">Die Methode nimmt auch einen Parameter an, der angibt, ob bei der Suche die Groß- und Kleinschreibung berücksichtigt werden soll; an diesen Parameter wird <see langword="false" /> übergeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2796">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="dd86b-2797">Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2797">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="dd86b-2798"><see langword="true" /> , damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" /> , damit <see langword="null" />zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2798"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="dd86b-2799">Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2799">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="dd86b-2800">Informationen finden Sie im Abschnitt für Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2800">See the Exceptions section.</span></span></param>
        <summary><span data-ttu-id="dd86b-2801">Ruft den Typ mit dem angegebenen Namen ab. Dabei wird angegeben, ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird, und optional werden benutzerdefinierte Methoden bereitgestellt, um die Assembly und den Typ aufzulösen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2801">Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-2802">Der Typ mit dem angegebenen Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2802">The type with the specified name.</span></span> <span data-ttu-id="dd86b-2803">Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2803">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="dd86b-2804">In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2804">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="dd86b-2805">Informationen finden Sie im Abschnitt für Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2805">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-2806">Verwendungs Szenarien für diese Methode und Details zu den `assemblyResolver` para `typeResolver` Metern und finden Sie in der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> -Methoden Überladung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2806">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="dd86b-2807">Das Aufrufen dieser Methoden Überladung ist identisch mit dem <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> Aufrufen der-Methoden `false` Überladung `ignoreCase` und der Angabe von für den-Parameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2807">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `ignoreCase` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-2808"><paramref name="typeName" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2808"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="dd86b-2809">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2809">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="dd86b-2810"><paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2810"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="dd86b-2811">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2811">-or-</span></span> 
 <span data-ttu-id="dd86b-2812"><paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2812"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="dd86b-2813">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2813">-or-</span></span> 
 <span data-ttu-id="dd86b-2814"><paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2814"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="dd86b-2815">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2815">-or-</span></span> 
 <span data-ttu-id="dd86b-2816"><paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2816"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="dd86b-2817">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2817">-or-</span></span> 
 <span data-ttu-id="dd86b-2818"><paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2818"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-2819">Ein Fehler tritt auf, wenn <paramref name="typeName" /> in einen Typnamen und einen Assemblynamen zerlegt wird (wenn z. B. der einfache Typname ein Sonderzeichen ohne Escapezeichen enthält).</span><span class="sxs-lookup"><span data-stu-id="dd86b-2819">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="dd86b-2820">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2820">-or-</span></span> 
 <span data-ttu-id="dd86b-2821"><paramref name="throwOnError" /> ist <see langword="true" /> und <paramref name="typeName" /> enthält ungültige Syntax (z. B. „MyType[,\*,]“).</span><span class="sxs-lookup"><span data-stu-id="dd86b-2821"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span></span>  
  
<span data-ttu-id="dd86b-2822">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2822">-or-</span></span> 
 <span data-ttu-id="dd86b-2823"><paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2823"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="dd86b-2824">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2824">-or-</span></span> 
 <span data-ttu-id="dd86b-2825"><paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2825"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="dd86b-2826">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2826">-or-</span></span> 
 <span data-ttu-id="dd86b-2827"><paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2827"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="dd86b-2828"><paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2828"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span>  
  
<span data-ttu-id="dd86b-2829">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2829">-or-</span></span> 
 <span data-ttu-id="dd86b-2830"><paramref name="typeName" /> enthält einen ungültigen Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2830"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="dd86b-2831">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2831">-or-</span></span> 
 <span data-ttu-id="dd86b-2832"><paramref name="typeName" /> ist ein gültiger Assemblyname ohne Typnamen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2832"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="dd86b-2833">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2833">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="dd86b-2834">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2834">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="dd86b-2835">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-2835">-or-</span></span>  
  
 <span data-ttu-id="dd86b-2836">Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2836">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="dd86b-2837">Der Name des abzurufenden Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2837">The name of the type to get.</span></span> <span data-ttu-id="dd86b-2838">Wenn der <paramref name="typeResolver" />-Parameter bereitgestellt wird, kann der Typname jede Zeichenfolge sein, die vom <paramref name="typeResolver" /> aufgelöst werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2838">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="dd86b-2839">Wenn der <paramref name="assemblyResolver" />-Parameter bereitgestellt wird oder wenn die Standardtypauflösung verwendet wird, muss der <paramref name="typeName" /> ein durch die Assembly qualifizierter Name (siehe <see cref="P:System.Type.AssemblyQualifiedName" />) sein, es sei denn, der Typ befindet sich in der gerade ausgeführten Assembly oder in der Datei Mscorlib.dll. In diesem Fall genügt es, den von seinem Namespace qualifizierten Typnamen anzugeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2839">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="dd86b-2840">Eine Methode, die die Assembly sucht und zurückgibt, die in <paramref name="typeName" /> angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2840">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="dd86b-2841">Der Assemblyname wird an den <paramref name="assemblyResolver" /> als ein <see cref="T:System.Reflection.AssemblyName" />-Objekt übergeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2841">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="dd86b-2842">Wenn <paramref name="typeName" /> keinen Namen einer Assembly enthält, wird der <paramref name="assemblyResolver" /> nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2842">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="dd86b-2843">Wenn der <paramref name="assemblyResolver" /> nicht angegeben wird, wird die Standardassemblyauflösung ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2843">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="dd86b-2844">Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2844">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="dd86b-2845">Andernfalls könnten Berechtigungen für bösartigen Code erweitert werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2845">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="dd86b-2846">Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2846">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="dd86b-2847">Eine Methode, die den Typ sucht und zurückgibt, der von <paramref name="typeName" /> von der Assembly angegeben wird, die vom <paramref name="assemblyResolver" /> oder von der Standardassemblyauflösung zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2847">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="dd86b-2848">Wenn keine Assembly bereitgestellt wird, kann die Methode eine Assembly zur Verfügung stellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2848">If no assembly is provided, the method can provide one.</span></span> <span data-ttu-id="dd86b-2849">Die Methode nimmt auch einen Parameter an, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll; an diesen Parameter wird der Wert von <paramref name="ignoreCase" /> übergeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2849">The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <paramref name="ignoreCase" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="dd86b-2850">Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2850">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="dd86b-2851"><see langword="true" /> , damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" /> , damit <see langword="null" />zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2851"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="dd86b-2852">Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2852">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="dd86b-2853">Informationen finden Sie im Abschnitt für Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2853">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="dd86b-2854"><see langword="true" />, um ohne Beachtung der Groß-/Kleinschreibung nach <paramref name="typeName" /> zu suchen, <see langword="false" />, um mit Beachtung der Groß-/Kleinschreibung nach <paramref name="typeName" /> zu suchen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2854"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />, <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="dd86b-2855">Ruft den Typ mit dem angegebenen Namen ab. Dabei wird angegeben, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird, und optional werden benutzerdefinierte Methoden bereitgestellt, um die Assembly und den Typ aufzulösen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2855">Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-2856">Der Typ mit dem angegebenen Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2856">The type with the specified name.</span></span> <span data-ttu-id="dd86b-2857">Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2857">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="dd86b-2858">In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2858">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="dd86b-2859">Informationen finden Sie im Abschnitt für Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2859">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-2860">Verwenden Sie diese Methoden Überladung und die zugehörigen über<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> Ladungen <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>(und), um <xref:System.Type.GetType%2A> die Standard Implementierung der-Methode durch flexiblere Implementierungen zu ersetzen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2860">Use this method overload and its associated overloads (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> and <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) to replace the default implementation of the <xref:System.Type.GetType%2A> method with more flexible implementations.</span></span> <span data-ttu-id="dd86b-2861">Durch die Bereitstellung Ihrer eigenen Methoden, mit denen Typnamen und die Namen der Assemblys aufgelöst werden, die Sie enthalten, können Sie Folgendes tun:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2861">By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</span></span>  
  
-   <span data-ttu-id="dd86b-2862">Steuern, aus welcher Version einer Assembly ein Typ geladen wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2862">Control which version of an assembly a type is loaded from.</span></span>  
  
-   <span data-ttu-id="dd86b-2863">Geben Sie einen anderen Ort an, um nach einem Typnamen zu suchen, der keinen Assemblynamen enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2863">Provide another place to look for a type name that does not include an assembly name.</span></span>  
  
-   <span data-ttu-id="dd86b-2864">Lädt Assemblys mit partiellen Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2864">Load assemblies using partial assembly names.</span></span>  
  
-   <span data-ttu-id="dd86b-2865">Gibt Unterklassen von <xref:System.Type?displayProperty=nameWithType> zurück, die nicht vom Common Language Runtime (CLR) erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2865">Return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the common language runtime (CLR).</span></span>  
  
 <span data-ttu-id="dd86b-2866">Bei der Versions toleranten Serialisierung können Sie mit dieser Methode z. b. nach einer "am besten geeigneten" Assembly suchen, indem Sie einen partiellen Namen verwenden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2866">For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name.</span></span> <span data-ttu-id="dd86b-2867">Andere über Ladungen der <xref:System.Type.GetType%2A> -Methode erfordern einen durch die Assembly qualifizierten Typnamen, der die Versionsnummer enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2867">Other overloads of the <xref:System.Type.GetType%2A> method require an assembly-qualified type name, which includes the version number.</span></span>  
  
 <span data-ttu-id="dd86b-2868">Alternative Implementierungen des Typsystems müssen möglicherweise Unterklassen von <xref:System.Type?displayProperty=nameWithType> zurückgeben, die nicht von der CLR erstellt werden. alle Typen, die von anderen über Ladungen <xref:System.Type.GetType%2A> der-Methode zurückgegeben werden, sind Lauf Zeit Typen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2868">Alternate implementations of the type system may need to return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the CLR; all types that are returned by other overloads of the <xref:System.Type.GetType%2A> method are runtime types.</span></span>  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a><span data-ttu-id="dd86b-2869">Hinweise zur Verwendung</span><span class="sxs-lookup"><span data-stu-id="dd86b-2869">Usage Notes</span></span>  
 <span data-ttu-id="dd86b-2870">Diese Methoden Überladung und die zugehörigen über Ladungen werden `typeName` in den Namen eines Typs und den Namen einer Assembly analysiert und dann die Namen aufgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2870">This method overload and its associated overloads parse `typeName` into the name of a type and the name of an assembly, and then resolve the names.</span></span> <span data-ttu-id="dd86b-2871">Die Auflösung des Assemblynamens tritt vor der Auflösung des Typnamens auf, da ein Typname im Kontext einer Assembly aufgelöst werden muss.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2871">Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-2872">Wenn Sie mit dem Konzept der durch die Assembly qualifizierten Typnamen nicht vertraut sind, <xref:System.Type.AssemblyQualifiedName%2A> lesen Sie die-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2872">If you are unfamiliar with the concept of assembly-qualified type names, see the <xref:System.Type.AssemblyQualifiedName%2A> property.</span></span>  
  
 <span data-ttu-id="dd86b-2873">Wenn `typeName` kein durch die Assembly qualifizierter Name ist, wird die Assemblyauflösung übersprungen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2873">If `typeName` is not an assembly-qualified name, assembly resolution is skipped.</span></span> <span data-ttu-id="dd86b-2874">Nicht qualifizierte Typnamen können im Kontext von mscorlib. dll oder der aktuell ausgeführten Assembly aufgelöst werden, oder Sie können optional eine Assembly im `typeResolver` -Parameter bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2874">Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the `typeResolver` parameter.</span></span> <span data-ttu-id="dd86b-2875">Die Auswirkungen, wie der AssemblyName für verschiedene Arten von Namensauflösung eingeschlossen oder weggelassen wird, werden als Tabelle im Abschnitt [gemischte Namensauflösung](#mixed_name_resolution) angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2875">The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section.</span></span>  
  
 <span data-ttu-id="dd86b-2876">Allgemeine Hinweise zur Verwendung:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2876">General usage notes:</span></span>  
  
-   <span data-ttu-id="dd86b-2877">Übergeben Sie Methoden nicht an `assemblyResolver` oder `typeResolver` , wenn Sie von unbekannten oder nicht vertrauenswürdigen Aufrufern stammen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2877">Do not pass methods to `assemblyResolver` or `typeResolver` if they come from unknown or untrusted callers.</span></span> <span data-ttu-id="dd86b-2878">Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2878">Use only methods that you provide or that you are familiar with.</span></span>  
  
    > [!CAUTION]
    >  <span data-ttu-id="dd86b-2879">Die Verwendung von Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern kann zu einer Erhöhung von Berechtigungen für bösartigen Code führen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2879">Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.</span></span>  
  
-   <span data-ttu-id="dd86b-2880">Wenn Sie den-Parameter `assemblyResolver` und/oder `typeResolver` den-Parameter weglassen `throwOnError` , wird der Wert des-Parameters an die Methoden übergeben, die die Standardauflösung ausführen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2880">If you omit the `assemblyResolver` and/or `typeResolver` parameters, the value of the `throwOnError` parameter is passed to the methods that perform the default resolution.</span></span>  
  
-   <span data-ttu-id="dd86b-2881">Wenn `throwOnError` ist `typeResolver` `null` `assemblyResolver` <xref:System.IO.FileNotFoundException> , löst diese Methode eine <xref:System.TypeLoadException> aus, `null`wenn zurückgibt, und ein, wenn zurückgibt. `true`</span><span class="sxs-lookup"><span data-stu-id="dd86b-2881">If `throwOnError` is `true`, this method throws a <xref:System.TypeLoadException> when `typeResolver` returns `null`, and a <xref:System.IO.FileNotFoundException> when `assemblyResolver` returns `null`.</span></span>  
  
-   <span data-ttu-id="dd86b-2882">Diese Methode fängt keine von `assemblyResolver` und `typeResolver`ausgelösten Ausnahmen ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2882">This method does not catch exceptions thrown by `assemblyResolver` and `typeResolver`.</span></span> <span data-ttu-id="dd86b-2883">Sie sind verantwortlich für alle Ausnahmen, die von den Konflikt Löser-Methoden ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2883">You are responsible for any exceptions that are thrown by the resolver methods.</span></span>  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a><span data-ttu-id="dd86b-2884">Assemblys auflösen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2884">Resolving Assemblies</span></span>  
 <span data-ttu-id="dd86b-2885">Die `assemblyResolver` -Methode empfängt <xref:System.Reflection.AssemblyName> ein-Objekt, das durch die Verarbeitung des in `typeName`enthaltenen zeichenfolgenassemblynamens erzeugt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2885">The `assemblyResolver` method receives an <xref:System.Reflection.AssemblyName> object, which is produced by parsing the string assembly name that is included in `typeName`.</span></span> <span data-ttu-id="dd86b-2886">Wenn `typeName` keinen Assemblynamen enthält, `assemblyResolver` wird nicht aufgerufen, `null` und wird an `typeResolver`den-Wert übermittelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2886">If `typeName` does not contain an assembly name, `assemblyResolver` is not called and `null` is passed to `typeResolver`.</span></span>  
  
 <span data-ttu-id="dd86b-2887">Wenn `assemblyResolver` nicht angegeben wird, wird die standardassemblyuntersuchung verwendet, um die Assembly zu suchen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2887">If `assemblyResolver` is not supplied, standard assembly probing is used to locate the assembly.</span></span> <span data-ttu-id="dd86b-2888">Wenn `assemblyResolver` angegeben wird, führt <xref:System.Type.GetType%2A> die-Methode keine Standardprüfung durch. in diesem Fall müssen Sie sicherstellen, `assemblyResolver` dass Ihr alle an Sie übergebenen Assemblys verarbeiten kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2888">If `assemblyResolver` is provided, the <xref:System.Type.GetType%2A> method does not do standard probing; in that case you must ensure that your `assemblyResolver` can handle all the assemblies you pass to it.</span></span>  
  
 <span data-ttu-id="dd86b-2889">Die `assemblyResolver` -Methode sollte `null` zurückgeben, wenn die Assembly nicht aufgelöst werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2889">The `assemblyResolver` method should return `null` if the assembly cannot be resolved.</span></span> <span data-ttu-id="dd86b-2890">Wenn `assemblyResolver` zurück `null`gibt `typeResolver` , wird nicht aufgerufen, und es erfolgt keine weitere Verarbeitung. `throwOnError` Wenn `true`ist, <xref:System.IO.FileNotFoundException> wird eine ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2890">If `assemblyResolver` returns `null`, `typeResolver` is not called and no further processing occurs; additionally, if `throwOnError` is `true`, a <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="dd86b-2891">Wenn die <xref:System.Reflection.AssemblyName> , die an `assemblyResolver` weitergegeben wird, ein partieller Name ist, ist mindestens ein `null`Teil davon.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2891">If the <xref:System.Reflection.AssemblyName> that is passed to `assemblyResolver` is a partial name, one or more of its parts are `null`.</span></span> <span data-ttu-id="dd86b-2892">Wenn Sie z. b. keine Version hat, <xref:System.Reflection.AssemblyName.Version%2A> ist `null`die-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2892">For example, if it has no version, the <xref:System.Reflection.AssemblyName.Version%2A> property is `null`.</span></span> <span data-ttu-id="dd86b-2893">Wenn die <xref:System.Reflection.AssemblyName.Version%2A> -Eigenschaft, <xref:System.Reflection.AssemblyName.CultureInfo%2A> die-Eigenschaft und <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> die-Methode `null`alle zurückgeben, wurde nur der einfache Name der Assembly bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2893">If the <xref:System.Reflection.AssemblyName.Version%2A> property, the <xref:System.Reflection.AssemblyName.CultureInfo%2A> property, and the <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method all return `null`, then only the simple name of the assembly was supplied.</span></span> <span data-ttu-id="dd86b-2894">Die `assemblyResolver` -Methode kann alle Teile des Assemblynamens verwenden oder ignorieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2894">The `assemblyResolver` method can use or ignore all parts of the assembly name.</span></span>  
  
 <span data-ttu-id="dd86b-2895">Die Auswirkungen verschiedener Optionen für die Assemblyauflösung werden im Abschnitt [gemischte Namensauflösung](#mixed_name_resolution) als Tabelle für einfache und durch assemblyqualifizierte Typnamen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2895">The effects of different assembly resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a><span data-ttu-id="dd86b-2896">Auflösen von Typen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2896">Resolving Types</span></span>  
 <span data-ttu-id="dd86b-2897">Wenn `typeName` keinen Assemblynamen angibt, `typeResolver` wird immer aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2897">If `typeName` does not specify an assembly name, `typeResolver` is always called.</span></span> <span data-ttu-id="dd86b-2898">Wenn `typeName` einen Assemblynamen `typeResolver` angibt, wird nur aufgerufen, wenn der AssemblyName erfolgreich aufgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2898">If `typeName` specifies an assembly name, `typeResolver` is called only when the assembly name is successfully resolved.</span></span> <span data-ttu-id="dd86b-2899">Wenn `assemblyResolver` oder die standardassemblysuche zurückgibt `null`, `typeResolver` wird nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2899">If `assemblyResolver` or standard assembly probing returns `null`, `typeResolver` is not called.</span></span>  
  
 <span data-ttu-id="dd86b-2900">Die `typeResolver` -Methode empfängt drei Argumente:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2900">The `typeResolver` method receives three arguments:</span></span>  
  
-   <span data-ttu-id="dd86b-2901">Die Assembly, die durch `null` sucht `typeName` werden soll, oder, wenn keinen Assemblynamen enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2901">The assembly to search or `null` if `typeName` does not contain an assembly name.</span></span>  
  
-   <span data-ttu-id="dd86b-2902">Der einfache Name des Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2902">The simple name of the type.</span></span> <span data-ttu-id="dd86b-2903">Bei einem in einem Typ eingefügten Typ ist dies der äußerste enthaltende Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2903">In the case of a nested type, this is the outermost containing type.</span></span> <span data-ttu-id="dd86b-2904">Bei einem generischen Typ ist dies der einfache Name des generischen Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2904">In the case of a generic type, this is the simple name of the generic type.</span></span>  
  
-   <span data-ttu-id="dd86b-2905">Ein boolescher Wert, der `true` ist, wenn die Groß-/Kleinschreibung von Typnamen ignoriert werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2905">A Boolean value that is `true` if the case of type names is to be ignored.</span></span>  
  
 <span data-ttu-id="dd86b-2906">Die-Implementierung bestimmt, wie diese Argumente verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2906">The implementation determines the way these arguments are used.</span></span> <span data-ttu-id="dd86b-2907">Die `typeResolver` Methode sollte zurück `null` geben, wenn der Typ nicht aufgelöst werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2907">The `typeResolver` method should return `null` if it cannot resolve the type.</span></span> <span data-ttu-id="dd86b-2908">Wenn `typeResolver` zurück `null` gibt und `throwOnError` <xref:System.Type.GetType%2A> den Wert <xref:System.TypeLoadException>hat, löst diese Überladung von eine aus. `true`</span><span class="sxs-lookup"><span data-stu-id="dd86b-2908">If `typeResolver` returns `null` and `throwOnError` is `true`, this overload of <xref:System.Type.GetType%2A> throws a <xref:System.TypeLoadException>.</span></span>  
  
 <span data-ttu-id="dd86b-2909">Die Auswirkungen verschiedener Optionen für die Typauflösung werden als Tabelle im Abschnitt [gemischte Namensauflösung](#mixed_name_resolution) für einfache und durch assemblyqualifizierte Typnamen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2909">The effects of different type resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
#### <a name="resolving-nested-types"></a><span data-ttu-id="dd86b-2910">Auflösen von Untertypen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2910">Resolving Nested Types</span></span>  
 <span data-ttu-id="dd86b-2911">Wenn `typeName` ein ein Typ ist, wird nur der Name des äußersten enthaltenden Typs an das- `typeResolver`Ereignis übermittelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2911">If `typeName` is a nested type, only the name of the outermost containing type is passed to `typeResolver`.</span></span> <span data-ttu-id="dd86b-2912">Wenn `typeResolver` diesen Typ zurückgibt, <xref:System.Type.GetNestedType%2A> wird die Methode rekursiv aufgerufen, bis der innerste, nicht aufgelöste Typ aufgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2912">When `typeResolver` returns this type, the <xref:System.Type.GetNestedType%2A> method is called recursively until the innermost nested type has been resolved.</span></span>  
  
#### <a name="resolving-generic-types"></a><span data-ttu-id="dd86b-2913">Auflösen von generischen Typen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2913">Resolving Generic Types</span></span>  
 <span data-ttu-id="dd86b-2914"><xref:System.Type.GetType%2A> Wird rekursiv aufgerufen, um generische Typen aufzulösen: Zuerst können Sie den generischen Typ selbst auflösen und dann seine Typargumente auflösen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2914">The <xref:System.Type.GetType%2A> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.</span></span> <span data-ttu-id="dd86b-2915">Wenn ein Typargument generisch ist, <xref:System.Type.GetType%2A> wird rekursiv aufgerufen, um die Typargumente aufzulösen, usw.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2915">If a type argument is generic, <xref:System.Type.GetType%2A> is called recursively to resolve its type arguments, and so on.</span></span>  
  
 <span data-ttu-id="dd86b-2916">Die Kombination `assemblyResolver` von `typeResolver` und, die Sie bereitstellen, muss in der Lage sein, alle Ebenen dieser Rekursion aufzulösen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2916">The combination of `assemblyResolver` and `typeResolver` that you provide must be capable of resolving all levels of this recursion.</span></span> <span data-ttu-id="dd86b-2917">Nehmen Sie beispielsweise an, Sie `assemblyResolver` stellen ein bereit, das `MyAssembly`das Laden von steuert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2917">For example, suppose you supply an `assemblyResolver` that controls the loading of `MyAssembly`.</span></span> <span data-ttu-id="dd86b-2918">Angenommen, Sie möchten den generischen Typ `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic) auflösen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2918">Suppose you want to resolve the generic type `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic).</span></span> <span data-ttu-id="dd86b-2919">Sie können den folgenden generischen Typnamen übergeben:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2919">You might pass the following generic type name:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="dd86b-2920">Beachten Sie `MyType` , dass das einzige durch die Assembly qualifizierte Typargument ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2920">Notice that `MyType` is the only assembly-qualified type argument.</span></span> <span data-ttu-id="dd86b-2921">Die Namen <xref:System.Collections.Generic.Dictionary%602> der-Klasse <xref:System.String> und der-Klasse sind nicht assemblyqualifiziert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2921">The names of the <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String> classes are not assembly-qualified.</span></span> <span data-ttu-id="dd86b-2922">Ihr `typeResolver` muss in der Lage sein, eine Assembly `null`oder zu verarbeiten, da `null` Sie <xref:System.Collections.Generic.Dictionary%602> für <xref:System.String>und empfängt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2922">Your `typeResolver` must be able handle either an assembly or `null`, because it will receive `null` for <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String>.</span></span> <span data-ttu-id="dd86b-2923">Dieser Fall kann verarbeitet werden, indem eine Überladung der <xref:System.Type.GetType%2A> -Methode aufgerufen wird, die eine Zeichenfolge annimmt, da sich beide nicht qualifizierten Typnamen in "mscorlib. dll" befinden:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2923">It can handle that case by calling an overload of the <xref:System.Type.GetType%2A> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 <span data-ttu-id="dd86b-2924">Die `assemblyResolver` -Methode wird nicht für den Wörter Buchtyp und den Zeichen Folgentyp aufgerufen, da diese Typnamen nicht assemblyqualifiziert sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2924">The `assemblyResolver` method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</span></span>  
  
 <span data-ttu-id="dd86b-2925">Nehmen Sie nun an, `System.String`dass anstelle von der erste generische Argumenttyp ist `YourAssembly` `YourType`, von:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2925">Now suppose that instead of `System.String`, the first generic argument type is `YourType`, from `YourAssembly`:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="dd86b-2926">Da es sich bei dieser Assembly weder um mscorlib. dll noch um die derzeit ausgeführte `YourType` Assembly handelt, kann keine Auflösung ohne einen assemblyqualifizierten Namen ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2926">Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve `YourType` without an assembly-qualified name.</span></span> <span data-ttu-id="dd86b-2927">Da Ihr `assemblyResolve` rekursiv aufgerufen wird, muss es in der Lage sein, diesen Fall zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2927">Because your `assemblyResolve` will be called recursively, it must be able to handle this case.</span></span> <span data-ttu-id="dd86b-2928">Anstatt für andere `null` Assemblys als `MyAssembly`zurückzugeben, führt es nun eine assemblyauslastung mithilfe des bereitgestellten <xref:System.Reflection.AssemblyName> -Objekts aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2928">Instead of returning `null` for assemblies other than `MyAssembly`, it now performs an assembly load using the supplied <xref:System.Reflection.AssemblyName> object.</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 <span data-ttu-id="dd86b-2929">Zurück zu den [Verwendungs hinweisen](#usage_notes).</span><span class="sxs-lookup"><span data-stu-id="dd86b-2929">Back to [Usage Notes](#usage_notes).</span></span>  
  
#### <a name="resolving-type-names-with-special-characters"></a><span data-ttu-id="dd86b-2930">Auflösen von Typnamen mit Sonderzeichen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2930">Resolving Type Names with Special Characters</span></span>  
 <span data-ttu-id="dd86b-2931">Bestimmte Zeichen haben eine besondere Bedeutung in qualifizierten Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2931">Certain characters have special meanings in assembly-qualified names.</span></span> <span data-ttu-id="dd86b-2932">Wenn ein einfacher Typname diese Zeichen enthält, führen die Zeichen zu Analyse Fehlern, wenn der einfache Name Teil eines durch die Assembly qualifizierten Namens ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2932">If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.</span></span> <span data-ttu-id="dd86b-2933">Um die Analyse-Fehler zu vermeiden, müssen Sie die Sonderzeichen mit einem umgekehrten Schrägstrich versehen, bevor Sie den mit der Assembly gekennzeichneten <xref:System.Type.GetType%2A> Namen an die-Methode übergeben können.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2933">To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="dd86b-2934">Wenn ein Typ beispielsweise den Namen `Strange]Type`hat, muss das Escapezeichen vor der eckigen Klammer wie folgt hinzugefügt werden:. `Strange\]Type`</span><span class="sxs-lookup"><span data-stu-id="dd86b-2934">For example, if a type is named `Strange]Type`, the escape character must be added ahead of the square bracket as follows: `Strange\]Type`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-2935">Namen mit solchen Sonderzeichen können nicht in Visual Basic oder C#erstellt werden, Sie können jedoch mithilfe von Microsoft Intermediate Language (MSIL) oder durch das Ausgeben dynamischer Assemblys erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2935">Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.</span></span>  
  
 <span data-ttu-id="dd86b-2936">In der folgenden Tabelle werden die Sonderzeichen für Typnamen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2936">The following table shows the special characters for type names.</span></span>  
  
|<span data-ttu-id="dd86b-2937">Zeichen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2937">Character</span></span>|<span data-ttu-id="dd86b-2938">Bedeutung</span><span class="sxs-lookup"><span data-stu-id="dd86b-2938">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="dd86b-2939">`,`Komma</span><span class="sxs-lookup"><span data-stu-id="dd86b-2939">`,` (comma)</span></span>|<span data-ttu-id="dd86b-2940">Trennzeichen für durch die Assembly qualifizierte Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2940">Delimiter for assembly-qualified names.</span></span>|  
|<span data-ttu-id="dd86b-2941">`[]`(eckige Klammern)</span><span class="sxs-lookup"><span data-stu-id="dd86b-2941">`[]` (square brackets)</span></span>|<span data-ttu-id="dd86b-2942">Als suffixpaar gibt einen Arraytyp an. als Trennzeichen Paar schließt generische Argumentlisten und assemblyqualifizierte Namen ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2942">As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</span></span>|  
|<span data-ttu-id="dd86b-2943">`&`kaufmännisches und</span><span class="sxs-lookup"><span data-stu-id="dd86b-2943">`&` (ampersand)</span></span>|<span data-ttu-id="dd86b-2944">Als Suffix gibt an, dass ein Typ ein Verweistyp ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2944">As a suffix, indicates that a type is a reference type.</span></span>|  
|<span data-ttu-id="dd86b-2945">`*` (Sternchen)</span><span class="sxs-lookup"><span data-stu-id="dd86b-2945">`*` (asterisk)</span></span>|<span data-ttu-id="dd86b-2946">Als Suffix gibt an, dass ein Typ ein Zeigertyp ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2946">As a suffix, indicates that a type is a pointer type.</span></span>|  
|<span data-ttu-id="dd86b-2947">`+`ZZ</span><span class="sxs-lookup"><span data-stu-id="dd86b-2947">`+` (plus)</span></span>|<span data-ttu-id="dd86b-2948">Trennzeichen für geschvelbte Typen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2948">Delimiter for nested types.</span></span>|  
|<span data-ttu-id="dd86b-2949">`\`umgekehrten Schrägstrich</span><span class="sxs-lookup"><span data-stu-id="dd86b-2949">`\` (backslash)</span></span>|<span data-ttu-id="dd86b-2950">Escapezeichen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2950">Escape character.</span></span>|  
  
 <span data-ttu-id="dd86b-2951">Eigenschaften wie <xref:System.Type.AssemblyQualifiedName%2A> geben Zeichen folgen mit Escapezeichen zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2951">Properties such as <xref:System.Type.AssemblyQualifiedName%2A> return correctly escaped strings.</span></span> <span data-ttu-id="dd86b-2952">Sie müssen ordnungsgemäß Escapezeichen folgen <xref:System.Type.GetType%2A> an die-Methode übergeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2952">You must pass correctly escaped strings to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="dd86b-2953">Die <xref:System.Type.GetType%2A> -Methode übergibt wiederum ordnungsgemäß Escapenamen `typeResolver` an und an die Standardmethoden für die Typauflösung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2953">In turn, the <xref:System.Type.GetType%2A> method passes correctly escaped names to `typeResolver` and to the default type resolution methods.</span></span> <span data-ttu-id="dd86b-2954">Wenn Sie in `typeResolver`einen Namen mit einem Namen ohne Escapezeichen vergleichen müssen, müssen Sie die Escapezeichen entfernen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2954">If you need to compare a name to an unescaped name in `typeResolver`, you must remove the escape characters.</span></span>  
  
 <span data-ttu-id="dd86b-2955">Zurück zu den [Verwendungs hinweisen](#usage_notes).</span><span class="sxs-lookup"><span data-stu-id="dd86b-2955">Back to [Usage Notes](#usage_notes).</span></span>  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a><span data-ttu-id="dd86b-2956">Auflösung gemischter Namen</span><span class="sxs-lookup"><span data-stu-id="dd86b-2956">Mixed Name Resolution</span></span>  
 <span data-ttu-id="dd86b-2957">In der folgenden Tabelle werden die Interaktionen `assemblyResolver`zwischen `typeResolver`, und der Standard Namensauflösung für alle Kombinationen aus Typname und Assemblyname in `typeName`zusammengefasst:</span><span class="sxs-lookup"><span data-stu-id="dd86b-2957">The following table summarizes the interactions between `assemblyResolver`, `typeResolver`, and default name resolution, for all combinations of type name and assembly name in `typeName`:</span></span>  
  
|<span data-ttu-id="dd86b-2958">Inhalt des Typnamens</span><span class="sxs-lookup"><span data-stu-id="dd86b-2958">Contents of type name</span></span>|<span data-ttu-id="dd86b-2959">AssemblyResolver-Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-2959">Assembly resolver method</span></span>|<span data-ttu-id="dd86b-2960">Typresolver-Methode</span><span class="sxs-lookup"><span data-stu-id="dd86b-2960">Type resolver method</span></span>|<span data-ttu-id="dd86b-2961">Ergebnis</span><span class="sxs-lookup"><span data-stu-id="dd86b-2961">Result</span></span>|  
|---------------------------|------------------------------|--------------------------|------------|  
|<span data-ttu-id="dd86b-2962">Typ, Assembly</span><span class="sxs-lookup"><span data-stu-id="dd86b-2962">type, assembly</span></span>|<span data-ttu-id="dd86b-2963">NULL</span><span class="sxs-lookup"><span data-stu-id="dd86b-2963">null</span></span>|<span data-ttu-id="dd86b-2964">NULL</span><span class="sxs-lookup"><span data-stu-id="dd86b-2964">null</span></span>|<span data-ttu-id="dd86b-2965">Äquivalent zum Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> -Methoden Überladung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2965">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span>|  
|<span data-ttu-id="dd86b-2966">Typ, Assembly</span><span class="sxs-lookup"><span data-stu-id="dd86b-2966">type, assembly</span></span>|<span data-ttu-id="dd86b-2967">bieten</span><span class="sxs-lookup"><span data-stu-id="dd86b-2967">provided</span></span>|<span data-ttu-id="dd86b-2968">NULL</span><span class="sxs-lookup"><span data-stu-id="dd86b-2968">null</span></span>|<span data-ttu-id="dd86b-2969">`assemblyResolver`Gibt die Assembly zurück oder `null` gibt zurück, wenn die Assembly nicht aufgelöst werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2969">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="dd86b-2970">Wenn die Assembly aufgelöst wird, <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> wird die-Methoden Überladung verwendet, um den Typ aus der Assembly zu laden; andernfalls gibt es keinen Versuch, den Typ aufzulösen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2970">If the assembly is resolved, the <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</span></span>|  
|<span data-ttu-id="dd86b-2971">Typ, Assembly</span><span class="sxs-lookup"><span data-stu-id="dd86b-2971">type, assembly</span></span>|<span data-ttu-id="dd86b-2972">NULL</span><span class="sxs-lookup"><span data-stu-id="dd86b-2972">null</span></span>|<span data-ttu-id="dd86b-2973">bieten</span><span class="sxs-lookup"><span data-stu-id="dd86b-2973">provided</span></span>|<span data-ttu-id="dd86b-2974">Entspricht dem Umbenennen des Assemblynamens in ein <xref:System.Reflection.AssemblyName> Objekt und dem Aufruf der <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> -Methoden Überladung, um die Assembly abzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2974">Equivalent to converting the assembly name to an <xref:System.Reflection.AssemblyName> object and calling the <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> method overload to get the assembly.</span></span> <span data-ttu-id="dd86b-2975">Wenn die Assembly aufgelöst wird, wird Sie an `typeResolver`weitergegeben. andernfalls wird nicht aufgerufen, `typeResolver` und es wird nicht versucht, den Typ aufzulösen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2975">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="dd86b-2976">Typ, Assembly</span><span class="sxs-lookup"><span data-stu-id="dd86b-2976">type, assembly</span></span>|<span data-ttu-id="dd86b-2977">bieten</span><span class="sxs-lookup"><span data-stu-id="dd86b-2977">provided</span></span>|<span data-ttu-id="dd86b-2978">bieten</span><span class="sxs-lookup"><span data-stu-id="dd86b-2978">provided</span></span>|<span data-ttu-id="dd86b-2979">`assemblyResolver`Gibt die Assembly zurück oder `null` gibt zurück, wenn die Assembly nicht aufgelöst werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2979">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="dd86b-2980">Wenn die Assembly aufgelöst wird, wird Sie an `typeResolver`weitergegeben. andernfalls wird nicht aufgerufen, `typeResolver` und es wird nicht versucht, den Typ aufzulösen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2980">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="dd86b-2981">Typ</span><span class="sxs-lookup"><span data-stu-id="dd86b-2981">type</span></span>|<span data-ttu-id="dd86b-2982">NULL, bereitgestellt</span><span class="sxs-lookup"><span data-stu-id="dd86b-2982">null, provided</span></span>|<span data-ttu-id="dd86b-2983">NULL</span><span class="sxs-lookup"><span data-stu-id="dd86b-2983">null</span></span>|<span data-ttu-id="dd86b-2984">Äquivalent zum Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> -Methoden Überladung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2984">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="dd86b-2985">Da der Assemblyname nicht angegeben wird, werden nur die Datei "mscorlib. dll" und die derzeit ausgeführte Assembly durchsucht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2985">Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched.</span></span> <span data-ttu-id="dd86b-2986">Wenn `assemblyResolver` angegeben wird, wird Sie ignoriert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2986">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="dd86b-2987">Typ</span><span class="sxs-lookup"><span data-stu-id="dd86b-2987">type</span></span>|<span data-ttu-id="dd86b-2988">NULL, bereitgestellt</span><span class="sxs-lookup"><span data-stu-id="dd86b-2988">null, provided</span></span>|<span data-ttu-id="dd86b-2989">bieten</span><span class="sxs-lookup"><span data-stu-id="dd86b-2989">provided</span></span>|<span data-ttu-id="dd86b-2990">`typeResolver`wird aufgerufen, und `null` wird für die Assembly übermittelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2990">`typeResolver` is called, and `null` is passed for the assembly.</span></span> <span data-ttu-id="dd86b-2991">`typeResolver`kann einen Typ aus einer beliebigen Assembly bereitstellen, einschließlich Assemblys, die für den Zweck geladen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2991">`typeResolver` can provide a type from any assembly, including assemblies it loads for the purpose.</span></span> <span data-ttu-id="dd86b-2992">Wenn `assemblyResolver` angegeben wird, wird Sie ignoriert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2992">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="dd86b-2993">Assembly</span><span class="sxs-lookup"><span data-stu-id="dd86b-2993">assembly</span></span>|<span data-ttu-id="dd86b-2994">NULL, bereitgestellt</span><span class="sxs-lookup"><span data-stu-id="dd86b-2994">null, provided</span></span>|<span data-ttu-id="dd86b-2995">NULL, bereitgestellt</span><span class="sxs-lookup"><span data-stu-id="dd86b-2995">null, provided</span></span>|<span data-ttu-id="dd86b-2996">Eine <xref:System.IO.FileLoadException> wird ausgelöst, da der AssemblyName so analysiert wird, als wäre er ein durch eine Assembly qualifizierter Typname.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2996">A <xref:System.IO.FileLoadException> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.</span></span> <span data-ttu-id="dd86b-2997">Dies führt zu einem ungültigen Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2997">This results in an invalid assembly name.</span></span>|  
  
 <span data-ttu-id="dd86b-2998">Zurück zu: [Verwendungs Hinweise](#usage_notes), [Auflösen](#resolving_assemblies)von Assemblys, [Auflösen von Typen](#resolving_types).</span><span class="sxs-lookup"><span data-stu-id="dd86b-2998">Back to: [Usage Notes](#usage_notes), [Resolving Assemblies](#resolving_assemblies), [Resolving Types](#resolving_types).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-2999"><paramref name="typeName" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-2999"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="dd86b-3000">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3000">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="dd86b-3001"><paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3001"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="dd86b-3002">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3002">-or-</span></span> 
 <span data-ttu-id="dd86b-3003"><paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3003"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="dd86b-3004">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3004">-or-</span></span> 
 <span data-ttu-id="dd86b-3005"><paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3005"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="dd86b-3006">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3006">-or-</span></span> 
 <span data-ttu-id="dd86b-3007"><paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3007"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="dd86b-3008">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3008">-or-</span></span> 
 <span data-ttu-id="dd86b-3009"><paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3009"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-3010">Ein Fehler tritt auf, wenn <paramref name="typeName" /> in einen Typnamen und einen Assemblynamen zerlegt wird (wenn z. B. der einfache Typname ein Sonderzeichen ohne Escapezeichen enthält).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3010">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="dd86b-3011">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3011">-or-</span></span> 
 <span data-ttu-id="dd86b-3012"><paramref name="throwOnError" /> ist <see langword="true" /> und <paramref name="typeName" /> enthält ungültige Syntax (z. B. „MyType[,\*,]“).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3012"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span></span>  
  
<span data-ttu-id="dd86b-3013">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3013">-or-</span></span> 
 <span data-ttu-id="dd86b-3014"><paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3014"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="dd86b-3015">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3015">-or-</span></span> 
 <span data-ttu-id="dd86b-3016"><paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3016"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="dd86b-3017">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3017">-or-</span></span> 
 <span data-ttu-id="dd86b-3018"><paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3018"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="dd86b-3019"><paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3019"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="dd86b-3020">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, aber konnte nicht geladen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3020">The assembly or one of its dependencies was found, but could not be loaded.</span></span>  
  
<span data-ttu-id="dd86b-3021">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3021">-or-</span></span> 
 <span data-ttu-id="dd86b-3022"><paramref name="typeName" /> enthält einen ungültigen Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3022"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="dd86b-3023">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3023">-or-</span></span> 
 <span data-ttu-id="dd86b-3024"><paramref name="typeName" /> ist ein gültiger Assemblyname ohne Typnamen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3024"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="dd86b-3025">Die Assembly oder eine der zugehörigen Abhängigkeiten ist nicht gültig.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3025">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="dd86b-3026">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3026">-or-</span></span>  
  
 <span data-ttu-id="dd86b-3027">Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3027">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="dd86b-3028">Ein Array von Objekten, deren Typen bestimmt werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3028">An array of objects whose types to determine.</span></span></param>
        <summary><span data-ttu-id="dd86b-3029">Ruft die Typen der Objekte im angegebenen Array ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3029">Gets the types of the objects in the specified array.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3030">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der entsprechenden Elemente in <paramref name="args" /> darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3030">An array of <see cref="T:System.Type" /> objects representing the types of the corresponding elements in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="dd86b-3031">Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Type.GetTypeArray%2A> -Methode verwendet wird, um die Typen der Elemente eines Arrays aufzulisten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3031">The following code example demonstrates how to use the <xref:System.Type.GetTypeArray%2A> method to list the types of the elements of an array.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-3032"><paramref name="args" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3032"><paramref name="args" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-3033">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3033">-or-</span></span> 
<span data-ttu-id="dd86b-3034">Mindestens eines der Elemente in <paramref name="args" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3034">One or more of the elements in <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="dd86b-3035">Die Klasseninitialisierer werden aufgerufen, und mindestens einer löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3035">The class initializers are invoked and at least one throws an exception.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="dd86b-3036">Der Typ, dessen zugrunde liegender Typcode abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3036">The type whose underlying type code to get.</span></span></param>
        <summary><span data-ttu-id="dd86b-3037">Ruft den zugrunde liegenden Typcode des angegebenen <see cref="T:System.Type" /> ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3037">Gets the underlying type code of the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3038">Der Code des zugrunde liegenden Typs oder <see cref="F:System.TypeCode.Empty" />, wenn <paramref name="type" /> <see langword="null" /> ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3038">The code of the underlying type, or <see cref="F:System.TypeCode.Empty" /> if <paramref name="type" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3039">Wenn Sie von <xref:System.Type>erben, können Sie das Verhalten dieser Methode ändern, indem Sie die <xref:System.Type.GetTypeCodeImpl%2A> -Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3039">When you inherit from <xref:System.Type>, you can change the behavior of this method by overriding the <xref:System.Type.GetTypeCodeImpl%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3040">Im folgenden Codebeispiel wird veranschaulicht, <xref:System.TypeCode> wie die-Enumeration verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3040">The following code example demonstrates how the <xref:System.TypeCode> enumeration can be used.</span></span> <span data-ttu-id="dd86b-3041">In einem Entscheidungs Block innerhalb der `WriteObjectInfo` -Methode wird <xref:System.TypeCode> der eines <xref:System.Object> -Parameters untersucht, und es wird eine entsprechende Meldung in die Konsole geschrieben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3041">In a decision block inside the `WriteObjectInfo` method, the <xref:System.TypeCode> of an <xref:System.Object> parameter is examined, and an appropriate message is written to the console.</span></span>  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-3042">Gibt den zugrunde liegenden Typcode dieser <see cref="T:System.Type" />-Instanz zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3042">Returns the underlying type code of this <see cref="T:System.Type" /> instance.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3043">Der Typcode des zugrunde liegenden Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3043">The type code of the underlying type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3044">Diese Methode stellt die-Implementierung für `static` die- C#Methode ( `Shared` in) oder die <xref:System.Type.GetTypeCode%28System.Type%29> -Methode (in Visual Basic) bereit.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3044">This method provides the implementation for the `static` (in C#) or `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> method.</span></span> <span data-ttu-id="dd86b-3045">Wenn Sie von <xref:System.Type>erben, können Sie diese Methode überschreiben, um eine eigene Implementierung <xref:System.Type.GetTypeCode%2A>von bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3045">When you inherit from <xref:System.Type>, you can override this method to provide your own implementation of <xref:System.Type.GetTypeCode%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-3046">Ruft den Typ ab, dem die angegebene Klassen-ID (CLSID) zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3046">Gets the type associated with the specified class identifier (CLSID).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="dd86b-3047">Die CLSID des abzurufenden Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3047">The CLSID of the type to get.</span></span></param>
        <summary><span data-ttu-id="dd86b-3048">Ruft den Typ ab, dem die angegebene Klassen-ID (CLSID) zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3048">Gets the type associated with the specified class identifier (CLSID).</span></span></summary>
        <returns><span data-ttu-id="dd86b-3049"><see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3049"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3050">Die <xref:System.Type.GetTypeFromCLSID%2A> -Methode unterstützt den spät gebundenen Zugriff auf nicht verwaltete COM-Objekte von .NET Framework-apps, wenn Sie den Klassen Bezeichner (CLSID) des COM-Objekts kennen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3050">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="dd86b-3051">Der Klassen Bezeichner für COM-Klassen wird im HKEY_CLASSES_ROOT\CLSID-Schlüssel der Registrierung definiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3051">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="dd86b-3052">Sie können den Wert der <xref:System.Type.IsCOMObject%2A> -Eigenschaft abrufen, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3052">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="dd86b-3053">Sie können die- <xref:System.Type.GetTypeFromProgID%2A> Methode für den spät gebundenen Zugriff auf COM-Objekte aufrufen, deren Programm Bezeichner (ProgID) Sie kennen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3053">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="dd86b-3054">Das Instanziieren eines nicht verwalteten COM-Objekts aus seiner CLSID ist ein zweistufiger Prozess:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3054">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="dd86b-3055">Rufen Sie <xref:System.Type> ein-Objekt ab`__ComObject` , das die darstellt, die der CLSID <xref:System.Type.GetTypeFromCLSID%2A> entspricht, indem Sie die-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3055">Get a <xref:System.Type> object that represents the`__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="dd86b-3056">Ruft die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> -Methode auf, um das COM-Objekt zu instanziieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3056">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="dd86b-3057">Eine Abbildung finden Sie im Beispiel.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3057">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="dd86b-3058">Die <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> -Überladung ignoriert alle Ausnahmen, die beim Instanziieren <xref:System.Type> eines-Objekts auf `clsid` Grundlage des Arguments auftreten können.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3058">The <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> overload ignores any exception that may occur when instantiating a <xref:System.Type> object based on the `clsid` argument.</span></span> <span data-ttu-id="dd86b-3059">Beachten Sie, dass keine Ausnahme ausgelöst `clsid` wird, wenn nicht in der Registrierung gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3059">Note that no exception is thrown if `clsid` is not found in the registry.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3060">Im folgenden Beispiel wird die CLSID des Microsoft Word- [Anwendungs Objekts](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) zum Abrufen eines COM-Typs verwendet, der die Microsoft Word-Anwendung darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3060">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="dd86b-3061">Anschließend wird der Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> -Methode instanziiert und durch Aufrufen der [Application. Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) -Methode geschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3061">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="dd86b-3062">Diese Methode ist für die Verwendung beim Arbeiten mit COM-Objekten gedacht, nicht für .NET Framework-Objekte.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3062">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="dd86b-3063">Alle verwalteten Objekte, einschließlich derjenigen, die für com sichtbar sind (d. h <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> ., <see langword="true" />ihr-Attribut ist), weisen eine GUID <see cref="P:System.Type.GUID" /> auf, die von der-Eigenschaft zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3063">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="dd86b-3064">Obwohl die-Methode ein <see cref="T:System.Type" /> -Objekt zurückgibt, das der GUID für .NET Framework-Objekte entspricht, <see cref="T:System.Type" /> können Sie dieses Objekt nicht verwenden, um eine <see cref="M:System.Activator.CreateInstance(System.Type)" /> Typinstanz zu erstellen, indem Sie die-Methode aufrufen, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3064">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="dd86b-3065">[! Code-csharp[System. Type. gettypeer fromclsid # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! Code-vb[System. Type. gettypinfromclsid # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="dd86b-3065">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="dd86b-3066">Stattdessen sollte nur zum Abrufen der GUID eines nicht verwalteten COM-Objekts verwendet werden, und das resultierende <see cref="T:System.Type" /> -Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" /> -Methode übermittelt wird, muss ein nicht verwaltetes COM-Objekt darstellen. <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /></span><span class="sxs-lookup"><span data-stu-id="dd86b-3066">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="dd86b-3067">Die CLSID des abzurufenden Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3067">The CLSID of the type to get.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="dd86b-3068"><see langword="true" />, um mögliche Ausnahmen auszulösen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3068"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="dd86b-3069">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3069">-or-</span></span> 
 <span data-ttu-id="dd86b-3070"><see langword="false" />, um Ausnahmen zu ignorieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3070"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="dd86b-3071">Ruft den Typ ab, dem die angegebene Klassen-ID (CLSID) zugeordnet ist. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3071">Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3072"><see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3072"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3073">Die <xref:System.Type.GetTypeFromCLSID%2A> -Methode unterstützt den spät gebundenen Zugriff auf nicht verwaltete COM-Objekte von .NET Framework-apps, wenn Sie den Klassen Bezeichner (CLSID) des COM-Objekts kennen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3073">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="dd86b-3074">Der Klassen Bezeichner für COM-Klassen wird im HKEY_CLASSES_ROOT\CLSID-Schlüssel der Registrierung definiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3074">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="dd86b-3075">Sie können den Wert der <xref:System.Type.IsCOMObject%2A> -Eigenschaft abrufen, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3075">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="dd86b-3076">Sie können die- <xref:System.Type.GetTypeFromProgID%2A> Methode für den spät gebundenen Zugriff auf COM-Objekte aufrufen, deren Programm Bezeichner (ProgID) Sie kennen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3076">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="dd86b-3077">Das Instanziieren eines nicht verwalteten COM-Objekts aus seiner CLSID ist ein zweistufiger Prozess:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3077">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="dd86b-3078">Rufen Sie <xref:System.Type> ein-Objekt ab `__ComObject` , das die darstellt, die der CLSID <xref:System.Type.GetTypeFromCLSID%2A> entspricht, indem Sie die-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3078">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="dd86b-3079">Ruft die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> -Methode auf, um das COM-Objekt zu instanziieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3079">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="dd86b-3080">Eine Abbildung finden Sie im Beispiel.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3080">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="dd86b-3081">Ausnahmen wie <xref:System.OutOfMemoryException> werden bei der Angabe `true` von für `throwOnError`ausgelöst, aber nicht für nicht registrierte CLSIDs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3081">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3082">Im folgenden Beispiel wird die CLSID des Microsoft Word- [Anwendungs Objekts](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) zum Abrufen eines COM-Typs verwendet, der die Microsoft Word-Anwendung darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3082">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="dd86b-3083">Anschließend wird der Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> -Methode instanziiert und durch Aufrufen der [Application. Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) -Methode geschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3083">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span> <span data-ttu-id="dd86b-3084">Eine Ausnahme wird ausgelöst, wenn beim Laden des Typs ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3084">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="dd86b-3085">Diese Methode ist für die Verwendung beim Arbeiten mit COM-Objekten gedacht, nicht für .NET Framework-Objekte.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3085">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="dd86b-3086">Alle verwalteten Objekte, einschließlich derjenigen, die für com sichtbar sind (d. h <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> ., <see langword="true" />ihr-Attribut ist), weisen eine GUID <see cref="P:System.Type.GUID" /> auf, die von der-Eigenschaft zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3086">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="dd86b-3087">Obwohl die-Methode ein <see cref="T:System.Type" /> -Objekt zurückgibt, das der GUID für .NET Framework-Objekte entspricht, <see cref="T:System.Type" /> können Sie dieses Objekt nicht verwenden, um eine <see cref="M:System.Activator.CreateInstance(System.Type)" /> Typinstanz zu erstellen, indem Sie die-Methode aufrufen, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3087">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="dd86b-3088">[! Code-csharp[System. Type. gettypeer fromclsid # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! Code-vb[System. Type. gettypinfromclsid # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="dd86b-3088">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="dd86b-3089">Stattdessen sollte nur zum Abrufen der GUID eines nicht verwalteten COM-Objekts verwendet werden, und das resultierende <see cref="T:System.Type" /> -Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" /> -Methode übermittelt wird, muss ein nicht verwaltetes COM-Objekt darstellen. <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /></span><span class="sxs-lookup"><span data-stu-id="dd86b-3089">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="dd86b-3090">Die CLSID des abzurufenden Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3090">The CLSID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="dd86b-3091">Der Server, von dem der Typ geladen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3091">The server from which to load the type.</span></span> <span data-ttu-id="dd86b-3092">Wenn der Servername <see langword="null" /> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3092">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <summary><span data-ttu-id="dd86b-3093">Ruft den Typ, dem die angegebene Klassen-ID (CLSID) zugeordnet ist, vom angegebenen Server ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3093">Gets the type associated with the specified class identifier (CLSID) from the specified server.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3094"><see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3094"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3095">Die <xref:System.Type.GetTypeFromCLSID%2A> -Methode unterstützt den spät gebundenen Zugriff auf nicht verwaltete COM-Objekte von .NET Framework-apps, wenn Sie den Klassen Bezeichner (CLSID) des COM-Objekts kennen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3095">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="dd86b-3096">Der Klassen Bezeichner für COM-Klassen wird im HKEY_CLASSES_ROOT\CLSID-Schlüssel der Registrierung definiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3096">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="dd86b-3097">Sie können den Wert der <xref:System.Type.IsCOMObject%2A> -Eigenschaft abrufen, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3097">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="dd86b-3098">Sie können die- <xref:System.Type.GetTypeFromProgID%2A> Methode für den spät gebundenen Zugriff auf COM-Objekte aufrufen, deren Programm Bezeichner (ProgID) Sie kennen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3098">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="dd86b-3099">Das Instanziieren eines nicht verwalteten COM-Objekts aus seiner CLSID ist ein zweistufiger Prozess:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3099">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="dd86b-3100">Rufen Sie <xref:System.Type> ein-Objekt ab `__ComObject` , das die darstellt, die der CLSID <xref:System.Type.GetTypeFromCLSID%2A> entspricht, indem Sie die-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3100">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="dd86b-3101">Ruft die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> -Methode auf, um das COM-Objekt zu instanziieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3101">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3102">Im folgenden Beispiel wird die CLSID des Microsoft Word- [Anwendungs Objekts](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) zum Abrufen eines COM-Typs verwendet, der die Microsoft Word-Anwendung von einem Server mit dem Namen computer17.Central.contoso.com darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3102">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com.</span></span> <span data-ttu-id="dd86b-3103">Anschließend wird der Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> -Methode instanziiert und durch Aufrufen der [Application. Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) -Methode geschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3103">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="dd86b-3104">Diese Methode ist für die Verwendung beim Arbeiten mit COM-Objekten gedacht, nicht für .NET Framework-Objekte.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3104">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="dd86b-3105">Alle verwalteten Objekte, einschließlich derjenigen, die für com sichtbar sind (d. h <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> ., <see langword="true" />ihr-Attribut ist), weisen eine GUID <see cref="P:System.Type.GUID" /> auf, die von der-Eigenschaft zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3105">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="dd86b-3106">Obwohl die-Methode ein <see cref="T:System.Type" /> -Objekt zurückgibt, das der GUID für .NET Framework-Objekte entspricht, <see cref="T:System.Type" /> können Sie dieses Objekt nicht verwenden, um eine <see cref="M:System.Activator.CreateInstance(System.Type)" /> Typinstanz zu erstellen, indem Sie die-Methode aufrufen, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3106">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="dd86b-3107">[! Code-csharp[System. Type. gettypeer fromclsid # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! Code-vb[System. Type. gettypinfromclsid # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="dd86b-3107">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="dd86b-3108">Stattdessen sollte nur zum Abrufen der GUID eines nicht verwalteten COM-Objekts verwendet werden, und das resultierende <see cref="T:System.Type" /> -Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" /> -Methode übermittelt wird, muss ein nicht verwaltetes COM-Objekt darstellen. <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /></span><span class="sxs-lookup"><span data-stu-id="dd86b-3108">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="dd86b-3109">Die CLSID des abzurufenden Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3109">The CLSID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="dd86b-3110">Der Server, von dem der Typ geladen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3110">The server from which to load the type.</span></span> <span data-ttu-id="dd86b-3111">Wenn der Servername <see langword="null" />ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3111">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="dd86b-3112"><see langword="true" />, um mögliche Ausnahmen auszulösen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3112"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="dd86b-3113">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3113">-or-</span></span> 
 <span data-ttu-id="dd86b-3114"><see langword="false" />, um Ausnahmen zu ignorieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3114"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="dd86b-3115">Ruft den Typ, dem die angegebene Klassen-ID (CLSID) zugeordnet ist, vom angegebenen Server ab. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3115">Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3116"><see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3116"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3117">Die <xref:System.Type.GetTypeFromCLSID%2A> -Methode unterstützt den spät gebundenen Zugriff auf nicht verwaltete COM-Objekte von .NET Framework-apps, wenn Sie den Klassen Bezeichner (CLSID) des COM-Objekts kennen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3117">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="dd86b-3118">Der Klassen Bezeichner für COM-Klassen wird im HKEY_CLASSES_ROOT\CLSID-Schlüssel der Registrierung definiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3118">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="dd86b-3119">Sie können den Wert der <xref:System.Type.IsCOMObject%2A> -Eigenschaft abrufen, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3119">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="dd86b-3120">Sie können die- <xref:System.Type.GetTypeFromProgID%2A> Methode für den spät gebundenen Zugriff auf COM-Objekte aufrufen, deren Programm Bezeichner (ProgID) Sie kennen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3120">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="dd86b-3121">Das Instanziieren eines nicht verwalteten COM-Objekts aus seiner CLSID ist ein zweistufiger Prozess:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3121">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="dd86b-3122">Rufen Sie <xref:System.Type> ein-Objekt ab `__ComObject` , das die darstellt, die der CLSID <xref:System.Type.GetTypeFromCLSID%2A> entspricht, indem Sie die-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3122">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="dd86b-3123">Ruft die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> -Methode auf, um das COM-Objekt zu instanziieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3123">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="dd86b-3124">Ausnahmen wie <xref:System.OutOfMemoryException> werden bei der Angabe `true` von für `throwOnError`ausgelöst, aber nicht für nicht registrierte CLSIDs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3124">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3125">Im folgenden Beispiel wird die CLSID des Microsoft Word- [Anwendungs Objekts](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) zum Abrufen eines COM-Typs verwendet, der die Microsoft Word-Anwendung von einem Server mit dem Namen computer17.Central.contoso.com darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3125">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com.</span></span> <span data-ttu-id="dd86b-3126">Anschließend wird der Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> -Methode instanziiert und durch Aufrufen der [Application. Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) -Methode geschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3126">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span> <span data-ttu-id="dd86b-3127">Eine Ausnahme wird ausgelöst, wenn beim Laden des Typs ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3127">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="dd86b-3128">Diese Methode ist für die Verwendung beim Arbeiten mit COM-Objekten gedacht, nicht für .NET Framework-Objekte.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3128">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="dd86b-3129">Alle verwalteten Objekte, einschließlich derjenigen, die für com sichtbar sind (d. h <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> ., <see langword="true" />ihr-Attribut ist), weisen eine GUID <see cref="P:System.Type.GUID" /> auf, die von der-Eigenschaft zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3129">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="dd86b-3130">Obwohl die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> -Methode ein <see cref="T:System.Type" /> -Objekt zurückgibt, das der GUID für ein bestimmtes verwaltetes Objekt entspricht, <see cref="T:System.Type" /> können Sie dieses Objekt nicht verwenden, um eine <see cref="M:System.Activator.CreateInstance(System.Type)" /> Typinstanz zu erstellen, indem Sie die-Methode aufrufen, wie im folgenden Beispiel gezeigt. Tanz.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3130">Although the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for a particular managed object, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="dd86b-3131">[! Code-csharp[System. Type. gettypeer fromclsid # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! Code-vb[System. Type. gettypinfromclsid # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="dd86b-3131">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="dd86b-3132">Stattdessen sollte nur zum Abrufen der GUID eines nicht verwalteten COM-Objekts verwendet werden, und das resultierende <see cref="T:System.Type" /> -Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" /> -Methode übermittelt wird, muss ein nicht verwaltetes COM-Objekt darstellen. <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /></span><span class="sxs-lookup"><span data-stu-id="dd86b-3132">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="dd86b-3133">Das Objekt, das auf den Typ verweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3133">The object that refers to the type.</span></span></param>
        <summary><span data-ttu-id="dd86b-3134">Ruft den Typ ab, auf den das angegebene Typhandle verweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3134">Gets the type referenced by the specified type handle.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3135">Der Typ, auf den das angegebene <see cref="T:System.RuntimeTypeHandle" /> verweist, oder <see langword="null" />, wenn die <see cref="P:System.RuntimeTypeHandle.Value" />-Eigenschaft von <paramref name="handle" /> den Wert <see langword="null" /> hat.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3135">The type referenced by the specified <see cref="T:System.RuntimeTypeHandle" />, or <see langword="null" /> if the <see cref="P:System.RuntimeTypeHandle.Value" /> property of <paramref name="handle" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3136">Die Handles sind nur in der Anwendungsdomäne gültig, in der Sie abgerufen wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3136">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3137">Im folgenden Beispiel wird die <xref:System.Type.GetTypeFromHandle%2A> -Methode verwendet, <xref:System.Type> um ein- <xref:System.RuntimeTypeHandle> Objekt aus einem <xref:System.Type.GetTypeHandle%2A> von der-Methode bereitgestellten zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3137">The following example uses the <xref:System.Type.GetTypeFromHandle%2A> method to get a <xref:System.Type> object from a <xref:System.RuntimeTypeHandle> provided by the <xref:System.Type.GetTypeHandle%2A> method.</span></span>  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="dd86b-3138">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3138">A class initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-3139">Ruft den Typ ab, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3139">Gets the type associated with the specified program identifier (ProgID).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="dd86b-3140">Die ProgID des abzurufenden Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3140">The ProgID of the type to get.</span></span></param>
        <summary><span data-ttu-id="dd86b-3141">Ruft den Typ ab, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist. Wenn beim Laden des <see cref="T:System.Type" /> ein Fehler auftritt, wird NULL zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3141">Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3142">Der Typ, dem die angegebene ProgID zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3142">The type associated with the specified ProgID, if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3143">Diese Methode wird für COM-Unterstützung bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3143">This method is provided for COM support.</span></span> <span data-ttu-id="dd86b-3144">ProgIDs werden im Microsoft .NET Framework nicht verwendet, da Sie durch das Konzept von Namespace abgelöst wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3144">ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-3145"><paramref name="progID" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3145"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="dd86b-3146">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3146">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="dd86b-3147">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3147">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="dd86b-3148">Die ProgID des abzurufenden Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3148">The ProgID of the type to get.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="dd86b-3149"><see langword="true" /> , um mögliche Ausnahmen auszulösen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3149"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="dd86b-3150">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3150">-or-</span></span> 
 <span data-ttu-id="dd86b-3151"><see langword="false" />, um Ausnahmen zu ignorieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3151"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="dd86b-3152">Ruft den Typ ab, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3152">Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3153">Der Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3153">The type associated with the specified program identifier (ProgID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3154">Diese Methode wird für COM-Unterstützung bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3154">This method is provided for COM support.</span></span> <span data-ttu-id="dd86b-3155">Programm-IDs werden in Microsoft .NET Framework nicht verwendet, da Sie durch das Konzept von Namespace abgelöst wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3155">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3156">Im folgenden Beispiel wird ein-Typ durch Übergeben einer ProgID abgerufen. dabei wird angegeben, ob eine Ausnahme ausgelöst werden soll, wenn die ProgID ungültig ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3156">The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid.</span></span> <span data-ttu-id="dd86b-3157">Im Beispiel wird dann die mit der ProgID verknüpfte ClassID zusammen mit jeder anwendbaren Ausnahme Meldung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3157">The example then displays the ClassID related to the ProgID, along with any applicable exception message.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-3158"><paramref name="progID" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3158"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="dd86b-3159">Die angegebene ProgID ist nicht registriert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3159">The specified ProgID is not registered.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="dd86b-3160">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3160">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="dd86b-3161">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3161">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="dd86b-3162">Die ProgID des abzurufenden Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3162">The progID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="dd86b-3163">Der Server, von dem der Typ geladen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3163">The server from which to load the type.</span></span> <span data-ttu-id="dd86b-3164">Wenn der Servername <see langword="null" /> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3164">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <summary><span data-ttu-id="dd86b-3165">Ruft den Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, vom angegebenen Server ab. Wenn bei Laden des Typs ein Fehler auftritt, wird NULL zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3165">Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3166">Der Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3166">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3167">Diese Methode wird für COM-Unterstützung bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3167">This method is provided for COM support.</span></span> <span data-ttu-id="dd86b-3168">Programm-IDs werden in Microsoft .NET Framework nicht verwendet, da Sie durch das Konzept von Namespace abgelöst wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3168">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3169">Im folgenden Beispiel wird ein-Typ abgerufen, indem eine ProgID und ein Servername übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3169">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="dd86b-3170">Im Beispiel wird dann die ClassID angezeigt, die mit der ProgID verknüpft ist, oder es wird eine Ausnahme ausgelöst, wenn die ProgID oder der Servername ungültig ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3170">The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-3171"><paramref name="prodID" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3171"><paramref name="prodID" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="dd86b-3172">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3172">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="dd86b-3173">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3173">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="dd86b-3174">Die ProgID des abzurufenden <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3174">The progID of the <see cref="T:System.Type" /> to get.</span></span></param>
        <param name="server"><span data-ttu-id="dd86b-3175">Der Server, von dem der Typ geladen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3175">The server from which to load the type.</span></span> <span data-ttu-id="dd86b-3176">Wenn der Servername <see langword="null" />ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3176">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="dd86b-3177"><see langword="true" />, um mögliche Ausnahmen auszulösen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3177"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="dd86b-3178">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3178">-or-</span></span> 
 <span data-ttu-id="dd86b-3179"><see langword="false" />, um Ausnahmen zu ignorieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3179"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="dd86b-3180">Ruft den Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, vom angegebenen Server ab. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3180">Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3181">Der Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3181">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3182">Diese Methode wird für COM-Unterstützung bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3182">This method is provided for COM support.</span></span> <span data-ttu-id="dd86b-3183">Programm-IDs werden in Microsoft .NET Framework nicht verwendet, da Sie durch das Konzept von Namespace abgelöst wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3183">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3184">Im folgenden Beispiel wird ein-Typ abgerufen, indem eine ProgID und ein Servername übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3184">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="dd86b-3185">Im Beispiel wird dann die ClassID angezeigt, die mit der ProgID verknüpft ist. dabei wird angegeben, ob eine Ausnahme ausgelöst werden soll, wenn die ProgID oder der Servername ungültig ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3185">The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-3186"><paramref name="progID" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3186"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="dd86b-3187">Die angegebene progID ist nicht registriert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3187">The specified progID is not registered.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="dd86b-3188">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3188">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="dd86b-3189">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3189">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="dd86b-3190">Das Objekt, für das das Typhandle abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3190">The object for which to get the type handle.</span></span></param>
        <summary><span data-ttu-id="dd86b-3191">Ruft das Handle für den <see cref="T:System.Type" />-Wert eines angegebenen Objekts ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3191">Gets the handle for the <see cref="T:System.Type" /> of a specified object.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3192">Das Handle für den <see cref="T:System.Type" /> des angegebenen <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3192">The handle for the <see cref="T:System.Type" /> of the specified <see cref="T:System.Object" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3193">Die Handles sind nur in der Anwendungsdomäne gültig, in der Sie abgerufen wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3193">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3194">Im folgenden Beispiel wird die- `MyClass1`Klasse definiert, eine Instanz davon abgerufen und das Lauf Zeit Handle des-Objekts abgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3194">The following example defines the class `MyClass1`, gets an instance of it, and retrieves the runtime handle of the object.</span></span>  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-3195"><paramref name="o" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3195"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3196">Ruft die dem <see cref="T:System.Type" />zugeordnete GUID ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3196">Gets the GUID associated with the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="dd86b-3197">Die dem <see cref="T:System.Type" /> zugeordnete GUID.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3197">The GUID associated with the <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3198">Eine GUID ist einem Typ zugeordnet, der das <xref:System.Runtime.InteropServices.GuidAttribute> -Attribut verwendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3198">A GUID is associated with a type using the <xref:System.Runtime.InteropServices.GuidAttribute> attribute.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3199">Im folgenden Beispiel wird die- `MyClass1` Klasse mit einer öffentlichen-Methode erstellt `Type` , ein- `MyClass1`Objekt erstellt, das <xref:System.Guid> entspricht, und `GUID` die-Struktur `Type` wird mithilfe der-Eigenschaft der-Klasse abgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3199">The following example creates the class `MyClass1` with a public method, creates a `Type` object corresponding to `MyClass1`, and gets the <xref:System.Guid> structure using the `GUID` property of the `Type` class.</span></span>  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3200">Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> einen anderen Typ umfasst oder auf einen anderen Typ verweist, d. h. ob der aktuelle <see cref="T:System.Type" /> ein Array oder ein Zeiger ist oder als Verweis übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3200">Gets a value indicating whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span></span></summary>
        <value><span data-ttu-id="dd86b-3201"><see langword="true" />, wenn <see cref="T:System.Type" /> ein Array oder ein Zeiger ist oder als Verweis übergeben wird, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3201"><see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3202">Beispielsweise Type.GetType("Int32[]"). HasElementType gibt `true`, wohingegen Type.GetType("Int32"). HasElementType gibt `false`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3202">For example, Type.GetType("Int32[]").HasElementType returns `true`, but Type.GetType("Int32").HasElementType returns `false`.</span></span> <span data-ttu-id="dd86b-3203">HasElementType gibt auch `true` für "Int32 \*" und "Int32 &" zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3203">HasElementType also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
 <span data-ttu-id="dd86b-3204">Wenn der aktuelle <xref:System.Type> einen generischen Typ oder einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `false`Eigenschaft immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3204">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3205">Das folgende Beispiel gibt `true` oder `false` zurück, je nachdem, ob es sich bei dem Objekt um ein Array, einen Verweistyp oder einen Zeiger handelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3205">The following example returns `true` or `false` depending on whether or not the object is an array, a reference type, or a pointer.</span></span>  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-3206">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.HasElementType" />-Eigenschaft und bestimmt, ob der aktuelle <see cref="T:System.Type" /> einen anderen Typ umfasst oder auf einen solchen verweist, d. h. ob der aktuelle <see cref="T:System.Type" /> ein Array oder Zeiger ist oder als Verweis übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3206">When overridden in a derived class, implements the <see cref="P:System.Type.HasElementType" /> property and determines whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3207"><see langword="true" />, wenn <see cref="T:System.Type" /> ein Array oder ein Zeiger ist oder als Verweis übergeben wird, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3207"><see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3208">Beispielsweise Type.GetType("Int32[]"). HasElementTypeImpl gibt `true`, wohingegen Type.GetType("Int32"). HasElementTypeImpl gibt `false`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3208">For example, Type.GetType("Int32[]").HasElementTypeImpl returns `true`, but Type.GetType("Int32").HasElementTypeImpl returns `false`.</span></span> <span data-ttu-id="dd86b-3209">HasElementTypeImpl gibt auch `true` für "Int32 \*" und "Int32 &" zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3209">HasElementTypeImpl also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3210">Im folgenden Beispiel wird die- `MyTypeDelegator`Klasse definiert, die die `HasElementTypeImpl` -Methode überschreibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3210">The following example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="dd86b-3211">Die Hauptklasse überprüft die- `HasElementType` Eigenschaft und zeigt den Elementtyp an.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3211">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-3212">Ruft einen bestimmten Member vom aktuellen <see cref="T:System.Type" /> auf.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3212">Invokes a specific member of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-3213">Die Zeichenfolge, die den Namen des Konstruktors, der Methode, der Eigenschaft oder des Feldmembers enthält, der bzw. die aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3213">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="dd86b-3214">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3214">-or-</span></span> 
<span data-ttu-id="dd86b-3215">Eine leere Zeichenfolge ("") zum Aufrufen des Standardmembers.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3215">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="dd86b-3216">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3216">-or-</span></span> 
<span data-ttu-id="dd86b-3217">Für <see langword="IDispatch" />-Member eine Zeichenfolge, die die DispID darstellt, z. B. "[DispID=3]".</span><span class="sxs-lookup"><span data-stu-id="dd86b-3217">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="dd86b-3218">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3218">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span> <span data-ttu-id="dd86b-3219">Der Zugriff kann aus einem der <see langword="BindingFlags" /> wie <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> usw. bestehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3219">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="dd86b-3220">Die Art der Suche muss nicht angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3220">The type of lookup need not be specified.</span></span> <span data-ttu-id="dd86b-3221">Wenn die Art der Suche nicht angegeben ist, werden <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> verwendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3221">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="dd86b-3222">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3222">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="dd86b-3223">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3223">-or-</span></span> 
<span data-ttu-id="dd86b-3224">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3224">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="dd86b-3225">Beachten Sie, dass möglicherweise ein <see cref="T:System.Reflection.Binder" />-Objekt explizit definiert werden muss, um erfolgreich Methodenüberladungen mit Variablenargumenten aufrufen zu können.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3225">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="dd86b-3226">Das Objekt, für das der angegebene Member aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3226">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="dd86b-3227">Ein Array mit den Argumenten, die dem aufzurufenden Member übergeben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3227">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <summary><span data-ttu-id="dd86b-3228">Ruft den angegebenen Member auf, der den angegebenen Bindungseinschränkungen und der angegebenen Argumentliste entspricht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3228">Invokes the specified member, using the specified binding constraints and matching the specified argument list.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3229">Ein Objekt, das den Rückgabewert des aufgerufenen Members darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3229">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-3230">Sie können nicht <xref:System.Type.InvokeMember%2A> verwenden, um eine generische Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3230">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="dd86b-3231">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Elemente in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3231">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-3232">Geben `BindingFlags.Public` Sie an, dass öffentliche Member in die Suche einbezogen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3232">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-3233">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Member in die Suche eingeschlossen werden sollen (d. h. private und geschützte Member).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3233">Specify `BindingFlags.NonPublic` to include non-public members (that is, private and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-3234">Gibt `BindingFlags.FlattenHierarchy` an, dass statische Elemente in der Hierarchie nach oben eingeschlossen werden</span><span class="sxs-lookup"><span data-stu-id="dd86b-3234">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="dd86b-3235">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3235">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="dd86b-3236">`BindingFlags.IgnoreCase`, wenn der Fall von `name`ignoriert werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3236">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="dd86b-3237">`BindingFlags.DeclaredOnly`, um nur die Member zu durchsuchen <xref:System.Type>, die auf dem deklariert sind, nicht Elemente, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3237">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="dd86b-3238">Die folgenden <xref:System.Reflection.BindingFlags> Aufruf-Flags können verwendet werden, um anzugeben, welche Aktion mit dem Element ausgeführt werden soll:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3238">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="dd86b-3239">`CreateInstance`, um einen Konstruktor aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3239">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="dd86b-3240">`name`wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3240">`name` is ignored.</span></span> <span data-ttu-id="dd86b-3241">Ungültig mit anderen Aufruf-Flags.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3241">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="dd86b-3242">`InvokeMethod`, um eine Methode aufzurufen, aber keinen Konstruktor oder Typinitialisierer.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3242">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="dd86b-3243">Ungültig mit `SetField` oder `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3243">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="dd86b-3244">Wenn `InvokeMethod` eigenständig angegeben wird `BindingFlags.Instance`, `BindingFlags.Public`werden, und `BindingFlags.Static` automatisch eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3244">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="dd86b-3245">`GetField`, wenn der Wert eines Felds angezeigt werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3245">`GetField` to get the value of a field.</span></span> <span data-ttu-id="dd86b-3246">Ungültig mit `SetField`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3246">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="dd86b-3247">`SetField`, um den Wert eines Felds festzulegen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3247">`SetField` to set the value of a field.</span></span> <span data-ttu-id="dd86b-3248">Ungültig mit `GetField`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3248">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="dd86b-3249">`GetProperty`, um eine Eigenschaft zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3249">`GetProperty` to get a property.</span></span> <span data-ttu-id="dd86b-3250">Ungültig mit `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3250">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="dd86b-3251">`SetProperty`, um eine Eigenschaft festzulegen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3251">`SetProperty` to set a property.</span></span> <span data-ttu-id="dd86b-3252">Ungültig mit `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3252">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="dd86b-3253">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3253">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="dd86b-3254">Eine Methode wird aufgerufen, wenn beide der folgenden Bedingungen zutreffen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3254">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="dd86b-3255">Die Anzahl der Parameter in der Methoden Deklaration entspricht der Anzahl der Argumente im `args` Array (es sei denn, es sind Standardargumente für `BindingFlags.OptionalParamBinding` den Member definiert und werden angegeben).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3255">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="dd86b-3256">Der Typ jedes Arguments kann vom Binder in den Typ des Parameters konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3256">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="dd86b-3257">Der Binder findet alle übereinstimmenden Methoden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3257">The binder will find all of the matching methods.</span></span> <span data-ttu-id="dd86b-3258">Diese Methoden werden basierend auf dem Typ der angeforderten Bindung gefunden (<xref:System.Reflection.BindingFlags> Werte `InvokeMethod`, `GetProperty`usw.).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3258">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="dd86b-3259">Der Satz von Methoden wird anhand des Namens, der Anzahl von Argumenten und einer Reihe von suchmodifizierermembern gefiltert, die im Binder definiert sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3259">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="dd86b-3260">Nachdem die Methode ausgewählt wurde, wird Sie aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3260">After the method is selected, it is invoked.</span></span> <span data-ttu-id="dd86b-3261">An diesem Punkt wird Barrierefreiheit geprüft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3261">Accessibility is checked at that point.</span></span> <span data-ttu-id="dd86b-3262">Die Suche kann steuern, welcher Satz von Methoden basierend auf dem Barrierefreiheits Attribut, das der Methode zugeordnet ist, durchsucht wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3262">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="dd86b-3263">Die <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> -Methode <xref:System.Reflection.Binder> der-Klasse ist verantwortlich für die Auswahl der aufzurufenden Methode.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3263">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="dd86b-3264">Der Standard Binder wählt die spezifischsten Übereinstimmung aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3264">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="dd86b-3265">Zugriffs Einschränkungen werden bei voll vertrauenswürdigem Code ignoriert. Das heißt, Private Konstruktoren, Methoden, Felder und Eigenschaften können aufgerufen und aufgerufen <xref:System.Reflection> werden, wenn der Code vollständig vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3265">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="dd86b-3266">Sie können verwenden `Type.InvokeMember` , um ein Feld auf einen bestimmten Wert festzulegen <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>, indem Sie angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3266">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="dd86b-3267">Wenn Sie z. b. ein öffentliches Instanzfeld mit dem Namen f für die Klasse C und f als `String`festlegen möchten, können Sie Code wie den folgenden verwenden:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3267">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 <span data-ttu-id="dd86b-3268">Wenn F ein `String[]`ist, können Sie Code wie den folgenden verwenden:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3268">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 <span data-ttu-id="dd86b-3269">Dadurch wird das Feld F mit diesem neuen Array initialisiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3269">which will initialize the field F to this new array.</span></span> <span data-ttu-id="dd86b-3270">Sie können auch verwenden `Type.InvokeMember` , um eine Position in einem Array festzulegen, indem Sie den Index des Werts und dann den nächsten Wert mithilfe von Code wie dem folgenden angeben:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3270">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 <span data-ttu-id="dd86b-3271">Dadurch wird die Zeichenfolge "z" in dem Array geändert, das F in die Zeichenfolge "b" enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3271">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="dd86b-3272">Wenn Sie einen `IDispatch` Member aufrufen, können Sie die DISPID anstelle des Element namens angeben, indem Sie das Zeichen folgen Format "[DispID = # #]" verwenden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3272">When you invoke an `IDispatch` member, you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="dd86b-3273">Wenn z. b. die DispID von MyComMethod den Wert 3 hat, können Sie die Zeichenfolge "[DispID = 3]" anstelle von "MyComMethod" angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3273">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="dd86b-3274">Das Aufrufen eines Members durch DISPID ist schneller, als das Element nach dem Namen zu suchen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3274">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="dd86b-3275">In komplexen Aggregations Szenarios ist die DISPID manchmal die einzige Möglichkeit, den gewünschten Member aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3275">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-3276">Ab kann diese Methode verwendet werden, um auf nicht öffentliche Member zuzugreifen, wenn der Aufrufer mit dem <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> -Flag erteilt wurde, und wenn der Berechtigungs Satz der nicht öffentlichen Member auf den Berechtigungs Satz des Aufrufers oder eine Teilmenge beschränkt ist. [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Auslegung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3276">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="dd86b-3277">(Siehe [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="dd86b-3277">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="dd86b-3278">Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3278">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3279">Im folgenden Beispiel wird `InvokeMember` verwendet, um auf Member eines Typs zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3279">The following example uses `InvokeMember` to access members of a type.</span></span>  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-3280"><paramref name="invokeAttr" /> enthält keine <see langword="CreateInstance" />, und <paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3280"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-3281"><paramref name="invokeAttr" /> ist kein gültiges <see cref="T:System.Reflection.BindingFlags" />-Attribut.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3281"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="dd86b-3282">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3282">-or-</span></span> 
 <span data-ttu-id="dd86b-3283"><paramref name="invokeAttr" /> enthält keines der folgenden Bindungsflags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3283"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="dd86b-3284">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3284">-or-</span></span> 
 <span data-ttu-id="dd86b-3285"><paramref name="invokeAttr" /> enthält <see langword="CreateInstance" /> in Kombination mit <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3285"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="dd86b-3286">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3286">-or-</span></span> 
 <span data-ttu-id="dd86b-3287"><paramref name="invokeAttr" /> enthält sowohl <see langword="GetField" /> als auch <see langword="SetField" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3287"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="dd86b-3288">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3288">-or-</span></span> 
 <span data-ttu-id="dd86b-3289"><paramref name="invokeAttr" /> enthält sowohl <see langword="GetProperty" /> als auch <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3289"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="dd86b-3290">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3290">-or-</span></span> 
 <span data-ttu-id="dd86b-3291"><paramref name="invokeAttr" /> enthält <see langword="InvokeMethod" /> in Kombination mit <see langword="SetField" /> oder <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3291"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="dd86b-3292">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3292">-or-</span></span> 
 <span data-ttu-id="dd86b-3293"><paramref name="invokeAttr" /> enthält <see langword="SetField" />, und <paramref name="args" /> enthält mehr als ein Element.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3293"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="dd86b-3294">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3294">-or-</span></span> 
<span data-ttu-id="dd86b-3295">Diese Methode wird für ein COM-Objekt aufgerufen, und eines der folgenden Bindungsflags wurde nicht übergeben: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> oder <see langword="BindingFlags.PutRefDispProperty" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3295">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="dd86b-3296">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3296">-or-</span></span> 
<span data-ttu-id="dd86b-3297">Eines der benannten Parameterarrays enthält eine Zeichenfolge, die <see langword="null" /> ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3297">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="dd86b-3298">Der angegebene Member ist ein Klasseninitialisierer.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3298">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="dd86b-3299">Das Feld oder die Eigenschaft wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3299">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="dd86b-3300">Es wurde keine Methode gefunden, die den Argumenten in <paramref name="args" /> entspricht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3300">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="dd86b-3301">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3301">-or-</span></span> 
<span data-ttu-id="dd86b-3302">Das aktuelle <see cref="T:System.Type" />-Objekt stellt einen Typ dar, der offene Typparameter enthält. Das bedeutet, dass <see cref="P:System.Type.ContainsGenericParameters" /> den Wert <see langword="true" /> zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3302">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="dd86b-3303">Der angegebene Member kann nicht für <paramref name="target" /> aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3303">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-3304">Mehrere Methoden entsprechen den Bindungskriterien.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3304">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd86b-3305">Diese Methode wird von .NET Compact Framework derzeit nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3305">The .NET Compact Framework does not currently support this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd86b-3306">Die durch <paramref name="name" /> dargestellte Methode enthält mindestens einen nicht angegebenen generischen Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3306">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="dd86b-3307">Das bedeutet, dass die <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />-Eigenschaft der Methode <see langword="true" /> zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3307">That is, the method's <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="dd86b-3308">für den Zugriff auf nicht öffentliche Member, unabhängig von deren Berechtigungs Satz.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3308">for accessing non-public members regardless of their grant set.</span></span> <span data-ttu-id="dd86b-3309">Zugehörige Enumeration:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="dd86b-3309">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="dd86b-3310">, wenn nicht verwalteter Code aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3310">to call unmanaged code.</span></span> <span data-ttu-id="dd86b-3311">Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="dd86b-3311">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-3312">Die Zeichenfolge, die den Namen des Konstruktors, der Methode, der Eigenschaft oder des Feldmembers enthält, der bzw. die aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3312">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="dd86b-3313">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3313">-or-</span></span> 
<span data-ttu-id="dd86b-3314">Eine leere Zeichenfolge ("") zum Aufrufen des Standardmembers.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3314">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="dd86b-3315">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3315">-or-</span></span> 
<span data-ttu-id="dd86b-3316">Für <see langword="IDispatch" />-Member eine Zeichenfolge, die die DispID darstellt, z. B. "[DispID=3]".</span><span class="sxs-lookup"><span data-stu-id="dd86b-3316">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="dd86b-3317">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3317">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span> <span data-ttu-id="dd86b-3318">Der Zugriff kann aus einem der <see langword="BindingFlags" /> wie <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> usw. bestehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3318">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="dd86b-3319">Die Art der Suche muss nicht angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3319">The type of lookup need not be specified.</span></span> <span data-ttu-id="dd86b-3320">Wenn die Art der Suche nicht angegeben ist, werden <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> verwendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3320">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="dd86b-3321">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3321">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="dd86b-3322">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3322">-or-</span></span> 
<span data-ttu-id="dd86b-3323">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3323">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="dd86b-3324">Beachten Sie, dass möglicherweise ein <see cref="T:System.Reflection.Binder" />-Objekt explizit definiert werden muss, um erfolgreich Methodenüberladungen mit Variablenargumenten aufrufen zu können.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3324">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="dd86b-3325">Das Objekt, für das der angegebene Member aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3325">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="dd86b-3326">Ein Array mit den Argumenten, die dem aufzurufenden Member übergeben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3326">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <param name="culture"><span data-ttu-id="dd86b-3327">Das Objekt, das das zu verwendende Globalisierungsgebietsschema darstellt, das für gebietsspezifische Konvertierungen wie die Konvertierung einer numerischen <see cref="T:System.String" /> in einen <see cref="T:System.Double" /> erforderlich sein kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3327">The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <see cref="T:System.String" /> to a <see cref="T:System.Double" />.</span></span>  
  
<span data-ttu-id="dd86b-3328">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3328">-or-</span></span> 
<span data-ttu-id="dd86b-3329">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3329">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span></span></param>
        <summary><span data-ttu-id="dd86b-3330">Ruft den angegebenen Member auf, der den angegebenen Bindungseinschränkungen sowie der angegebenen Argumentliste und Kultur entspricht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3330">Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3331">Ein Objekt, das den Rückgabewert des aufgerufenen Members darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3331">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3332">Obwohl der Standard <xref:System.Globalization.CultureInfo> Binder nicht verarbeitet (der `culture` -Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> -Klasse verwenden, um einen benutzerdefinierten Binder zu `culture`schreiben, der verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3332">Although the default binder does not process <xref:System.Globalization.CultureInfo> (the `culture` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `culture`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-3333">Sie können nicht <xref:System.Type.InvokeMember%2A> verwenden, um eine generische Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3333">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="dd86b-3334">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Elemente in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3334">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-3335">Geben `BindingFlags.Public` Sie an, dass öffentliche Member in die Suche einbezogen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3335">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-3336">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Member in die Suche eingeschlossen werden sollen (d. h. private, interne und geschützte Member).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3336">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-3337">Gibt `BindingFlags.FlattenHierarchy` an, dass statische Elemente in der Hierarchie nach oben eingeschlossen werden</span><span class="sxs-lookup"><span data-stu-id="dd86b-3337">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="dd86b-3338">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3338">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="dd86b-3339">`BindingFlags.IgnoreCase`, wenn der Fall von `name`ignoriert werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3339">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="dd86b-3340">`BindingFlags.DeclaredOnly`, um nur die Member zu durchsuchen <xref:System.Type>, die auf dem deklariert sind, nicht Elemente, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3340">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="dd86b-3341">Die folgenden <xref:System.Reflection.BindingFlags> Aufruf-Flags können verwendet werden, um anzugeben, welche Aktion mit dem Element ausgeführt werden soll:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3341">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="dd86b-3342">`CreateInstance`, um einen Konstruktor aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3342">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="dd86b-3343">`name`wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3343">`name` is ignored.</span></span> <span data-ttu-id="dd86b-3344">Ungültig mit anderen Aufruf-Flags.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3344">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="dd86b-3345">`InvokeMethod`, um eine Methode aufzurufen, aber keinen Konstruktor oder Typinitialisierer.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3345">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="dd86b-3346">Ungültig mit `SetField` oder `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3346">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="dd86b-3347">Wenn `InvokeMethod` eigenständig angegeben wird `BindingFlags.Instance`, `BindingFlags.Public`werden, und `BindingFlags.Static` automatisch eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3347">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="dd86b-3348">`GetField`, wenn der Wert eines Felds angezeigt werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3348">`GetField` to get the value of a field.</span></span> <span data-ttu-id="dd86b-3349">Ungültig mit `SetField`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3349">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="dd86b-3350">`SetField`, um den Wert eines Felds festzulegen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3350">`SetField` to set the value of a field.</span></span> <span data-ttu-id="dd86b-3351">Ungültig mit `GetField`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3351">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="dd86b-3352">`GetProperty`, um eine Eigenschaft zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3352">`GetProperty` to get a property.</span></span> <span data-ttu-id="dd86b-3353">Ungültig mit `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3353">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="dd86b-3354">`SetProperty`, um eine Eigenschaft festzulegen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3354">`SetProperty` to set a property.</span></span> <span data-ttu-id="dd86b-3355">Ungültig mit `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3355">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="dd86b-3356">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3356">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="dd86b-3357">Eine Methode wird aufgerufen, wenn beide der folgenden Bedingungen zutreffen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3357">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="dd86b-3358">Die Anzahl der Parameter in der Methoden Deklaration entspricht der Anzahl der Argumente im `args` Array (es sei denn, es sind Standardargumente für `BindingFlags.OptionalParamBinding` den Member definiert und werden angegeben).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3358">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="dd86b-3359">Der Typ jedes Arguments kann vom Binder in den Typ des Parameters konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3359">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="dd86b-3360">Der Binder findet alle übereinstimmenden Methoden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3360">The binder will find all of the matching methods.</span></span> <span data-ttu-id="dd86b-3361">Diese Methoden werden basierend auf dem Typ der angeforderten Bindung gefunden (<xref:System.Reflection.BindingFlags> Werte `InvokeMethod`, `GetProperty`usw.).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3361">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="dd86b-3362">Der Satz von Methoden wird anhand des Namens, der Anzahl von Argumenten und einer Reihe von suchmodifizierermembern gefiltert, die im Binder definiert sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3362">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="dd86b-3363">Nachdem die Methode ausgewählt wurde, wird Sie aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3363">After the method is selected, it is invoked.</span></span> <span data-ttu-id="dd86b-3364">An diesem Punkt wird Barrierefreiheit geprüft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3364">Accessibility is checked at that point.</span></span> <span data-ttu-id="dd86b-3365">Die Suche kann steuern, welcher Satz von Methoden basierend auf dem Barrierefreiheits Attribut, das der Methode zugeordnet ist, durchsucht wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3365">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="dd86b-3366">Die <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> -Methode <xref:System.Reflection.Binder> der-Klasse ist verantwortlich für die Auswahl der aufzurufenden Methode.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3366">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="dd86b-3367">Der Standard Binder wählt die spezifischsten Übereinstimmung aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3367">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="dd86b-3368">Zugriffs Einschränkungen werden bei voll vertrauenswürdigem Code ignoriert. Das heißt, dass auf Private Konstruktoren, Methoden, Felder und Eigenschaften zugegriffen werden kann und die über Reflektion aufgerufen werden, wenn der Code vollständig vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3368">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="dd86b-3369">Sie können verwenden `Type.InvokeMember` , um ein Feld auf einen bestimmten Wert festzulegen <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>, indem Sie angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3369">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="dd86b-3370">Wenn Sie z. b. ein öffentliches Instanzfeld mit dem Namen f in Class C und f als `String` festlegen möchten, können Sie Code wie den folgenden verwenden:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3370">For example, if you want to set a public instance field named F on class C, and F is a `String` you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 <span data-ttu-id="dd86b-3371">Wenn F ein `String[]`ist, können Sie Code wie den folgenden verwenden:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3371">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 <span data-ttu-id="dd86b-3372">Dadurch wird das Feld F mit diesem neuen Array initialisiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3372">which will initialize the field F to this new array.</span></span> <span data-ttu-id="dd86b-3373">Sie können auch verwenden `Type.InvokeMember` , um eine Position in einem Array festzulegen, indem Sie den Index des Werts und dann den nächsten Wert mithilfe von Code wie dem folgenden angeben:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3373">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 <span data-ttu-id="dd86b-3374">Dadurch wird die Zeichenfolge "z" in dem Array geändert, das F in die Zeichenfolge "b" enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3374">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="dd86b-3375">Wenn Sie einen `IDispatch` Member aufrufen, können Sie die DISPID anstelle des Element namens angeben, indem Sie das Zeichen folgen Format "[DispID = # #]" verwenden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3375">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="dd86b-3376">Wenn z. b. die DispID von MyComMethod den Wert 3 hat, können Sie die Zeichenfolge "[DispID = 3]" anstelle von "MyComMethod" angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3376">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="dd86b-3377">Das Aufrufen eines Members durch DISPID ist schneller, als das Element nach dem Namen zu suchen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3377">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="dd86b-3378">In komplexen Aggregations Szenarios ist die DISPID manchmal die einzige Möglichkeit, den gewünschten Member aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3378">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-3379">Ab kann diese Methode verwendet werden, um auf nicht öffentliche Member zuzugreifen, wenn der Aufrufer mit dem <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> -Flag erteilt wurde, und wenn der Berechtigungs Satz der nicht öffentlichen Member auf den Berechtigungs Satz des Aufrufers oder eine Teilmenge beschränkt ist. [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Auslegung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3379">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="dd86b-3380">(Siehe [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="dd86b-3380">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="dd86b-3381">Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3381">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-3382"><paramref name="invokeAttr" /> enthält keine <see langword="CreateInstance" />, und <paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3382"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-3383"><paramref name="invokeAttr" /> ist kein gültiges <see cref="T:System.Reflection.BindingFlags" />-Attribut.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3383"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="dd86b-3384">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3384">-or-</span></span> 
 <span data-ttu-id="dd86b-3385"><paramref name="invokeAttr" /> enthält keines der folgenden Bindungsflags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3385"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="dd86b-3386">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3386">-or-</span></span> 
 <span data-ttu-id="dd86b-3387"><paramref name="invokeAttr" /> enthält <see langword="CreateInstance" /> in Kombination mit <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3387"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="dd86b-3388">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3388">-or-</span></span> 
 <span data-ttu-id="dd86b-3389"><paramref name="invokeAttr" /> enthält sowohl <see langword="GetField" /> als auch <see langword="SetField" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3389"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="dd86b-3390">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3390">-or-</span></span> 
 <span data-ttu-id="dd86b-3391"><paramref name="invokeAttr" /> enthält sowohl <see langword="GetProperty" /> als auch <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3391"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="dd86b-3392">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3392">-or-</span></span> 
 <span data-ttu-id="dd86b-3393"><paramref name="invokeAttr" /> enthält <see langword="InvokeMethod" /> in Kombination mit <see langword="SetField" /> oder <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3393"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="dd86b-3394">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3394">-or-</span></span> 
 <span data-ttu-id="dd86b-3395"><paramref name="invokeAttr" /> enthält <see langword="SetField" />, und <paramref name="args" /> enthält mehr als ein Element.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3395"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="dd86b-3396">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3396">-or-</span></span> 
<span data-ttu-id="dd86b-3397">Diese Methode wird für ein COM-Objekt aufgerufen, und eines der folgenden Bindungsflags wurde nicht übergeben: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> oder <see langword="BindingFlags.PutRefDispProperty" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3397">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="dd86b-3398">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3398">-or-</span></span> 
<span data-ttu-id="dd86b-3399">Eines der benannten Parameterarrays enthält eine Zeichenfolge, die <see langword="null" /> ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3399">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="dd86b-3400">Der angegebene Member ist ein Klasseninitialisierer.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3400">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="dd86b-3401">Das Feld oder die Eigenschaft wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3401">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="dd86b-3402">Es wurde keine Methode gefunden, die den Argumenten in <paramref name="args" /> entspricht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3402">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="dd86b-3403">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3403">-or-</span></span> 
<span data-ttu-id="dd86b-3404">Das aktuelle <see cref="T:System.Type" />-Objekt stellt einen Typ dar, der offene Typparameter enthält. Das bedeutet, dass <see cref="P:System.Type.ContainsGenericParameters" /> den Wert <see langword="true" /> zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3404">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="dd86b-3405">Der angegebene Member kann nicht für <paramref name="target" /> aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3405">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-3406">Mehrere Methoden entsprechen den Bindungskriterien.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3406">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd86b-3407">Die durch <paramref name="name" /> dargestellte Methode enthält mindestens einen nicht angegebenen generischen Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3407">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="dd86b-3408">Das bedeutet, dass die <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />-Eigenschaft der Methode <see langword="true" /> zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3408">That is, the method's <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="dd86b-3409">für den Zugriff auf nicht öffentliche Member, unabhängig von deren Berechtigungs Satz.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3409">for accessing non-public members regardless of their grant set.</span></span> <span data-ttu-id="dd86b-3410">Zugehörige Enumeration:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="dd86b-3410">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="dd86b-3411">, wenn nicht verwalteter Code aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3411">to call unmanaged code.</span></span> <span data-ttu-id="dd86b-3412">Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="dd86b-3412">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="namedParameters" Type="System.String[]" Index="7" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="dd86b-3413">Die Zeichenfolge, die den Namen des Konstruktors, der Methode, der Eigenschaft oder des Feldmembers enthält, der bzw. die aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3413">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="dd86b-3414">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3414">-or-</span></span> 
<span data-ttu-id="dd86b-3415">Eine leere Zeichenfolge ("") zum Aufrufen des Standardmembers.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3415">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="dd86b-3416">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3416">-or-</span></span> 
<span data-ttu-id="dd86b-3417">Für <see langword="IDispatch" />-Member eine Zeichenfolge, die die DispID darstellt, z. B. "[DispID=3]".</span><span class="sxs-lookup"><span data-stu-id="dd86b-3417">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="dd86b-3418">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3418">A bitwise combination of the enumeration values that specify how the search is conducted.</span></span> <span data-ttu-id="dd86b-3419">Der Zugriff kann aus einem der <see langword="BindingFlags" /> wie <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> usw. bestehen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3419">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="dd86b-3420">Die Art der Suche muss nicht angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3420">The type of lookup need not be specified.</span></span> <span data-ttu-id="dd86b-3421">Wenn die Art der Suche nicht angegeben ist, werden <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> verwendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3421">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="dd86b-3422">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3422">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="dd86b-3423">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3423">-or-</span></span> 
<span data-ttu-id="dd86b-3424">Ein Nullverweis (Nothing in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3424">A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="dd86b-3425">Beachten Sie, dass möglicherweise ein <see cref="T:System.Reflection.Binder" />-Objekt explizit definiert werden muss, um erfolgreich Methodenüberladungen mit Variablenargumenten aufrufen zu können.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3425">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="dd86b-3426">Das Objekt, für das der angegebene Member aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3426">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="dd86b-3427">Ein Array mit den Argumenten, die dem aufzurufenden Member übergeben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3427">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <param name="modifiers"><span data-ttu-id="dd86b-3428">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="args" />-Array zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3428">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="args" /> array.</span></span> <span data-ttu-id="dd86b-3429">Die einem Parameter zugeordneten Attribute werden in der Signatur des Members gespeichert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3429">A parameter's associated attributes are stored in the member's signature.</span></span>  
  
<span data-ttu-id="dd86b-3430">Der Standardbinder verarbeitet diesen Parameter nur, wenn eine COM-Komponente aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3430">The default binder processes this parameter only when calling a COM component.</span></span></param>
        <param name="culture"><span data-ttu-id="dd86b-3431">Das <see cref="T:System.Globalization.CultureInfo" />-Objekt, das das zu verwendende Globalisierungsgebietsschema darstellt, das für gebietsspezifische Konvertierungen wie die Konvertierung einer numerischen Zeichenfolge in einen Double erforderlich sein kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3431">The <see cref="T:System.Globalization.CultureInfo" /> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</span></span>  
  
<span data-ttu-id="dd86b-3432">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3432">-or-</span></span> 
<span data-ttu-id="dd86b-3433">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3433">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span></span></param>
        <param name="namedParameters"><span data-ttu-id="dd86b-3434">Ein Array mit den Namen der Parameter, an die die Elemente des <paramref name="args" />-Arrays übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3434">An array containing the names of the parameters to which the values in the <paramref name="args" /> array are passed.</span></span></param>
        <summary><span data-ttu-id="dd86b-3435">Ruft nach Überschreiben in einer abgeleiteten Klasse den angegebenen Member auf, der den angegebenen Bindungseinschränkungen sowie der angegebenen Argumentliste, den Modifizierern und der Kultur entspricht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3435">When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3436">Ein Objekt, das den Rückgabewert des aufgerufenen Members darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3436">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3437">`InvokeMember`Ruft einen konstruktormember oder einen Methodenmember auf, Ruft einen Eigenschaftenmember ab oder legt ihn fest, Ruft einen datenfeldmember ab oder legt ihn fest oder Ruft ein Element eines Array Members ab oder legt es fest.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3437">`InvokeMember` calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-3438">Sie können nicht <xref:System.Type.InvokeMember%2A> verwenden, um eine generische Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3438">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="dd86b-3439">Wenn Sie einen `IDispatch` Member aufrufen, können Sie die DISPID anstelle des Element namens angeben, indem Sie das Zeichen folgen Format "[DispID = # #]" verwenden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3439">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="dd86b-3440">Wenn z. b. die DispID von MyComMethod den Wert 3 hat, können Sie die Zeichenfolge "[DispID = 3]" anstelle von "MyComMethod" angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3440">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="dd86b-3441">Das Aufrufen eines Members durch DISPID ist schneller, als das Element nach dem Namen zu suchen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3441">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="dd86b-3442">In komplexen Aggregations Szenarios ist die DISPID manchmal die einzige Möglichkeit, den gewünschten Member aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3442">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
 <span data-ttu-id="dd86b-3443">Obwohl der Standard Binder <xref:System.Reflection.ParameterModifier> weder noch <xref:System.Globalization.CultureInfo> den `modifiers` -Parameter und den `culture` -Parameter verarbeitet, können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> -Klasse verwenden, um einen benutzerdefinierten Binder `modifiers` zu schreiben, der verarbeitet und `culture`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3443">Although the default binder does not process <xref:System.Reflection.ParameterModifier> or <xref:System.Globalization.CultureInfo> (the `modifiers` and `culture` parameters), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers` and `culture`.</span></span> <span data-ttu-id="dd86b-3444">`ParameterModifier`wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3444">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="dd86b-3445">Jeder Parameter im `namedParameters`-Array ruft den Wert im entsprechenden Element im `args`-Array ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3445">Each parameter in the `namedParameters` array gets the value in the corresponding element in the `args` array.</span></span> <span data-ttu-id="dd86b-3446">Wenn die Länge von `args` größer als die Länge von `namedParameters` ist, werden die restlichen Argumentwerte in der Reihenfolge übergeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3446">If the length of `args` is greater than the length of `namedParameters`, the remaining argument values are passed in order.</span></span>  
  
 <span data-ttu-id="dd86b-3447">Das `namedParameters` Array kann verwendet werden, um die Reihenfolge der Argumente in einem Eingabe Array zu ändern.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3447">The `namedParameters` array can be used to change the order of arguments in an input array.</span></span> <span data-ttu-id="dd86b-3448">Wenn beispielsweise die-Methode `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) und das Eingabe Array `{ 42, "x" }`angegeben werden, kann das Eingabe Array unverändert an `args` übergeben werden, `{ "b", "a" }` wenn das Array `namedParameters`für bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3448">For example, given the method `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) and the input array `{ 42, "x" }`, the input array can be passed unchanged to `args` if the array `{ "b", "a" }` is supplied for `namedParameters`.</span></span>  
  
 <span data-ttu-id="dd86b-3449">Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Elemente in die Suche eingeschlossen werden sollen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3449">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="dd86b-3450">Geben `BindingFlags.Public` Sie an, dass öffentliche Member in die Suche einbezogen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3450">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-3451">Geben `BindingFlags.NonPublic` Sie an, dass nicht öffentliche Member in die Suche eingeschlossen werden sollen (d. h. private, interne und geschützte Member).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3451">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="dd86b-3452">Gibt `BindingFlags.FlattenHierarchy` an, dass statische Elemente in der Hierarchie nach oben eingeschlossen werden</span><span class="sxs-lookup"><span data-stu-id="dd86b-3452">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="dd86b-3453">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3453">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="dd86b-3454">`BindingFlags.IgnoreCase`, wenn der Fall von `name`ignoriert werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3454">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="dd86b-3455">`BindingFlags.DeclaredOnly`, um nur die Member zu durchsuchen <xref:System.Type>, die auf dem deklariert sind, nicht Elemente, die einfach geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3455">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="dd86b-3456">Die folgenden <xref:System.Reflection.BindingFlags> Aufruf-Flags können verwendet werden, um anzugeben, welche Aktion mit dem Element ausgeführt werden soll:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3456">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="dd86b-3457">`CreateInstance`, um einen Konstruktor aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3457">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="dd86b-3458">`name`wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3458">`name` is ignored.</span></span> <span data-ttu-id="dd86b-3459">Ungültig mit anderen Aufruf-Flags.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3459">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="dd86b-3460">`InvokeMethod`, um eine Methode aufzurufen, aber keinen Konstruktor oder Typinitialisierer.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3460">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="dd86b-3461">Ungültig mit `SetField` oder `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3461">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="dd86b-3462">Wenn `InvokeMethod` eigenständig angegeben wird `BindingFlags.Instance`, `BindingFlags.Public`werden, und `BindingFlags.Static` automatisch eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3462">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="dd86b-3463">`GetField`, wenn der Wert eines Felds angezeigt werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3463">`GetField` to get the value of a field.</span></span> <span data-ttu-id="dd86b-3464">Ungültig mit `SetField`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3464">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="dd86b-3465">`SetField`, um den Wert eines Felds festzulegen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3465">`SetField` to set the value of a field.</span></span> <span data-ttu-id="dd86b-3466">Ungültig mit `GetField`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3466">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="dd86b-3467">`GetProperty`, um eine Eigenschaft zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3467">`GetProperty` to get a property.</span></span> <span data-ttu-id="dd86b-3468">Ungültig mit `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3468">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="dd86b-3469">`SetProperty`, um eine Eigenschaft festzulegen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3469">`SetProperty` to set a property.</span></span> <span data-ttu-id="dd86b-3470">Ungültig mit `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3470">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="dd86b-3471">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3471">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="dd86b-3472">Eine Methode wird aufgerufen, wenn beide der folgenden Bedingungen zutreffen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3472">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="dd86b-3473">Die Anzahl der Parameter in der Methoden Deklaration entspricht der Anzahl der Argumente im `args` Array (es sei denn, es sind Standardargumente für `BindingFlags.OptionalParamBinding` den Member definiert und werden angegeben).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3473">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="dd86b-3474">Der Typ jedes Arguments kann vom Binder in den Typ des Parameters konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3474">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="dd86b-3475">Der Binder findet alle übereinstimmenden Methoden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3475">The binder will find all of the matching methods.</span></span> <span data-ttu-id="dd86b-3476">Diese Methoden werden basierend auf dem Typ der angeforderten Bindung gefunden (<xref:System.Reflection.BindingFlags> Werte `InvokeMethod`, `GetProperty`usw.).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3476">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="dd86b-3477">Der Satz von Methoden wird anhand des Namens, der Anzahl von Argumenten und einer Reihe von suchmodifizierermembern gefiltert, die im Binder definiert sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3477">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="dd86b-3478">Nachdem die Methode ausgewählt wurde, wird Sie aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3478">After the method is selected, it is invoked.</span></span> <span data-ttu-id="dd86b-3479">An diesem Punkt wird Barrierefreiheit geprüft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3479">Accessibility is checked at that point.</span></span> <span data-ttu-id="dd86b-3480">Die Suche kann steuern, welcher Satz von Methoden basierend auf dem Barrierefreiheits Attribut, das der Methode zugeordnet ist, durchsucht wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3480">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="dd86b-3481">Die <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> -Methode <xref:System.Reflection.Binder> der-Klasse ist verantwortlich für die Auswahl der aufzurufenden Methode.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3481">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="dd86b-3482">Der Standard Binder wählt die spezifischsten Übereinstimmung aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3482">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="dd86b-3483">`InvokeMember`kann verwendet werden, um Methoden mit Parametern aufzurufen, die über Standardwerte verfügen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3483">`InvokeMember` can be used to invoke methods with parameters that have default values.</span></span> <span data-ttu-id="dd86b-3484">Um an diese Methoden gebunden zu werden, <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> muss die Reflektion angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3484">To bind to these methods, Reflection requires <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> to be specified.</span></span> <span data-ttu-id="dd86b-3485">Bei einem Parameter mit einem Standardwert können Sie entweder einen anderen Wert angeben oder angeben <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> , um den Standardwert zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3485">For a parameter that has a default value, you can either supply a different value, or supply <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> to use the default value.</span></span>  
  
 <span data-ttu-id="dd86b-3486">Angenommen, eine Methode, z. b. "MyMethod" (int x, float y = 2,0).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3486">For example, consider a method such as MyMethod(int x, float y = 2.0).</span></span> <span data-ttu-id="dd86b-3487">Um diese Methode nur mit dem ersten Argument als MyMethod (4) aufzurufen, übergeben Sie eines der obigen Bindungsflags, und übergeben Sie zwei Argumente, nämlich 4 für das `Missing.Value` erste Argument und für das zweite Argument.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3487">To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and `Missing.Value` for the second argument.</span></span> <span data-ttu-id="dd86b-3488">Wenn Sie nicht `Missing.Value`verwenden, dürfen Sie keine optionalen Parameter mit der `Invoke` -Methode weglassen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3488">Unless you use `Missing.Value`, you may not omit optional parameters with the `Invoke` method.</span></span> <span data-ttu-id="dd86b-3489">Wenn Sie dies tun müssen, verwenden `InvokeMember` Sie stattdessen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3489">If you must do so, use `InvokeMember` instead.</span></span>  
  
 <span data-ttu-id="dd86b-3490">Zugriffs Einschränkungen werden bei voll vertrauenswürdigem Code ignoriert. Das heißt, Private Konstruktoren, Methoden, Felder und Eigenschaften können aufgerufen und aufgerufen <xref:System.Reflection> werden, wenn der Code vollständig vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3490">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="dd86b-3491">Sie können verwenden `Type.InvokeMember` , um ein Feld auf einen bestimmten Wert festzulegen <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>, indem Sie angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3491">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="dd86b-3492">Wenn Sie z. b. ein öffentliches Instanzfeld mit dem Namen f für die Klasse C und f als `String`festlegen möchten, können Sie Code wie den folgenden verwenden:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3492">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 <span data-ttu-id="dd86b-3493">Wenn F ein `String[]`ist, können Sie Code wie den folgenden verwenden:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3493">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 <span data-ttu-id="dd86b-3494">Dadurch wird das Feld F mit diesem neuen Array initialisiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3494">which will initialize the field F to this new array.</span></span> <span data-ttu-id="dd86b-3495">Sie können auch verwenden `Type.InvokeMember` , um eine Position in einem Array festzulegen, indem Sie den Index des Werts und dann den nächsten Wert mithilfe von Code wie dem folgenden angeben:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3495">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 <span data-ttu-id="dd86b-3496">Dadurch wird die Zeichenfolge "z" in dem Array geändert, das F in die Zeichenfolge "b" enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3496">This will change string "z" in the array that F holds to string "b".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-3497">Ab kann diese Methode verwendet werden, um auf nicht öffentliche Member zuzugreifen, wenn der Aufrufer mit dem <xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> -Flag erteilt wurde, und wenn der Berechtigungs Satz der nicht öffentlichen Member auf den Berechtigungs Satz des Aufrufers oder eine Teilmenge beschränkt ist. [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Auslegung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3497">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="dd86b-3498">(Siehe [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="dd86b-3498">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="dd86b-3499">Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3499">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-3500"><paramref name="invokeAttr" /> enthält keine <see langword="CreateInstance" />, und <paramref name="name" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3500"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-3501"><paramref name="args" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3501"><paramref name="args" /> and <paramref name="modifiers" /> do not have the same length.</span></span>  
  
<span data-ttu-id="dd86b-3502">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3502">-or-</span></span> 
 <span data-ttu-id="dd86b-3503"><paramref name="invokeAttr" /> ist kein gültiges <see cref="T:System.Reflection.BindingFlags" /> -Attribut.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3503"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="dd86b-3504">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3504">-or-</span></span> 
 <span data-ttu-id="dd86b-3505"><paramref name="invokeAttr" /> enthält keines der folgenden Bindungsflags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3505"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="dd86b-3506">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3506">-or-</span></span> 
 <span data-ttu-id="dd86b-3507"><paramref name="invokeAttr" /> enthält <see langword="CreateInstance" /> in Kombination mit <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3507"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="dd86b-3508">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3508">-or-</span></span> 
 <span data-ttu-id="dd86b-3509"><paramref name="invokeAttr" /> enthält sowohl <see langword="GetField" /> als auch <see langword="SetField" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3509"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="dd86b-3510">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3510">-or-</span></span> 
 <span data-ttu-id="dd86b-3511"><paramref name="invokeAttr" /> enthält sowohl <see langword="GetProperty" /> als auch <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3511"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="dd86b-3512">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3512">-or-</span></span> 
 <span data-ttu-id="dd86b-3513"><paramref name="invokeAttr" /> enthält <see langword="InvokeMethod" /> in Kombination mit <see langword="SetField" /> oder <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3513"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="dd86b-3514">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3514">-or-</span></span> 
 <span data-ttu-id="dd86b-3515"><paramref name="invokeAttr" /> enthält <see langword="SetField" />, und <paramref name="args" /> enthält mehr als ein Element.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3515"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="dd86b-3516">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3516">-or-</span></span> 
<span data-ttu-id="dd86b-3517">Das benannte Parameterarray ist größer als das Argumentarray.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3517">The named parameter array is larger than the argument array.</span></span>  
  
<span data-ttu-id="dd86b-3518">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3518">-or-</span></span> 
<span data-ttu-id="dd86b-3519">Diese Methode wird für ein COM-Objekt aufgerufen, und eines der folgenden Bindungsflags wurde nicht übergeben: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> oder <see langword="BindingFlags.PutRefDispProperty" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3519">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="dd86b-3520">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3520">-or-</span></span> 
<span data-ttu-id="dd86b-3521">Eines der benannten Parameterarrays enthält eine Zeichenfolge, die <see langword="null" /> ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3521">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="dd86b-3522">Der angegebene Member ist ein Klasseninitialisierer.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3522">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="dd86b-3523">Das Feld oder die Eigenschaft wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3523">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="dd86b-3524">Es wurde keine Methode gefunden, die den Argumenten in <paramref name="args" /> entspricht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3524">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="dd86b-3525">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3525">-or-</span></span> 
<span data-ttu-id="dd86b-3526">Es wurde kein Member gefunden, dessen Argumentnamen in <paramref name="namedParameters" /> angegeben sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3526">No member can be found that has the argument names supplied in <paramref name="namedParameters" />.</span></span>  
  
<span data-ttu-id="dd86b-3527">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-3527">-or-</span></span> 
<span data-ttu-id="dd86b-3528">Das aktuelle <see cref="T:System.Type" />-Objekt stellt einen Typ dar, der offene Typparameter enthält. Das bedeutet, dass <see cref="P:System.Type.ContainsGenericParameters" /> den Wert <see langword="true" /> zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3528">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="dd86b-3529">Der angegebene Member kann nicht für <paramref name="target" /> aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3529">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="dd86b-3530">Mehrere Methoden entsprechen den Bindungskriterien.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3530">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd86b-3531">Die durch <paramref name="name" /> dargestellte Methode enthält mindestens einen nicht angegebenen generischen Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3531">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="dd86b-3532">Das bedeutet, dass die <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />-Eigenschaft der Methode <see langword="true" /> zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3532">That is, the method's <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="dd86b-3533">für den Zugriff auf nicht öffentliche Member, unabhängig von deren Berechtigungs Satz.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3533">for accessing non-public members regardless of their grant set.</span></span> <span data-ttu-id="dd86b-3534">Zugehörige Enumeration:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="dd86b-3534">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="dd86b-3535">, wenn nicht verwalteter Code aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3535">to call unmanaged code.</span></span> <span data-ttu-id="dd86b-3536">Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="dd86b-3536">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3537">Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> abstrakt ist und überschrieben werden muss.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3537">Gets a value indicating whether the <see cref="T:System.Type" /> is abstract and must be overridden.</span></span></summary>
        <value><span data-ttu-id="dd86b-3538"><see langword="true" />, wenn <see cref="T:System.Type" /> abstrakt ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3538"><see langword="true" /> if the <see cref="T:System.Type" /> is abstract; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3539">Die <xref:System.Type.IsAbstract%2A> -Eigenschaft `true` wird in den folgenden Fällen zurückgegeben:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3539">The <xref:System.Type.IsAbstract%2A> property returns `true` in the following cases:</span></span>  
  
-   <span data-ttu-id="dd86b-3540">Der aktuelle Typ ist abstrakt. Das heißt, dass es nicht instanziiert werden kann, sondern nur als Basisklasse für abgeleitete Klassen fungieren kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3540">The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.</span></span> <span data-ttu-id="dd86b-3541">In C#werden abstrakte Klassen mit dem [abstract](~/docs/csharp/language-reference/keywords/abstract.md) -Schlüsselwort gekennzeichnet. in Visual Basic sind Sie mit dem [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) -Schlüsselwort gekennzeichnet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3541">In C#, abstract classes are marked with the [abstract](~/docs/csharp/language-reference/keywords/abstract.md) keyword; in Visual Basic, they are marked with the [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) keyword.</span></span>  
  
-   <span data-ttu-id="dd86b-3542">Der aktuelle Typ ist eine Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3542">The current type is an interface.</span></span>  
  
 <span data-ttu-id="dd86b-3543">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `false`Eigenschaft immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3543">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3544">Im folgenden Beispiel wird ein Array von <xref:System.Type> -Objekten erstellt, die die folgenden Typen darstellen: `true` enthält Rückgabe Typen, wenn `abstract`das angegebene Objekt ist, `false`andernfalls wird zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3544">The following example creates an array of <xref:System.Type> objects that represent the following types:contains type returns `true` if the specified object is `abstract`; otherwise, it returns `false`.</span></span>  
  
-   <span data-ttu-id="dd86b-3545">`AbstractClass`, eine abstrakte Klasse (eine Klasse, die `abstract` als C# in `MustInherit` und in Visual Basic gekennzeichnet ist).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3545">`AbstractClass`, an abstract class (a class marked as `abstract` in C# and `MustInherit` in Visual Basic).</span></span>  
  
-   <span data-ttu-id="dd86b-3546">`DerivedClass`, eine Klasse, die von `AbstractClass`erbt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3546">`DerivedClass`, a class that inherits from `AbstractClass`.</span></span>  
  
-   <span data-ttu-id="dd86b-3547">`SingleClass`, eine nicht vererbbare Klasse.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3547">`SingleClass`, a non-inheritable class.</span></span> <span data-ttu-id="dd86b-3548">Sie wird als `sealed` in C# und `NotInheritable` in Visual Basic definiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3548">It is defined as `sealed` in C# and `NotInheritable` in Visual Basic.</span></span>  
  
-   <span data-ttu-id="dd86b-3549">`ITypeInfo`, eine-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3549">`ITypeInfo`, an interface.</span></span>  
  
-   <span data-ttu-id="dd86b-3550">`ImplementingClass`, eine Klasse, die die `ITypeInfo` -Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3550">`ImplementingClass`, a class that implements the `ITypeInfo` interface.</span></span>  
  
 <span data-ttu-id="dd86b-3551">Die-Methode `true` gibt nur `AbstractClass`für die-Schnittstelle, `ITypeInfo`die abstrakte-Klasse und die-Schnittstelle zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3551">The method returns `true` only for `AbstractClass`, the abstract class, and `ITypeInfo`, the interface.</span></span>  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3552">Ruft einen Wert ab, der angibt, ob für <see langword="AnsiClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3552">Gets a value indicating whether the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="dd86b-3553"><see langword="true" />, wenn für <see langword="AnsiClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3553"><see langword="true" /> if the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3554"><xref:System.Reflection.TypeAttributes.StringFormatMask> Wählt die Zeichen folgen Format Attribute aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3554">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="dd86b-3555">Die Attribute des Zeichen folgen Formats verbessern die Interoperabilität durch definieren, wie Zeichen folgen interpretiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3555">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="dd86b-3556">Wenn der aktuelle <xref:System.Type> einen generischen Typ darstellt, bezieht sich diese Eigenschaft auf die generische Typdefinition, aus der der Typ erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3556">If the current <xref:System.Type> represents a generic type, this property pertains to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="dd86b-3557">Wenn der <xref:System.Type> aktuelle z. b. `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic) darstellt, wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3557">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="dd86b-3558">Wenn der aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft immer `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3558">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3559">Im folgenden Beispiel werden die Feldinformationen abgerufen und das `AnsiClass` -Attribut überprüft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3559">The following example gets the field information and checks for the `AnsiClass` attribute.</span></span>  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3560">Ruft einen Wert ab, der angibt, ob der Typ ein Array ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3560">Gets a value that indicates whether the type is an array.</span></span></summary>
        <value><span data-ttu-id="dd86b-3561"><see langword="true" />, wenn der aktuelle Typ ein Array ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3561"><see langword="true" /> if the current type is an array; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3562">Die <xref:System.Type.IsArray%2A> -Eigenschaft `false` gibt für <xref:System.Array> die-Klasse zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3562">The <xref:System.Type.IsArray%2A> property returns `false` for the <xref:System.Array> class.</span></span> <span data-ttu-id="dd86b-3563">Außerdem wird zurück `false` gegeben, wenn es sich bei <xref:System.Type> der aktuellen Instanz um ein-Objekt handelt, das einen Auflistungstyp oder eine <xref:System.Collections.IEnumerable> Schnitt <xref:System.Collections.Generic.IEnumerable%601>Stelle darstellt, die für die Arbeit mit Auflistungen</span><span class="sxs-lookup"><span data-stu-id="dd86b-3563">It also returns `false` if the current instance is a <xref:System.Type> object that represents a collection type or an interface designed to work with collections, such as <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="dd86b-3564">Um nach einem Array zu suchen, verwenden Sie Code wie z. b.:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3564">To check for an array, use code such as:</span></span>  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 <span data-ttu-id="dd86b-3565">Wenn der aktuelle Typ einen generischen Typ oder einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `false`Eigenschaft immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3565">If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="dd86b-3566">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3566">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3567">Im folgenden Beispiel wird die Verwendung <xref:System.Type.IsArray%2A> der-Eigenschaft veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3567">The following example demonstrates using the <xref:System.Type.IsArray%2A> property.</span></span>  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-3568">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsArray" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein Array ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3568">When overridden in a derived class, implements the <see cref="P:System.Type.IsArray" /> property and determines whether the <see cref="T:System.Type" /> is an array.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3569"><see langword="true" />, wenn <see cref="T:System.Type" /> ein Array ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3569"><see langword="true" /> if the <see cref="T:System.Type" /> is an array; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3570">Eine Instanz der <xref:System.Array> -Klasse muss zurück `false` geben, da es sich um ein Objekt und nicht um ein Array handelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3570">An instance of the <xref:System.Array> class must return `false` because it is an object, not an array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3571">Im folgenden Beispiel wird die `IsArrayImpl` -Methode in der `MyTypeDelegator` -Klasse überschrieben, es wird überprüft, ob eine Variable ein Array ist, und das Ergebnis wird angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3571">The following example overrides the `IsArrayImpl` method in the `MyTypeDelegator` class, checks if a variable is an array, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="dd86b-3572">Der Typ, der mit dem aktuellen Typ verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3572">The type to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="dd86b-3573">Bestimmt, ob eine Instanz des angegebenen Typs einer Variablen des aktuellen Typs zugewiesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3573">Determines whether an instance of a specified type can be assigned to a variable of the current type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3574"><see langword="true" />, wenn eine der folgenden Bedingungen erfüllt ist:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3574"><see langword="true" /> if any of the following conditions is true:</span></span> <span data-ttu-id="dd86b-3575">
-   <paramref name="c" /> und die aktuelle Instanz haben denselben Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3575">
-   <paramref name="c" /> and the current instance represent the same type.</span></span>  
  <span data-ttu-id="dd86b-3576">
-   <paramref name="c" /> ist entweder direkt oder indirekt von der aktuellen Instanz abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3576">
-   <paramref name="c" /> is derived either directly or indirectly from the current instance.</span></span> <span data-ttu-id="dd86b-3577"><paramref name="c" /> wird direkt von der aktuellen Instanz abgeleitet, wenn es von der aktuellen Instanz erbt; <paramref name="c" /> wird indirekt von der aktuellen Instanz abgeleitet, wenn es von einer Folge von einer oder mehr Klassen erbt, die von der aktuellen Instanz erben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3577"><paramref name="c" /> is derived directly from the current instance if it inherits from the current instance; <paramref name="c" /> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.</span></span>  
  
<span data-ttu-id="dd86b-3578">–   Die aktuelle Instanz ist eine Schnittstelle, die von <paramref name="c" /> implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3578">-   The current instance is an interface that <paramref name="c" /> implements.</span></span>  
  <span data-ttu-id="dd86b-3579">
-   <paramref name="c" /> ist ein generischer Typparameter, und die aktuelle Instanz stellt eine der Einschränkungen von <paramref name="c" /> dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3579">
-   <paramref name="c" /> is a generic type parameter, and the current instance represents one of the constraints of <paramref name="c" />.</span></span>  
  
<span data-ttu-id="dd86b-3580">Im folgenden Beispiel handelt es sich bei der aktuellen Instanz um ein <see cref="T:System.Type" />-Objekt, das die Klasse <see cref="T:System.IO.Stream" /> darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3580">In the following example, the current instance is a <see cref="T:System.Type" /> object that represents the <see cref="T:System.IO.Stream" /> class.</span></span> <span data-ttu-id="dd86b-3581">Bei <c>GenericWithConstraint</c> handel es sich um einen generische Typ, dessen generischer Typparameter vom Typ <see cref="T:System.IO.Stream" /> sein muss.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3581"><c>GenericWithConstraint</c> is a generic type whose generic type parameter must be of type    <see cref="T:System.IO.Stream" />.</span></span> <span data-ttu-id="dd86b-3582">Wenn der generische Typparameter an <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> übergeben wird,zeigt dies, dass eine Instanz des generischen Typparameters einem <see cref="T:System.IO.Stream" />-Objekt zugewiesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3582">Passing its generic type parameter to the <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indicates that  an instance of the generic type parameter can be assigned to an <see cref="T:System.IO.Stream" /> object.</span></span>  
  
<span data-ttu-id="dd86b-3583">[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="dd86b-3583">[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]</span></span> <span data-ttu-id="dd86b-3584">
-   <paramref name="c" /> stellt einen Werttyp dar, und die aktuelle Instanz stellt <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic) dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3584">
-   <paramref name="c" /> represents a value type, and the current instance represents <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic).</span></span>  
  
 <span data-ttu-id="dd86b-3585"><see langword="false" />, wenn keine dieser Bedingungen erfüllt sind oder wenn <paramref name="c" /><see langword="null" /> ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3585"><see langword="false" /> if none of these conditions are true, or if <paramref name="c" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3586">Die <xref:System.Type.IsAssignableFrom%2A> -Methode kann verwendet werden, um zu bestimmen, `c` ob eine Instanz von einer Instanz des aktuellen Typs zugewiesen werden kann. die-Methode ist besonders nützlich, wenn Sie Objekte verarbeiten, deren Typen zur Entwurfszeit nicht bekannt sind, und eine bedingte Zuweisung, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3586">The <xref:System.Type.IsAssignableFrom%2A> method can be used to determine whether an instance of `c` can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 <span data-ttu-id="dd86b-3587">Durch diese Methode wird sichergestellt, dass eine Codezeile wie die folgende zur Laufzeit ausgeführt wird, <xref:System.InvalidCastException> ohne eine Ausnahme auszulösen oder eine ähnliche Ausnahme auszulösen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3587">This method thus ensures that a line of code like the following will execute at runtime without throwing an <xref:System.InvalidCastException> exception or a similar exception:</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 <span data-ttu-id="dd86b-3588">Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3588">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-3589">Eine generische Typdefinition kann nicht aus einem geschlossenen konstruierten Typ zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3589">A generic type definition is not assignable from a closed constructed type.</span></span> <span data-ttu-id="dd86b-3590">Das heißt, Sie können den geschlossenen konstruierten Typ `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) nicht einer Variablen des Typs `MyGenericList<T>`zuweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3590">That is, you cannot assign the closed constructed type `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) to a variable of type `MyGenericList<T>`.</span></span>  
  
 <span data-ttu-id="dd86b-3591">Wenn der `c` -Parameter vom Typ <xref:System.Reflection.Emit.TypeBuilder>ist, basiert das Ergebnis auf dem Typ, der erstellt werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3591">If the `c` parameter is of type <xref:System.Reflection.Emit.TypeBuilder>, the result is based on the type that is to be built.</span></span> <span data-ttu-id="dd86b-3592">Das folgende Codebeispiel veranschaulicht dies mithilfe eines erstellten Typs mit `B`dem Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3592">The following code example demonstrates this using a built type named `B`.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3593">Im folgenden Beispiel wird die `IsAssignableFrom` -Methode veranschaulicht, indem definierte Klassen, ganzzahlige Arrays und Generika verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3593">The following example demonstrates the `IsAssignableFrom` method using defined classes, integer arrays, and generics.</span></span>  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3594">Ruft einen Wert ab, der angibt, ob für <see langword="AutoClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3594">Gets a value indicating whether the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="dd86b-3595"><see langword="true" />, wenn für <see langword="AutoClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3595"><see langword="true" /> if the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3596"><xref:System.Reflection.TypeAttributes.StringFormatMask> Wählt die Zeichen folgen Format Attribute aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3596">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="dd86b-3597">Die Attribute des Zeichen folgen Formats verbessern die Interoperabilität durch definieren, wie Zeichen folgen interpretiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3597">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="dd86b-3598">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3598">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="dd86b-3599">Wenn der <xref:System.Type> aktuelle z. b. `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic) darstellt, wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3599">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="dd86b-3600">Wenn der aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft immer `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3600">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3601">Ruft einen Wert ab, der angibt, ob die Felder des aktuellen Typs automatisch von der Common Language Runtime angelegt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3601">Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</span></span></summary>
        <value><span data-ttu-id="dd86b-3602"><see langword="true" />, wenn die <see cref="P:System.Type.Attributes" />-Eigenschaft des aktuellen Typs <see cref="F:System.Reflection.TypeAttributes.AutoLayout" /> umfasst; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3602"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3603">Diese Eigenschaft wird als praktische Hilfe bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3603">This property is provided as a convenience.</span></span> <span data-ttu-id="dd86b-3604">Alternativ können Sie den- <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> Enumerationswert verwenden, um die Typlayoutattribute auszuwählen, und dann testen, ob <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3604">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="dd86b-3605">Die <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>Enumerationswerte, und <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> geben an,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>wie die Felder des Typs im Arbeitsspeicher angeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3605">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="dd86b-3606">Bei dynamischen Typen können Sie angeben <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> , wann der Typ erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3606">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="dd86b-3607">Wenden Sie im Code das <xref:System.Runtime.InteropServices.StructLayoutAttribute> -Attribut mit <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> dem-Enumerationswert auf den-Typ an, damit die Common Language Runtime die geeignete Methode zum Anordnen der Klasse bestimmen kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3607">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-3608">Sie können die <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> -Methode nicht verwenden, um <xref:System.Runtime.InteropServices.StructLayoutAttribute> zu bestimmen, ob auf einen Typ angewendet wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3608">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="dd86b-3609">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3609">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="dd86b-3610">Wenn der aktuelle <xref:System.Type> z. b. `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic) darstellt, wird der Wert dieser Eigenschaft durch`MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="dd86b-3610">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="dd86b-3611">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `false`Eigenschaft immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3611">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3612">Im folgenden Beispiel wird eine Instanz des-Typs erstellt und die <xref:System.Type.IsAutoLayout%2A> -Eigenschaft angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3612">The following example creates an instance of the type and displays the <xref:System.Type.IsAutoLayout%2A> property.</span></span>  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="dd86b-3613">Metadaten und selbstbeschreibende Komponenten</span><span class="sxs-lookup"><span data-stu-id="dd86b-3613">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3614">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> als Verweis übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3614">Gets a value indicating whether the <see cref="T:System.Type" /> is passed by reference.</span></span></summary>
        <value><span data-ttu-id="dd86b-3615"><see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis übergeben wird, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3615"><see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3616">Um zum eigentlichen Typ zu gelangen, Dereferenzieren Sie den Typ, der als Verweis weitergegeben wurde <xref:System.Type.GetElementType%2A> , und dann für diesen Typ aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3616">To get to the actual type, dereference the type that was passed by reference, and then call <xref:System.Type.GetElementType%2A> on that type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3617">Das folgende Beispiel veranschaulicht die Verwendung `IsByRef` der-Eigenschaft, um zu überprüfen, ob ein angegebener Typ als Verweis übergangen wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3617">The following example demonstrates a use of the `IsByRef` property to check whether a specified type is passed by reference.</span></span> <span data-ttu-id="dd86b-3618">Im Beispiel wird die- `MyTypeDelegator`Klasse definiert, die die `HasElementTypeImpl` -Methode überschreibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3618">The example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="dd86b-3619">Die Hauptklasse überprüft die- `HasElementType` Eigenschaft und zeigt den Elementtyp an.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3619">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-3620">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsByRef" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> als Verweis übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3620">When overridden in a derived class, implements the <see cref="P:System.Type.IsByRef" /> property and determines whether the <see cref="T:System.Type" /> is passed by reference.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3621"><see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis übergeben wird, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3621"><see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3622">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> eine Klasse oder ein Delegat ist, d. h. weder ein Werttyp noch eine Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3622">Gets a value indicating whether the <see cref="T:System.Type" /> is a class or a delegate; that is, not a value type or interface.</span></span></summary>
        <value><span data-ttu-id="dd86b-3623"><see langword="true" />, wenn <see cref="T:System.Type" /> eine Klasse ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3623"><see langword="true" /> if the <see cref="T:System.Type" /> is a class; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3624">Diese Eigenschaft gibt `true` sowohl für-Klassen als auch für Delegaten zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3624">This property returns `true` for classes as well as delegates.</span></span> <span data-ttu-id="dd86b-3625">Sie gibt `false` für Werttypen (für Strukturen und Enumerationen) zurück, auch wenn Sie gekapselt sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3625">It returns `false` for value types (for structures and enumerations) even if they are boxed.</span></span>  
  
 <span data-ttu-id="dd86b-3626">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `true`Eigenschaft immer zurück. Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt `true` diese Eigenschaft zurück, wenn die generische Typdefinition eine Klassendefinition ist, d. h., es wird keine Schnittstelle oder ein Werttyp definiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3626">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `true`.If the current <xref:System.Type> represents a constructed generic type, this property returns `true` if the generic type definition is a class definition; that is, it does not define an interface or a value type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-3627">Diese Eigenschaft gibt `true` für `Type` -Instanzen zurück, <xref:System.Enum> die <xref:System.ValueType> die Klassen und darstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3627">This property returns `true` for `Type` instances that represent the <xref:System.Enum> and <xref:System.ValueType> classes.</span></span> <span data-ttu-id="dd86b-3628">Diese beiden Klassen sind die Basis Typen für Enumerationen und Werttypen, aber Sie sind nicht selbst Enumerationen oder Werttypen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3628">These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.</span></span> <span data-ttu-id="dd86b-3629">Weitere Informationen finden Sie unter den <xref:System.Type.IsValueType%2A> Eigenschaften <xref:System.Type.IsEnum%2A> und.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3629">For more information, see the <xref:System.Type.IsValueType%2A> and <xref:System.Type.IsEnum%2A> properties.</span></span>  
  
 <span data-ttu-id="dd86b-3630">Der <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> -Enumerationswert unterscheidet eine Typdeklaration als Klasse oder Schnittstelle. Allerdings werden sowohl Klassen als auch Werttypen mit <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> dem-Attribut markiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3630">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> attribute.</span></span> <span data-ttu-id="dd86b-3631">Wenn Sie den Wert der Attributeigenschaft eines Typs abrufen und den <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> Wert verwenden, um zu bestimmen, ob ein Typ eine Klasse anstelle eines Werttyps ist, müssen Sie auch die <xref:System.Type.IsValueType%2A> -Eigenschaft aufrufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3631">If you retrieve the value of a type's Attributes property and use the <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> value to determine whether a type is a class instead of a value type, you must also call the <xref:System.Type.IsValueType%2A> property.</span></span> <span data-ttu-id="dd86b-3632">Das Beispiel für die <xref:System.Reflection.TypeAttributes> -Enumeration enthält zusätzliche Informationen und ein Beispiel.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3632">The example for the <xref:System.Reflection.TypeAttributes> enumeration contains additional information as well as anexample.</span></span>  
  
 <span data-ttu-id="dd86b-3633">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3633">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3634">Im folgenden Beispiel wird eine Instanz eines Typs erstellt, und es wird angegeben, ob der Typ eine Klasse ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3634">The following example creates an instance of a type and indicates whether the type is a class.</span></span>  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3635">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> ein COM-Objekt ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3635">Gets a value indicating whether the <see cref="T:System.Type" /> is a COM object.</span></span></summary>
        <value><span data-ttu-id="dd86b-3636"><see langword="true" />, wenn <see cref="T:System.Type" /> ein COM-Objekt ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3636"><see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3637">Diese Methode gibt `false` für COM-Schnittstellen zurück, da Sie keine Objekte sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3637">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="dd86b-3638">COM-Schnittstellen können von Microsoft .NET Framework-Objekten implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3638">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 <span data-ttu-id="dd86b-3639">Sie können auch eine COM-Klasse laden und mithilfe `Type` des Tools " [Tlbimp. exe" (Typbibliothek-Import Programm)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) ein-Objekt für diese com-Klasse erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3639">You can also load a COM class and get a `Type` object for that COM class by using the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool.</span></span>  
  
 <span data-ttu-id="dd86b-3640">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3640">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="dd86b-3641">Wenn der <xref:System.Type> aktuelle z. b. `MyGenericType<int`> darstellt`MyGenericType(Of Integer)` (in Visual Basic), wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3641">For example, if the current <xref:System.Type> represents `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="dd86b-3642">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `false`Eigenschaft immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3642">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-3643">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsCOMObject" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein COM-Objekt ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3643">When overridden in a derived class, implements the <see cref="P:System.Type.IsCOMObject" /> property and determines whether the <see cref="T:System.Type" /> is a COM object.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3644"><see langword="true" />, wenn <see cref="T:System.Type" /> ein COM-Objekt ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3644"><see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3645">Diese Methode gibt `false` für COM-Schnittstellen zurück, da Sie keine Objekte sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3645">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="dd86b-3646">COM-Schnittstellen können von Microsoft .NET Framework-Objekten implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3646">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3647">Ruft einen Wert ab, der angibt, ob dieses Objekt einen konstruierten generischen Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3647">Gets a value that indicates whether this object represents a constructed generic type.</span></span> <span data-ttu-id="dd86b-3648">Sie können Instanzen eines konstruierten generischen Typs erstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3648">You can create instances of a constructed generic type.</span></span></summary>
        <value><span data-ttu-id="dd86b-3649"><see langword="true" />, wenn dieses Objekt einen konstruierten generischen Typ darstellt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3649"><see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3650">Für einen konstruierten generischen Typ wurden explizite Typen für alle seine generischen Typparameter bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3650">A constructed generic type has had explicit types supplied for all of its generic type parameters.</span></span> <span data-ttu-id="dd86b-3651">Sie wird auch als geschlossener generischer Typ bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3651">It is also referred to as a closed generic type.</span></span>  
  
 <span data-ttu-id="dd86b-3652">Wenn diese Eigenschaft ist `true`, können Sie Instanzen des aktuellen Typs erstellen; Wenn dies der Fall `false`ist, können Sie dies nicht tun.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3652">When this property is `true`, you can create instances of the current type; when it is `false`, you can't.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3653">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3653">Gets a value indicating whether the <see cref="T:System.Type" /> can be hosted in a context.</span></span></summary>
        <value><span data-ttu-id="dd86b-3654"><see langword="true" />, wenn <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3654"><see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3655">Ein Kontext fängt Aufrufe der Klassenmember ab und erzwingt Richtlinien, die auf die Klasse angewendet werden, z. b. die Synchronisierung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3655">A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.</span></span> <span data-ttu-id="dd86b-3656">Ausführlichere Informationen zu remotingkontexten finden <xref:System.Runtime.Remoting.Contexts.Context>Sie unter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3656">For more detailed information on remoting contexts, see <xref:System.Runtime.Remoting.Contexts.Context>.</span></span>  
  
 <span data-ttu-id="dd86b-3657">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `false`Eigenschaft immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3657">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3658">Im folgenden Beispiel werden die `IsContextful`Eigenschaften <xref:System.Type.IsMarshalByRef%2A>, und <xref:System.Type.IsPrimitive%2A> der <xref:System.Type> -Klasse veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3658">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="dd86b-3659">Er überprüft, ob der angegebene Typ im Kontext gehostet werden kann, ob er als Verweis gemarshallt werden kann und ob der Typ ein primitiver Datentyp ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3659">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-3660">Implementiert die <see cref="P:System.Type.IsContextful" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3660">Implements the <see cref="P:System.Type.IsContextful" /> property and determines whether the <see cref="T:System.Type" /> can be hosted in a context.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3661"><see langword="true" />, wenn <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3661"><see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3662">Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3662">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="dd86b-3663">Ein Kontext fängt Aufrufe der Klassenmember ab und erzwingt Richtlinien, die auf die Klasse angewendet werden, z. b. die Synchronisierung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3663">A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3664">Im folgenden Beispiel wird die `IsContextfulImpl` Verwendung der-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3664">The following example demonstrates a use of the `IsContextfulImpl` method.</span></span>  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3665">Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> eine Enumeration darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3665">Gets a value indicating whether the current <see cref="T:System.Type" /> represents an enumeration.</span></span></summary>
        <value><span data-ttu-id="dd86b-3666"><see langword="true" />, wenn der aktuelle <see cref="T:System.Type" /> eine Enumeration darstellt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3666"><see langword="true" /> if the current <see cref="T:System.Type" /> represents an enumeration; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3667">Diese Eigenschaft gibt `true` für eine Enumeration zurück, jedoch nicht für <xref:System.Enum> den Typ selbst.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3667">This property returns `true` for an enumeration, but not for the <xref:System.Enum> type itself.</span></span>  
  
 <span data-ttu-id="dd86b-3668">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3668">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="dd86b-3669">Wenn der <xref:System.Type> aktuelle z. b. `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic) darstellt, wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3669">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="dd86b-3670">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `false`Eigenschaft immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3670">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="dd86b-3671">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3671">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3672">Im folgenden Beispiel wird die Verwendung der `IsEnum` -Eigenschaft veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3672">The following example demonstrates how to use the `IsEnum` property.</span></span>  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="dd86b-3673">Der zu überprüfende Wert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3673">The value to be tested.</span></span></param>
        <summary><span data-ttu-id="dd86b-3674">Gibt einen Wert zurück, der angibt, ob der angegebene Wert im aktuellen Enumerationstyp vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3674">Returns a value that indicates whether the specified value exists in the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3675"><see langword="true" />, wenn der angegebene Wert ein Member des aktuellen Enumerationstyps ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3675"><see langword="true" /> if the specified value is a member of the current enumeration type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-3676">Der aktuelle Typ ist keine Enumeration.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3676">The current type is not an enumeration.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-3677"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3677"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd86b-3678"><paramref name="value" /> ist ein Typ, der nicht der zugrunde liegende Typ einer Enumeration sein kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3678"><paramref name="value" /> is of a type that cannot be the underlying type of an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="dd86b-3679">Der COM-Typ, der auf Äquivalenz mit dem aktuellen Typ überprüft wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3679">The COM type that is tested for equivalence with the current type.</span></span></param>
        <summary><span data-ttu-id="dd86b-3680">Bestimmt, ob zwei COM-Typen die gleiche Identität haben und äquivalente Typen aufweisen können.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3680">Determines whether two COM types have the same identity and are eligible for type equivalence.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3681"><see langword="true" />, wenn die COM-Typen äquivalent sind, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3681"><see langword="true" /> if the COM types are equivalent; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="dd86b-3682">Diese Methode gibt auch <see langword="false" /> zurück, wenn ein Typ in einer Assembly enthalten ist, die zum Ausführen geladen wird, und der andere in einer Assembly enthalten ist, die in den reflektionsbezogenen Kontext geladen wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3682">This method also returns <see langword="false" /> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3683">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]Ab unterstützt die Common Language Runtime die Einbettung von Typinformationen für COM-Typen direkt in verwaltete Assemblys, anstatt dass die verwalteten Assemblys Typinformationen für COM-Typen aus Interop abrufen müssen. Gemeinden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3683">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</span></span> <span data-ttu-id="dd86b-3684">Da die eingebettete Typinformation nur die Typen und Member enthält, die tatsächlich von einer verwalteten Assembly verwendet werden, können zwei verwaltete Assemblys möglicherweise sehr unterschiedliche Ansichten desselben COM-Typs haben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3684">Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</span></span> <span data-ttu-id="dd86b-3685">Jede verwaltete Assembly besitzt ein anderes <xref:System.Type>-Objekt, das eine Ansicht des COM-Typs darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3685">Each managed assembly has a different <xref:System.Type> object to represent its view of the COM type.</span></span> <span data-ttu-id="dd86b-3686">Die Common Language Runtime unterstützt Typäquivalenz zwischen diesen unterschiedlichen Ansichten für Schnittstellen, Strukturen, Enumerationen und Delegaten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3686">The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</span></span>  
  
 <span data-ttu-id="dd86b-3687">Typäquivalenz bedeutet, dass ein COM-Objekt, das von einer verwalteten Assembly an eine andere übergeben wird, für den entsprechenden verwalteten Typ in der empfangenden Assembly bereitgestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3687">Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</span></span> <span data-ttu-id="dd86b-3688">Die <xref:System.Type.IsEquivalentTo%2A> -Methode ermöglicht es einer Assembly zu bestimmen, dass ein COM-Objekt, das aus einer anderen Assembly abgerufen wurde, dieselbe com-Identität wie einer der eigenen eingebetteten Interop-Typen der ersten Assembly hat und daher in diesen Typ umgewandelt werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3688">The <xref:System.Type.IsEquivalentTo%2A> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.</span></span>  
  
 <span data-ttu-id="dd86b-3689">Weitere Informationen finden Sie unter [typäquivalenz und eingebettete Interop-Typen](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3689">For more information, see [Type Equivalence and Embedded Interop Types](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3690">Ruft einen Wert ab, der angibt, ob die Felder des aktuellen Typs an den explizit angegebenen Offsets angelegt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3690">Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</span></span></summary>
        <value><span data-ttu-id="dd86b-3691"><see langword="true" />, wenn die <see cref="P:System.Type.Attributes" />-Eigenschaft des aktuellen Typs <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /> umfasst; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3691"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3692">Diese Eigenschaft wird als praktische Hilfe bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3692">This property is provided as a convenience.</span></span> <span data-ttu-id="dd86b-3693">Alternativ können Sie den- <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> Enumerationswert verwenden, um die Typlayoutattribute auszuwählen, und dann testen, ob <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3693">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="dd86b-3694">Die <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>Enumerationswerte, und <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> geben an, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>wie die Felder des Typs im Arbeitsspeicher angeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3694">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="dd86b-3695">Bei dynamischen Typen können Sie angeben <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> , wann der Typ erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3695">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="dd86b-3696">Wenden Sie im Code das <xref:System.Runtime.InteropServices.StructLayoutAttribute> -Attribut mit <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> dem-Enumerationswert auf den-Typ an, um anzugeben, dass die Offsets, bei denen die Felder beginnen, explizit angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3696">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-3697">Sie können die <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> -Methode nicht verwenden, um <xref:System.Runtime.InteropServices.StructLayoutAttribute> zu bestimmen, ob auf einen Typ angewendet wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3697">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="dd86b-3698">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3698">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="dd86b-3699">Wenn der <xref:System.Type> aktuelle z. b. `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic) darstellt, wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3699">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="dd86b-3700">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `false`Eigenschaft immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3700">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3701">Im folgenden Beispiel wird eine Instanz eines Typs erstellt und der Wert der <xref:System.Type.IsExplicitLayout%2A> zugehörigen-Eigenschaft angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3701">The following example creates an instance of a type and displays the value of its <xref:System.Type.IsExplicitLayout%2A> property.</span></span> <span data-ttu-id="dd86b-3702">Dabei wird die `MySystemTime` -Klasse verwendet, die auch im Codebeispiel für <xref:System.Runtime.InteropServices.StructLayoutAttribute>steht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3702">It uses the `MySystemTime` class, which is also in the code example for <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span></span>  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="dd86b-3703">Metadaten und selbstbeschreibende Komponenten</span><span class="sxs-lookup"><span data-stu-id="dd86b-3703">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3704">Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Typ- oder Methodendefinition darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3704">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or method.</span></span></summary>
        <value><span data-ttu-id="dd86b-3705"><see langword="true" />, wenn das <see cref="T:System.Type" />-Objekt einen Typparameter einer generischen Typ- oder Methodendefinition darstellt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3705"><see langword="true" /> if the <see cref="T:System.Type" /> object represents a type parameter of a generic type definition or generic method definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3706"><xref:System.Type>Objekte, die generische Typparameter darstellen, können abgerufen werden, <xref:System.Type.GetGenericArguments%2A> indem die- <xref:System.Type> Methode eines-Objekts aufgerufen wird, das eine generische <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> Typdefinition darstellt <xref:System.Reflection.MethodInfo> , oder die-Methode eines-Objekts, das eine generische Methode darstellt. Definition.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3706"><xref:System.Type> objects that represent generic type parameters can be obtained by calling the <xref:System.Type.GetGenericArguments%2A> method of a <xref:System.Type> object that represents a generic type definition, or the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.</span></span>  
  
-   <span data-ttu-id="dd86b-3707">Bei einer generischen Typ-oder Methoden Definition <xref:System.Type.IsGenericParameter%2A> gibt die `true` -Eigenschaft für jedes Element des resultierenden Arrays zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3707">For a generic type or method definition, the <xref:System.Type.IsGenericParameter%2A> property returns `true` for every element of the resulting array.</span></span>  
  
-   <span data-ttu-id="dd86b-3708">Bei einem geschlossenen konstruierten Typ oder einer geschlossenen <xref:System.Type.IsGenericParameter%2A> Methode gibt `false` die-Eigenschaft für jedes Element des Arrays zurück <xref:System.Type.GetGenericArguments%2A> , das von der-Methode zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3708">For a closed constructed type or method, the <xref:System.Type.IsGenericParameter%2A> property returns `false` for every element of the array returned by the <xref:System.Type.GetGenericArguments%2A> method.</span></span>  
  
-   <span data-ttu-id="dd86b-3709">Bei einem offenen konstruierten Typ oder einer offenen Methode können einige Elemente des Arrays bestimmte Typen sein, und andere können Typparameter sein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3709">For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.</span></span> <span data-ttu-id="dd86b-3710"><xref:System.Type.IsGenericParameter%2A>gibt `false` für die Typen und `true` für die Typparameter zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3710"><xref:System.Type.IsGenericParameter%2A> returns `false` for the types and `true` for the type parameters.</span></span> <span data-ttu-id="dd86b-3711">Das Codebeispiel für die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft veranschaulicht eine generische Klasse mit einer Mischung aus Typen und Typparametern.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3711">The code example for the <xref:System.Type.ContainsGenericParameters%2A> property demonstrates a generic class with a mixture of types and type parameters.</span></span>  
  
 <span data-ttu-id="dd86b-3712">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3712">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3713">Im folgenden Beispiel wird die <xref:System.Type.IsGenericParameter%2A> -Eigenschaft verwendet, um auf generische Typparameter in einem generischen Typ zu testen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3713">The following example uses the <xref:System.Type.IsGenericParameter%2A> property to test for generic type parameters in a generic type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="dd86b-3714">Reflektion und generische Typen</span><span class="sxs-lookup"><span data-stu-id="dd86b-3714">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="dd86b-3715">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</span><span class="sxs-lookup"><span data-stu-id="dd86b-3715">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3716">Ruft einen Wert ab, der angibt, ob der aktuelle Typ ein generischer Typ ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3716">Gets a value indicating whether the current type is a generic type.</span></span></summary>
        <value><span data-ttu-id="dd86b-3717"><see langword="true" />, wenn der aktuelle Typ ein generischer Typ ist. <see langword="false" />andernfalls.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3717"><see langword="true" /> if the current type is a generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3718">Mithilfe der <xref:System.Type.IsGenericType%2A> -Eigenschaft können Sie fest <xref:System.Type> stellen, ob ein-Objekt einen generischen Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3718">Use the <xref:System.Type.IsGenericType%2A> property to determine whether a <xref:System.Type> object represents a generic type.</span></span> <span data-ttu-id="dd86b-3719">Verwenden Sie <xref:System.Type.ContainsGenericParameters%2A> die-Eigenschaft, um <xref:System.Type> zu bestimmen, ob ein-Objekt einen geöffneten konstruierten Typ oder einen geschlossenen konstruierten Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3719">Use the <xref:System.Type.ContainsGenericParameters%2A> property to determine whether a <xref:System.Type> object represents an open constructed type or a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-3720">Die <xref:System.Type.IsGenericType%2A> -Eigenschaft `false` gibt zurück, wenn der unmittelbare Typ nicht generisch ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3720">The <xref:System.Type.IsGenericType%2A> property returns `false` if the immediate type is not generic.</span></span> <span data-ttu-id="dd86b-3721">Beispielsweise ist ein Array, dessen Elemente vom Typ `A<int>` (`A(Of Integer)` in Visual Basic) sind, nicht selbst ein generischer Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3721">For example, an array whose elements are of type `A<int>` (`A(Of Integer)` in Visual Basic) is not itself a generic type.</span></span>  
  
 <span data-ttu-id="dd86b-3722">In der folgenden Tabelle werden die invarianten Bedingungen für allgemeine Begriffe zusammengefasst, die bei allgemeiner Reflektion verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3722">The following table summarizes the invariant conditions for common terms used in generic reflection.</span></span>  
  
|<span data-ttu-id="dd86b-3723">Begriff</span><span class="sxs-lookup"><span data-stu-id="dd86b-3723">Term</span></span>|<span data-ttu-id="dd86b-3724">Invariante</span><span class="sxs-lookup"><span data-stu-id="dd86b-3724">Invariant</span></span>|  
|----------|---------------|  
|<span data-ttu-id="dd86b-3725">generische Typdefinition</span><span class="sxs-lookup"><span data-stu-id="dd86b-3725">generic type definition</span></span>|<span data-ttu-id="dd86b-3726">Die <xref:System.Type.IsGenericTypeDefinition%2A>-Eigenschaft ist `true`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3726">The <xref:System.Type.IsGenericTypeDefinition%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="dd86b-3727">Definiert einen generischen Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3727">Defines a generic type.</span></span> <span data-ttu-id="dd86b-3728">Ein konstruierter Typ wird erstellt, indem <xref:System.Type.MakeGenericType%2A> die-Methode <xref:System.Type> für ein-Objekt aufgerufen wird, das eine generische Typdefinition darstellt und ein Array von Typargumenten angibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3728">A constructed type is created by calling the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object that represents a generic type definition and specifying an array of type arguments.</span></span><br /><br /> <span data-ttu-id="dd86b-3729"><xref:System.Type.MakeGenericType%2A>kann nur für generische Typdefinitionen aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3729"><xref:System.Type.MakeGenericType%2A> can be called only on generic type definitions.</span></span><br /><br /> <span data-ttu-id="dd86b-3730">Jede generische Typdefinition ist ein generischer Typ ( <xref:System.Type.IsGenericType%2A> die- `true`Eigenschaft ist), aber das Gegenteil ist nicht "true".</span><span class="sxs-lookup"><span data-stu-id="dd86b-3730">Any generic type definition is a generic type (the <xref:System.Type.IsGenericType%2A> property is `true`), but the converse is not true.</span></span>|  
|<span data-ttu-id="dd86b-3731">generischer Typ</span><span class="sxs-lookup"><span data-stu-id="dd86b-3731">generic type</span></span>|<span data-ttu-id="dd86b-3732">Die <xref:System.Type.IsGenericType%2A>-Eigenschaft ist `true`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3732">The <xref:System.Type.IsGenericType%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="dd86b-3733">Dabei kann es sich um eine generische Typdefinition, einen offenen konstruierten Typ oder einen geschlossenen konstruierten Typ handeln.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3733">Can be a generic type definition, an open constructed type, or a closed constructed type.</span></span><br /><br /> <span data-ttu-id="dd86b-3734">Beachten Sie, dass ein Arraytyp, dessen Elementtyp generisch ist, nicht selbst ein generischer Typ ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3734">Note that an array type whose element type is generic is not itself a generic type.</span></span> <span data-ttu-id="dd86b-3735">Das gleiche gilt für ein <xref:System.Type> -Objekt, das einen Zeiger auf einen generischen Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3735">The same is true of a <xref:System.Type> object representing a pointer to a generic type.</span></span>|  
|<span data-ttu-id="dd86b-3736">erstellter Typ öffnen</span><span class="sxs-lookup"><span data-stu-id="dd86b-3736">open constructed type</span></span>|<span data-ttu-id="dd86b-3737">Die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft ist `true`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3737">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="dd86b-3738">Beispiele sind ein generischer Typ, der nicht zugewiesene Typparameter aufweist, ein Typ, der in einer generischen Typdefinition oder in einem geöffneten konstruierten Typ oder ein generischer Typ mit einem Typargument <xref:System.Type.ContainsGenericParameters%2A> , für `true`das die-Eigenschaft ist, eingebettet ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3738">Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="dd86b-3739">Es ist nicht möglich, eine Instanz eines geöffneten konstruierten Typs zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3739">It is not possible to create an instance of an open constructed type.</span></span><br /><br /> <span data-ttu-id="dd86b-3740">Beachten Sie, dass nicht alle offenen konstruierten Typen generisch sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3740">Note that not all open constructed types are generic.</span></span> <span data-ttu-id="dd86b-3741">Beispielsweise ist ein Array, dessen Elementtyp eine generische Typdefinition ist, nicht generisch, und ein Zeiger auf einen geöffneten konstruierten Typ ist nicht generisch.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3741">For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</span></span>|  
|<span data-ttu-id="dd86b-3742">geschlossener konstruierter Typ</span><span class="sxs-lookup"><span data-stu-id="dd86b-3742">closed constructed type</span></span>|<span data-ttu-id="dd86b-3743">Die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft ist `false`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3743">The <xref:System.Type.ContainsGenericParameters%2A> property is `false`.</span></span><br /><br /> <span data-ttu-id="dd86b-3744">Bei rekursiver unter Prüfung verfügt der Typ nicht über nicht zugewiesene generische Parameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3744">When examined recursively, the type has no unassigned generic parameters.</span></span>|  
|<span data-ttu-id="dd86b-3745">generischer Typparameter</span><span class="sxs-lookup"><span data-stu-id="dd86b-3745">generic type parameter</span></span>|<span data-ttu-id="dd86b-3746">Die <xref:System.Type.IsGenericParameter%2A>-Eigenschaft ist `true`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3746">The <xref:System.Type.IsGenericParameter%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="dd86b-3747">Die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft ist `true`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3747">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="dd86b-3748">In einer generischen Typdefinition ein Platzhalter für einen Typ, der später zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3748">In a generic type definition, a placeholder for a type that will be assigned later.</span></span>|  
|<span data-ttu-id="dd86b-3749">generisches Typargument</span><span class="sxs-lookup"><span data-stu-id="dd86b-3749">generic type argument</span></span>|<span data-ttu-id="dd86b-3750">Kann ein beliebiger Typ sein, einschließlich eines generischen Typparameters.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3750">Can be any type, including a generic type parameter.</span></span><br /><br /> <span data-ttu-id="dd86b-3751">Typargumente werden als Array von <xref:System.Type> -Objekten angegeben, <xref:System.Type.MakeGenericType%2A> die beim Erstellen eines konstruierten generischen Typs an die Methode übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3751">Type arguments are specified as an array of <xref:System.Type> objects passed to the <xref:System.Type.MakeGenericType%2A> method when creating a constructed generic type.</span></span> <span data-ttu-id="dd86b-3752">Wenn Instanzen des resultierenden Typs erstellt werden sollen, muss die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft für alle Typargumente lauten. `false`</span><span class="sxs-lookup"><span data-stu-id="dd86b-3752">If instances of the resulting type are to be created, the <xref:System.Type.ContainsGenericParameters%2A> property must be `false` for all the type arguments.</span></span>|  
  
 <span data-ttu-id="dd86b-3753">Im folgenden Codebeispiel und in der Tabelle werden einige dieser Begriffe und invarianten veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3753">The following code example and table illustrate some of these terms and invariants.</span></span> <span data-ttu-id="dd86b-3754">Die `Derived` -Klasse ist von besonderem Interesse, da ihr Basistyp ein konstruierter Typ ist, der über eine Mischung aus Typen und Typparametern in der Typargument Liste verfügt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3754">The `Derived` class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 <span data-ttu-id="dd86b-3755">In der folgenden Tabelle sind Beispiele aufgeführt, in denen die- `Base`Klassen `Derived`, und `G`verwendet und erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3755">The following table shows examples that use and build on the classes `Base`, `Derived`, and `G`.</span></span> <span data-ttu-id="dd86b-3756">Wenn der C++ - C# und der-Code identisch sind, wird nur ein Eintrag angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3756">When the C++ and C# code is the same, only one entry is shown.</span></span>  
  
|<span data-ttu-id="dd86b-3757">Beispiel</span><span class="sxs-lookup"><span data-stu-id="dd86b-3757">Example</span></span>|<span data-ttu-id="dd86b-3758">Invarianten</span><span class="sxs-lookup"><span data-stu-id="dd86b-3758">Invariants</span></span>|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|<span data-ttu-id="dd86b-3759">Für diesen Typ:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3759">For this type:</span></span><br /><br /> <span data-ttu-id="dd86b-3760"><xref:System.Type.IsGenericType%2A> ist `true`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3760"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="dd86b-3761"><xref:System.Type.IsGenericTypeDefinition%2A> ist `true`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3761"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="dd86b-3762"><xref:System.Type.ContainsGenericParameters%2A> ist `true`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3762"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|<span data-ttu-id="dd86b-3763">Für diesen Typ:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3763">For this type:</span></span><br /><br /> <span data-ttu-id="dd86b-3764"><xref:System.Type.IsGenericType%2A> ist `true`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3764"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="dd86b-3765"><xref:System.Type.IsGenericTypeDefinition%2A> ist `false`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3765"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="dd86b-3766"><xref:System.Type.ContainsGenericParameters%2A> ist `true`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3766"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|<span data-ttu-id="dd86b-3767">Für den Typ der Variablen `d`:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3767">For the type of variable `d`:</span></span><br /><br /> <span data-ttu-id="dd86b-3768"><xref:System.Type.IsGenericType%2A>ist `false` , `d` weil ein Array ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3768"><xref:System.Type.IsGenericType%2A> is `false` because `d` is an array.</span></span><br /><br /> <span data-ttu-id="dd86b-3769"><xref:System.Type.IsGenericTypeDefinition%2A> ist `false`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3769"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="dd86b-3770"><xref:System.Type.ContainsGenericParameters%2A> ist `false`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3770"><xref:System.Type.ContainsGenericParameters%2A> is `false`.</span></span>|  
|<span data-ttu-id="dd86b-3771">`T`, `U` und`V` (überall angezeigt)</span><span class="sxs-lookup"><span data-stu-id="dd86b-3771">`T`, `U`, and `V` (everywhere they appear)</span></span>|<span data-ttu-id="dd86b-3772"><xref:System.Type.IsGenericParameter%2A> ist `true`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3772"><xref:System.Type.IsGenericParameter%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="dd86b-3773"><xref:System.Type.IsGenericType%2A>liegt `false` daran, dass es keine Möglichkeit gibt, einen Typparameter auf generische Typen zu beschränken.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3773"><xref:System.Type.IsGenericType%2A> is `false` because there is no way to constrain a type parameter to generic types.</span></span><br /><br /> <span data-ttu-id="dd86b-3774"><xref:System.Type.IsGenericTypeDefinition%2A> ist `false`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3774"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="dd86b-3775"><xref:System.Type.ContainsGenericParameters%2A>liegt `true` daran `T`, `U`dass, und`V` selbst generische Typparameter sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3775"><xref:System.Type.ContainsGenericParameters%2A> is `true` because `T`, `U`, and `V` are themselves generic type parameters.</span></span> <span data-ttu-id="dd86b-3776">Dies impliziert nicht etwas über Typargumente, die später zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3776">This does not imply anything about type arguments that are assigned to them later.</span></span>|  
|<span data-ttu-id="dd86b-3777">Der Feldtyp.`F`</span><span class="sxs-lookup"><span data-stu-id="dd86b-3777">The type of field `F`</span></span>|<span data-ttu-id="dd86b-3778"><xref:System.Type.IsGenericType%2A> ist `true`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3778"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="dd86b-3779"><xref:System.Type.IsGenericTypeDefinition%2A>liegt `false` daran, dass dem Typparameter von `G`ein Typ zugewiesen wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3779"><xref:System.Type.IsGenericTypeDefinition%2A> is `false` because a type has been assigned to the type parameter of `G`.</span></span> <span data-ttu-id="dd86b-3780">Beachten Sie, dass dies der <xref:System.Type.MakeGenericType%2A> Methode entspricht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3780">Note that this is equivalent to having called the <xref:System.Type.MakeGenericType%2A> method.</span></span><br /><br /> <span data-ttu-id="dd86b-3781"><xref:System.Type.ContainsGenericParameters%2A>liegt `true` daran, dass der Feldtyp `F` über ein Typargument verfügt, das ein offener konstruierter Typ ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3781"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the type of field `F` has a type argument that is an open constructed type.</span></span> <span data-ttu-id="dd86b-3782">Der konstruierte Typ ist offen, da sein Typargument ( `Base`d. h.) eine generische Typdefinition ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3782">The constructed type is open because its type argument (that is, `Base`) is a generic type definition.</span></span> <span data-ttu-id="dd86b-3783">Dadurch wird die rekursive Natur der <xref:System.Type.IsGenericType%2A> Eigenschaft veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3783">This illustrates the recursive nature of the <xref:System.Type.IsGenericType%2A> property.</span></span>|  
|<span data-ttu-id="dd86b-3784">Die-Klasse, die die Klasse`Nested`</span><span class="sxs-lookup"><span data-stu-id="dd86b-3784">The nested class `Nested`</span></span>|<span data-ttu-id="dd86b-3785"><xref:System.Type.IsGenericType%2A>ist `true`, obwohl die `Nested` -Klasse über keine eigenen generischen Typparameter verfügt, da Sie in einem generischen Typ eingebettet ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3785"><xref:System.Type.IsGenericType%2A> is `true`, even though the `Nested` class has no generic type parameters of its own, because it is nested in a generic type.</span></span><br /><br /> <span data-ttu-id="dd86b-3786"><xref:System.Type.IsGenericTypeDefinition%2A> ist `true`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3786"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span> <span data-ttu-id="dd86b-3787">Das heißt, Sie können die <xref:System.Type.MakeGenericType%2A> -Methode aufrufen und den Typparameter des einschließenden `Derived`Typs angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3787">That is, you can call the <xref:System.Type.MakeGenericType%2A> method and supply the type parameter of the enclosing type, `Derived`.</span></span><br /><br /> <span data-ttu-id="dd86b-3788"><xref:System.Type.ContainsGenericParameters%2A>liegt `true` daran, dass der einschließende `Derived`Typ,, über generische Typparameter verfügt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3788"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the enclosing type, `Derived`, has generic type parameters.</span></span> <span data-ttu-id="dd86b-3789">Dadurch wird die rekursive Natur der <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3789">This illustrates the recursive nature of the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3790">Im folgenden Codebeispiel <xref:System.Type.IsGenericType%2A>wird der Wert der Eigenschaften,, <xref:System.Type.IsGenericParameter%2A>und <xref:System.Type.ContainsGenericParameters%2A> für die Typen angezeigt, die im Abschnitt "Hinweise" beschrieben werden <xref:System.Type.IsGenericTypeDefinition%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3790">The following code example displays the value of the <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, and <xref:System.Type.ContainsGenericParameters%2A> properties for the types described in the Remarks section.</span></span> <span data-ttu-id="dd86b-3791">Erläuterungen zu den Eigenschafts Werten finden Sie in der zugehörigen Tabelle unter "Hinweise".</span><span class="sxs-lookup"><span data-stu-id="dd86b-3791">For explanations of the property values, see the accompanying table in Remarks.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="dd86b-3792">Reflektion und generische Typen</span><span class="sxs-lookup"><span data-stu-id="dd86b-3792">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="dd86b-3793">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</span><span class="sxs-lookup"><span data-stu-id="dd86b-3793">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3794">Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> eine generische Typdefinition darstellt, aus der andere generische Typen konstruiert werden können.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3794">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a generic type definition, from which other generic types can be constructed.</span></span></summary>
        <value><span data-ttu-id="dd86b-3795"><see langword="true" />, wenn das <see cref="T:System.Type" />-Objekt eine generische Typdefinition darstellt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3795"><see langword="true" /> if the <see cref="T:System.Type" /> object represents a generic type definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3796">Eine generische Typdefinition ist eine Vorlage, von der andere Typen erstellt werden können.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3796">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="dd86b-3797">Beispielsweise aus der generischen Typdefinition `G<T>` (ausgedrückt in C# Syntax). `G(Of Integer)` <xref:System.Type.MakeGenericType%2A> `G<int>` in Visual Basic oder `generic <typename T> ref class G` in C++) können Sie den-Typ (in Visual Basic) erstellen und instanziieren, indem Sie die-Methode mit einer generischen Argumentliste aufrufen, die das `G(Of T)` <xref:System.Int32>geben Sie ein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3797">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic), by calling the <xref:System.Type.MakeGenericType%2A> method with a generic argument list containing the <xref:System.Int32> type.</span></span> <span data-ttu-id="dd86b-3798">Bei einem <xref:System.Type> -Objekt, das diesen konstruierten <xref:System.Type.GetGenericTypeDefinition%2A> Typ darstellt, ruft die-Methode die generische Typdefinition erneut ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3798">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method gets the generic type definition back again.</span></span>  
  
 <span data-ttu-id="dd86b-3799">Verwenden Sie <xref:System.Type.IsGenericTypeDefinition%2A> die-Eigenschaft, um zu bestimmen, ob Sie neue Typen aus dem aktuellen Typ erstellen können.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3799">Use the <xref:System.Type.IsGenericTypeDefinition%2A> property to determine whether you can create new types from the current type.</span></span> <span data-ttu-id="dd86b-3800">Wenn die <xref:System.Type.IsGenericTypeDefinition%2A> -Eigenschaft `true`zurückgibt, kann die <xref:System.Type.MakeGenericType%2A> -Methode aufgerufen werden, um neue generische Typen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3800">If the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `true`, you can call the <xref:System.Type.MakeGenericType%2A> method to create new generic types.</span></span>  
  
 <span data-ttu-id="dd86b-3801">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3801">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3802">Im folgenden Beispiel werden Informationen zu einem Typ, einschließlich der Angabe, ob es sich um eine generische Typdefinition handelt, angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3802">The following example displays information about a type, including whether or not it is a generic type definition.</span></span> <span data-ttu-id="dd86b-3803">Informationen werden für einen konstruierten Typ, für die generische Typdefinition und für einen normalen Typ angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3803">Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="dd86b-3804">Reflektion und generische Typen</span><span class="sxs-lookup"><span data-stu-id="dd86b-3804">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="dd86b-3805">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</span><span class="sxs-lookup"><span data-stu-id="dd86b-3805">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3806">Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> ein <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />-Attribut hat, was bedeutet, dass er aus einer COM-Typbibliothek importiert wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3806">Gets a value indicating whether the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> attribute applied, indicating that it was imported from a COM type library.</span></span></summary>
        <value><span data-ttu-id="dd86b-3807"><see langword="true" />, wenn der <see cref="T:System.Type" /> ein <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> hat, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3807"><see langword="true" /> if the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3808">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3808">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="dd86b-3809">Wenn der aktuelle <xref:System.Type> z. b. `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic) darstellt, wird der Wert dieser Eigenschaft durch`MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="dd86b-3809">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="dd86b-3810">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `false`Eigenschaft immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3810">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="dd86b-3811">Das mit dem aktuellen Typ zu vergleichende Objekt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3811">The object to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="dd86b-3812">Bestimmt, ob das angegebene Objekt eine Instanz des aktuellen <see cref="T:System.Type" /> ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3812">Determines whether the specified object is an instance of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3813"><see langword="true" />, wenn der aktuelle <see langword="Type" /> in der Vererbungshierarchie des von <paramref name="o" /> dargestellten Objekts vorhanden ist oder wenn der aktuelle <see langword="Type" /> eine Schnittstelle ist, die von <paramref name="o" /> implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3813"><see langword="true" /> if the current <see langword="Type" /> is in the inheritance hierarchy of the object represented by <paramref name="o" />, or if the current <see langword="Type" /> is an interface that <paramref name="o" /> implements.</span></span> <span data-ttu-id="dd86b-3814"><see langword="false" />, wenn keine dieser Bedingungen zutrifft, wenn <paramref name="o" /> den Wert <see langword="null" /> hat oder wenn der aktuelle <see langword="Type" /> ein offener generischer Typ ist (d. h. <see cref="P:System.Type.ContainsGenericParameters" /> gibt <see langword="true" /> zurück).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3814"><see langword="false" /> if neither of these conditions is the case, if <paramref name="o" /> is <see langword="null" />, or if the current <see langword="Type" /> is an open generic type (that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3815">Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3815">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-3816">Ein konstruierter Typ ist keine Instanz seiner generischen Typdefinition.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3816">A constructed type is not an instance of its generic type definition.</span></span> <span data-ttu-id="dd86b-3817">Das heißt, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) ist keine Instanz von `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3817">That is, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) is not an instance of `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3818">Im folgenden Beispiel wird die Verwendung der `IsInstanceOfType`-Methode gezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3818">The following example demonstrates the use of the `IsInstanceOfType` method.</span></span>  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3819">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> eine Schnittstelle ist, d. h. weder eine Klasse noch ein Werttyp.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3819">Gets a value indicating whether the <see cref="T:System.Type" /> is an interface; that is, not a class or a value type.</span></span></summary>
        <value><span data-ttu-id="dd86b-3820"><see langword="true" />, wenn <see cref="T:System.Type" /> eine Schnittstelle ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3820"><see langword="true" /> if the <see cref="T:System.Type" /> is an interface; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3821">Unter <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> scheidet eine Typdeklaration als Klasse, Schnittstelle oder Werttyp.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3821">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distinguishes a type declaration as class, interface or value type.</span></span>  
  
 <span data-ttu-id="dd86b-3822">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `false`Eigenschaft immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3822">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="dd86b-3823">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3823">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3824">Im folgenden Beispiel wird eine Schnittstelle erstellt, die auf den Schnittstellentyp überprüft wird und angegeben wird `IsInterface` , ob für eine Klasse die-Eigenschaft festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3824">The following example creates an interface, checks for the interface type, and indicates whether a class has the `IsInterface` property set.</span></span>  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3825">Ruft einen Wert ab, der angibt, ob die Felder des aktuellen Typs sequenziell angelegt werden, in der Reihenfolge, in der sie definiert oder an die Metadaten ausgegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3825">Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</span></span></summary>
        <value><span data-ttu-id="dd86b-3826"><see langword="true" />, wenn die <see cref="P:System.Type.Attributes" />-Eigenschaft des aktuellen Typs <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /> umfasst; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3826"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3827">Diese Eigenschaft wird als praktische Hilfe bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3827">This property is provided as a convenience.</span></span> <span data-ttu-id="dd86b-3828">Alternativ können Sie den- <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> Enumerationswert verwenden, um die Typlayoutattribute auszuwählen, und dann testen, ob <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3828">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="dd86b-3829">Die <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>Enumerationswerte, und <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> geben an, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>wie die Felder des Typs im Arbeitsspeicher angeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3829">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="dd86b-3830">Bei dynamischen Typen können Sie angeben <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> , wann der Typ erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3830">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="dd86b-3831">Wenden Sie im Code das <xref:System.Runtime.InteropServices.StructLayoutAttribute> -Attribut mit <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> dem-Enumerationswert auf den-Typ an, um anzugeben, dass das Layout sequenziell ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3831">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value to the type, to specify that layout is sequential.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-3832">Sie können die <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> -Methode nicht verwenden, um <xref:System.Runtime.InteropServices.StructLayoutAttribute> zu bestimmen, ob auf einen Typ angewendet wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3832">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="dd86b-3833">Weitere Informationen finden Sie im Abschnitt 9.1.2 der Spezifikation für die Common Language Infrastructure (CLI)-Dokumentation "Partition II: Metadatendefinition und-Semantik ".</span><span class="sxs-lookup"><span data-stu-id="dd86b-3833">For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="dd86b-3834">Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](https://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](https://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3834">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="dd86b-3835">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3835">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="dd86b-3836">Wenn der <xref:System.Type> aktuelle z. b. `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic) darstellt, wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3836">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="dd86b-3837">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `false`Eigenschaft immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3837">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3838">Im folgenden Beispiel wird eine Instanz einer-Klasse erstellt, für <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> die der-Enumerationswert in der <xref:System.Runtime.InteropServices.StructLayoutAttribute> -Klasse <xref:System.Type.IsLayoutSequential%2A> festgelegt wurde, die-Eigenschaft überprüft und das Ergebnis anzeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3838">The following example creates an instance of a class for which the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value in the <xref:System.Runtime.InteropServices.StructLayoutAttribute> class has been set, checks for the <xref:System.Type.IsLayoutSequential%2A> property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="dd86b-3839">Metadaten und selbstbeschreibende Komponenten</span><span class="sxs-lookup"><span data-stu-id="dd86b-3839">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3840">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> als Verweis gemarshallt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3840">Gets a value indicating whether the <see cref="T:System.Type" /> is marshaled by reference.</span></span></summary>
        <value><span data-ttu-id="dd86b-3841"><see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis gemarshallt wird, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3841"><see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="dd86b-3842">Im folgenden Beispiel werden die `IsContextful`Eigenschaften <xref:System.Type.IsMarshalByRef%2A>, und <xref:System.Type.IsPrimitive%2A> der <xref:System.Type> -Klasse veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3842">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="dd86b-3843">Er überprüft, ob der angegebene Typ im Kontext gehostet werden kann, ob er als Verweis gemarshallt werden kann und ob der Typ ein primitiver Datentyp ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3843">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-3844">Implementiert die <see cref="P:System.Type.IsMarshalByRef" />-Eigenschaft und bestimmt, ob der <see cref="T:System.Type" /> als Verweis gemarshallt wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3844">Implements the <see cref="P:System.Type.IsMarshalByRef" /> property and determines whether the <see cref="T:System.Type" /> is marshaled by reference.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3845"><see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis gemarshallt wird, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3845"><see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3846">Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3846">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3847">Im folgenden Beispiel wird ermittelt, ob der angegebene Typ als Verweis gemarshallt wird, und das Ergebnis wird angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3847">The following example determines whether the given type is marshaled by reference and displays the result.</span></span>  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3848">Ruft einen Wert ab, der angibt, ob das aktuelle <see cref="T:System.Type" />-Objekt einen Typ darstellt, dessen Definition in der Definition eines anderen Typs geschachtelt ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3848">Gets a value indicating whether the current <see cref="T:System.Type" /> object represents a type whose definition is nested inside the definition of another type.</span></span></summary>
        <value><span data-ttu-id="dd86b-3849"><see langword="true" />, wenn der <see cref="T:System.Type" /> in einem anderen Typ geschachtelt ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3849"><see langword="true" /> if the <see cref="T:System.Type" /> is nested inside another type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3850">Die <xref:System.Type.IsNested%2A> -Eigenschaft `true` gibt für alle Typen unabhängig von der Sichtbarkeit zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3850">The <xref:System.Type.IsNested%2A> property returns `true` for all nested types, regardless of visibility.</span></span> <span data-ttu-id="dd86b-3851">Um gleichzeitig auf Schachtelung und Sichtbarkeit zu testen, verwenden Sie <xref:System.Type.IsNestedAssembly%2A>die <xref:System.Type.IsNestedFamily%2A>zugehörigen <xref:System.Type.IsNestedFamANDAssem%2A>Eigenschaften <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>,, <xref:System.Type.IsNestedPublic%2A>, oder.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3851">To test for nesting and visibility at the same time, use the related properties <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, or <xref:System.Type.IsNestedPublic%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-3852">Der <xref:System.Reflection.TypeAttributes.VisibilityMask> Enumerationsmember wählt die Sichtbarkeits Attribute für einen Typ aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3852">The <xref:System.Reflection.TypeAttributes.VisibilityMask> enumeration member selects the visibility attributes for a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3853">Im folgenden Beispiel wird eine äußere Klasse mit einer Reihe von Klassen erstellt, die verschiedene Arten von Sichtbarkeit aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3853">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="dd86b-3854">Anschließend wird der Wert einer Reihe von Sichtbarkeits bezogenen <xref:System.Type> Eigenschaften für den übergeordneten Typ und jeden der zugehörigen untergeordneten Typen abgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3854">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3855">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Assembly sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3855">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own assembly.</span></span></summary>
        <value><span data-ttu-id="dd86b-3856"><see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Assembly sichtbar ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3856"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3857">Wenn der aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft immer `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3857">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="dd86b-3858"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>wählt die Sichtbarkeits Attribute aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3858"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3859">Im folgenden Beispiel wird eine äußere Klasse mit einer Reihe von Klassen erstellt, die verschiedene Arten von Sichtbarkeit aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3859">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="dd86b-3860">Anschließend wird der Wert einer Reihe von Sichtbarkeits bezogenen <xref:System.Type> Eigenschaften für den übergeordneten Typ und jeden der zugehörigen untergeordneten Typen abgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3860">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3861">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die sowohl zur eigenen Familie als auch zur eigenen Assembly gehören.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3861">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly.</span></span></summary>
        <value><span data-ttu-id="dd86b-3862"><see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die sowohl zur eigenen Familie als auch zur eigenen Assembly gehören, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3862"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3863">Wenn der aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft immer `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3863">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="dd86b-3864"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>wählt die Sichtbarkeits Attribute aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3864"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-3865">Die C# Sprachen und Visual Basic enthalten keine Semantik, mit der Sie einen nicht definierten Typ definieren können, der nur für geschützte Typen in der eigenen Assembly sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3865">The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.</span></span> <span data-ttu-id="dd86b-3866">`protected internal`Sichtbarkeit C# in `Protected Friend` und Sichtbarkeit in Visual Basic definieren Sie einen Typ, der sowohl für geschützte Typen als auch für Typen in derselben Assembly sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3866">`protected internal` visibility in C# and `Protected Friend` visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.</span></span>  
  
 <span data-ttu-id="dd86b-3867">Die <xref:System.Type> -Familie eines-Objekts wird als alle Objekte desselben <xref:System.Type> und seiner Untertypen definiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3867">A <xref:System.Type> object's family is defined as all objects of the same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3868">Im folgenden Beispiel wird eine äußere Klasse mit einer Reihe von Klassen erstellt, die verschiedene Arten von Sichtbarkeit aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3868">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="dd86b-3869">Anschließend wird der Wert einer Reihe von Sichtbarkeits bezogenen <xref:System.Type> Eigenschaften für den übergeordneten Typ und jeden der zugehörigen untergeordneten Typen abgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3869">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3870">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Familie sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3870">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own family.</span></span></summary>
        <value><span data-ttu-id="dd86b-3871"><see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Familie sichtbar ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3871"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own family; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3872">Wenn der aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft immer `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3872">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="dd86b-3873"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>wählt die Sichtbarkeits Attribute aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3873"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="dd86b-3874">Die <xref:System.Type> -Familie eines-Objekts wird als alle-Objekte genau derselben <xref:System.Type> und seiner Untertypen definiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3874">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3875">Im folgenden Beispiel wird eine äußere Klasse mit einer Reihe von Klassen erstellt, die verschiedene Arten von Sichtbarkeit aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3875">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="dd86b-3876">Anschließend wird der Wert einer Reihe von Sichtbarkeits bezogenen <xref:System.Type> Eigenschaften für den übergeordneten Typ und jeden der zugehörigen untergeordneten Typen abgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3876">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3877">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die zur eigenen Familie oder zur eigenen Assembly gehören.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3877">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to either its own family or to its own assembly.</span></span></summary>
        <value><span data-ttu-id="dd86b-3878"><see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die zur eigenen Familie oder zur eigenen Assembly gehören, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3878"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3879">Wenn die Sichtbarkeit eines Typs in `protected internal` C# oder `Protected Friend` Visual Basic ist, gibt die <xref:System.Type.IsNestedFamORAssem%2A> -Eigenschaft `true`zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3879">If the visibility of a type is `protected internal` in C# or `Protected Friend` in Visual Basic, the <xref:System.Type.IsNestedFamORAssem%2A> property returns `true`.</span></span>  
  
 <span data-ttu-id="dd86b-3880">Wenn der aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft immer `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3880">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="dd86b-3881"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>wählt die Sichtbarkeits Attribute aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3881"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="dd86b-3882">Die <xref:System.Type> -Familie eines-Objekts wird als alle-Objekte genau derselben <xref:System.Type> und seiner Untertypen definiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3882">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3883">Im folgenden Beispiel wird eine äußere Klasse mit einer Reihe von Klassen erstellt, die verschiedene Arten von Sichtbarkeit aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3883">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="dd86b-3884">Anschließend wird der Wert einer Reihe von Sichtbarkeits bezogenen <xref:System.Type> Eigenschaften für den übergeordneten Typ und jeden der zugehörigen untergeordneten Typen abgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3884">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3885">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und als privat deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3885">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and declared private.</span></span></summary>
        <value><span data-ttu-id="dd86b-3886"><see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und als privat deklariert ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3886"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and declared private; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3887">Wenn der aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft immer `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3887">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="dd86b-3888"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>wählt die Sichtbarkeits Attribute aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3888"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3889">Im folgenden Beispiel wird eine äußere Klasse mit einer Reihe von Klassen erstellt, die verschiedene Arten von Sichtbarkeit aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3889">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="dd86b-3890">Anschließend wird der Wert einer Reihe von Sichtbarkeits bezogenen <xref:System.Type> Eigenschaften für den übergeordneten Typ und jeden der zugehörigen untergeordneten Typen abgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3890">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3891">Ruft einen Wert ab, der angibt, ob eine Klasse geschachtelt und als öffentlich deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3891">Gets a value indicating whether a class is nested and declared public.</span></span></summary>
        <value><span data-ttu-id="dd86b-3892"><see langword="true" />, wenn die Klasse geschachtelt und als öffentlich deklariert ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3892"><see langword="true" /> if the class is nested and declared public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3893">Wenn der aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft immer `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3893">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="dd86b-3894"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>wählt die Sichtbarkeits Attribute aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3894"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3895">Im folgenden Beispiel wird eine äußere Klasse mit einer Reihe von Klassen erstellt, die verschiedene Arten von Sichtbarkeit aufweisen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3895">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="dd86b-3896">Anschließend wird der Wert einer Reihe von Sichtbarkeits bezogenen <xref:System.Type> Eigenschaften für den übergeordneten Typ und jeden der zugehörigen untergeordneten Typen abgerufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3896">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3897">Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> nicht als öffentlich deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3897">Gets a value indicating whether the <see cref="T:System.Type" /> is not declared public.</span></span></summary>
        <value><span data-ttu-id="dd86b-3898"><see langword="true" />, wenn der <see cref="T:System.Type" /> nicht als öffentlich deklariert und kein geschachtelter Typ ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3898"><see langword="true" /> if the <see cref="T:System.Type" /> is not declared public and is not a nested type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3899">Verwenden Sie diese Eigenschaft nicht mit den folgenden Typen: Verwenden Sie <xref:System.Type.IsNestedPublic%2A> stattdessen die-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3899">Do not use this property with nested types; use the <xref:System.Type.IsNestedPublic%2A> property instead.</span></span>  
  
 <span data-ttu-id="dd86b-3900">Wenn der aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3900">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3901">In diesem Beispiel wird `IsNotPublic` die-Eigenschaft verwendet, um die Sichtbarkeit des Typs zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3901">This example uses the `IsNotPublic` property to get the visibility of the type.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 <span data-ttu-id="dd86b-3902">Im folgenden Codebeispiel wird veranschaulicht, warum Sie `IsPublic` und `IsNotPublic` nicht für geschlagelte Klassen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3902">The following code example demonstrates why you cannot use `IsPublic` and `IsNotPublic` for nested classes.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 <span data-ttu-id="dd86b-3903">Ignorieren Sie bei der-Klasse die Ergebnisse von `IsPublic` und `IsNotPublic` , und achten Sie nur auf die Ergebnisse `IsNestedPublic` von `IsNestedPrivate`und.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3903">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of `IsNestedPublic` and `IsNestedPrivate`.</span></span> <span data-ttu-id="dd86b-3904">Die Reflektionsausgabe für dieses Code Fragment lautet wie folgt:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3904">The reflection output for this code fragment would be as follows:</span></span>  
  
|<span data-ttu-id="dd86b-3905">Klasse</span><span class="sxs-lookup"><span data-stu-id="dd86b-3905">Class</span></span>|<span data-ttu-id="dd86b-3906">IsNotPublic</span><span class="sxs-lookup"><span data-stu-id="dd86b-3906">IsNotPublic</span></span>|<span data-ttu-id="dd86b-3907">IsPublic</span><span class="sxs-lookup"><span data-stu-id="dd86b-3907">IsPublic</span></span>|<span data-ttu-id="dd86b-3908">IsNestedPublic</span><span class="sxs-lookup"><span data-stu-id="dd86b-3908">IsNestedPublic</span></span>|<span data-ttu-id="dd86b-3909">IsNestedPrivate</span><span class="sxs-lookup"><span data-stu-id="dd86b-3909">IsNestedPrivate</span></span>|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|<span data-ttu-id="dd86b-3910">A</span><span class="sxs-lookup"><span data-stu-id="dd86b-3910">A</span></span>|<span data-ttu-id="dd86b-3911">false</span><span class="sxs-lookup"><span data-stu-id="dd86b-3911">FALSE</span></span>|<span data-ttu-id="dd86b-3912">true</span><span class="sxs-lookup"><span data-stu-id="dd86b-3912">TRUE</span></span>|<span data-ttu-id="dd86b-3913">false</span><span class="sxs-lookup"><span data-stu-id="dd86b-3913">FALSE</span></span>|<span data-ttu-id="dd86b-3914">false</span><span class="sxs-lookup"><span data-stu-id="dd86b-3914">FALSE</span></span>|  
|<span data-ttu-id="dd86b-3915">B</span><span class="sxs-lookup"><span data-stu-id="dd86b-3915">B</span></span>|<span data-ttu-id="dd86b-3916">false</span><span class="sxs-lookup"><span data-stu-id="dd86b-3916">FALSE</span></span>|<span data-ttu-id="dd86b-3917">false</span><span class="sxs-lookup"><span data-stu-id="dd86b-3917">FALSE</span></span>|<span data-ttu-id="dd86b-3918">true</span><span class="sxs-lookup"><span data-stu-id="dd86b-3918">TRUE</span></span>|<span data-ttu-id="dd86b-3919">false</span><span class="sxs-lookup"><span data-stu-id="dd86b-3919">FALSE</span></span>|  
|<span data-ttu-id="dd86b-3920">C</span><span class="sxs-lookup"><span data-stu-id="dd86b-3920">C</span></span>|<span data-ttu-id="dd86b-3921">false</span><span class="sxs-lookup"><span data-stu-id="dd86b-3921">FALSE</span></span>|<span data-ttu-id="dd86b-3922">false</span><span class="sxs-lookup"><span data-stu-id="dd86b-3922">FALSE</span></span>|<span data-ttu-id="dd86b-3923">false</span><span class="sxs-lookup"><span data-stu-id="dd86b-3923">FALSE</span></span>|<span data-ttu-id="dd86b-3924">true</span><span class="sxs-lookup"><span data-stu-id="dd86b-3924">TRUE</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3925">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> ein Zeiger ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3925">Gets a value indicating whether the <see cref="T:System.Type" /> is a pointer.</span></span></summary>
        <value><span data-ttu-id="dd86b-3926"><see langword="true" />, wenn <see cref="T:System.Type" /> ein Zeiger ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3926"><see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3927">Wenn der aktuelle <xref:System.Type> einen generischen Typ oder einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `false`Eigenschaft immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3927">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="dd86b-3928">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3928">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3929">Das folgende Beispiel zeigt die `IsPointer` Verwendung der-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3929">The following example shows a use of the `IsPointer` property.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-3930">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsPointer" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein Zeiger ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3930">When overridden in a derived class, implements the <see cref="P:System.Type.IsPointer" /> property and determines whether the <see cref="T:System.Type" /> is a pointer.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3931"><see langword="true" />, wenn <see cref="T:System.Type" /> ein Zeiger ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3931"><see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3932">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> zu den primitiven Typen gehört.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3932">Gets a value indicating whether the <see cref="T:System.Type" /> is one of the primitive types.</span></span></summary>
        <value><span data-ttu-id="dd86b-3933"><see langword="true" />, wenn <see cref="T:System.Type" /> zu den primitiven Typen gehört, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3933"><see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3934">Die primitiven Typen sind <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, ,<xref:System.Int32> ,<xref:System.Int64>, ,<xref:System.IntPtr>,, ,<xref:System.Char> <xref:System.UInt32> <xref:System.UInt64> <xref:System.UIntPtr> <xref:System.Double>und .<xref:System.Single></span><span class="sxs-lookup"><span data-stu-id="dd86b-3934">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
 <span data-ttu-id="dd86b-3935">Wenn der aktuelle <xref:System.Type> einen generischen Typ oder einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `false`Eigenschaft immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3935">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3936">Im folgenden Beispiel werden die `IsContextful`Eigenschaften <xref:System.Type.IsMarshalByRef%2A>, und <xref:System.Type.IsPrimitive%2A> der <xref:System.Type> -Klasse veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3936">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="dd86b-3937">Er überprüft, ob der angegebene Typ im Kontext gehostet werden kann, ob er als Verweis gemarshallt werden kann und ob der Typ ein primitiver Datentyp ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3937">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-3938">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsPrimitive" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> zu den primitiven Typen gehört.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3938">When overridden in a derived class, implements the <see cref="P:System.Type.IsPrimitive" /> property and determines whether the <see cref="T:System.Type" /> is one of the primitive types.</span></span></summary>
        <returns><span data-ttu-id="dd86b-3939"><see langword="true" />, wenn <see cref="T:System.Type" /> zu den primitiven Typen gehört, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3939"><see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3940">Die primitiven Typen sind <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, ,<xref:System.Int32> ,<xref:System.Int64>, ,<xref:System.Char>,und. <xref:System.Double> <xref:System.UInt64> <xref:System.UInt32> <xref:System.Single></span><span class="sxs-lookup"><span data-stu-id="dd86b-3940">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3941">Im folgenden Beispiel wird ermittelt, ob der angegebene Typ ein primitiver Typ ist und das Ergebnis anzeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3941">The following example determines whether the given type is a primitive type and displays the result.</span></span>  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3942">Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> als öffentlich deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3942">Gets a value indicating whether the <see cref="T:System.Type" /> is declared public.</span></span></summary>
        <value><span data-ttu-id="dd86b-3943"><see langword="true" />, wenn der <see cref="T:System.Type" /> als öffentlich deklariert und kein geschachtelter Typ ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3943"><see langword="true" /> if the <see cref="T:System.Type" /> is declared public and is not a nested type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3944">Nicht mit-Typen verwenden; verwenden <xref:System.Type.IsNestedPublic%2A> Sie stattdessen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3944">Do not use with nested types; use <xref:System.Type.IsNestedPublic%2A> instead.</span></span>  
  
 <span data-ttu-id="dd86b-3945">Wenn der aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft `true`zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3945">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `true`.</span></span>  
  
 <span data-ttu-id="dd86b-3946"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>wählt die Sichtbarkeits Attribute aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3946"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3947">Im folgenden Beispiel wird eine Instanz von `MyTestClass`erstellt, die `IsPublic` -Eigenschaft überprüft und das Ergebnis angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3947">The following example creates an instance of `MyTestClass`, checks for the `IsPublic` property, and displays the result.</span></span>  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 <span data-ttu-id="dd86b-3948">Ignorieren Sie bei der-Klasse die Ergebnisse von `IsPublic` und `IsNotPublic` , und achten Sie nur auf die Ergebnisse <xref:System.Type.IsNestedPublic%2A> von <xref:System.Type.IsNestedPrivate%2A>und.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3948">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of <xref:System.Type.IsNestedPublic%2A> and <xref:System.Type.IsNestedPrivate%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3949">Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> als versiegelt deklariert ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3949">Gets a value indicating whether the <see cref="T:System.Type" /> is declared sealed.</span></span></summary>
        <value><span data-ttu-id="dd86b-3950"><see langword="true" />, wenn <see cref="T:System.Type" /> als versiegelt deklariert ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3950"><see langword="true" /> if the <see cref="T:System.Type" /> is declared sealed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3951">Wenn der aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft immer `true`zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3951">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-3952">Im folgenden Beispiel wird eine Instanz `sealed` einer-Klasse erstellt, die `IsSealed` -Eigenschaft überprüft und das Ergebnis angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3952">The following example creates an instance of a `sealed` class, checks for the `IsSealed` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3953">Ruft einen Wert ab, der angibt, ob der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist und daher wichtige Vorgänge ausführen darf.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3953">Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span></span></summary>
        <value><span data-ttu-id="dd86b-3954"><see langword="true" />, wenn der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist, <see langword="false" />, wenn er sicherheitstransparent ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3954"><see langword="true" /> if the current type is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3955">Die <xref:System.Type.IsSecurityCritical%2A>Eigenschaften <xref:System.Type.IsSecuritySafeCritical%2A>, und<xref:System.Type.IsSecurityTransparent%2A> melden die Transparenz Ebene des Typs auf der aktuellen Vertrauens Ebene, wie vom Common Language Runtime (CLR) festgelegt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3955">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="dd86b-3956">Die Kombinationen dieser Eigenschaften werden in der folgenden Tabelle gezeigt:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3956">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="dd86b-3957">Sicherheitsstufe</span><span class="sxs-lookup"><span data-stu-id="dd86b-3957">Security level</span></span>|<span data-ttu-id="dd86b-3958">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="dd86b-3958">IsSecurityCritical</span></span>|<span data-ttu-id="dd86b-3959">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="dd86b-3959">IsSecuritySafeCritical</span></span>|<span data-ttu-id="dd86b-3960">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="dd86b-3960">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="dd86b-3961">Kritisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-3961">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="dd86b-3962">Sicher kritisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-3962">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="dd86b-3963">Transparent</span><span class="sxs-lookup"><span data-stu-id="dd86b-3963">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="dd86b-3964">Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3964">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="dd86b-3965">Für teilweise vertrauenswürdige Assemblys hängt der Wert dieser Eigenschaft von der aktuellen Vertrauens Ebene der Assembly ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3965">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="dd86b-3966">Wenn die Assembly in eine teilweise vertrauenswürdige Anwendungsdomäne geladen wird (z. b. in eine Sandbox-Anwendungsdomäne), werden die Sicherheits Anmerkungen der Assembly von der Laufzeit ignoriert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3966">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="dd86b-3967">Die Assembly und alle zugehörigen Typen werden als transparent behandelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3967">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="dd86b-3968">Die Laufzeit achtet auf die Sicherheits Anmerkungen einer teilweise vertrauenswürdigen Assembly nur, wenn diese Assembly in eine voll vertrauenswürdige Anwendungsdomäne geladen wird (z. b. in die Standard Anwendungsdomäne einer Desktop Anwendung).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3968">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="dd86b-3969">Im Gegensatz dazu wird eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) immer mit voller Vertrauenswürdigkeit geladen, unabhängig von der Vertrauens Ebene der Anwendungsdomäne, sodass die aktuelle Vertrauens Ebene immer voll vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3969">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="dd86b-3970">Mithilfe der <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> -Eigenschaft und der- <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> Eigenschaft können Sie die aktuellen Vertrauens Ebenen von Assemblys und Anwendungs Domänen ermitteln.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3970">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="dd86b-3971">Weitere Informationen zur Reflektion und Transparenz finden Sie unter [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3971">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="dd86b-3972">Informationen zur Transparenz finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3972">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="dd86b-3973">Sicherheitsüberlegungen für die Reflektion</span><span class="sxs-lookup"><span data-stu-id="dd86b-3973">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="dd86b-3974">Änderungen der Sicherheit in .NET Framework</span><span class="sxs-lookup"><span data-stu-id="dd86b-3974">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3975">Ruft einen Wert ab, der angibt, ob der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist, d. h. ob er wichtige Vorgänge ausführen darf und ob von transparentem Code auf ihn zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3975">Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span></span></summary>
        <value><span data-ttu-id="dd86b-3976"><see langword="true" />, wenn der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist, <see langword="false" /> wenn er sicherheitstransparent oder sicherheitsrelevant ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3976"><see langword="true" /> if the current type is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3977">Die <xref:System.Type.IsSecurityCritical%2A>Eigenschaften <xref:System.Type.IsSecuritySafeCritical%2A>, und<xref:System.Type.IsSecurityTransparent%2A> melden die Transparenz Ebene des Typs auf der aktuellen Vertrauens Ebene, wie vom Common Language Runtime (CLR) festgelegt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3977">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="dd86b-3978">Die Kombinationen dieser Eigenschaften werden in der folgenden Tabelle gezeigt:</span><span class="sxs-lookup"><span data-stu-id="dd86b-3978">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="dd86b-3979">Sicherheitsstufe</span><span class="sxs-lookup"><span data-stu-id="dd86b-3979">Security level</span></span>|<span data-ttu-id="dd86b-3980">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="dd86b-3980">IsSecurityCritical</span></span>|<span data-ttu-id="dd86b-3981">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="dd86b-3981">IsSecuritySafeCritical</span></span>|<span data-ttu-id="dd86b-3982">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="dd86b-3982">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="dd86b-3983">Kritisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-3983">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="dd86b-3984">Sicher kritisch</span><span class="sxs-lookup"><span data-stu-id="dd86b-3984">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="dd86b-3985">Transparent</span><span class="sxs-lookup"><span data-stu-id="dd86b-3985">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="dd86b-3986">Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3986">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="dd86b-3987">Für teilweise vertrauenswürdige Assemblys hängt der Wert dieser Eigenschaft von der aktuellen Vertrauens Ebene der Assembly ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3987">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="dd86b-3988">Wenn die Assembly in eine teilweise vertrauenswürdige Anwendungsdomäne geladen wird (z. b. in eine Sandbox-Anwendungsdomäne), werden die Sicherheits Anmerkungen der Assembly von der Laufzeit ignoriert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3988">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="dd86b-3989">Die Assembly und alle zugehörigen Typen werden als transparent behandelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3989">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="dd86b-3990">Die Laufzeit achtet auf die Sicherheits Anmerkungen einer teilweise vertrauenswürdigen Assembly nur, wenn diese Assembly in eine voll vertrauenswürdige Anwendungsdomäne geladen wird (z. b. in die Standard Anwendungsdomäne einer Desktop Anwendung).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3990">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="dd86b-3991">Im Gegensatz dazu wird eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) immer mit voller Vertrauenswürdigkeit geladen, unabhängig von der Vertrauens Ebene der Anwendungsdomäne, sodass die aktuelle Vertrauens Ebene immer voll vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3991">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="dd86b-3992">Mithilfe der <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> -Eigenschaft und der- <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> Eigenschaft können Sie die aktuellen Vertrauens Ebenen von Assemblys und Anwendungs Domänen ermitteln.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3992">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="dd86b-3993">Weitere Informationen zur Reflektion und Transparenz finden Sie unter [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3993">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="dd86b-3994">Informationen zur Transparenz finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="dd86b-3994">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="dd86b-3995">Sicherheitsüberlegungen für die Reflektion</span><span class="sxs-lookup"><span data-stu-id="dd86b-3995">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="dd86b-3996">Änderungen der Sicherheit in .NET Framework</span><span class="sxs-lookup"><span data-stu-id="dd86b-3996">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-3997">Ruft einen Wert ab, der angibt, ob der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitstransparent ist und daher keine wichtigen Vorgänge ausführen kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3997">Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</span></span></summary>
        <value><span data-ttu-id="dd86b-3998"><see langword="true" />, wenn der Typ auf der aktuellen Vertrauensebene sicherheitstransparent ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3998"><see langword="true" /> if the type is security-transparent at the current trust level; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-3999">Wenn diese Eigenschaft zurück `true`gibt, <xref:System.Type.IsSecurityCritical%2A> geben <xref:System.Type.IsSecuritySafeCritical%2A> die Eigenschaften `false`und zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-3999">If this property returns `true`, the <xref:System.Type.IsSecurityCritical%2A> and <xref:System.Type.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="dd86b-4000">Die <xref:System.Type.IsSecurityCritical%2A>Eigenschaften <xref:System.Type.IsSecuritySafeCritical%2A>, und<xref:System.Type.IsSecurityTransparent%2A> melden die Transparenz Ebene des Typs auf der aktuellen Vertrauens Ebene, wie vom Common Language Runtime (CLR) festgelegt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4000">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="dd86b-4001">Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4001">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="dd86b-4002">Für teilweise vertrauenswürdige Assemblys hängt der Wert dieser Eigenschaft von der aktuellen Vertrauens Ebene der Assembly ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4002">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="dd86b-4003">Wenn die Assembly in eine teilweise vertrauenswürdige Anwendungsdomäne geladen wird (z. b. in eine Sandbox-Anwendungsdomäne), werden die Sicherheits Anmerkungen der Assembly von der Laufzeit ignoriert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4003">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="dd86b-4004">Die Assembly und alle zugehörigen Typen werden als transparent behandelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4004">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="dd86b-4005">Die Laufzeit achtet auf die Sicherheits Anmerkungen einer teilweise vertrauenswürdigen Assembly nur, wenn diese Assembly in eine voll vertrauenswürdige Anwendungsdomäne geladen wird (z. b. in die Standard Anwendungsdomäne einer Desktop Anwendung).</span><span class="sxs-lookup"><span data-stu-id="dd86b-4005">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="dd86b-4006">Im Gegensatz dazu wird eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) immer mit voller Vertrauenswürdigkeit geladen, unabhängig von der Vertrauens Ebene der Anwendungsdomäne, sodass die aktuelle Vertrauens Ebene immer voll vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4006">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="dd86b-4007">Mithilfe der <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> -Eigenschaft und der- <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> Eigenschaft können Sie die aktuellen Vertrauens Ebenen von Assemblys und Anwendungs Domänen ermitteln.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4007">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="dd86b-4008">Weitere Informationen zur Reflektion und Transparenz finden Sie unter [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="dd86b-4008">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="dd86b-4009">Informationen zur Transparenz finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="dd86b-4009">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="dd86b-4010">Sicherheitsüberlegungen für die Reflektion</span><span class="sxs-lookup"><span data-stu-id="dd86b-4010">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="dd86b-4011">Änderungen der Sicherheit in .NET Framework</span><span class="sxs-lookup"><span data-stu-id="dd86b-4011">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-4012">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> serialisierbar ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4012">Gets a value indicating whether the <see cref="T:System.Type" /> is serializable.</span></span></summary>
        <value><span data-ttu-id="dd86b-4013"><see langword="true" />, wenn <see cref="T:System.Type" /> serialisierbar ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4013"><see langword="true" /> if the <see cref="T:System.Type" /> is serializable; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="dd86b-4014">Typen, die in der .NET Standard definiert sind, sind nicht <xref:System.SerializableAttribute>mit markiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4014">Types that are defined in the .NET Standard are not marked with <xref:System.SerializableAttribute>.</span></span> <span data-ttu-id="dd86b-4015">Stattdessen bestimmt jede .NET-Implementierung, ob ein Typ serialisierbar ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4015">Instead, each .NET implementation determines whether a type is serializable.</span></span> <span data-ttu-id="dd86b-4016">Zur Laufzeit können Sie die <xref:System.Type.IsSerializable%2A> -Eigenschaft verwenden, um zu bestimmen, ob diese Implementierung die Serialisierung einer Instanz des-Typs unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4016">At run time, you can use the <xref:System.Type.IsSerializable%2A> property to determine whether that implementation supports serialization of an instance of the type.</span></span> <span data-ttu-id="dd86b-4017">Weitere Informationen und ein Beispiel finden Sie unter [bestimmen, ob ein .NET Standard Objekt serialisierbar ist](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span><span class="sxs-lookup"><span data-stu-id="dd86b-4017">For more information and an example, see [How to determine if a .NET Standard object is serializable](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span></span>
  
 <span data-ttu-id="dd86b-4018">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4018">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="dd86b-4019">Wenn der <xref:System.Type> aktuelle z. b. `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic) darstellt, wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4019">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="dd86b-4020">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `false`Eigenschaft immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4020">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-4021">Im folgenden Beispiel wird eine Instanz der `MyTestClass` -Klasse erstellt, das [serialisierbare]-Attribut festgelegt `IsSerializable` und die `true` - `false`Eigenschaft für oder überprüft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4021">The following example creates an instance of `MyTestClass` class, sets the [Serializable] attribute, and checks the `IsSerializable` property for `true` or `false`.</span></span>  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-4022">Ruft einen Wert ab, der angibt, ob der Typ einen Namen besitzt, der eine Sonderbehandlung erfordert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4022">Gets a value indicating whether the type has a name that requires special handling.</span></span></summary>
        <value><span data-ttu-id="dd86b-4023"><see langword="true" /> , wenn der Typ einen Namen besitzt, der eine Sonderbehandlung erfordert, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4023"><see langword="true" /> if the type has a name that requires special handling; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4024">Namen, die mit oder beginnen, enthalten einen Unterstrich (_), Eigenschaftenaccessoren und Operator Überladungsmethoden sind Beispiele für Typen, die von einigen Compilern möglicherweise eine besondere Behandlung erfordern.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4024">Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</span></span>  
  
 <span data-ttu-id="dd86b-4025">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4025">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="dd86b-4026">Wenn der <xref:System.Type> aktuelle z. b. `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic) darstellt, wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4026">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="dd86b-4027">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `false`Eigenschaft immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4027">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="dd86b-4028">Der Typ, der mit dem aktuellen Typ verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4028">The type to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="dd86b-4029">Bestimmt, ob der aktuelle <see cref="T:System.Type" /> vom angegebenen <see cref="T:System.Type" /> abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4029">Determines whether the current <see cref="T:System.Type" /> derives from the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-4030"><see langword="true" />, wenn der aktuelle <see langword="Type" /> von <paramref name="c" /> abgeleitet ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4030"><see langword="true" /> if the current <see langword="Type" /> derives from <paramref name="c" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="dd86b-4031">Diese Methode gibt auch dann <see langword="false" /> zurück, wenn <paramref name="c" /> und der aktuelle <see langword="Type" /> gleich sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4031">This method also returns <see langword="false" /> if <paramref name="c" /> and the current <see langword="Type" /> are equal.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4032">Die <xref:System.Type.IsSubclassOf%2A> -Methode kann aufgerufen werden, um Folgendes zu bestimmen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-4032">You can call the <xref:System.Type.IsSubclassOf%2A> method to determine any of the following:</span></span>  
  
-   <span data-ttu-id="dd86b-4033">Gibt an, ob eine Klasse von einer anderen abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4033">Whether one class derives from another.</span></span>  
  
-   <span data-ttu-id="dd86b-4034">Gibt an, ob ein <xref:System.ValueType>Typ von abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4034">Whether a type derives from <xref:System.ValueType>.</span></span> <span data-ttu-id="dd86b-4035">Das <xref:System.Type.IsValueType%2A> ist jedoch eine effizientere Methode, um zu bestimmen, ob ein Typ ein Werttyp ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4035">However, the <xref:System.Type.IsValueType%2A> is a more efficient way to determine whether a type is a value type.</span></span>  
  
-   <span data-ttu-id="dd86b-4036">Gibt an, ob ein <xref:System.Enum>Typ von abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4036">Whether a type derives from <xref:System.Enum>.</span></span> <span data-ttu-id="dd86b-4037">Die <xref:System.Type.IsEnum%2A> -Methode ist jedoch eine effizientere Methode, um zu bestimmen, ob ein Typ eine Enumeration ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4037">However, the <xref:System.Type.IsEnum%2A> method is a more efficient way to determine whether a type is an enumeration.</span></span>  
  
-   <span data-ttu-id="dd86b-4038">Gibt an, ob ein Typ ein Delegat ist, d. h. <xref:System.Delegate> ob <xref:System.MulticastDelegate>er entweder von oder abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4038">Whether a type is a delegate, that is, whether it derives from either <xref:System.Delegate> or <xref:System.MulticastDelegate>.</span></span>  
  
 <span data-ttu-id="dd86b-4039">Die <xref:System.Type.IsSubclassOf%2A> -Methode kann nicht verwendet werden, um zu bestimmen, ob eine Schnittstelle von einer anderen Schnittstelle abgeleitet wird oder ob eine Klasse eine Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4039">The <xref:System.Type.IsSubclassOf%2A> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.</span></span> <span data-ttu-id="dd86b-4040">Verwenden Sie <xref:System.Type.IsAssignableFrom%2A> für diesen Zweck die-Methode, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4040">Use the <xref:System.Type.IsAssignableFrom%2A> method for that purpose, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 <span data-ttu-id="dd86b-4041">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, wird er von seiner Klassen Einschränkung <xref:System.Object?displayProperty=nameWithType> oder von abgeleitet, wenn er keine Klassen Einschränkung aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4041">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <xref:System.Object?displayProperty=nameWithType> if it has no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-4042">Außer bei Verwendung mit-Schnitt <xref:System.Type.IsSubclassOf%2A> stellen ist das Gegenteil <xref:System.Type.IsAssignableFrom%2A>von.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4042">Except when used with interfaces, <xref:System.Type.IsSubclassOf%2A> is the converse of <xref:System.Type.IsAssignableFrom%2A>.</span></span> <span data-ttu-id="dd86b-4043">Das heißt, wenn `t1.IsSubclassOf(t2)` ist `true`, dann `t2.IsAssignableFrom(t1)` ist ebenfalls `true`.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4043">That is, if `t1.IsSubclassOf(t2)` is `true`, then `t2.IsAssignableFrom(t1)` is also `true`.</span></span>  
  
 <span data-ttu-id="dd86b-4044">Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4044">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-4045">Im folgenden Beispiel wird eine Klasse `Class1` mit dem Namen und eine abgeleitete Klasse mit dem Namen `DerivedC1`erstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4045">The following example creates a class named `Class1` and a derived class named `DerivedC1`.</span></span> <span data-ttu-id="dd86b-4046">Die <xref:System.Type.IsSubclassOf%2A> -Methode wird aufgerufen, um `DerivedC1` anzuzeigen, dass eine unter `Class1`Klasse von ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4046">It calls the <xref:System.Type.IsSubclassOf%2A> method to show that `DerivedC1` is a subclass of `Class1`.</span></span>  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-4047"><paramref name="c" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4047"><paramref name="c" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-4048">Ruft einen Wert ab, der angibt, ob für <see langword="UnicodeClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" />ausgewählt ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4048">Gets a value indicating whether the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="dd86b-4049"><see langword="true" />, wenn für <see langword="UnicodeClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4049"><see langword="true" /> if the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4050"><xref:System.Reflection.TypeAttributes.StringFormatMask> Wird verwendet, um die Attribute des Zeichen folgen Formats auszuwählen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4050">The <xref:System.Reflection.TypeAttributes.StringFormatMask> is used to select the string format attributes.</span></span> <span data-ttu-id="dd86b-4051">Die Attribute des Zeichen folgen Formats verbessern die Interoperabilität durch definieren, wie Zeichen folgen interpretiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4051">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="dd86b-4052">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4052">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="dd86b-4053">Wenn der <xref:System.Type> aktuelle z. b. `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic) darstellt, wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4053">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="dd86b-4054">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese `false`Eigenschaft immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4054">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-4055">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> ein Werttyp ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4055">Gets a value indicating whether the <see cref="T:System.Type" /> is a value type.</span></span></summary>
        <value><span data-ttu-id="dd86b-4056"><see langword="true" />, wenn <see cref="T:System.Type" /> ein Werttyp ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4056"><see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4057">Werttypen sind Typen, die als Sequenzen von Bits dargestellt werden. Werttypen sind keine Klassen oder Schnittstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4057">Value types are types that are represented as sequences of bits; value types are not classes or interfaces.</span></span> <span data-ttu-id="dd86b-4058">Werttypen werden in einigen Programmiersprachen als "Strukturen" bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4058">Value types are referred to as "structs" in some programming languages.</span></span> <span data-ttu-id="dd86b-4059">Enumerationswerte sind ein Sonderfall von Werttypen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4059">Enums are a special case of value types.</span></span>  
  
 <span data-ttu-id="dd86b-4060">Diese Eigenschaft gibt `false` für die <xref:System.ValueType> -Klasse zurück <xref:System.ValueType> , da kein Werttyp selbst ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4060">This property returns `false` for the <xref:System.ValueType> class, because <xref:System.ValueType> is not a value type itself.</span></span> <span data-ttu-id="dd86b-4061">Dabei handelt es sich um die Basisklasse für alle Werttypen. Daher kann Ihr ein beliebiger Werttyp zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4061">It is the base class for all value types, and therefore any value type can be assigned to it.</span></span> <span data-ttu-id="dd86b-4062">Dies wäre nicht möglich, wenn <xref:System.ValueType> es sich selbst um einen Werttyp handelt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4062">This would not be possible if <xref:System.ValueType> itself was a value type.</span></span> <span data-ttu-id="dd86b-4063">Werttypen werden gekapselt, wenn Sie einem Feld vom Typ <xref:System.ValueType>zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4063">Value types are boxed when they are assigned to a field of type <xref:System.ValueType>.</span></span>  
  
 <span data-ttu-id="dd86b-4064">Diese Eigenschaft gibt `true` für Enumerationen zurück, jedoch nicht für <xref:System.Enum> den Typ selbst.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4064">This property returns `true` for enumerations, but not for the <xref:System.Enum> type itself.</span></span> <span data-ttu-id="dd86b-4065">Ein Beispiel, in dem dieses Verhalten veranschaulicht wird <xref:System.Type.IsEnum%2A>, finden Sie unter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4065">For an example that demonstrates this behavior, see <xref:System.Type.IsEnum%2A>.</span></span>  
  
 <span data-ttu-id="dd86b-4066">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4066">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-4067">Im folgenden Beispiel wird eine Variable vom Typ `MyEnum`erstellt, die `IsValueType` -Eigenschaft überprüft und das Ergebnis angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4067">The following example creates a variable of type `MyEnum`, checks for the `IsValueType` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-4068">Implementiert die <see cref="P:System.Type.IsValueType" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein Werttyp ist, also weder eine Klasse noch eine Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4068">Implements the <see cref="P:System.Type.IsValueType" /> property and determines whether the <see cref="T:System.Type" /> is a value type; that is, not a class or an interface.</span></span></summary>
        <returns><span data-ttu-id="dd86b-4069"><see langword="true" />, wenn <see cref="T:System.Type" /> ein Werttyp ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4069"><see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4070">Diese Methode wird bereitgestellt, um die Implementierung alternativer Typsysteme zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4070">This method is provided to enable the implementation of alternate type systems.</span></span> <span data-ttu-id="dd86b-4071">Sie wird in der Regel nicht im Anwendungscode verwendet.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4071">It is not generally used in application code.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-4072">Ruft einen Wert ab, der angibt, ob auf den <see cref="T:System.Type" /> aus Code von außerhalb der Assembly zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4072">Gets a value indicating whether the <see cref="T:System.Type" /> can be accessed by code outside the assembly.</span></span></summary>
        <value><span data-ttu-id="dd86b-4073"><see langword="true" />, wenn der aktuelle <see cref="T:System.Type" /> ein öffentlicher Typ oder ein öffentlicher geschachtelter Typ ist, sodass alle einschließenden Typen öffentlich sind, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4073"><see langword="true" /> if the current <see cref="T:System.Type" /> is a public type or a public nested type such that all the enclosing types are public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4074">Verwenden Sie diese Eigenschaft, um zu bestimmen, ob ein Typ Teil der öffentlichen Schnittstelle einer Komponentenassembly ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4074">Use this property to determine whether a type is part of the public interface of a component assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-4075">Im folgenden Codebeispiel werden zwei Klassen getestet, von denen nur eine außerhalb der Assembly sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4075">The following code example tests two classes, only one of which is visible outside the assembly.</span></span>  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd86b-4076">Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein Array des aktuellen Typs darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4076">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-4077">Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein eindimensionales Array vom aktuellen Typ mit einer unteren Grenze von 0 (null) darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4077">Returns a <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span></span></summary>
        <returns><span data-ttu-id="dd86b-4078">Ein <see cref="T:System.Type" />-Objekt, das ein eindimensionales Array vom aktuellen Typ mit einer unteren Grenze von 0 (null) darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4078">A <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4079">Die <xref:System.Type.MakeArrayType%2A> -Methode bietet eine Möglichkeit, Array Typen zu generieren, deren Elementtypen zur Laufzeit berechnet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4079">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
 <span data-ttu-id="dd86b-4080">**Hinweis** Der Common Language Runtime unterscheidet zwischen Vektoren (d. h. eindimensionalen Arrays, die stets NULL basiert) und mehrdimensionalen Arrays.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4080">**Note** The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="dd86b-4081">Ein Vektor, der immer nur eine Dimension hat, ist nicht identisch mit einem mehrdimensionalen Array, das nur eine Dimension aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4081">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="dd86b-4082">Diese Methoden Überladung kann nur zum Erstellen von Vektor Typen verwendet werden, und Sie ist die einzige Möglichkeit, einen Vektortyp zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4082">This method overload can only be used to create vector types, and it is the only way to create a vector type.</span></span> <span data-ttu-id="dd86b-4083">Verwenden Sie <xref:System.Type.MakeArrayType%28System.Int32%29> die-Methoden Überladung zum Erstellen von mehrdimensionalen Array Typen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4083">Use the <xref:System.Type.MakeArrayType%28System.Int32%29> method overload to create multidimensional array types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-4084">Im folgenden Codebeispiel werden Array- `ref` ,`ByRef` (in Visual Basic) und Zeiger Typen für die `Test` -Klasse erstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4084">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd86b-4085">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4085">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="dd86b-4086">Abgeleitete Klassen müssen eine Implementation angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4086">Derived classes must provide an implementation.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="dd86b-4087">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4087">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="dd86b-4088">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-4088">-or-</span></span> 
<span data-ttu-id="dd86b-4089">Der aktuelle Typ ist ein <see langword="ByRef" />-Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4089">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="dd86b-4090">Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4090">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rank"><span data-ttu-id="dd86b-4091">Die Anzahl von Dimensionen für das Array.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4091">The number of dimensions for the array.</span></span> <span data-ttu-id="dd86b-4092">Diese Zahl muss kleiner oder gleich 32 sein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4092">This number must be less than or equal to 32.</span></span></param>
        <summary><span data-ttu-id="dd86b-4093">Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein Array vom aktuellen Typ mit der angegebenen Anzahl von Dimensionen darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4093">Returns a <see cref="T:System.Type" /> object representing an array of the current type, with the specified number of dimensions.</span></span></summary>
        <returns><span data-ttu-id="dd86b-4094">Ein Objekt, das ein Array vom aktuellen Typ mit der angegebenen Anzahl von Dimensionen darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4094">An object representing an array of the current type, with the specified number of dimensions.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4095">Die <xref:System.Type.MakeArrayType%2A> -Methode bietet eine Möglichkeit, Array Typen zu generieren, deren Elementtypen zur Laufzeit berechnet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4095">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-4096">Der Common Language Runtime unterscheidet zwischen Vektoren (d. h. eindimensionalen Arrays, die stets NULL basiert) und mehrdimensionalen Arrays.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4096">The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="dd86b-4097">Ein Vektor, der immer nur eine Dimension hat, ist nicht identisch mit einem mehrdimensionalen Array, das nur eine Dimension aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4097">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="dd86b-4098">Sie können diese Methoden Überladung nicht zum Erstellen eines Vektor Typs verwenden. Wenn `rank` den Wert 1 hat, gibt diese Methoden Überladung einen mehrdimensionalen Arraytyp zurück, der eine Dimension hat.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4098">You cannot use this method overload to create a vector type; if `rank` is 1, this method overload returns a multidimensional array type that happens to have one dimension.</span></span> <span data-ttu-id="dd86b-4099">Verwenden Sie <xref:System.Type.MakeArrayType> die-Methoden Überladung, um Vektor Typen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4099">Use the <xref:System.Type.MakeArrayType> method overload to create vector types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-4100">Im folgenden Codebeispiel werden Array- `ref` ,`ByRef` (in Visual Basic) und Zeiger Typen für die `Test` -Klasse erstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4100">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="dd86b-4101"><paramref name="rank" /> ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4101"><paramref name="rank" /> is invalid.</span></span> <span data-ttu-id="dd86b-4102">Beispielsweise 0 oder ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4102">For example, 0 or negative.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd86b-4103">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4103">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="dd86b-4104">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4104">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="dd86b-4105">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-4105">-or-</span></span> 
<span data-ttu-id="dd86b-4106">Der aktuelle Typ ist ein <see langword="ByRef" />-Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4106">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="dd86b-4107">Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4107">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span>  
  
<span data-ttu-id="dd86b-4108">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-4108">-or-</span></span> 
 <span data-ttu-id="dd86b-4109"><paramref name="rank" /> ist größer als 32.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4109"><paramref name="rank" /> is greater than 32.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-4110">Gibt ein <see cref="T:System.Type" />-Objekt zurück, das beim Übergeben als <see langword="ref" />-Parameter (<see langword="ByRef" />-Parameter in Visual Basic) den aktuellen Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4110">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span></span></summary>
        <returns><span data-ttu-id="dd86b-4111">Ein <see cref="T:System.Type" />-Objekt, das beim Übergeben als <see langword="ref" />-Parameter (<see langword="ByRef" />-Parameter in Visual Basic) den aktuellen Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4111">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4112">Die <xref:System.Type.MakeByRefType%2A> -Methode bietet eine Möglichkeit, `ref` Typen (`ByRef` in Visual Basic) für Parameterlisten zu generieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4112">The <xref:System.Type.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
 <span data-ttu-id="dd86b-4113">Bei Verwendung der Syntax von Microsoft Intermediate Language <xref:System.Type> (MSIL) gibt diese `Int32&`Methode ein <xref:System.Type> - <xref:System.Int32>Objekt zurück, das darstellt, wenn das aktuelle-Objekt darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4113">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-4114">Im folgenden Codebeispiel werden Array- `ref` ,`ByRef` (in Visual Basic) und Zeiger Typen für die `Test` -Klasse erstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4114">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd86b-4115">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4115">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="dd86b-4116">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4116">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="dd86b-4117">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-4117">-or-</span></span> 
<span data-ttu-id="dd86b-4118">Der aktuelle Typ ist ein <see langword="ByRef" />-Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4118">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="dd86b-4119">Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4119">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericSignatureType">
      <MemberSignature Language="C#" Value="public static Type MakeGenericSignatureType (Type genericTypeDefinition, params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericSignatureType(class System.Type genericTypeDefinition, class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericSignatureType(System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericSignatureType (genericTypeDefinition As Type, ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericSignatureType(Type ^ genericTypeDefinition, ... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="static member MakeGenericSignatureType : Type * Type[] -&gt; Type" Usage="System.Type.MakeGenericSignatureType (genericTypeDefinition, typeArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericTypeDefinition" Type="System.Type" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeArguments" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="genericTypeDefinition"><span data-ttu-id="dd86b-4120">Die generische Typdefinition.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4120">The generic type definition.</span></span></param>
        <param name="typeArguments"><span data-ttu-id="dd86b-4121">Ein Array von Typargumenten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4121">An array of type arguments.</span></span></param>
        <summary><span data-ttu-id="dd86b-4122">Erstellt einen generischen Signaturtyp, der Neuimplementierungen von Reflection durch Drittanbieter zulässt, um die Verwendung von Signaturtypen bei der Abfrage von Typmembern vollständig zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4122">Creates a generic signature type, which allows third party reimplementations of Reflection to fully support the use of signature types in querying type members.</span></span></summary>
        <returns><span data-ttu-id="dd86b-4123">Ein generischer Signaturtyp.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4123">A generic signature type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments"><span data-ttu-id="dd86b-4124">Ein Array von Typen, die die Typparameter des aktuellen generischen Typs ersetzen sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4124">An array of types to be substituted for the type parameters of the current generic type.</span></span></param>
        <summary><span data-ttu-id="dd86b-4125">Ersetzt die Typparameter der aktuellen generischen Typdefinition durch die Elemente eines Arrays von Typen und gibt ein <see cref="T:System.Type" />-Objekt zurück, das den resultierenden konstruierten Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4125">Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <see cref="T:System.Type" /> object representing the resulting constructed type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-4126">Ein <see cref="T:System.Type" />, der den konstruierten Typ darstellt, der durch Ersetzen der Typparameter des aktuellen generischen Typs durch die Elemente von <paramref name="typeArguments" /> erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4126">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4127">Mit <xref:System.Type.MakeGenericType%2A> der-Methode können Sie Code schreiben, der den Typparametern einer generischen Typdefinition bestimmte Typen zuweist, wodurch <xref:System.Type> ein-Objekt erstellt wird, das einen bestimmten konstruierten Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4127">The <xref:System.Type.MakeGenericType%2A> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <xref:System.Type> object that represents a particular constructed type.</span></span> <span data-ttu-id="dd86b-4128">Sie können dieses <xref:System.Type> Objekt verwenden, um Lauf Zeit Instanzen des konstruierten Typs zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4128">You can use this <xref:System.Type> object to create run-time instances of the constructed type.</span></span>  
  
 <span data-ttu-id="dd86b-4129">Mit <xref:System.Type.MakeGenericType%2A> erstellte Typen können geöffnet werden, d. h., einige ihrer Typargumente können Typparameter von einschließenden generischen Methoden oder Typen sein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4129">Types constructed with <xref:System.Type.MakeGenericType%2A> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.</span></span> <span data-ttu-id="dd86b-4130">Bei der Ausgabe dynamischer Assemblys können solche geöffneten konstruierten Typen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4130">You might use such open constructed types when you emit dynamic assemblies.</span></span> <span data-ttu-id="dd86b-4131">Stellen Sie sich z. b `Base` . `Derived` die Klassen und im folgenden Code vor.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4131">For example, consider the classes `Base` and `Derived` in the following code.</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="dd86b-4132">Um in `Derived` einer dynamischen Assembly zu generieren, muss der Basistyp erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4132">To generate `Derived` in a dynamic assembly, it is necessary to construct its base type.</span></span> <span data-ttu-id="dd86b-4133">Um dies zu erreichen, müssen <xref:System.Type.MakeGenericType%2A> Sie die- <xref:System.Type> Methode für ein- `Base`Objekt aufrufen, das die- <xref:System.Int32> Klasse mit den generischen `Derived`Typargumenten und dem Typparameter `V` von darstellt</span><span class="sxs-lookup"><span data-stu-id="dd86b-4133">To do this, call the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object representing the class `Base`, using the generic type arguments <xref:System.Int32> and the type parameter `V` from `Derived`.</span></span> <span data-ttu-id="dd86b-4134">Da Typen und generische Typparameter beide durch <xref:System.Type> -Objekte dargestellt werden, kann ein Array, das beide enthält, an die <xref:System.Type.MakeGenericType%2A> -Methode übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4134">Because types and generic type parameters are both represented by <xref:System.Type> objects, an array containing both can be passed to the <xref:System.Type.MakeGenericType%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-4135">Ein konstruierter Typ, `Base<int, V>` wie z. b., ist beim Ausgeben von Code <xref:System.Type.MakeGenericType%2A> nützlich, aber Sie können die-Methode für diesen Typ nicht abrufen, da es sich nicht um eine generische Typdefinition</span><span class="sxs-lookup"><span data-stu-id="dd86b-4135">A constructed type such as `Base<int, V>` is useful when emitting code, but you cannot call the <xref:System.Type.MakeGenericType%2A> method on this type because it is not a generic type definition.</span></span> <span data-ttu-id="dd86b-4136">Um einen geschlossenen konstruierten Typ zu erstellen, der instanziiert werden kann, <xref:System.Type.GetGenericTypeDefinition%2A> rufen Sie zuerst die <xref:System.Type> -Methode auf, um ein- <xref:System.Type.MakeGenericType%2A> Objekt abzurufen, das die generische Typdefinition darstellt</span><span class="sxs-lookup"><span data-stu-id="dd86b-4136">To create a closed constructed type that can be instantiated, first call the <xref:System.Type.GetGenericTypeDefinition%2A> method to get a <xref:System.Type> object representing the generic type definition and then call <xref:System.Type.MakeGenericType%2A> with the desired type arguments.</span></span>  
  
 <span data-ttu-id="dd86b-4137">Das <xref:System.Type> <xref:System.Type> von <xref:System.Type.MakeGenericType%2A> zurückgegebene Objekt ist das gleiche wie das, das durch <xref:System.Object.GetType%2A> den Aufruf der-Methode des resultierenden konstruierten <xref:System.Object.GetType%2A> Typs abgerufen wird, oder die-Methode eines konstruierten Typs, der aus demselben generischen erstellt wurde. Typdefinition mit denselben Typargumenten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4137">The <xref:System.Type> object returned by <xref:System.Type.MakeGenericType%2A> is the same as the <xref:System.Type> obtained by calling the <xref:System.Object.GetType%2A> method of the resulting constructed type, or the <xref:System.Object.GetType%2A> method of any constructed type that was created from the same generic type definition using the same type arguments.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dd86b-4138">Ein Array generischer Typen ist nicht selbst ein generischer Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4138">An array of generic types is not itself a generic type.</span></span> <span data-ttu-id="dd86b-4139">Es ist nicht <xref:System.Type.MakeGenericType%2A> möglich, für einen Arraytyp`Dim ac() As C(Of T)` `C<T>[]` wie (in Visual Basic) aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4139">You cannot call <xref:System.Type.MakeGenericType%2A> on an array type such as `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic).</span></span> <span data-ttu-id="dd86b-4140">Um einen geschlossenen generischen Typ aus `C<T>[]`zu erstellen <xref:System.Type.GetElementType%2A> , rufen Sie auf, um `C<T>`die generische <xref:System.Type.MakeGenericType%2A> Typdefinition abzurufen. Rufen Sie die generische Typdefinition auf, um den konstruierten Typ zu erstellen, und rufen Sie schließlich die <xref:System.Type.MakeArrayType%2A> -Methode auf der konstruierte Typ zum Erstellen des Arraytyps.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4140">To construct a closed generic type from `C<T>[]`, call <xref:System.Type.GetElementType%2A> to obtain the generic type definition `C<T>`; call <xref:System.Type.MakeGenericType%2A> on the generic type definition to create the constructed type; and finally call the <xref:System.Type.MakeArrayType%2A> method on the constructed type to create the array type.</span></span> <span data-ttu-id="dd86b-4141">Das gleiche gilt für Zeiger Typen und- `ref` Typen (`ByRef` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="dd86b-4141">The same is true of pointer types and `ref` types (`ByRef` in Visual Basic).</span></span>  
  
 <span data-ttu-id="dd86b-4142">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4142">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
## <a name="nested-types"></a><span data-ttu-id="dd86b-4143">Geschachtelte Typen</span><span class="sxs-lookup"><span data-stu-id="dd86b-4143">Nested Types</span></span>  
 <span data-ttu-id="dd86b-4144">Wenn ein generischer Typ mithilfe C#von, C++oder Visual Basic definiert wird, sind die zugehörigen nerischen Typen alle generisch.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4144">If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.</span></span> <span data-ttu-id="dd86b-4145">Dies ist auch dann der Fall, wenn die in der Liste für die Typen übergebenen Typen keine eigenen Typparameter aufweisen, da alle drei Sprachen die Typparameter der einschließenden Typen in den Typparameter Listen der in einem Typ untergeordneten Typen enthalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4145">This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.</span></span> <span data-ttu-id="dd86b-4146">Beachten Sie die folgenden Klassen:</span><span class="sxs-lookup"><span data-stu-id="dd86b-4146">Consider the following classes:</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 <span data-ttu-id="dd86b-4147">Die Typparameter Liste der-Klasse `Inner` hat zwei Typparameter, `T` und `U`, der erste ist der Typparameter der einschließenden Klasse.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4147">The type parameter list of the nested class `Inner` has two type parameters, `T` and `U`, the first of which is the type parameter of its enclosing class.</span></span> <span data-ttu-id="dd86b-4148">Entsprechend `Innermost1` verfügt die Typparameter Liste der-Klasse über die drei `T`Typparameter,, `U`und `V`, mit `T` und `U` aus den zugehörigen einschließenden Klassen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4148">Similarly, the type parameter list of the nested class `Innermost1` has three type parameters, `T`, `U`, and `V`, with `T` and `U` coming from its enclosing classes.</span></span> <span data-ttu-id="dd86b-4149">Die-Klasse `Innermost2` verfügt über zwei Typparameter, `T` und `U`, die von ihren einschließenden Klassen stammen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4149">The nested class `Innermost2` has two type parameters, `T` and `U`, which come from its enclosing classes.</span></span>  
  
 <span data-ttu-id="dd86b-4150">Wenn die Parameterliste des einschließenden Typs mehr als einen Typparameter aufweist, werden alle Typparameter in der Reihenfolge in der Typparameter Liste des untergeordneten Typs eingefügt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4150">If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</span></span>  
  
 <span data-ttu-id="dd86b-4151">Um einen generischen Typ aus der generischen Typdefinition für einen Typ zu erstellen, wird <xref:System.Type.MakeGenericType%2A> die-Methode mit dem Array aufgerufen, das durch Verkettung der Typargument Arrays aller einschließenden Typen, beginnend mit dem äußersten generischen Typ, beginnend mit dem äußersten generischen Typ und endende mit dem Typargument Array des in den arsted Typ selbst, wenn es über eigene Typparameter verfügt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4151">To construct a generic type from the generic type definition for a nested type, call the <xref:System.Type.MakeGenericType%2A> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.</span></span> <span data-ttu-id="dd86b-4152">Um eine Instanz von `Innermost1`zu erstellen, rufen Sie die-Methode mit einem Array auf, das drei Typen enthält, die <xref:System.Type.MakeGenericType%2A> T, U und V zugewiesen werden sollen. Um eine Instanz von `Innermost2`zu erstellen, rufen Sie die-Methode mit einem Array auf, das zwei Typen enthält, die <xref:System.Type.MakeGenericType%2A> T und U zugewiesen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4152">To create an instance of `Innermost1`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing three types, to be assigned to T, U, and V. To create an instance of `Innermost2`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing two types, to be assigned to T and U.</span></span>  
  
 <span data-ttu-id="dd86b-4153">Die Sprachen propagieren die Typparameter von einschließenden Typen auf diese Weise, sodass Sie die Typparameter eines einschließenden Typs verwenden können, um Felder von geschachtelte Types zu definieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4153">The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.</span></span> <span data-ttu-id="dd86b-4154">Andernfalls befinden sich die Typparameter nicht im Gültigkeitsbereich innerhalb der Texte der geschachtelten Typen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4154">Otherwise, the type parameters would not be in scope within the bodies of the nested types.</span></span> <span data-ttu-id="dd86b-4155">Es ist möglich, die Typparameter von einschließenden Typen zu definieren, indem Sie Code in dynamischen Assemblys oder mithilfe von [Ilasm. exe (Il-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md)ausgeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4155">It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span> <span data-ttu-id="dd86b-4156">Beachten Sie den folgenden Code für den MSIL-Assembler:</span><span class="sxs-lookup"><span data-stu-id="dd86b-4156">Consider the following code for the MSIL assembler:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="dd86b-4157">In diesem Beispiel ist es nicht möglich, ein Feld vom Typ `T` oder `U` in der Klasse `Innermost`zu definieren, da diese Typparameter nicht im Gültigkeitsbereich liegen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4157">In this example, it is not possible to define a field of type `T` or `U` in class `Innermost`, because those type parameters are not in scope.</span></span> <span data-ttu-id="dd86b-4158">Der folgende Assemblycode definiert die Klassen, die sich so Verhalten, wie Sie C++in, Visual Basic und C#definiert werden:</span><span class="sxs-lookup"><span data-stu-id="dd86b-4158">The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="dd86b-4159">Sie können den [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) verwenden, um in den Sprachen auf hoher Ebene definierte in der Sprache definierte Klassen zu untersuchen und dieses Benennungs Schema zu beobachten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4159">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine nested classes defined in the high-level languages and observe this naming scheme.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-4160">Im folgenden Beispiel wird die <xref:System.Type.MakeGenericType%2A> -Methode verwendet, um einen konstruierten Typ aus der generischen <xref:System.Collections.Generic.Dictionary%602> Typdefinition für den-Typ zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4160">The following example uses the <xref:System.Type.MakeGenericType%2A> method to create a constructed type from the generic type definition for the <xref:System.Collections.Generic.Dictionary%602> type.</span></span> <span data-ttu-id="dd86b-4161">Der konstruierte Typ stellt eine <xref:System.Collections.Generic.Dictionary%602> von `Test` Objekten mit Zeichen folgen Schlüsseln dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4161">The constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd86b-4162">Der aktuelle Typ stellt keine generische Typdefinition dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4162">The current type does not represent a generic type definition.</span></span> <span data-ttu-id="dd86b-4163">Das heißt, <see cref="P:System.Type.IsGenericTypeDefinition" /> gibt <see langword="false" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4163">That is, <see cref="P:System.Type.IsGenericTypeDefinition" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-4164"><paramref name="typeArguments" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4164"><paramref name="typeArguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd86b-4165">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-4165">-or-</span></span> 
<span data-ttu-id="dd86b-4166">Ein beliebiges Element von <paramref name="typeArguments" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4166">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-4167">Die Anzahl der Elemente im <paramref name="typeArguments" /> entspricht nicht der Anzahl von Typparametern in der aktuellen generischen Typdefinition.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4167">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters in the current generic type definition.</span></span>  
  
<span data-ttu-id="dd86b-4168">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-4168">-or-</span></span> 
<span data-ttu-id="dd86b-4169">Ein beliebiges Element von <paramref name="typeArguments" /> erfüllt nicht die Einschränkungen, die für den entsprechenden Typparameter des aktuellen generischen Typs angegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4169">Any element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.</span></span>  
  
<span data-ttu-id="dd86b-4170">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-4170">-or-</span></span> 
 <span data-ttu-id="dd86b-4171"><paramref name="typeArguments" /> enthält ein Element, das ein Zeigertyp (<see cref="P:System.Type.IsPointer" /> gibt <see langword="true" /> zurück), vom Typ „by-ref“ (<see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück) oder <see cref="T:System.Void" /> ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4171"><paramref name="typeArguments" /> contains an element that is a pointer type (<see cref="P:System.Type.IsPointer" /> returns <see langword="true" />), a by-ref type (<see cref="P:System.Type.IsByRef" /> returns <see langword="true" />), or <see cref="T:System.Void" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd86b-4172">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4172">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="dd86b-4173">Abgeleitete Klassen müssen eine Implementation angeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4173">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="dd86b-4174">Reflektion und generische Typen</span><span class="sxs-lookup"><span data-stu-id="dd86b-4174">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="dd86b-4175">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</span><span class="sxs-lookup"><span data-stu-id="dd86b-4175">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-4176">Gibt ein <see cref="T:System.Type" />-Objekt zurück, das einen Zeiger auf den aktuellen Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4176">Returns a <see cref="T:System.Type" /> object that represents a pointer to the current type.</span></span></summary>
        <returns><span data-ttu-id="dd86b-4177">Ein <see cref="T:System.Type" />-Objekt, das einen Zeiger auf den aktuellen Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4177">A <see cref="T:System.Type" /> object that represents a pointer to the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4178">Die <xref:System.Type.MakePointerType%2A> -Methode bietet eine Möglichkeit zum Generieren von Zeiger Typen für Parameterlisten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4178">The <xref:System.Type.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
 <span data-ttu-id="dd86b-4179">Bei Verwendung der Syntax von Microsoft Intermediate Language <xref:System.Type> (MSIL) gibt diese `Int32*`Methode ein <xref:System.Type> - <xref:System.Int32>Objekt zurück, das darstellt, wenn das aktuelle-Objekt darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4179">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-4180">Im folgenden Codebeispiel werden Array- `ref` ,`ByRef` (in Visual Basic) und Zeiger Typen für die `Test` -Klasse erstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4180">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd86b-4181">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4181">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="dd86b-4182">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4182">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="dd86b-4183">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-4183">-or-</span></span> 
<span data-ttu-id="dd86b-4184">Der aktuelle Typ ist ein <see langword="ByRef" />-Typ.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4184">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="dd86b-4185">Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4185">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-4186">Ruft einen <see cref="T:System.Reflection.MemberTypes" />-Wert ab, der angibt, dass dieser Member ein Typ oder ein geschachtelter Typ ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4186">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span></span></summary>
        <value><span data-ttu-id="dd86b-4187">Ein <see cref="T:System.Reflection.MemberTypes" />-Wert, der angibt, dass dieser Member ein Typ oder ein geschachtelter Typ ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4187">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4188">Diese Eigenschaft über <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>schreibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4188">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="dd86b-4189">Wenn Sie z. b. eine Gruppe <xref:System.Reflection.MemberInfo> von Objekten untersuchen, gibt z. b <xref:System.Type.GetMembers%2A> . das <xref:System.Reflection.MemberInfo.MemberType%2A> von der <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> -Eigenschaft zurückgegebene Array zurück, wenn ein angegebener Member ein Typ ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4189">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects - for example, the array returned by <xref:System.Type.GetMembers%2A> - the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> when a given member is a nested type.</span></span>  
  
 <span data-ttu-id="dd86b-4190">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4190">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="dd86b-4191">Wenn der <xref:System.Type> aktuelle z. b. `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic) darstellt, wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4191">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="dd86b-4192">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>Eigenschaft immer zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4192">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-4193">Im folgenden Codebeispiel wird das `MemberType` -Feld als Parameter für die `GetMember` -Methode veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="dd86b-4193">The following code example shows the `MemberType` field as a parameter to the `GetMember` method:</span></span>  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-4194">Stellt einen in den <see cref="T:System.Type" />-Informationen fehlenden Wert dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4194">Represents a missing value in the <see cref="T:System.Type" /> information.</span></span> <span data-ttu-id="dd86b-4195">Dieses Feld ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4195">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4196">Verwenden Sie `Missing` das-Feld für den Aufruf durch Reflektion, um den Standardwert eines Parameters zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4196">Use the `Missing` field for invocation through reflection to obtain the default value of a parameter.</span></span> <span data-ttu-id="dd86b-4197">Wenn das `Missing` Feld für einen Parameterwert übergeben wird und kein Standardwert für diesen Parameter vorhanden ist, wird eine <xref:System.ArgumentException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4197">If the `Missing` field is passed in for a parameter value and there is no default value for that parameter, an <xref:System.ArgumentException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-4198">Das folgende Codebeispiel zeigt die Verwendung des `Missing` -Felds, um eine Methode mit ihren Standardargumenten aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4198">The following code example shows the use of the `Missing` field to invoke a method with its default arguments.</span></span>  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 <span data-ttu-id="dd86b-4199">Dieser Code erzeugt die folgende Ausgabe:</span><span class="sxs-lookup"><span data-stu-id="dd86b-4199">This code produces the following output:</span></span>  
  
 <span data-ttu-id="dd86b-4200">a = 10 b = 55,3 c = 12</span><span class="sxs-lookup"><span data-stu-id="dd86b-4200">a = 10 b = 55.3 c = 12</span></span>  
  
 <span data-ttu-id="dd86b-4201">a = 10 b = 1,3 c = 1</span><span class="sxs-lookup"><span data-stu-id="dd86b-4201">a = 10 b = 1.3 c = 1</span></span>  
  
 <span data-ttu-id="dd86b-4202">a = 10 b = 1,2 c = 1</span><span class="sxs-lookup"><span data-stu-id="dd86b-4202">a = 10 b = 1.2 c = 1</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-4203">Ruft das Modul (die DLL) ab, in dem der aktuelle <see cref="T:System.Type" /> definiert ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4203">Gets the module (the DLL) in which the current <see cref="T:System.Type" /> is defined.</span></span></summary>
        <value><span data-ttu-id="dd86b-4204">Das Modul, in dem der aktuelle <see cref="T:System.Type" /> definiert ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4204">The module in which the current <see cref="T:System.Type" /> is defined.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4205">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Eigenschaft das Modul zurück, in dem die generische Typdefinition definiert wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4205">If the current <xref:System.Type> represents a constructed generic type, this property returns the module in which the generic type definition was defined.</span></span> <span data-ttu-id="dd86b-4206">Wenn Sie z. b. eine Instanz von `MyGenericStack<int>`erstellen, <xref:System.Type.Module%2A> `MyGenericStack<T>` gibt die-Eigenschaft für den konstruierten Typ das Modul zurück, in dem definiert ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4206">For example, if you create an instance of `MyGenericStack<int>`, the <xref:System.Type.Module%2A> property for the constructed type returns the module in which `MyGenericStack<T>` is defined.</span></span>  
  
 <span data-ttu-id="dd86b-4207">Wenn der aktuelle <xref:System.Type> einen generischen Parameter `T`darstellt, gibt diese Eigenschaft die Assembly zurück, die den generischen Typ enthält `T`, der definiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4207">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-4208">Im folgenden <xref:System.Type.Namespace%2A> Beispiel wird die Verwendung der-Eigenschaft und `Module` der-Eigenschaft und <xref:System.Type>der <xref:System.Type.ToString%2A> -Methode von veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4208">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and `Module` properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-4209">Ruft beim Überschreiben in einer abgeleiteten Klasse den Namen des aktuellen Typs ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4209">When overridden in a derived class, gets the name of the current type.</span></span></summary>
        <value><span data-ttu-id="dd86b-4210">Der Name des aktuellen Typs.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4210">The name of the current type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-4211">Ruft den Namespace von <see cref="T:System.Type" /> ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4211">Gets the namespace of the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="dd86b-4212">Der Namespace des <see cref="T:System.Type" />; <see langword="null" />, wenn die aktuelle Instanz über keinen Namespace verfügt oder einen generischen Parameter darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4212">The namespace of the <see cref="T:System.Type" />; <see langword="null" /> if the current instance has no namespace or represents a generic parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4213">Ein Namespace ist eine logische Entwurfszeit-Benennungs Zweck, die hauptsächlich zum Definieren des Bereichs in einer Anwendung und zum Organisieren von Klassen und anderen Typen in einer einzelnen hierarchischen Struktur verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4213">A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.</span></span> <span data-ttu-id="dd86b-4214">Vom Standpunkt der Laufzeit sind keine Namespaces vorhanden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4214">From the viewpoint of the runtime, there are no namespaces.</span></span>  
  
 <span data-ttu-id="dd86b-4215">Wenn der aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Eigenschaft den Namespace zurück, der die generische Typdefinition enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4215">If the current <xref:System.Type> represents a constructed generic type, this property returns the namespace that contains the generic type definition.</span></span> <span data-ttu-id="dd86b-4216">Wenn der aktuelle <xref:System.Type> einen generischen Parameter `T`darstellt, gibt diese Eigenschaft den Namespace zurück, der die Definition des generischen Typs `T`enthält, der definiert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4216">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the namespace that contains the generic type definition that defines `T`.</span></span>  
  
 <span data-ttu-id="dd86b-4217">Wenn das aktuelle <xref:System.Type> -Objekt einen generischen Parameter darstellt, gibt `null`diese Eigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4217">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-4218">Im folgenden `Namespace` Beispiel wird die Verwendung der-Eigenschaft und <xref:System.Type.Module%2A> der-Eigenschaft und <xref:System.Type>der <xref:System.Type.ToString%2A> -Methode von veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4218">This following example demonstrates a use of the `Namespace` and <xref:System.Type.Module%2A> properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="dd86b-4219">Angeben vollständig gekennzeichneter Typnamen</span><span class="sxs-lookup"><span data-stu-id="dd86b-4219">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="dd86b-4220">Das erste zu vergleichende Objekt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4220">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="dd86b-4221">Das zweite zu vergleichende Objekt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4221">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="dd86b-4222">Gibt an, ob zwei <see cref="T:System.Type" />-Objekte gleich sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4222">Indicates whether two <see cref="T:System.Type" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="dd86b-4223"><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> gleich sind, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4223"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="dd86b-4224">Das erste zu vergleichende Objekt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4224">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="dd86b-4225">Das zweite zu vergleichende Objekt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4225">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="dd86b-4226">Gibt an, ob zwei <see cref="T:System.Type" />-Objekte ungleich sind.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4226">Indicates whether two <see cref="T:System.Type" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="dd86b-4227"><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4227"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-4228">Ruft das Klassenobjekt ab, über das dieser Member abgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4228">Gets the class object that was used to obtain this member.</span></span></summary>
        <value><span data-ttu-id="dd86b-4229">Das <see langword="Type" />-Objekt, über das dieses <see cref="T:System.Type" />-Objekt abgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4229">The <see langword="Type" /> object through which this <see cref="T:System.Type" /> object was obtained.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4230">Für <xref:System.Type> -Objekte ist der Wert dieser Eigenschaft immer identisch <xref:System.Type.DeclaringType%2A> mit dem Wert der-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4230">For <xref:System.Type> objects, the value of this property is always the same as the value of the <xref:System.Type.DeclaringType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-4231">In diesem Beispiel wird der reflektierte Typ einer-Klasse angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4231">This example displays the reflected type of a nested class.</span></span>  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="dd86b-4232">Der durch die Assembly bezeichnete Name des abzurufenden <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4232">The assembly-qualified name of the <see cref="T:System.Type" /> to get.</span></span></param>
        <param name="throwIfNotFound"><span data-ttu-id="dd86b-4233"><see langword="true" />, damit eine <see cref="T:System.TypeLoadException" /> ausgelöst wird, wenn der Typ nicht gefunden wird. <see langword="false" />, damit <see langword="null" /> zurückgegeben wird, wenn der Typ nicht gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4233"><see langword="true" /> to throw a <see cref="T:System.TypeLoadException" /> if the type cannot be found; <see langword="false" /> to return <see langword="null" /> if the type cannot be found.</span></span> <span data-ttu-id="dd86b-4234">Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4234">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="dd86b-4235">Informationen finden Sie im Abschnitt für Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4235">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="dd86b-4236"><see langword="true" />, um ohne Beachtung der Groß-/Kleinschreibung nach <paramref name="typeName" /> zu suchen; <see langword="false" />, um mit Beachtung der Groß-/Kleinschreibung nach <paramref name="typeName" /> zu suchen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4236"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />; <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="dd86b-4237">Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Dabei wird angegeben, ob bei der Suche die Groß- und Kleinschreibung berücksichtigt werden soll und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4237">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</span></span> <span data-ttu-id="dd86b-4238">Der Typ wird für die Reflektion, nicht für Ausführung geladen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4238">The type is loaded for reflection only, not for execution.</span></span></summary>
        <returns><span data-ttu-id="dd86b-4239">Der Typ mit dem angegebenen Namen, sofern gefunden, andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4239">The type with the specified name, if found; otherwise, <see langword="null" />.</span></span> <span data-ttu-id="dd86b-4240">Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwIfNotFound" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4240">If the type is not found, the <paramref name="throwIfNotFound" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="dd86b-4241">In einigen Fällen wird unabhängig vom Wert von <paramref name="throwIfNotFound" /> eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4241">In some cases, an exception is thrown regardless of the value of <paramref name="throwIfNotFound" />.</span></span> <span data-ttu-id="dd86b-4242">Informationen finden Sie im Abschnitt für Ausnahmen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4242">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4243">Wenn die Assembly, die den Typ enthält, nicht bereits in den Reflektionskontext geladen wurde <xref:System.Type.ReflectionOnlyGetType%2A> , entspricht die Verwendung der-Methode dem ersten Laden der Assembly für die <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> Reflektion, der Verwendung der-Methode und dem anschließenden Laden des Typs durch Aufrufen von. die- <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> Methode der Assembly.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4243">If the assembly containing the type is not already loaded into the reflection-only context, using the <xref:System.Type.ReflectionOnlyGetType%2A> method is equivalent to first loading the assembly for reflection only, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, and then loading the type by calling the assembly's <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="dd86b-4244">Informationen zu qualifizierten Assemblynamen finden Sie unter <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> der-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4244">For information about assembly-qualified names, see the <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="dd86b-4245">Weitere Informationen zum Angeben von Typnamen finden Sie unter <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> der-Methoden Überladung.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4245">For additional details on specifying type names, see the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="dd86b-4246">Wenn die Assembly bereits zur Ausführung geladen ist, wird eine andere Kopie in den reflektionsbasierten Kontext geladen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4246">If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="dd86b-4247">Der `throwIfNotFound` -Parameter gibt an, was geschieht, wenn der Typ nicht gefunden wird, und unterdrückt auch bestimmte andere Ausnahmebedingungen, wie im Abschnitt Ausnahmen beschrieben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4247">The `throwIfNotFound` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="dd86b-4248">Einige Ausnahmen werden unabhängig vom Wert von `throwIfNotFound`ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4248">Some exceptions are thrown regardless of the value of `throwIfNotFound`.</span></span> <span data-ttu-id="dd86b-4249">Wenn die Assembly z. b. ungültig ist, wird <xref:System.BadImageFormatException> eine ausgelöst, auch `throwIfNotFound` Wenn `false`ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4249">For example, if the assembly is not valid, a <xref:System.BadImageFormatException> is thrown even if `throwIfNotFound` is `false`.</span></span>  
  
 <span data-ttu-id="dd86b-4250">Weitere Informationen zur Verwendung des reflektionsbasierten Kontexts finden [Sie unter Gewusst wie: Laden von Assemblys in den reflexionsbezogenen Kontext](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span><span class="sxs-lookup"><span data-stu-id="dd86b-4250">For more information about using the reflection-only context, see [How to: Load Assemblies into the Reflection-Only Context](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd86b-4251"><paramref name="typeName" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4251"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="dd86b-4252">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4252">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="dd86b-4253"><paramref name="throwIfNotFound" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4253"><paramref name="throwIfNotFound" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="dd86b-4254">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-4254">-or-</span></span> 
 <span data-ttu-id="dd86b-4255"><paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4255"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="dd86b-4256">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-4256">-or-</span></span> 
 <span data-ttu-id="dd86b-4257"><paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4257"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="dd86b-4258">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-4258">-or-</span></span> 
 <span data-ttu-id="dd86b-4259"><paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4259"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="dd86b-4260">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-4260">-or-</span></span> 
 <span data-ttu-id="dd86b-4261"><paramref name="typeName" /> stellt ein Array mit <see cref="T:System.TypedReference" />-Objekten dar.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4261"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" /> objects.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd86b-4262"><paramref name="typeName" /> enthält keinen Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4262"><paramref name="typeName" /> does not include the assembly name.</span></span>  
  
<span data-ttu-id="dd86b-4263">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-4263">-or-</span></span> 
 <span data-ttu-id="dd86b-4264"><paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax (z.B. „MyType[,\*,]“).</span><span class="sxs-lookup"><span data-stu-id="dd86b-4264"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax; for example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="dd86b-4265">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-4265">-or-</span></span> 
 <span data-ttu-id="dd86b-4266"><paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4266"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="dd86b-4267">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-4267">-or-</span></span> 
 <span data-ttu-id="dd86b-4268"><paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4268"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="dd86b-4269">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-4269">-or-</span></span> 
 <span data-ttu-id="dd86b-4270"><paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4270"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="dd86b-4271"><paramref name="throwIfNotFound" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4271"><paramref name="throwIfNotFound" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="dd86b-4272">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4272">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="dd86b-4273">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4273">The assembly or one of its dependencies is not valid.</span></span>  
  
 <span data-ttu-id="dd86b-4274">- oder -</span><span class="sxs-lookup"><span data-stu-id="dd86b-4274">-or-</span></span>  
  
 <span data-ttu-id="dd86b-4275">Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4275">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="dd86b-4276">Angeben vollständig gekennzeichneter Typnamen</span><span class="sxs-lookup"><span data-stu-id="dd86b-4276">Specifying Fully Qualified Type Names</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md"><span data-ttu-id="dd86b-4277">Gewusst wie: Laden von Assemblys in den reflektionsbezogenen Kontext</span><span class="sxs-lookup"><span data-stu-id="dd86b-4277">How to: Load Assemblies into the Reflection-Only Context</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-4278">Ruft ein <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> ab, der das Layout des aktuellen Typs beschreibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4278">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the layout of the current type.</span></span></summary>
        <value><span data-ttu-id="dd86b-4279">Ruft ein <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> ab, das den allgemeinen Layoutfunktionen des aktuellen Typs beschreibt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4279">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the gross layout features of the current type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4280"><xref:System.Runtime.InteropServices.StructLayoutAttribute>wird von der <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> -Methode nicht zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4280"><xref:System.Runtime.InteropServices.StructLayoutAttribute> is not returned by the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method.</span></span> <span data-ttu-id="dd86b-4281">Verwenden Sie diese Eigenschaft stattdessen, um Sie zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4281">Instead, use this property to get it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-4282">Im folgenden Codebeispiel werden zuerst eine-Klasse, eine-Struktur und eine-Struktur mit speziellen Layoutattributen definiert (die-Strukturen sind in der-Klasse geschachtelt).</span><span class="sxs-lookup"><span data-stu-id="dd86b-4282">The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class).</span></span> <span data-ttu-id="dd86b-4283">Im Beispiel wird dann die <xref:System.Type.StructLayoutAttribute%2A> -Eigenschaft verwendet, <xref:System.Runtime.InteropServices.StructLayoutAttribute> um einen für jeden Typ abzurufen, und die Eigenschaften der Attribute werden angezeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4283">The example then uses the <xref:System.Type.StructLayoutAttribute%2A> property to obtain a <xref:System.Runtime.InteropServices.StructLayoutAttribute> for each type, and displays the properties of the attributes.</span></span>  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd86b-4284">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4284">The invoked method is not supported in the base class.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="dd86b-4285">Für zukünftige Verwendung reserviert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4285">Reserved for future use.</span></span> <span data-ttu-id="dd86b-4286">Muss IID_NULL sein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4286">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="dd86b-4287">Das übergebene Array von zuzuordnenden Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4287">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="dd86b-4288">Die Anzahl der zuzuordnenden Namen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4288">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="dd86b-4289">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4289">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="dd86b-4290">Das vom Aufrufer zugewiesene Array, das die IDs entsprechend den Namen empfängt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4290">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="dd86b-4291">Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4291">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4292">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4292">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="dd86b-4293">Weitere Informationen zu `IDispatch::GetIDsOfNames`finden Sie in der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4293">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="dd86b-4294">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4294">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="dd86b-4295">Die zurückzugebenden Typinformationen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4295">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="dd86b-4296">Der Gebietsschemabezeichner für die Typinformationen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4296">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="dd86b-4297">Ein Zeiger auf das angeforderte Objekt mit den Typinformationen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4297">A pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="dd86b-4298">Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4298">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4299">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4299">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="dd86b-4300">Weitere Informationen zu `IDispatch::GetTypeInfo`finden Sie in der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4300">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="dd86b-4301">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4301">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="dd86b-4302">Zeigt auf einen Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4302">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="dd86b-4303">Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</span><span class="sxs-lookup"><span data-stu-id="dd86b-4303">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4304">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4304">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="dd86b-4305">Weitere Informationen zu `IDispatch::GetTypeInfoCount`finden Sie in der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4305">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="dd86b-4306">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4306">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="dd86b-4307">Bezeichnet den Member.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4307">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="dd86b-4308">Für zukünftige Verwendung reserviert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4308">Reserved for future use.</span></span> <span data-ttu-id="dd86b-4309">Muss IID_NULL sein.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4309">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="dd86b-4310">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4310">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="dd86b-4311">Flags, die den Kontext des Aufrufs beschreiben.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4311">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="dd86b-4312">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4312">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="dd86b-4313">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4313">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="dd86b-4314">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4314">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="dd86b-4315">Der Index des ersten Arguments mit einem Fehler.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4315">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="dd86b-4316">Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4316">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4317">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4317">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="dd86b-4318">Weitere Informationen zu `IDispatch::Invoke`finden Sie in der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4318">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="dd86b-4319">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4319">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="dd86b-4320">Gibt einen <see langword="String" /> zurück, der den Namen des aktuellen <see langword="Type" /> darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4320">Returns a <see langword="String" /> representing the name of the current <see langword="Type" />.</span></span></summary>
        <returns><span data-ttu-id="dd86b-4321">Ein <see cref="T:System.String" />, der den Namen des aktuellen <see cref="T:System.Type" /> darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4321">A <see cref="T:System.String" /> representing the name of the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4322">Diese Methode gibt den voll qualifizierten Common Language Runtime Namespace und den Namen für alle primitiven Typen zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4322">This method returns the fully qualified common language runtime namespace and name for all primitive types.</span></span> <span data-ttu-id="dd86b-4323">Die C# -Anweisung `(long)0.Type().ToString()` gibt beispielsweise "System. Int64" anstelle von "Int64" zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4323">For example, the C# instruction, `(long)0.Type().ToString()` returns "System.Int64" instead of merely "Int64".</span></span>  
  
 <span data-ttu-id="dd86b-4324">Wenn der aktuelle <xref:System.Type> einen generischen Typ darstellt, werden der Typ und seine Typargumente durch den Namespace und den Typ, jedoch nicht durch die Assembly qualifiziert.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4324">If the current <xref:System.Type> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.</span></span> <span data-ttu-id="dd86b-4325">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Methode den nicht qualifizierten Namen des Typparameters zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4325">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-4326">Im folgenden <xref:System.Type.Namespace%2A> Beispiel wird die Verwendung der-Eigenschaft und <xref:System.Type.Module%2A> der-Eigenschaft und <xref:System.Type>der `ToString` -Methode von veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4326">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and <xref:System.Type.Module%2A> properties and the `ToString` method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 <span data-ttu-id="dd86b-4327">Im folgenden Beispiel werden die von <xref:System.Type.ToString%2A> der-Methode zurückgegebenen Zeichen folgen und die <xref:System.Type.AssemblyQualifiedName%2A> `Name`Eigenschaften, <xref:System.Type.FullName%2A>und verglichen.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4327">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-4328">Ruft das Handle für den aktuellen <see cref="T:System.Type" /> ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4328">Gets the handle for the current <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="dd86b-4329">Das Handle für den aktuellen <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4329">The handle for the current <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4330">`TypeHandle`kapselt einen Zeiger auf eine interne Datenstruktur, die den Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4330">`TypeHandle` encapsulates a pointer to an internal data structure that represents the type.</span></span> <span data-ttu-id="dd86b-4331">Dieses Handle ist während der Prozess Lebensdauer eindeutig.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4331">This handle is unique during the process lifetime.</span></span> <span data-ttu-id="dd86b-4332">Das Handle ist nur in der Anwendungsdomäne gültig, in der es abgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4332">The handle is valid only in the application domain in which it was obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd86b-4333">Das folgende Beispiel gibt das Handle des entsprechenden Typs zurück und übergibt das Handle an eine Methode, die den Typ aus dem Handle abruft und anzeigt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4333">The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.</span></span>  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="dd86b-4334">Diese Eigenschaft wird von .NET Compact Framework derzeit nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4334">The .NET Compact Framework does not currently support this property.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-4335">Ruft den Initialisierer für den Typ ab.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4335">Gets the initializer for the type.</span></span></summary>
        <value><span data-ttu-id="dd86b-4336">Ein Objekt, das den Namen des Klassenkonstruktors von <see cref="T:System.Type" /> enthält.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4336">An object that contains the name of the class constructor for the <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd86b-4337">Klasseninitialisierer sind auch über die <xref:System.Type.FindMembers%2A> -Methode verfügbar, oder über über Ladungen <xref:System.Type.GetMember%2A>der <xref:System.Type.GetMembers%2A>Methoden <xref:System.Type.GetConstructor%2A>,, <xref:System.Type.GetConstructors%2A> und, die <xref:System.Reflection.BindingFlags> als Parameter akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4337">Class initializers are also available through the <xref:System.Type.FindMembers%2A> method, or through overloads of the <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, and <xref:System.Type.GetConstructors%2A> methods that take <xref:System.Reflection.BindingFlags> as a parameter.</span></span>  
  
 <span data-ttu-id="dd86b-4338">Wenn der aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt `null`diese Eigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4338">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="dd86b-4339">Gibt den von der Common Language Runtime bereitgestellten Typ an, der diesen Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4339">Indicates the type provided by the common language runtime that represents this type.</span></span></summary>
        <value><span data-ttu-id="dd86b-4340">Der Systemtyp, der <see cref="T:System.Type" />zugrunde liegt.</span><span class="sxs-lookup"><span data-stu-id="dd86b-4340">The underlying system type for the <see cref="T:System.Type" />.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>
