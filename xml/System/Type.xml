<Type Name="Type" FullName="System.Type">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c13fa7b3afc18c9fbda4a9976478c70d9f148788" /><Meta Name="ms.sourcegitcommit" Value="7555c040bd7cb677d117ddf03e647aa7bf625bfc" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/08/2019" /><Meta Name="ms.locfileid" Value="65440872" /></Metadata><TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Typdeklarationen dar: Klassentypen, Schnittstellentypen, Arraytypen, Werttypen, Enumerationstypen, Typparameter, generische Typdefinitionen und offen oder geschlossen konstruierte generische Typen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` ist der Stamm der <xref:System.Reflection> Funktionen und ist der einfachste Weg, um auf Metadaten zuzugreifen. Verwenden Sie die Elemente der <xref:System.Type> zum Abrufen von Informationen über die Typdeklaration, über die Elemente eines Typs (z. B. die Konstruktoren, Methoden, Felder, Eigenschaften und Ereignisse von einer Klasse), sowie das Modul und die Assembly, in dem die Klasse bereitgestellt wird.  
  
 Es sind keine Berechtigungen erforderlich, damit Code Reflektion verwenden, um Informationen zu Typen und Member, unabhängig von ihrer Zugriffsebenen zu erhalten. Es sind keine Berechtigungen erforderlich, damit Code Reflektion verwenden, um Zugriff auf öffentliche Member oder andere Elemente, deren Zugriffsebenen sie während der normalen Kompilierung sichtbar wäre. Allerdings nacheinander für Ihren Code Reflektion, um Zugriff auf Member zu verwenden, die normalerweise nicht zugegriffen werden kann, z. B. private oder interne Methoden werden, oder geschützte Felder eines Typs, die die Klasse erbt nicht, Ihr Code müssen <xref:System.Security.Permissions.ReflectionPermission>. Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).  
  
 `Type` ist eine abstrakte Basisklasse, die mehrere Implementierungen ermöglicht. Das System stellt immer die abgeleitete Klasse `RuntimeType`. In der Reflektion werden alle Klassen, die mit dem Wort Common Language Runtime beginnt nur einmal pro Objekt in der System- und Unterstützung Vergleichsvorgängen erstellt.  
  
> [!NOTE]
>  Multithreading Szenarien, Sperren Sie keine <xref:System.Type> Objekte zum Synchronisieren des Zugriffs auf `static` Daten. Anderer Code, in dem Sie keine Kontrolle, haben möglicherweise auch Ihr Klassentyp sperren. Dies kann zu einem Deadlock führen. Synchronisieren Sie den Zugriff auf statische Daten stattdessen von Sperren eines privaten `static` Objekt.  
  
> [!NOTE]
>  Eine abgeleitete Klasse kann es sich um geschützte Member der Basisklassen des aufrufenden Codes zugreifen. Darüber hinaus ist der Zugriff auf Assemblymember des aufrufenden Codes Assembly zulässig. Wenn Sie den Zugriff im Code früh gebundene dürfen er in der Regel auch in spät gebundenen Code zulässig.  
  
> [!NOTE]
>  Schnittstellen, die andere Schnittstellen erweitern erben nicht die Methoden, die in die erweiterten Schnittstellen definiert.  
  
 In diesem Abschnitt  
  
 [Welche Typen stellt ein Typobjekt dar?](#WhatTypes)   
 [Abrufen eines Typobjekt](#Retrieve)   
 [Vergleichen von Typ Objekte auf Gleichheit](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>Welche Typen stellt ein Typobjekt dar?  
 Diese Klasse ist threadsicher. eine Instanz dieses Typs können mehrere Threads gleichzeitig gelesen werden. Eine Instanz von der <xref:System.Type> Klasse kann einen der folgenden Typen darstellen:  
  
-   Klassen  
  
-   Werttypen  
  
-   Arrays  
  
-   Schnittstellen  
  
-   Enumerationen  
  
-   Delegaten  
  
-   Konstruierte generische Typen und generische Typdefinitionen  
  
-   Geben Sie Argumente und Parameter der konstruierte generische Typen, generische Typdefinitionen und generischen Methodendefinitionen  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>Abrufen eines Typobjekt  
 Die <xref:System.Type> einen bestimmten Typ zugeordnete Objekt abgerufen werden kann, es gibt folgende Möglichkeiten:  
  
-   Die Instanz <xref:System.Object.GetType%2A?displayProperty=nameWithType> Methode gibt eine <xref:System.Type> -Objekt, das den Typ einer Instanz darstellt. Da alle verwaltete Typen abgeleitet <xref:System.Object>, <xref:System.Object.GetType%2A> Methode für eine Instanz eines beliebigen Typs aufgerufen werden kann.  
  
     Im folgenden Beispiel wird die <xref:System.Object.GetType%2A?displayProperty=nameWithType> Methode, um den Laufzeittyp der einzelnen Objekte in einem Objektarray festzulegen.  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   Die statische <xref:System.Type.GetType%2A?displayProperty=nameWithType> Methoden zurückgeben einer <xref:System.Type> -Objekt, das einen durch den vollständig qualifizierten Namen angegebenen Typ darstellt.  
  
-   Die <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, und <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> Methoden zurückgeben `Type` -Objekten, die in einem Modul definierten Typen darstellen. Die erste Methode kann zum Abrufen eines Arrays von <xref:System.Type> Objekte für alle öffentlichen und privaten Typen, die in einem Modul definiert. (Sie erhalten eine Instanz von `Module` über die <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> -Methode, oder über die <xref:System.Type.Module%2A?displayProperty=nameWithType> Eigenschaft.)  
  
-   Die <xref:System.Reflection.Assembly?displayProperty=nameWithType> Objekt enthält eine Reihe von Methoden zum Abrufen von der Klassen, die in einer Assembly definiert, einschließlich <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, und <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.  
  
-   Die <xref:System.Type.FindInterfaces%2A> Methode gibt eine gefilterte Liste der Schnittstellentypen, die von einem Typ unterstützt.  
  
-   Die <xref:System.Type.GetElementType%2A> Methode gibt eine `Type` -Objekt, das Element darstellt.  
  
-   Die <xref:System.Type.GetInterfaces%2A> und <xref:System.Type.GetInterface%2A> Methoden zurückgeben <xref:System.Type> Objekte, die von einem Typ unterstützten Schnittstellentypen darstellt.  
  
-   Die <xref:System.Type.GetTypeArray%2A> Methode gibt ein Array von <xref:System.Type> Objekte, die durch einen beliebigen Satz von Objekten angegebenen Typen darstellen. Die Objekte sind mit einem Array des Typs angegeben <xref:System.Object>.  
  
-   Die <xref:System.Type.GetTypeFromProgID%2A> und <xref:System.Type.GetTypeFromCLSID%2A> Methoden für COM-Interoperabilität bereitgestellt werden. Sie zurückgeben einer <xref:System.Type> -Objekt, den vom angegebenen Typ darstellt. ein `ProgID` oder `CLSID`.  
  
-   Die <xref:System.Type.GetTypeFromHandle%2A> Methode wird für die Interoperabilität bereitgestellt. Gibt eine `Type` -Objekt, den durch ein Klassenhandle angegebenen Typ darstellt.  
  
-   Die C#- `typeof` Operator an, die C++ `typeid` Operator und die Visual Basic `GetType` Operator erhalten die `Type` Objekt für einen Typ.  
  
-   Die <xref:System.Type.MakeGenericType%2A> Methode gibt eine <xref:System.Type> Objekt einen konstruierten generischen Typ, der ein offener Typ ist, darstellt, die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft gibt `true`, und einem geschlossenen konstruierten Typ andernfalls. Ein generischer Typ kann instanziiert werden, nur, wenn es geschlossen ist.  
  
-   Die <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, und <xref:System.Type.MakeByRefType%2A> Methoden zurückgeben <xref:System.Type> darstellende – Objekte, bzw. ein Array des angegebenen Typs, der einen Zeiger auf einen angegebenen Typ und den Typ des Verweisparameters (`ref` in c# `ByRef`in Visual Basic).  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>Vergleichen von Typ Objekte auf Gleichheit  
 Ein <xref:System.Type> -Objekt, stellt ein Typ eindeutig ist, d. h. zwei <xref:System.Type> Objektverweise auf dasselbe Objekt verweisen, wenn sie denselben Typ darstellen. Dies ermöglicht den Vergleich von <xref:System.Type> Objekte mithilfe von Verweisgleichheit. Im folgenden Beispiel wird die <xref:System.Type> Objekte, die als von ganzzahligen Werten Zahl, um zu bestimmen, ob diese vom gleichen Typ sind.  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 Das folgende Beispiel zeigt einige repräsentative Features von <xref:System.Type>. Die C# `typeof` Operator (`GetType` -Operator in Visual Basic) Dient zum Abrufen einer <xref:System.Type> Objekt darstellt <xref:System.String>. Aus diesem <xref:System.Type> Objekt die <xref:System.Type.GetMethod%2A> Methode dient zum Abrufen einer <xref:System.Reflection.MethodInfo> darstellt der <xref:System.String.Substring%2A?displayProperty=nameWithType> Überladung, die eine Anfangsposition und eine Länge akzeptiert.
  
 Um die Überladungssignatur zu identifizieren, das Codebeispiel erstellt ein temporäres Array mit zwei <xref:System.Type> Objekte darstellt `int` (`Integer` in Visual Basic).  
  
> [!NOTE]
>  Genauer gesagt, das Array enthält zwei Verweise auf die Instanz von <xref:System.Type> darstellender `int` in der aktuellen Anwendungsdomäne. Für jeden Typ, es gibt nur eine Instanz des <xref:System.Type> pro Anwendungsdomäne.  
  
 Das Codebeispiel verwendet die <xref:System.Reflection.MethodInfo> zum Aufrufen der <xref:System.String.Substring%2A> Methode in der Zeichenfolge "Hello, World!", und das Ergebnis wird angezeigt.  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <block subset="none" type="overrides"><para>Beim Erben von <see langword="Type" />, müssen Sie die folgenden Member überschreiben: 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md">Anzeigen von Typinformationen</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Type" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird von abgeleiteten Klassen aufgerufen, während der Konstruktion von Objekten des Typs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Reflection.Assembly" /> ab, in der der Typ deklariert ist. Ruft bei generischen Typen die <see cref="T:System.Reflection.Assembly" /> ab, in der der generische Typ definiert ist.</summary>
        <value>Eine <see cref="T:System.Reflection.Assembly" />-Instanz, die die Assembly mit dem aktuellen Typ beschreibt. Bei generischen Typen beschreibt die Instanz die Assembly, die die generische Typdefinition enthält, nicht die Assembly, in der ein bestimmter konstruierter Typ erstellt und verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> -Objekt stellt einen konstruierten generischen Typ dar, das diese Eigenschaft gibt die Assembly, die generische Typdefinition enthält. Nehmen wir beispielsweise an, die Sie erstellen eine Assembly mit dem Namen MyGenerics.dll, die die generische Typdefinition enthält `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic `generic<T> ref class MyGenericStack` in C++). Bei der Erstellung einer Instanz von `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in einer anderen Assembly, die <xref:System.Type.Assembly%2A> -Eigenschaft für den konstruierten Typ gibt eine <xref:System.Reflection.Assembly> -Objekt, das MyGenerics.dll darstellt.  
  
 Auf ähnliche Weise, wenn die aktuelle <xref:System.Type> Objekt darstellt, einen nicht zugewiesenen generischen Parameter `T`, diese Eigenschaft gibt die Assembly, die den generischen Typ enthält, die definiert `T`.  
  
 Wenn die <xref:System.Type.Assembly%2A?displayProperty=nameWithType> Eigenschaft ist nicht in einer bestimmten .NET-Implementierung, z. B. .NET Core- oder die universelle Windows-Plattform verfügbar, verwenden Sie die <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> Eigenschaft stattdessen.      
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Namen der Assembly, der Klasse zugeordnet und der vollqualifizierte Name des Typs.  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den durch die Assembly qualifizierten Namen des Typs ab, der den Namen der Assembly enthält, aus der der <see cref="T:System.Type" /> geladen wurde.</summary>
        <value>Der durch die Assembly qualifizierte Name des <see cref="T:System.Type" />, der den Namen der Assembly enthält, aus der der <see cref="T:System.Type" /> geladen wurde, oder <see langword="null" />, wenn die aktuelle Instanz einen generischen Typparameter darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Assembly qualifizierten Namen eines Typs besteht aus der Typname, einschließlich des Namespaces, gefolgt von einem Komma, gefolgt von den Anzeigenamen der Assembly. Der Anzeigename einer Assembly mit abgerufen wird die <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> Eigenschaft.  
  
> [!NOTE]
>  In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt wird, und kann als Teil der Assembly-Zeichenfolgen angegeben werden. Z. B. "ProcessorArchitecture = Msil". Es ist jedoch nicht enthalten in der Zeichenfolge, die vom der <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft aus Kompatibilitätsgründen. Siehe <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 Alle Compiler, die die common Language Runtime unterstützen, geben den einfachen Namen einer geschachtelten Klasse und Reflektion erstellt einen ergänzten Namen in Übereinstimmung mit den folgenden Konventionen abgefragt.  
  
|Delimiter|Bedeutung|  
|---------------|-------------|  
|Umgekehrter Schrägstrich (\\)|Escape-Zeichen.|  
|Komma (,)|Der Name der Assembly wird vorangestellt.|  
|Pluszeichen (+)|Steht vor einer geschachtelten Klasse.|  
|Punkt (.)|Bezeichnet die Namespacebezeichner.|  
|Eckige Klammern ([])|Nach der ein Typname gibt Sie ein Array dieses Typs an.<br /><br /> - oder - <br /><br /> Für einen generischen Typ ist schließt die Argumentliste für den generischen Typ.<br /><br /> - oder - <br /><br /> In einer Liste der Typargumente schließt eine Assembly qualifizierten Typnamen ein.|  
  
 Die Assembly qualifizierten Namen für eine Klasse kann beispielsweise wie folgt aussehen:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 Wenn der Namespace enthalten, ein Pluszeichen (+), z. B. TopNamespace.Sub sind, und klicken Sie dann das Pluszeichen (+) ein Escapezeichen vorangestellt werden würde (\\) zu verhindern, dass es als geschachteltes Trennzeichen interpretiert wird. Wird diese Zeichenfolge wie folgt für die Reflektionsausgabe:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 Ein "++" wird "\\+\\+", und ein "\\"wird"\\\\".  
  
 Dieser qualifizierte Name persistent gespeichert werden kann, und später verwendet, um das Laden der <xref:System.Type>. Suchen und Laden eine <xref:System.Type>, verwenden Sie <xref:System.Type.GetType%2A> entweder mit dem Typ oder einen Namen geben nur mit dem Namen der Assembly qualifizierten Typ. <xref:System.Type.GetType%2A> mit dem Namen nur sucht die <xref:System.Type> in der Assembly des Aufrufers, und klicken Sie dann in der System-Assembly. <xref:System.Type.GetType%2A> mit der Assembly qualifizierten Typnamen sucht die <xref:System.Type> in jeder Assembly.  
  
 Namen können nachfolgende Zeichen enthalten, zusätzliche Informationen über den Typ, z. B., ob der Typ ein Verweistyp, ein Zeigertyp oder einen Arraytyp ist. Verwenden Sie zum Abrufen der Typname ohne diese nachfolgenden Zeichen `t.GetElementType().ToString()`, wobei `t` ist der Typ.  
  
 Leerzeichen sind in allen Komponenten von Typnamen mit Ausnahme der Assemblyname relevant. Der Assemblyname Leerzeichen vor dem Trennzeichen ',' relevant, aber Leerzeichen nach dem Trennzeichen ',' werden ignoriert.  
  
 Generischen Argumente von generischen Typen werden selbst durch Assemblynamen gekennzeichnet. Z. B. in der Assembly qualifizierter Typname für `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` wird erweitert, um die Assembly qualifizierten Typnamen für <xref:System.Int32>.  
  
 Wenn die aktuelle <xref:System.Type> -Objekt einen generischen Parameter darstellt, gibt diese Eigenschaft `null`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Namen der Assembly, der Klasse zugeordnet und der vollqualifizierte Name des Typs.  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 Im folgenden Beispiel wird die Zeichenfolgen, die zurückgegeben werden, indem die <xref:System.Type.ToString%2A> Methode und die `Name`, <xref:System.Type.FullName%2A>, und <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaften.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Angeben vollständig gekennzeichneter Typnamen</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dem <see cref="T:System.Type" /> zugeordneten Attribute ab.</summary>
        <value>Ein <see cref="T:System.Reflection.TypeAttributes" />-Objekt, das die Attributgruppe von <see cref="T:System.Type" /> darstellt. Falls <see cref="T:System.Type" /> jedoch einen generischen Typparameter darstellt, ist der Wert nicht festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Mitglied der <xref:System.Reflection.TypeAttributes> Enumeration werden von Masken, die eine Gruppe von Werten darstellen. Jede Gruppe enthält ein Element, dessen zugrunde liegender Wert 0 (null) ist. Z. B. den zugrunde liegenden Wert von der <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> Element in der <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Gruppe ist 0 (null), da die <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> Element in der <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> Gruppe. Aus diesem Grund müssen Sie die Maske verwenden, bevor Sie für diese Werte zu testen. Dies wird im Beispiel veranschaulicht.  
  
> [!TIP]
>  In den meisten Fällen Eigenschaften wie <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, und <xref:System.Type.IsSpecialName%2A> sind einfacher zu verwenden als Attribute des Typs.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gibt die Attribute der Definition des generischen Typs zurück. Z. B. die Attribute, die für die zurückgegebenen `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) sind die Attribute des `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).  
  
 Wenn die aktuelle <xref:System.Type> , also einen generischen Typparameter - darstellt, wenn die <xref:System.Type.IsGenericParameter%2A> -Eigenschaft gibt `true` : die <xref:System.Reflection.TypeAttributes> von dieser Eigenschaft zurückgegebene Wert ist nicht angegeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Type.Attributes%2A> Eigenschaft.  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ ab, von dem der aktuelle <see cref="T:System.Type" /> direkt vererbt wird.</summary>
        <value>Der <see cref="T:System.Type" />, von dem der aktuelle <see cref="T:System.Type" /> direkt erbt, oder <see langword="null" />, wenn der aktuelle <see langword="Type" /> die <see cref="T:System.Object" />-Klasse oder eine Schnittstelle darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Basistyp ist der Typ, von dem der aktuelle Typ direkt erbt. <xref:System.Object> ist der einzige Typ, der aus diesem Grund keinen Basistyp, `null` wird zurückgegeben, als der Basistyp des <xref:System.Object>.  
  
 Schnittstellen werden von keinem oder mehreren Basisschnittstellen erben. aus diesem Grund gibt diese Eigenschaft zurück `null` Wenn die `Type` Objekt stellt eine Schnittstelle dar. Die Basisschnittstellen können bestimmt werden, mit <xref:System.Type.GetInterfaces%2A> oder <xref:System.Type.FindInterfaces%2A>.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierter generischen Typ darstellt, der Basistyp spiegelt wider, die generischen Argumente. Betrachten Sie beispielsweise die folgenden Deklarationen:  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 Für den konstruierten Typ `C<int>` (`C(Of Integer)` in Visual Basic), wird die <xref:System.Type.BaseType%2A> -Eigenschaft gibt `B<int>`.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter einer generischen Typdefinition, <xref:System.Type.BaseType%2A> gibt zurück, der die Class-Einschränkung, d. h. die Klasse, die der Typparameter erben muss. Es ist keine klasseneinschränkung <xref:System.Type.BaseType%2A> gibt <xref:System.Object?displayProperty=nameWithType>.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Type.BaseType%2A> Eigenschaft.  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 Im folgenden Beispiel wird Rekursion, um die vollständige Vererbungshierarchie jeder Klasse finden Sie in einer Assembly aufzulisten. Das Beispiel definiert eine Klasse namens `C` abgeleitet, die eine Klasse namens `B`, das wiederum eine Klasse namens abgeleitet `A`.  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflektion und generische Typen</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das aktuelle <see cref="T:System.Type" />-Objekt über Typparameter verfügt, die nicht durch bestimmte Typen ersetzt wurden.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Type" />-Objekt selbst ein generischer Parametertyp ist oder über Typparameter verfügt, für die keine bestimmten Typen angegeben wurden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um eine Instanz eines Typs zu erstellen, muss keine generische Typdefinitionen oder offenen konstruierten Typen in die Typargumente des Typs selbst, in der einschließenden generischen Typen oder Elemente des Typs vorhanden sein. Anders ausgedrückt: Dies ist bei überprüft rekursiv, der Typ muss keine generischen Typparameter enthalten.  
  
 Da die Typen nicht übermäßig komplex sein können, ist dieser Feststellung schwierig. Der Einfachheit halber und reduzieren die Wahrscheinlichkeit, dass Fehler, die <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft bietet eine standardisierte Möglichkeit zur Unterscheidung von geschlossener konstruierter Typen, die instanziiert werden kann, und offen konstruierte Typen, die nicht. Wenn die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft gibt `true`, der Typ kann nicht instanziiert werden.  
  
 Die <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft sucht rekursiv nach Typparameter. Es gibt z. B. `true` für ein Array, dessen Elemente sind `A<T>` (`A(Of T)` in Visual Basic), auch wenn das Array selbst nicht generisch ist. Vergleichen Sie dies mit dem Verhalten von der <xref:System.Type.IsGenericType%2A> -Eigenschaft, die gibt `false` für Arrays.  
  
 Für eine Reihe von Beispielklassen und eine Tabelle mit den Werten der der <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft finden Sie unter <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine generische Klasse mit zwei Typparametern und definiert dann eine zweite generische Klasse, die von der ersten Klasse abgeleitet ist. Basisklasse für die abgeleitete Klasse verfügt über zwei Typargumente: der erste <xref:System.Int32> und die zweite ist ein Typparameter des abgeleiteten Typs. Das Beispiel zeigt Informationen zu diesen generischen Klassen, von gemeldeten einschließlich die Positionen der <xref:System.Type.GenericParameterPosition%2A> Eigenschaft.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflektion und generische Typen</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Vorgehensweise: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Reflection.MethodBase" /> ab, die die deklarierende Methode darstellt, wenn der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Methode darstellt.</summary>
        <value>Wenn der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Methode darstellt, eine <see cref="T:System.Reflection.MethodBase" />, die die deklarierende Methode darstellt, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die deklarierende Methode ist eine generische Methodendefinition. D. h. wenn <xref:System.Type.DeclaringMethod%2A> keinen zurückgibt `null`, klicken Sie dann `DeclaringMethod.IsGenericMethodDefinition` gibt `true`.  
  
 Die <xref:System.Type.DeclaringType%2A> und <xref:System.Type.DeclaringMethod%2A> Eigenschaften identifizieren, die generische Typdefinition oder generische Methodendefinition, die in der der generische Typparameter ursprünglich definiert wurde:  
  
-   Wenn die <xref:System.Type.DeclaringMethod%2A> -Eigenschaft gibt eine <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.MethodInfo> stellt eine generische Methodendefinition, und das aktuelle <xref:System.Type> Objekt einen Typparameter der generischen Methodendefinition darstellt.  
  
-   Wenn die <xref:System.Type.DeclaringMethod%2A> -Eigenschaft gibt `null`, und klicken Sie dann die <xref:System.Type.DeclaringType%2A> -Eigenschaft gibt immer einen <xref:System.Type> Objekt, das eine generische Typdefinition, und das aktuelle darstellt <xref:System.Type> -Objekt einen Typparameter des generischen Typs darstellt die Definition.  
  
-   Abrufen der <xref:System.Type.DeclaringMethod%2A> Eigenschaft für einen Typ, dessen <xref:System.Type.IsGenericParameter%2A> Eigenschaft `false` löst eine <xref:System.InvalidOperationException>.  
  
 Die <xref:System.Reflection.MethodBase> von zurückgegebenen der <xref:System.Type.DeclaringMethod%2A> -Eigenschaft ist entweder ein <xref:System.Reflection.MethodInfo> im Fall einer generischen Methode oder ein <xref:System.Reflection.ConstructorInfo> bei einem generischen Konstruktor.  
  
> [!NOTE]
>  In .NET Framework, Version 2.0 sind generische Konstruktoren nicht unterstützt.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel definiert eine Klasse, die eine generische Methode, ein Typargument an die Methode weist und die sich ergebende konstruierte generische Methode aufruft. Außerdem werden Informationen zur Definition der generischen Methode und die konstruierte Methode angezeigt. Anzeigen von Informationen über die Typparameter der generischen Methodendefinition, in der `DisplayGenericMethodInfo` -Methode der Beispielcode zeigt den Wert des der <xref:System.Type.DeclaringMethod%2A> -Eigenschaft für generischen Typparameter der Methode.  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflektion und generische Typen</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Vorgehensweise: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ ab, der den aktuellen geschachtelten oder generischen Typparameter deklariert.</summary>
        <value>Ein <see cref="T:System.Type" />-Objekt, das den einschließenden Typ darstellt, wenn es sich bei dem aktuellen Typ um einen geschachtelten Typ handelt. Die generische Typdefinition, wenn es sich bei dem aktuellen Typ um einen Typparameter eines generischen Typs handelt. Der Typ, der die generische Methode deklariert, wenn es sich bei dem aktuellen Typ um einen Typparameter einer generischen Methode handelt. Andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> -Objekt einen Typparameter eines generischen Typs darstellt, diese Eigenschaft gibt die Definition des generischen Typs zurück.  
  
 Wenn die aktuelle <xref:System.Type> -Objekt einen Typparameter einer generischen Methode darstellt, diese Eigenschaft gibt den Typ zurück, die die Methodendefinition enthält. Wenn der Typ generisch ist, wird die Definition des generischen Typs zurückgegeben. Der folgende Code gibt, also die generische Typdefinition von der <xref:System.Collections.Generic.List%601> generische Klasse, die enthält die <xref:System.Collections.Generic.List%601.ConvertAll%2A> generische Methode:  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt der <xref:System.Type.DeclaringType%2A> und <xref:System.Type.DeclaringMethod%2A> Eigenschaften identifizieren, die generische Typdefinition oder generische Methodendefinition, in dem der generische Typparameter, ursprünglich definiert wurde:  
  
-   Wenn die <xref:System.Type.DeclaringMethod%2A> -Eigenschaft gibt eine <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.MethodInfo> stellt eine generische Methodendefinition, und das aktuelle <xref:System.Type> Objekt einen Typparameter der generischen Methodendefinition darstellt.  
  
-   Wenn die <xref:System.Type.DeclaringMethod%2A> -Eigenschaft gibt `null`, und klicken Sie dann die <xref:System.Type.DeclaringType%2A> -Eigenschaft gibt immer einen <xref:System.Type> Objekt, das eine generische Typdefinition, und das aktuelle darstellt <xref:System.Type> -Objekt einen Typparameter des generischen Typs darstellt die Definition.  
  
-   Abrufen der <xref:System.Type.DeclaringType%2A> Eigenschaft für einen Typ, dessen <xref:System.Type.IsGenericParameter%2A> Eigenschaft `false` löst eine <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Dieses Beispiel zeigt den deklarierenden Typ einer Methode in einer abgeleiteten Klasse.  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf den Standardbinder ab, der interne Regeln für die Auswahl der passenden Member implementiert, die von <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> aufgerufen werden sollen.</summary>
        <value>Ein Verweis auf den vom System verwendeten Standardbinder.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardbinder bereitgestellt, mit der common Language Runtime ist in allen außer den sehr speziellen Umständen anwendbar. Bei Bedarf einen Binder, mit denen Regeln folgt, die von den angegebenen Standardbinder unterscheiden definiert ein abgeleiteten Typ der <xref:System.Reflection.Binder> Klasse und übergeben Sie eine Instanz dieses Typs mithilfe der `binder` Parameter eines der <xref:System.Type.InvokeMember%2A> Überladungen.  
  
 Reflektion modelliert die Zugriffsregeln des allgemeinen Typsystems. Wenn der Aufrufer in der gleichen Assembly ist, wird z. B. spezielle Berechtigungen von der Aufrufer nicht für interne Member benötigt. Andernfalls, benötigt der Aufrufer <xref:System.Security.Permissions.ReflectionPermission>. Dies ist konsistent mit der Suche nach Membern, die geschützt werden, private und so weiter.  
  
 Im Allgemeinen gilt, die <xref:System.Reflection.Binder.ChangeType%2A> nur erweiternde Konvertierungen, die keine Daten verloren gehen durchführen sollte. Ein Beispiel für eine erweiternde Konvertierung ist das Konvertieren eines Werts, der eine 32-Bit-Ganzzahl mit Vorzeichen in einen Wert, der eine 64-Bit-Ganzzahl mit Vorzeichen ist. Dies ist von einer einschränkenden Konvertierung unterschieden, die Daten verloren gehen können. Ein Beispiel für eine einschränkende Konvertierung ist eine 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen konvertiert werden.  
  
 Die folgende Tabelle enthält die Konvertierungen, die von der Standardbinder unterstützt werden.  
  
|Quelltyp|Zieltyp|  
|-----------------|-----------------|  
|Beliebiger Typ|Basistyp.|  
|Beliebiger Typ|Die Schnittstelle, die er implementiert.|  
|Char|Unt16 "," UInt32 "," Int32 "," UInt64 "," Int64, Single, Double|  
|Byte|Char-Zeichen, Unt16 "," Int16 "," UInt32 "," Int32 "," UInt64 "," Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, Single, Double|  
|UInt64|Single, Double|  
|Int64|Single, Double|  
|Single|Double|  
|Ohne Verweis|Per-Verweis.|  
  
   
  
## Examples  
 Im folgenden Beispiel wird den Standardbinder aus der `DefaultBinder` -Eigenschaft, und ruft Sie einen Member von MyClass durch Übergeben der `DefaultBinder` Wert als Parameter an <xref:System.Type.InvokeMember%2A>.  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trennt Namen im Namespace des <see cref="T:System.Type" />. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt ein leeres Array vom <see cref="T:System.Type" />-Typ dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel zeigt die `EmptyTypes` Feld verwendet die `GetConstructor` Methoden zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob der zugrunde liegende Systemtyp des aktuellen <see cref="T:System.Type" /> mit dem zugrunde liegende Systemtyp des angegebenen <see cref="T:System.Object" /> oder <see cref="T:System.Type" /> übereinstimmt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, dessen zugrunde liegender Systemtyp mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> verglichen werden soll. <paramref name="o" /> muss in ein Objekt vom Typ <see cref="T:System.Type" /> umgewandelt oder konvertiert werden können, damit der Vergleich erfolgreich durchgeführt werden kann.</param>
        <summary>Bestimmt, ob der zugrunde liegende Systemtyp des aktuellen <see cref="T:System.Type" />-Objekts mit dem zugrunde liegenden Systemtyp des angegebenen <see cref="T:System.Object" />-Objekts übereinstimmt</summary>
        <returns><see langword="true" />, wenn der zugrunde liegende Systemtyp von <paramref name="o" /> mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> übereinstimmt, andernfalls <see langword="false" />. Diese Methode gibt auch <see langword="false" /> zurück, wenn:  
  
-   <paramref name="o" /> ist <see langword="null" />.  
  
-   <paramref name="o" /> nicht in ein <see cref="T:System.Type" />-Objekt umgewandelt oder konvertiert werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Es wandelt `o` auf ein Objekt des Typs <xref:System.Type> und ruft die <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Type.Equals%28System.Object%29> zum Vergleichen verschiedener <xref:System.Type> Objektinstanzen mit verschiedenen <xref:System.Object> Instanzen.  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 Zwei Dinge sind besonders erwähnenswert Informationen zum Beispiel:  
  
-   Der Vergleich eine <xref:System.Type> Objekt, das eine ganze Zahl mit darstellt eine <xref:System.Reflection.TypeInfo> -Objekt, das eine ganze Zahl zurückgeben darstellt `true` da <xref:System.Reflection.TypeInfo> ergibt sich aus <xref:System.Type>.  
  
-   Der Vergleich eine <xref:System.Type> Objekt, das darstellt eine <xref:System.Collections.Generic.IList%601> Objekt (ein offener generischer Typ) mit einer `List(Of String)` -Objekt (einen geschlossenen generischen Typ) zurückgibt `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, dessen zugrunde liegender Systemtyp mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> verglichen werden soll.</param>
        <summary>Bestimmt, ob der zugrunde liegende Systemtyp des aktuellen <see cref="T:System.Type" /> mit dem zugrunde liegenden Systemtyp des angegebenen <see cref="T:System.Type" /> übereinstimmt.</summary>
        <returns><see langword="true" />, wenn der zugrunde liegende Systemtyp von <paramref name="o" /> mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird `Equals` zum Vergleichen zweier Typen.  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den für Attribute verwendeten Memberfilter dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Feld enthält einen Verweis auf den Delegaten ein, die die <xref:System.Type.FindMembers%2A> Methode. Durch diesen Delegaten gekapselte Methode akzeptiert zwei Parameter: die erste ist ein <xref:System.Reflection.MemberInfo> Objekt und die zweite ist ein `Object`. Die Methode bestimmt, ob die `MemberInfo` Objekt mit die vom angegebenen Kriterien übereinstimmt. die `Object`. Die `Object` möglicherweise den Wert eines der Felder in den Klassen zugeordnet <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, oder <xref:System.Reflection.MethodImplAttributes>.  
  
 Z. B. die `Object` kann der Wert eines Felds aus zugewiesen werden `FieldAttributes` wie "Public". In diesem Fall, wenn die `FilterAttribute` Delegat wird aufgerufen, wird zurückgegeben, die `true` nur dann, wenn die Methode von dargestellt die `MemberInfo` Objekt mit dem öffentlichen Feld-Attribut in den Metadaten ergänzt wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `FilterAttribute` delegieren, übergibt sie als Parameter an die <xref:System.Type.FindMembers%2A> -Methode, und zeigt die angegebenen Elemente und ihre Attribute.  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den für Namen verwendeten Memberfilter mit Beachtung der Groß-/Kleinschreibung dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Feld enthält einen Verweis auf den Delegaten ein, die die <xref:System.Type.FindMembers%2A> Methode. Durch diesen Delegaten gekapselte Methode akzeptiert zwei Parameter: die erste ist ein <xref:System.Reflection.MemberInfo> Objekt und die zweite ist ein `Object`. Die Methode bestimmt, ob die `MemberInfo` Objekt mit die vom angegebenen Kriterien übereinstimmt. die `Object`. Die `Object` erhält einen Zeichenfolgenwert an, die kein nachfolgendes Zeichen enthalten, kann "*" Platzhalterzeichen. Nur Ende Zeichenfolge mit Platzhalterzeichen werden unterstützt.  
  
 Z. B. die `Object` kann den Wert "Byte *" zugewiesen werden. In diesem Fall, wenn die `FilterName` Delegat wird aufgerufen, wird zurückgegeben, die `true` nur dann, wenn die Methode von dargestellt die `MemberInfo` Objekt hat einen Namen, die mit "Byte" beginnt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird Ruft ab, die die benutzerdefinierte zugeordneten Methoden `Application` Typ.  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den für Namen verwendeten Memberfilter ohne Beachtung der Groß-/Kleinschreibung dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Feld enthält einen Verweis auf den Delegaten ein, die die <xref:System.Type.FindMembers%2A> Methode. Durch diesen Delegaten gekapselte Methode akzeptiert zwei Parameter: die erste ist ein <xref:System.Reflection.MemberInfo> Objekt und die zweite ist ein `Object`. Die Methode bestimmt, ob die `MemberInfo` Objekt mit die vom angegebenen Kriterien übereinstimmt. die `Object`. Die `Object` erhält einen Zeichenfolgenwert an, die kein nachfolgendes Zeichen enthalten, kann "*" Platzhalterzeichen. Nur Ende Zeichenfolge mit Platzhalterzeichen werden unterstützt.  
  
 Z. B. die `Object` kann den Wert "ByTe *" zugewiesen werden. In diesem Fall, wenn die `FilterName` Delegat wird aufgerufen, es wird nur dann true zurück, wenn die Methode von dargestellt die `MemberInfo` Objekt hat einen Namen, die mit "Byte", ignorieren Groß-/Kleinschreibung beginnt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `MemberFilter` delegieren, übergibt sie als Parameter an die <xref:System.Type.FindMembers%2A> -Methode, und zeigt die Methoden und ihre Attribute den `String` -Klasse, die mit dem Buchstaben "c", wobei die Groß-/Kleinschreibung beginnen.  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="filter">Der Delegat, der die Schnittstellen anhand der <paramref name="filterCriteria" /> vergleicht.</param>
        <param name="filterCriteria">Die Suchkriterien, die bestimmen, ob eine Schnittstelle in das zurückgegebene Array aufgenommen wird.</param>
        <summary>Gibt ein Array von <see cref="T:System.Type" />-Objekten zurück, die eine gefilterte Liste von Schnittstellen darstellen, die vom aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurden.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, die eine gefilterte Liste von Schnittstellen darstellt, die durch den aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurden, oder ein leeres Array vom Typ <see cref="T:System.Type" />, wenn der aktuelle <see cref="T:System.Type" /> keine dem Filter entsprechenden Schnittstellen implementiert oder erbt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
 Die <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> und <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> Delegaten die <xref:System.Reflection.Module?displayProperty=nameWithType> Klasse kann auch in verwendet werden, anstelle der der <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegieren.  
  
 Alle von dieser Klasse implementierten Schnittstellen gelten bei der Suche, ob die von einer Basisklasse oder von der Klasse selbst deklariert.  
  
 Diese Methode sucht in der Basisklasse-Hierarchie, die zurückgegeben wird, jede der entsprechenden Schnittstellen, die jede Klasse implementiert wird, sowie alle entsprechenden Schnittstellen für jede von diesen Schnittstellen implementiert (d. h. der transitive Abschluss von den entsprechenden Schnittstellen wird zurückgegeben). Es werden keine doppelten Schnittstellen zurückgegeben.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt <xref:System.Type.FindInterfaces%2A> sucht alle Schnittstellen in den Einschränkungen für den Typparameter deklariert, und alle Schnittstellen, die über die Schnittstellen vererbt in den Einschränkungen deklariert. Wenn die aktuelle <xref:System.Type> stellt ein Typargument eines generischen Typs, <xref:System.Type.FindInterfaces%2A> sucht Sie alle Schnittstellen vom Typ, implementiert werden, und zwar unabhängig davon, ob sie Einschränkungen entsprechen.  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A> generische Schnittstellen, sogar für Typen, die nicht generisch sind, können zurückgegeben werden. Beispielsweise kann ein nicht generischer Typ implementieren `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).  
  
   
  
## Examples  
 Das folgende Beispiel sucht die angegebene Schnittstelle implementiert oder geerbt vom angegebenen Typ und zeigt dann die Schnittstellennamen.  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein statischer Initialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="memberType">Ein Objekt, das den Typ der gesuchten Member angibt.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="filter">Der Delegat, der die Vergleiche durchführt. Der Rückgabewert ist <see langword="true" />, wenn der gerade betrachtete Member den <paramref name="filterCriteria" /> entspricht, andernfalls <see langword="false" />. Sie können die Delegaten <see langword="FilterAttribute" />, <see langword="FilterName" /> und <see langword="FilterNameIgnoreCase" /> dieser Klasse verwenden. Der erste Delegat verwendet als Suchkriterien die Felder von <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> und <see langword="MethodImplAttributes" />, die anderen beiden Delegaten verwenden <see langword="String" />-Objekte als Suchkriterien.</param>
        <param name="filterCriteria">Die Suchkriterien, die bestimmen, ob ein Member im Array von <see langword="MemberInfo" />-Objekten zurückgegeben wird.  
  
Die Felder von <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> und <see langword="MethodImplAttributes" /> können zusammen mit dem <see langword="FilterAttribute" />-Delegaten dieser Klasse verwendet werden.</param>
        <summary>Gibt ein gefiltertes Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten mit dem angegebenen Membertyp zurück.</summary>
        <returns>Ein gefiltertes Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten vom angegebenen Membertyp.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Reflection.MemberInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine den Filterkriterien entsprechenden Member vom <paramref name="memberType" />-Typ besitzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
 Mitglieder enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, auf welche Member in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Instance` Instanzmember in die Suche eingeschlossen.  
  
-   Geben Sie `BindingFlags.Static` statische Mitglieder in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Mitglieder in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentliche Mitglieder (d. h. private, interne und geschützte Member) in die Suche eingeschlossen werden sollen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die Member deklariert die <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Gültige Werte für <xref:System.Type.MemberType%2A> in definiert <xref:System.Reflection.MemberInfo>. Wenn keine solchen Member gefunden werden, wird ein leeres Array zurückgegeben.  
  
 Rufen Sie die klasseninitialisierung (.cctor), die mit dieser Methode müssen Sie angeben <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). Erhalten Sie auch die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter einer generischen Typ-oder Methodendefinition, <xref:System.Type.FindMembers%2A> verarbeitet alle Member deklariert, indem die Class-Einschränkung und die schnittstelleneinschränkungen des Typparameters.  
  
   
  
## Examples  
 Im folgende Beispiel sucht alle Elemente in einer Klasse, die die angegebenen Suchkriterien entsprechen, und klicken Sie dann werden die übereinstimmenden Elemente angezeigt.  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den voll vollqualifizierten Namen des Typs ab. Dies beinhaltet den Namespace, nicht jedoch die Assembly.</summary>
        <value>Der vollqualifizierte Name des Typs, einschließlich des Namespace, jedoch ausschließlich der Assembly, oder <see langword="null" />, wenn die aktuelle Instanz einen auf einem Typparameter basierenden generischen Typparameter, Arraytyp, Zeigertyp oder <see langword="byref" />-Typ oder einen generischen Typ darstellt, der keine generische Typdefinition ist, jedoch nicht aufgelöste Typparameter enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Z. B. den vollqualifizierten Namen des der <xref:System.String> Typ `System.String`. Vergleichen Sie dies mit dem assemblyqualifizierten Namen zurückgegeben werden, indem die <xref:System.Type.AssemblyQualifiedName%2A> -Eigenschaft, die den vollständigen Namen sowie den vollständigen Assemblynamen besteht.  
  
 Wenn der aktuelle Typ einen geschlossenen generischen Typ darstellt, die Typargumente, die in der Zeichenfolge zurückgegeben, durch die <xref:System.Type.FullName%2A> Eigenschaft werden durch ihren vollständigen Assemblynamen, qualifiziert, auch wenn die Zeichenfolgendarstellung des generischen Typs selbst nicht durch seine voll qualifiziert wird Name der Assembly. Das folgende Beispiel veranschaulicht den Unterschied in der FullName-Eigenschaft für einen Typ, der generische Typdefinition darstellt, und eine, die einen geschlossenen generischen Typ darstellt.  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 Diese Eigenschaft gibt `null` wenn:  
  
-   Die aktuelle <xref:System.Type> -Objekt einen Typparameter eines generischen Typs darstellt.  
  
     Das folgende Beispiel ruft die Typparameter der <xref:System.Nullable%601> Typ und die Versuche zum Anzeigen der <xref:System.Type.FullName%2A> Eigenschaft.  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   Die aktuelle <xref:System.Type> Objekt stellt einen Arraytyp, ein Zeigertyp oder ein `byref` Typ, der auf einen generischen Typparameter basiert.  
  
     Das folgende Beispiel definiert einen generischen Typ `Generictype1<T>`, mit drei Methoden: `Display(T[])`, die ein Array vom Typ T, übergeben wird `HandleT(T)`, die ein T-Objekt übergeben wird und `ChangeValue(ref T)`, die ein T-Objekt als Verweis übergeben wird. Da C#- und Visual Basic, definieren Sie T als Zeiger in unzulässig sind die `HandleT` -Methode aufrufen, müssen die <xref:System.Type.MakePointerType%2A> Methode für die <xref:System.Type> -Objekt, Parametertyp der Methode, um einen Zeiger auf einen generischen Typ erstellen darstellt. Die Ausgabe des Beispiels zeigt, dass in allen drei Fällen die <xref:System.Type.FullName%2A> Eigenschaft `null`.  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   Der aktuelle Typ enthält generischen Typparameter, die nicht durch bestimmte Typen ersetzt wurden (d. h. die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft gibt `true`), aber der Typ ist nicht die Definition eines generischen Typs (, also die <xref:System.Type.IsGenericTypeDefinition%2A> -Eigenschaft gibt `false`  
  
     Im folgenden Beispiel `Derived<T>` erbt `Base<T>`. Die <xref:System.Type.BaseType%2A> Eigenschaft ruft die <xref:System.Type> Objekt, das den Basistyp darstellt `Derived<T>`, und die zugehörige <xref:System.Type.FullName%2A> -Eigenschaft gibt `null`.  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     Zum Abrufen einer <xref:System.Type.FullName%2A> , die sich nicht `null`, können Sie die <xref:System.Type.GetGenericTypeDefinition%2A> Methode, um die Definition eines generischen Typs abzurufen, wie im Beispiel veranschaulicht.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den vollständigen Namen des angegebenen Typs.  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 Im folgenden Beispiel wird die Zeichenfolgen, die zurückgegeben werden, indem die <xref:System.Type.ToString%2A> Methode und die `Name`, <xref:System.Type.FullName%2A>, und <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaften.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Angeben vollständig gekennzeichneter Typnamen</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Kombination von <see cref="T:System.Reflection.GenericParameterAttributes" />-Flags ab, die die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters beschreiben.</summary>
        <value>Eine bitweise Kombination von <see cref="T:System.Reflection.GenericParameterAttributes" />-Werten, die die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters beschreiben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft enthält Flags, die beschreiben, ob der aktuellen generischen Typparameter kovariant ist, und die Flags, die besonderen Einschränkungen zu beschreiben. Verwenden Sie die <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> Wert, der die Kovarianzflags auswählen, und Verwenden der <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> Wert, der die Einschränkungsflags auswählen.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel definiert einen generischen Typ `Test` mit zwei Typparametern, die verschiedene Einschränkungen aufweisen. Wenn das Programm ausgeführt wird, die Einschränkungen werden überprüft, mit der <xref:System.Type.GenericParameterAttributes%2A> Eigenschaft und die <xref:System.Type.GetGenericParameterConstraints%2A> Methode.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das aktuelle <see cref="T:System.Type" />-Objekt ist kein generischer Typparameter. Das bedeutet, dass die <see cref="P:System.Type.IsGenericParameter" />-Eigenschaft <see langword="false" /> zurückgibt.</exception>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflektion und generische Typen</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Vorgehensweise: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position des Typparameters in der Typparameterliste des generischen Typs oder der Methode ab, der bzw. die den Parameter deklariert hat, wenn das <see cref="T:System.Type" />-Objekt einen Typparameter eines generischen Typs oder einer generischen Methode darstellt.</summary>
        <value>Die Position eines Typparameters in der Typparameterliste des generischen Typs oder der generischen Methode, der bzw. die den Parameter definiert. Die Positionsnummern beginnen mit 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GenericParameterPosition%2A> -Eigenschaft gibt die Position eines Typparameters in der Parameterliste der Definition eines generischen Typs oder generische Methodendefinition, in dem der Typparameter ursprünglich definiert wurde. Die <xref:System.Type.DeclaringType%2A> und <xref:System.Type.DeclaringMethod%2A> Eigenschaften identifizieren den generische Typ- oder Methodendefinition:  
  
-   Wenn die <xref:System.Type.DeclaringMethod%2A> -Eigenschaft gibt eine <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.MethodInfo> stellt eine generische Methodendefinition, und das aktuelle <xref:System.Type> Objekt einen Typparameter der generischen Methodendefinition darstellt.  
  
-   Wenn die <xref:System.Type.DeclaringMethod%2A> -Eigenschaft gibt `null`, und klicken Sie dann die <xref:System.Type.DeclaringType%2A> -Eigenschaft gibt immer einen <xref:System.Type> Objekt, das eine generische Typdefinition, und das aktuelle darstellt <xref:System.Type> -Objekt einen Typparameter des generischen Typs darstellt die Definition.  
  
 Zu den richtigen Kontext für den Wert der <xref:System.Type.GenericParameterPosition%2A> -Eigenschaft, es ist notwendig, identifizieren Sie die generischen Typ oder Methode, die ein Typparameter gehört. Betrachten Sie beispielsweise den Rückgabewert der generischen Methode `GetSomething` in den folgenden Code:  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 Der Rückgabetyp von `GetSomething` hängt von der Klasse angegebenen Typargumente `A` und `GetSomething` selbst. Sie erhalten eine <xref:System.Reflection.MethodInfo> für `GetSomething`, und von dem Sie den Rückgabetyp erhalten. Wenn Sie überprüfen, dass die Typparameter des Rückgabetyps, <xref:System.Type.GenericParameterPosition%2A> gibt 0 zurück, für beide. Die Position des `V` ist 0, da `V` ist der erste Typparameter in der Liste der Typparameter für die Klasse `A`. Die Position des `X` ist 0, da `X` ist der erste Typparameter in der Typparameterliste für `GetSomething`.  
  
> [!NOTE]
>  Aufrufen der <xref:System.Type.GenericParameterPosition%2A> Eigenschaft löst eine Ausnahme aus, wenn die aktuelle <xref:System.Type> stellt keinen Typparameter dar. Wenn Sie die Typargumente eines offenen konstruierten Typs zu untersuchen, verwenden Sie die <xref:System.Type.IsGenericParameter%2A> Eigenschaft mitteilen, welche Parameter vom Typ und die Typen sind. Die <xref:System.Type.IsGenericParameter%2A> -Eigenschaft gibt `true` für einen Typparameter; anschließend können Sie die <xref:System.Type.GenericParameterPosition%2A> Methode, um seine Position abrufen und Verwenden der <xref:System.Type.DeclaringMethod%2A> und <xref:System.Type.DeclaringType%2A> Eigenschaften, um zu bestimmen die generische Methode, oder geben Sie die Definition, die es definiert .  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine generische Klasse mit zwei Typparametern, und es wird eine zweite generische Klasse, die von der ersten Klasse abgeleitet ist. Basisklasse für die abgeleitete Klasse verfügt über zwei Typargumente: der erste <xref:System.Int32>, und die zweite ist ein Typparameter des abgeleiteten Typs. Das Beispiel zeigt Informationen zu diesen generischen Klassen, von gemeldeten einschließlich die Positionen der <xref:System.Type.GenericParameterPosition%2A> Eigenschaft.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Typ stellt keinen Typparameter dar. Das heißt, <see cref="P:System.Type.IsGenericParameter" /> gibt <see langword="false" /> zurück.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflektion und generische Typen</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Vorgehensweise: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Array von generischen Typargumenten für diesen Typ ab.</summary>
        <value>Ein Array von generischen Typargumenten für diesen Typ.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird nur die generischen Typargumente; d. h. Typen, die für die generischen Typparameter des aktuellen Typs angegeben wurden. Wenn der aktuelle Typ eine generische Typdefinition ist, gibt diese Eigenschaft ein leeres Array zurück.  
  
> [!NOTE]
>  Wenn ein generischer Typ in einer generischen Methode oder in einem anderen generischen Typ verwendet wird, möglicherweise einiger seiner generischen Typargumente der einschließenden Methode oder der Typ generische Typparameter.  
  
 Rufen Sie die generischen Typparameter eines Typs, die eine generische Typdefinition darstellt, mit der <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> Eigenschaft. Zum Abrufen einer <xref:System.Reflection.TypeInfo> Objekt für die aktuelle <xref:System.Type> -Objekts die <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> -Erweiterungsmethode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Anzahl der Dimensionen eines Arrays ab.</summary>
        <returns>Eine Ganzzahl, die die Anzahl der Dimensionen im aktuellen Typ darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt die Anzahl der Dimensionen in einem Array.  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Funktionalität dieser Methode wird in der Basisklasse nicht unterstützt und muss stattdessen in einer abgeleiteten Klasse implementiert werden.</exception>
        <exception cref="T:System.ArgumentException">Der aktuelle Typ ist kein Array.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.Attributes" />-Eigenschaft und ruft eine Bitmaske ab, die die <see cref="T:System.Type" /> zugeordneten Attribute anzeigt.</summary>
        <returns>Ein <see cref="T:System.Reflection.TypeAttributes" />-Objekt, das die Attributgruppe von <see cref="T:System.Type" /> darstellt.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen bestimmten Konstruktor des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter des abzurufenden Konstruktors darstellt.  
  
- oder -  
Ein leeres Array von <see cref="T:System.Type" />-Objekten zum Abrufen eines Konstruktors ohne Parameter. Das <see langword="static" />-Feld <see cref="F:System.Type.EmptyTypes" /> stellt ein entsprechendes leeres Array bereit.</param>
        <summary>Sucht einen öffentlichen Instanzkonstruktor, dessen Parameter den Typen im angegebenen Array entsprechen.</summary>
        <returns>Ein Objekt, das den öffentlichen Instanzkonstruktor darstellt, dessen Parameter den Typen im Parametertyparray entsprechen, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese methodenüberladung sucht nach öffentlichen Instanzkonstruktoren und kann nicht verwendet werden, um ein Klasseninitialisierer (.cctor) zu erhalten. Um ein Klasseninitialisierer zu erhalten, verwenden Sie eine Überladung mit <xref:System.Reflection.BindingFlags>, und geben Sie <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). Erhalten Sie auch die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Wenn der angeforderte Konstruktor nicht öffentlich ist, gibt diese Methode `null`.  
  
> [!NOTE]
>  Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden. Sie können nur Parameter auslassen, beim Aufrufen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt. Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Methode gibt immer `null`.  
  
   
  
## Examples  
 Im folgende Beispiel ruft den Typ der `MyClass`, ruft der <xref:System.Reflection.ConstructorInfo> Objekt aus, und zeigt die Signatur des Konstruktors.  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> ist <see langword="null" />.  
  
- oder -  
Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
- oder -  
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das Anzahl, Reihenfolge und Typ der Parameter des abzurufenden Konstruktors darstellt.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.  
  
- oder -  
 <see cref="F:System.Type.EmptyTypes" />.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im Parametertyparray zugeordnet sind. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht einen Konstruktor, dessen Parameter unter Verwendung der angegebenen Bindungseinschränkungen den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein <see cref="T:System.Reflection.ConstructorInfo" />-Objekt, das den Konstruktor darstellt, der den angegebenen Anforderungen entspricht, oder <see langword="null" />, wenn kein entsprechender Konstruktor gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine genaue Übereinstimmung nicht vorhanden ist, die `binder` wird versucht, die im angegebenen Parametertypen zu konvertieren die `types` Array, um eine Übereinstimmung auszuwählen. Wenn die `binder` kann eine Übereinstimmung, wählen Sie dann `null` zurückgegeben wird.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um die Konstruktoren in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Konstruktoren in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentlichen Konstruktoren (d.h. private, interne und geschützte Konstruktoren) in die Suche eingeschlossen werden sollen.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Rufen Sie die klasseninitialisierung (.cctor) mithilfe der Überladung dieser Methode müssen Sie angeben <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). Erhalten Sie auch die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
> [!NOTE]
>  Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden. Sie können nur Parameter auslassen, beim Aufrufen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt. Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Methode gibt immer `null`.  
  
   
  
## Examples  
 Das folgende Programm ruft den Typ der `MyClass1` -Klasse ruft die <xref:System.Reflection.ConstructorInfo> Objekt den angegebenen Bindungsflags und zeigt die Signatur des Konstruktors.  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> ist <see langword="null" />.  
  
- oder -  
Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="modifiers" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
- oder -  
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="callConvention">Das Objekt, das die Regeln für die Reihenfolge und das Layout von Argumenten, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das Anzahl, Reihenfolge und Typ der Parameter des abzurufenden Konstruktors darstellt.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht einen Konstruktor, dessen Parameter den angegebenen Argumenttypen und -modifizierern entsprechen, und berücksichtigt dabei die angegebenen Bindungseinschränkungen und die angegebene Aufrufkonvention.</summary>
        <returns>Ein Objekt, das den Konstruktor darstellt, der den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl nicht der Standardbinder verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, der verarbeitet `modifiers`. `ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und behandelt nur die Parameter, die als Verweis übergeben werden.  
  
 Wenn eine genaue Übereinstimmung nicht vorhanden ist, die `binder` wird versucht, die im angegebenen Parametertypen zu konvertieren die `types` Array, um eine Übereinstimmung auszuwählen. Wenn die `binder` kann eine Übereinstimmung, wählen Sie dann `null` zurückgegeben wird.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um die Konstruktoren in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Konstruktoren in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentlichen Konstruktoren (d.h. private, interne und geschützte Konstruktoren) in die Suche eingeschlossen werden sollen.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Rufen Sie die klasseninitialisierung (.cctor), die mit dieser Methode müssen Sie angeben <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). Erhalten Sie auch die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden ein, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|event|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuelle) möglich Ausblenden nach Namen oder nach Name und Signatur ausblenden.|  
|Geschachtelter Typ|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen, Sentinels enthält und nicht verwaltete Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit dem ein Get und Set-Accessor in der Basisklasse haben, aber die abgeleitete Klasse nur einen Get-Accessor hat, die Eigenschaft der abgeleiteten Klasse blendet die Basisklasseneigenschaft aus, und nicht werden auf den Setter in der Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
> [!NOTE]
>  Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden. Sie können nur Parameter auslassen, beim Aufrufen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt. Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Methode gibt immer `null`.  
  
   
  
## Examples  
 Im folgende Beispiel ruft den Typ der `MyClass1`, ruft der <xref:System.Reflection.ConstructorInfo> -Objekt, das den angegebenen Bindungsflags entspricht, und zeigt die Signatur des Konstruktors.  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> ist <see langword="null" />.  
  
- oder -  
Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="modifiers" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
- oder -  
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="callConvention">Das Objekt, das die Regeln für die Reihenfolge und das Layout von Argumenten, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das Anzahl, Reihenfolge und Typ der Parameter des abzurufenden Konstruktors darstellt.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse, unter Verwendung der angegebenen Bindungseinschränkungen und der angegebenen Aufrufkonvention, nach einem Konstruktor, dessen Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein <see cref="T:System.Reflection.ConstructorInfo" />-Objekt, das den Konstruktor darstellt, der den angegebenen Anforderungen entspricht, oder <see langword="null" />, wenn kein entsprechender Konstruktor gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl nicht der Standardbinder verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, der verarbeitet `modifiers`. `ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und behandelt nur die Parameter, die als Verweis übergeben werden.  
  
 Wenn eine genaue Übereinstimmung nicht vorhanden ist, die `binder` wird versucht, die im angegebenen Parametertypen zu konvertieren die `types` Array, um eine Übereinstimmung auszuwählen. Wenn die `binder` kann eine Übereinstimmung, wählen Sie dann `null` zurückgegeben wird.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um die Konstruktoren in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Konstruktoren in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentlichen Konstruktoren (d.h. private, interne und geschützte Konstruktoren) in die Suche eingeschlossen werden sollen.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Diese Methode implementiert <xref:System.Type.GetConstructor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> ist <see langword="null" />.  
  
- oder -  
Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="modifiers" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <exception cref="T:System.NotSupportedException">Der aktuelle Typ ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" /> oder <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die Konstruktoren des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle öffentlichen Konstruktoren zurück, die für den aktuellen <see cref="T:System.Type" /> definiert sind.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.ConstructorInfo" /> -Objekten, die alle für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Instanzkonstruktoren mit Ausnahme des Typinitialisierers (statischer Konstruktor) darstellen. Wenn für den aktuellen <see cref="T:System.Type" /> keine öffentlichen Instanzkonstruktoren definiert sind oder der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Typ- oder Methodendefinition darstellt, wird ein leeres Array vom Typ <see cref="T:System.Reflection.ConstructorInfo" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetConstructors%2A> Methode Konstruktoren nicht in einer bestimmten Reihenfolge, z. B. die Reihenfolge der Deklaration zurückgegeben. Ihr Code muss nicht abhängig von der Reihenfolge, in der Konstruktoren zurückgegeben werden, da, die variieren kann.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden ein, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|event|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuelle) möglich Ausblenden nach Namen oder nach Name und Signatur ausblenden.|  
|Geschachtelter Typ|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen, Sentinels enthält und nicht verwaltete Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit dem ein Get und Set-Accessor in der Basisklasse haben, aber die abgeleitete Klasse nur einen Get-Accessor hat, die Eigenschaft der abgeleiteten Klasse blendet die Basisklasseneigenschaft aus, und nicht werden auf den Setter in der Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Diese methodenüberladung Ruft die <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> methodenüberladung mit <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in Visual Basic). Die Klasseninitialisierer (.cctor) nicht gefunden. Um Klasseninitialisierer zu ermitteln, verwenden Sie eine Überladung mit <xref:System.Reflection.BindingFlags>, und geben Sie <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). Erhalten Sie auch die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> Objekte mit den Typparametern, die durch die entsprechenden Typargumente ersetzt. Z. B. Wenn Klasse `C<T>` verfügt über einen Konstruktor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), wird beim Aufruf <xref:System.Type.GetConstructors%2A> auf `C<int>` gibt eine <xref:System.Reflection.ConstructorInfo> darstellender `C(int t1)` in c# (`Sub New(ByVal t1 As Integer)` in Visual Basic).  
  
 Wenn die aktuelle <xref:System.Type> stellt einen generischen Typparameter, der <xref:System.Type.GetConstructors%2A> Methode ein leeres Array zurück.  
  
   
  
## Examples  
 Dieses Beispiel zeigt die Ausgabe der <xref:System.Type.GetConstructors%2A> überladen, die von einer Klasse, die über zwei Instanzkonstruktoren und einen statischen Konstruktor verfügt.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 Die Ausgabe dieses Codes lautet:  
  
 2  
  
 False  
  
 False  
  
 Da die <xref:System.Type.GetConstructors> Überladung verwendet nur <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, der statische Konstruktor ist weder gezählt, indem die `for` Ausdruck noch ausgewertet, indem `IsStatic`.  
  
 Um statische Konstruktoren zu suchen, verwenden die <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> überladen, und übergeben Sie die Kombination (logische `OR`) der <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, wie im folgenden Codebeispiel gezeigt:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Jetzt ist die Ausgabe:  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen <see cref="T:System.Type" /> die für den aktuellen <see langword="BindingFlags" /> definierten Konstruktoren.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.ConstructorInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten Konstruktoren, einschließlich eines ggf. definierten Typinitialisierers, darstellen, die den angegebenen Bindungseinschränkungen entsprechen. Gibt ein leeres Array vom Typ <see cref="T:System.Reflection.ConstructorInfo" /> zurück, wenn für den aktuellen <see cref="T:System.Type" /> keine Konstruktoren definiert sind, keiner der definierten Konstruktoren den Bindungseinschränkungen entspricht oder der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Typ- oder Methodendefinition darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetConstructors%2A> Methode Konstruktoren nicht in einer bestimmten Reihenfolge, z. B. die Reihenfolge der Deklaration zurückgegeben. Ihr Code muss nicht abhängig von der Reihenfolge, in der Konstruktoren zurückgegeben werden, da, die variieren kann.  
  
 `bindingAttr` kann verwendet werden, um anzugeben, ob ausschließlich öffentliche Konstruktoren oder sowohl öffentliche als auch nicht öffentliche Konstruktoren zurückgegeben.  
  
 Wenn eine genaue Übereinstimmung nicht vorhanden ist, die `binder` wird versucht, die im angegebenen Parametertypen zu konvertieren die `types` Array, um eine Übereinstimmung auszuwählen. Wenn die `binder` kann eine Übereinstimmung, wählen Sie dann `null` zurückgegeben wird.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um die Konstruktoren in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Konstruktoren in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentlichen Konstruktoren (d.h. private, interne und geschützte Konstruktoren) in die Suche eingeschlossen werden sollen. Konstruktoren von Basisklassen werden nicht zurückgegeben.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Rufen Sie die klasseninitialisierung (.cctor) mithilfe der Überladung dieser Methode müssen Sie angeben <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). Erhalten Sie auch die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> Objekte mit den Typparametern, die durch die entsprechenden Typargumente ersetzt. Z. B. Wenn Klasse `C<T>` verfügt über einen Konstruktor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), wird beim Aufruf <xref:System.Type.GetConstructors%2A> auf `C<int>` gibt eine <xref:System.Reflection.ConstructorInfo> darstellender `C(int t1)` in c# (`Sub New(ByVal t1 As Integer)` in Visual Basic).  
  
 Wenn die aktuelle <xref:System.Type> stellt einen generischen Typparameter, der <xref:System.Type.GetConstructors%2A> Methode ein leeres Array zurück.  
  
   
  
## Examples  
 Dieses Beispiel zeigt die Ausgabe der <xref:System.Type.GetConstructors> überladen, die von einer Klasse, die über zwei Instanzkonstruktoren und einen statischen Konstruktor verfügt.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 Die Ausgabe dieses Codes lautet:  
  
 2  
  
 False  
  
 False  
  
 Da die <xref:System.Type.GetConstructors%2A> Überladung verwendet nur <xref:System.Reflection.BindingFlags.Public> und <xref:System.Reflection.BindingFlags.Instance>, der statische Konstruktor ist weder gezählt, indem die `for` Ausdruck noch ausgewertet, indem `IsStatic`.  
  
 Um statische Konstruktoren zu suchen, verwenden die <xref:System.Type.GetConstructors%2A> überladen, und übergeben sie die Kombination (logisches OR) von <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, wie im folgenden Codebeispiel gezeigt:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Jetzt ist die Ausgabe:  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sucht nach den für den aktuellen <see cref="T:System.Type" /> definierten Membern, deren <see cref="T:System.Reflection.DefaultMemberAttribute" /> festgelegt ist.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die alle Standardmember des aktuellen <see cref="T:System.Type" /> darstellen.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Reflection.MemberInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Standardmember besitzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetDefaultMembers%2A> Methode nicht zurückgegeben Member in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Ihr Code muss nicht abhängig von der Reihenfolge, in der Elemente zurückgegeben werden, da, die variieren kann.  
  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
 Mitglieder enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden ein, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|event|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuelle) möglich Ausblenden nach Namen oder nach Name und Signatur ausblenden.|  
|Geschachtelter Typ|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen, Sentinels enthält und nicht verwaltete Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit dem ein Get und Set-Accessor in der Basisklasse haben, aber die abgeleitete Klasse nur einen Get-Accessor hat, die Eigenschaft der abgeleiteten Klasse blendet die Basisklasseneigenschaft aus, und nicht werden auf den Setter in der Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> Objekte mit den Typparametern, die durch die entsprechenden Typargumente ersetzt. Z. B. Wenn Klasse `C<T>` verfügt über eine Eigenschaft `P` zurückgibt `T`, wird beim Aufruf <xref:System.Type.GetDefaultMembers%2A> auf `C<int>` gibt `int P` in c# (`Property P As Integer` in Visual Basic).  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Mitglieder der <xref:System.Object> liegt keine klasseneinschränkung.  
  
   
  
## Examples  
 Im folgende Beispiel ruft die Informationen der `MyClass` und zeigt die Standardelemente.  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse den <see cref="T:System.Type" /> des Objekts zurück, das der aktuelle Array-, Zeiger- oder Verweistyp einschließt bzw. auf das er verweist.</summary>
        <returns>Der <see cref="T:System.Type" /> des eingeschlossenen Objekts bzw. des Objekts, auf das durch den aktuellen Array-, Zeiger- oder Verweistyp verwiesen wird, oder <see langword="null" />, wenn der aktuelle <see cref="T:System.Type" /> kein Array oder Zeiger ist, nicht als Verweis übergeben wurde oder einen generischen Typ oder Typparameter einer generischen Typ- oder Methodendefinition darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt `null` für die <xref:System.Array> Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der `GetElementType` Methode.  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, dessen Name abgerufen werden soll.</param>
        <summary>Gibt den Namen der Konstanten für den aktuellen Enumerationstyp zurück, die den angegebenen Wert aufweist.</summary>
        <returns>Der Name des Members des aktuellen Enumerationstyps, der über den angegebenen Wert verfügt, oder<see langword="null" />, wenn keine solche Konstante gefunden wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Der aktuelle Typ ist keine Enumeration.  
  
- oder -  
 <paramref name="value" /> ist nicht vom aktuellen Typ und weist auch nicht den gleichen zugrunde liegenden Typ wie der aktuelle Typ auf.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Namen der Member des aktuellen Enumerationstyps zurück.</summary>
        <returns>Ein Array, das die Namen der Member der Enumeration enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente des Arrays Rückgabewert werden nach den Binärwerten (d. h. aus den Werten ohne Vorzeichen) der Enumerationskonstanten sortiert. Wenn das Array aufgezählte Konstanten mit dem gleichen Wert enthält, ist die Reihenfolge der entsprechenden Namen nicht angegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der aktuelle Typ ist keine Enumeration.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den zugrunde liegenden Typ des aktuellen Enumerationstyps zurück.</summary>
        <returns>Der zugrunde liegende Typ der aktuellen Enumeration.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig ist der zugrunde liegende Typ einer Enumeration in c# und Visual Basic <xref:System.Int32>. Andere Integer-Typen können angegeben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der aktuelle Typ ist keine Enumeration.  
  
- oder -  
Der Enumerationstyp ist ungültig, da er mehr als ein Instanzfeld enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array mit den Werten der Konstanten im aktuellen Enumerationstyp zurück.</summary>
        <returns>Ein Array, das die Werte enthält. Die Elemente des Arrays sind nach den Binärwerten (den Werten ohne Vorzeichen) der Enumerationskonstanten sortiert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Der aktuelle Typ ist keine Enumeration.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ein bestimmtes Ereignis ab, das vom aktuellen <see cref="T:System.Type" /> deklariert oder geerbt wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen eines vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisses enthält.</param>
        <summary>Gibt das <see cref="T:System.Reflection.EventInfo" />-Objekt zurück, das das angegebene öffentliche Ereignis darstellt.</summary>
        <returns>Das Objekt, das das angegebene, vom aktuellen <see cref="T:System.Type" /> deklarierte oder geerbte öffentliche Ereignis darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Ereignis ist Reflektion als öffentlich betrachtet, wenn er verfügt über mindestens eine Methode oder der Accessor, der öffentlich ist. Andernfalls wird das Ereignis als private betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic kombinieren Sie die Werte mit `Or`) anfordern.  
  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet wird. Die Suche enthält öffentliche statisch und öffentlich Instanz Ereignisse.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden ein, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|event|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuelle) möglich Ausblenden nach Namen oder nach Name und Signatur ausblenden.|  
|Geschachtelter Typ|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen, Sentinels enthält und nicht verwaltete Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit dem ein Get und Set-Accessor in der Basisklasse haben, aber die abgeleitete Klasse nur einen Get-Accessor hat, die Eigenschaft der abgeleiteten Klasse blendet die Basisklasseneigenschaft aus, und nicht werden auf den Setter in der Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.EventInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die Ereignisse der Class-Einschränkung.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Reflection.EventInfo> -Objekt und ruft das Ereignis für ein Button-Klasse für das angegebene Ereignis ab.  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen eines vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisses enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse das <see cref="T:System.Reflection.EventInfo" />-Objekt zurück, das das angegebene Ereignis unter Verwendung der angegebenen Bindungseinschränkungen darstellt.</summary>
        <returns>Das Objekt, das das angegebene vom aktuellen <see cref="T:System.Type" /> deklarierte oder geerbte Ereignis darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können festgelegt werden, welche Ereignisse in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentlichen Ereignisse in die Suche eingeschlossen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentlichen Ereignisse (d. h. private, interne und geschützten) in die Suche eingeschlossen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` sollen `public` und `protected` statische Member der Hierarchie; `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die Ereignisse, die deklariert wird, auf die <xref:System.Type>, nicht die Ereignisse, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Ein Ereignis ist Reflektion als öffentlich betrachtet, wenn er verfügt über mindestens eine Methode oder der Accessor, der öffentlich ist. Andernfalls wird das Ereignis als private betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic kombinieren Sie die Werte mit `Or`) anfordern.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.EventInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die Ereignisse der Class-Einschränkung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> Methode, um einen Typ für einen öffentlichen oder privaten-Ereignis, die mit dem Namen "Click" zu suchen, die nicht `static` (`Shared` in Visual Basic).  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisse ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt sämtliche vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten öffentlichen Ereignisse zurück.</summary>
        <returns>Gibt ein Array von <see cref="T:System.Reflection.EventInfo" />-Objekten zurück, die sämtliche vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten öffentlichen Ereignisse darstellen.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Reflection.EventInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine öffentlichen Ereignisse besitzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Ereignis ist Reflektion als öffentlich betrachtet, wenn er verfügt über mindestens eine Methode oder der Accessor, der öffentlich ist. Andernfalls wird das Ereignis als private betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic kombinieren Sie die Werte mit `Or`) anfordern.  
  
 Die <xref:System.Type.GetEvents%2A> Methode nicht zurückgegeben Ereignisse in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Ihr Code muss nicht abhängig von der Reihenfolge, in der Ereignisse zurückgegeben werden, da, die variieren kann.  
  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden ein, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|event|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuelle) möglich Ausblenden nach Namen oder nach Name und Signatur ausblenden.|  
|Geschachtelter Typ|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen, Sentinels enthält und nicht verwaltete Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit dem ein Get und Set-Accessor in der Basisklasse haben, aber die abgeleitete Klasse nur einen Get-Accessor hat, die Eigenschaft der abgeleiteten Klasse blendet die Basisklasseneigenschaft aus, und nicht werden auf den Setter in der Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.EventInfo> Objekte mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die Ereignisse der Class-Einschränkung.  
  
   
  
## Examples  
 Im folgende Beispiel ruft ein Array von <xref:System.Reflection.EventInfo> Objekte, die alle Ereignisse für eine `Button` Klasse, und die Ereignisnamen angezeigt. Um die Visual Basic-Beispiel zu kompilieren, verwenden Sie die folgende Befehlszeile ein:  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen nach vom aktuellen <see cref="T:System.Type" /> definierten oder geerbten Ereignissen.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.EventInfo" />-Objekten, die sämtliche vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisse darstellen, die den angegebenen Bindungseinschränkungen entsprechen.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Reflection.EventInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Ereignisse besitzt oder keines der Ereignisse den Bindungseinschränkungen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetEvents%2A> Methode nicht zurückgegeben Ereignisse in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Ihr Code muss nicht abhängig von der Reihenfolge, in der Ereignisse zurückgegeben werden, da, die variieren kann.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können festgelegt werden, welche Ereignisse in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentlichen Ereignisse in die Suche eingeschlossen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentlichen Ereignisse (d. h. private, interne und geschützten) in die Suche eingeschlossen. Nur geschützte und interne Ereignisse in Basisklassen werden zurückgegeben. Private Ereignisse in Basisklassen werden nicht zurückgegeben.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` sollen `public` und `protected` statische Member der Hierarchie; `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die Ereignisse, die deklariert wird, auf die <xref:System.Type>, nicht die Ereignisse, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Ein Ereignis ist Reflektion als öffentlich betrachtet, wenn er verfügt über mindestens eine Methode oder der Accessor, der öffentlich ist. Andernfalls wird das Ereignis als private betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic kombinieren Sie die Werte mit `Or`) anfordern.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.EventInfo> Objekte mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die Ereignisse der Class-Einschränkung.  
  
   
  
## Examples  
 Im folgende Beispiel ruft ein Array von <xref:System.Reflection.EventInfo> Objekte, die den angegebenen Bindungsflags entsprechen Ruft alle Ereignisse für eine `Button` Klasse, und die Ereignisnamen angezeigt. Um die Visual Basic-Beispiel zu kompilieren, verwenden Sie die folgende Befehlszeile ein:  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ein bestimmtes Feld des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des abzurufenden Datenfelds enthält.</param>
        <summary>Sucht das öffentliche Feld mit dem angegebenen Namen.</summary>
        <returns>Ein Objekt, das das öffentliche Feld mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet wird. Die Suche enthält öffentliche statisch und öffentlich Instanzfelder.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.FieldInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die Felder der Class-Einschränkung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Type` Objekt für die angegebene Klasse, erhält der <xref:System.Reflection.FieldInfo> Objekt für das Feld, und der Wert des Felds angezeigt.  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Bei diesem <see cref="T:System.Type" />-Objekt handelt es sich um einen <see cref="T:System.Reflection.Emit.TypeBuilder" />, dessen <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />-Methode noch nicht aufgerufen wurde.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des abzurufenden Datenfelds enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht das angegebene Feld unter Verwendung der angegebenen Bindungseinschränkungen.</summary>
        <returns>Ein Objekt, das das Feld darstellt, das den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden ein, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|event|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuelle) möglich Ausblenden nach Namen oder nach Name und Signatur ausblenden.|  
|Geschachtelter Typ|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen, Sentinels enthält und nicht verwaltete Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit dem ein Get und Set-Accessor in der Basisklasse haben, aber die abgeleitete Klasse nur einen Get-Accessor hat, die Eigenschaft der abgeleiteten Klasse blendet die Basisklasseneigenschaft aus, und nicht werden auf den Setter in der Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können festgelegt werden, welche Felder in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Felder in die Suche eingeschlossen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Felder (d.h. private, interne und geschützte Felder) in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` sollen `public` und `protected` statische Member der Hierarchie; `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die Felder, die deklariert wird, auf die <xref:System.Type>, nicht nach Feldern, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.FieldInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die Felder der Class-Einschränkung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Type` Objekt für die angegebene Klasse, erhält der <xref:System.Reflection.FieldInfo> -Objekt für das Feld, das den angegebenen Bindungsflags entspricht, und zeigt den Wert des Felds.  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die Felder des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt sämtliche öffentlichen Felder des aktuellen <see cref="T:System.Type" /> zurück.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.FieldInfo" />-Objekten, die alle für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Felder darstellen.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Reflection.FieldInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine öffentlichen Felder definiert sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetFields%2A> Methode nicht zurückgegeben Felder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Ihr Code muss nicht abhängig von der Reihenfolge, in der Felder zurückgegeben werden, da, die variieren kann.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden ein, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|event|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuelle) möglich Ausblenden nach Namen oder nach Name und Signatur ausblenden.|  
|Geschachtelter Typ|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen, Sentinels enthält und nicht verwaltete Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit dem ein Get und Set-Accessor in der Basisklasse haben, aber die abgeleitete Klasse nur einen Get-Accessor hat, die Eigenschaft der abgeleiteten Klasse blendet die Basisklasseneigenschaft aus, und nicht werden auf den Setter in der Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.FieldInfo> Objekte mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die öffentlichen Felder des der Class-Einschränkung.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der `GetFields()` Methode.  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die für den aktuellen <see cref="T:System.Type" /> definierten Felder.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.FieldInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Felder darstellen, die den angegebenen Bindungseinschränkungen entsprechen.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Reflection.FieldInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine Felder definiert sind oder keines der definierten Felder den Bindungseinschränkungen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetFields%2A> Methode nicht zurückgegeben Felder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Ihr Code muss nicht abhängig von der Reihenfolge, in der Felder zurückgegeben werden, da, die variieren kann.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können festgelegt werden, welche Felder in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Felder in die Suche eingeschlossen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Felder (d.h. private, interne und geschützte Felder) in die Suche einbeziehen. Nur geschützte und internen Felder auf der Basis-Klassen zurückgegeben werden. private Felder für Basisklassen werden nicht zurückgegeben.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` sollen `public` und `protected` statische Member der Hierarchie; `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die Felder, die deklariert wird, auf die <xref:System.Type>, nicht nach Feldern, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.FieldInfo> Objekte mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die öffentlichen Felder des der Class-Einschränkung.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der `GetFields(BindingFlags)` Methode.  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array von <see cref="T:System.Type" />-Objekten zurück, die die Typargumente eines geschlossenen generischen Typs oder die Typparameter einer generischen Typdefinition darstellen.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, die die Typargumente eines generischen Typs darstellen. Gibt ein leeres Array zurück, wenn der aktuelle Typ kein generischer Typ ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente des Arrays werden in der Reihenfolge zurückgegeben, in denen sie in der Liste der Typargumente für den generischen Typ angezeigt werden.  
  
-   Wenn der aktuelle Typ ein geschlossener konstruierter Typ ist (, also die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft gibt `false`), das von zurückgegebene Array die <xref:System.Type.GetGenericArguments%2A> Methode enthält die Typen, die die generischen Typparameter der generischen Typdefinition zugewiesen wurden .  
  
-   Wenn der aktuelle Typ eine generische Typdefinition ist, enthält das Array die Typparameter an.  
  
-   Wenn der aktuelle Typ ein offener Typ ist (d. h. die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft gibt `true`) in denen bestimmten Typen nicht für alle Typparameter und Typparameter von einschließenden generischen Typen oder Methoden zugewiesen wurden, enthält das Array sowohl Typen als auch Typparameter. Verwenden der <xref:System.Type.IsGenericParameter%2A> Eigenschaft, um Sie voneinander zu unterscheiden. Eine Demonstration dieses Szenarios finden Sie im Codebeispiel für die <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Type.GetGenericArguments%2A> Methode, um die Typargumente einer konstruierten Typ und die Typparameter der generischen Typdefinition anzuzeigen.  
  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Type.IsGenericTypeDefinition%2A> Eigenschaft. Finden Sie unter den umfangreicheren Beispiels für die Ausgabe des Beispiels.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt. Abgeleitete Klassen müssen eine Implementation angeben.</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflektion und generische Typen</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Vorgehensweise: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array von <see cref="T:System.Type" />-Objekten zurück, die die Einschränkungen für den aktuellen generischen Typparameter darstellen.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, die die Einschränkungen für den aktuellen generischen Typparameter darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede Einschränkung für einen generischen Typparameter wird als eine <xref:System.Type> Objekt. Verwenden der <xref:System.Type.IsClass%2A> Eigenschaft, um zu bestimmen, ob eine Einschränkung der basisklassenconstraint ist; wenn die Eigenschaft zurückgibt `false`, die Einschränkung ist eine schnittstelleneinschränkung. Wenn ein Typparameter ohne klasseneinschränkung und keine schnittstelleneinschränkungen verfügt, wird ein leeres Array zurückgegeben.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel definiert einen generischen Typ `Test` mit zwei Typparametern, die verschiedene Einschränkungen aufweisen. Wenn das Programm ausgeführt wird, die Einschränkungen werden überprüft, mit der <xref:System.Type.GenericParameterAttributes%2A> Eigenschaft und die <xref:System.Type.GetGenericParameterConstraints%2A> Methode.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das aktuelle <see cref="T:System.Type" />-Objekt ist kein generischer Typparameter. Das bedeutet, dass die <see cref="P:System.Type.IsGenericParameter" />-Eigenschaft <see langword="false" /> zurückgibt.</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Vorgehensweise: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das eine generische Typdefinition darstellt, aus der der aktuelle generische Typ konstruiert werden kann.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das einen generischen Typ darstellt, aus dem der aktuelle Typ konstruiert werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine generische Typdefinition ist eine Vorlage aus der anderen Typen konstruiert werden können. Z. B. von der generischen Typdefinition `G<T>` (ausgedrückt in C#-Syntax; `G(Of T)` in Visual Basic oder `generic <typename T> ref class G` in C++) können Sie zu erstellen und den Typ instanziieren `G<int>` (`G(Of Integer)` in Visual Basic). Erhält eine <xref:System.Type> Objekt, das diese darstellt konstruierter Typ, der <xref:System.Type.GetGenericTypeDefinition%2A> Methode gibt zurück, die generische Typdefinition.  
  
 Wenn zwei konstruierte Typen aus der gleichen generischen Typdefinition erstellt werden, verwenden Sie die gleichen Argumenten des Typs, der <xref:System.Type.GetGenericTypeDefinition%2A> Methode gibt denselben Wert zurück <xref:System.Type> -Objekt für beide Typen.  
  
 Aufrufen der <xref:System.Type.GetGenericTypeDefinition%2A> Methode für eine <xref:System.Type> -Objekt, das bereits eine Definition eines generischen Typs darstellt wird die aktuelle <xref:System.Type>.  
  
> [!IMPORTANT]
>  Ein Array von generischen Typen ist selbst nicht generisch. In der C#-Code `A<int>[] v;` oder Visual Basic-Code `Dim v() As A(Of Integer)`, den Typ der Variable `v` ist nicht generisch. Verwendung <xref:System.Type.IsGenericType%2A> zu bestimmen, ob ein Typ generisch ist, vor dem Aufruf ist <xref:System.Type.GetGenericTypeDefinition%2A>.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine Instanz eines konstruierten Typs mit normalen instanzerstellung und verwendet dann die <xref:System.Type.GetType%2A> und <xref:System.Type.GetGenericTypeDefinition%2A> Methoden zum Abrufen der konstruierte Typ und die generische Typdefinition. In diesem Beispiel verwendet den generischen <xref:System.Collections.Generic.Dictionary%602> ein, der den konstruierten Typ darstellt eine <xref:System.Collections.Generic.Dictionary%602> von `Test` Objekte mit Zeichenfolgenschlüsseln.  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Typ ist kein generischer Typ.  Das heißt, <see cref="P:System.Type.IsGenericType" /> gibt <see langword="false" /> zurück.</exception>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt. Abgeleitete Klassen müssen eine Implementation angeben.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflektion und generische Typen</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Vorgehensweise: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
        <returns>Der Hashcode für diese Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Hashcode der `System.Windows.Forms.Button` Klasse.  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine bestimmte Schnittstelle ab, die vom aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Schnittstelle enthält. Bei generischen Schnittstellen ist dies der ergänzte Name.</param>
        <summary>Sucht die Schnittstelle mit dem angegebenen Namen.</summary>
        <returns>Ein Objekt, das die vom aktuellen <see cref="T:System.Type" /> implementierte oder geerbte Schnittstelle mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet wird.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Type> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode durchsucht, die schnittstelleneinschränkungen und alle Schnittstellen, die von der Klasse oder Schnittstelle Einschränkungen geerbt.  
  
> [!NOTE]
>  Bei generischen Schnittstellen die `name` -Parameter ist der ergänzte Name, endend mit einem Graviszeichen (\`) und die Anzahl von Typparametern. Dies gilt für sowohl die generische Schnittstellendefinitionen als auch die konstruierte generische Schnittstellen. Beispielsweise, um suchen `IExample<T>` (`IExample(Of T)` in Visual Basic) oder `IExample<string>` (`IExample(Of String)` in Visual Basic), suchen Sie nach ``"IExample`1"``.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Type.GetInterface%28System.String%29> Methode zum Suchen der <xref:System.Collections.Hashtable> -Klasse für die <xref:System.Runtime.Serialization.IDeserializationCallback> -Schnittstelle und Listen die Methoden der Schnittstelle.  
  
 Im Codebeispiel wird veranschaulicht, die auch die <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> -methodenüberladung, und die <xref:System.Type.GetInterfaceMap%2A> Methode.  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Der aktuelle <see cref="T:System.Type" /> stellt einen Typ dar, der dieselbe generische Schnittstelle mit unterschiedlichen Typargumenten implementiert.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Schnittstelle enthält. Bei generischen Schnittstellen ist dies der ergänzte Name.</param>
        <param name="ignoreCase"><see langword="true" />, wenn die Groß-/Kleinschreibung dieses Teils von <paramref name="name" />, der den einfachen Schnittstellennamen angibt, ignoriert werden soll. (Bei der Namespaceangabe im Namen muss die Groß-/Kleinschreibung immer beachtet werden.)  
  
- oder -  
 <see langword="false" />, wenn nach allen Teilen von <paramref name="name" /> mit Beachtung der Groß-/Kleinschreibung gesucht werden soll.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse die angegebene Schnittstelle, wobei festgelegt wird, ob bei der Suche des Schnittstellennamens die Groß-/Kleinschreibung beachtet wird.</summary>
        <returns>Ein Objekt, das die vom aktuellen <see cref="T:System.Type" /> implementierte oder geerbte Schnittstelle mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ignoreCase` Parameter gilt nur für den einfachen Schnittstellennamen, nicht für den Namespace. Der Teil des `name` , die angibt, der Namespace muss die Groß-/Kleinschreibung, oder die Schnittstelle wird nicht gefunden. Z. B. die Zeichenfolge "System.icomparable" sucht nach dem <xref:System.IComparable> -Schnittstelle, die Zeichenfolge "system.icomparable" hingegen nicht.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Type> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode durchsucht, die schnittstelleneinschränkungen und alle Schnittstellen, die von der Klasse oder Schnittstelle Einschränkungen geerbt.  
  
> [!NOTE]
>  Bei generischen Schnittstellen die `name` -Parameter ist der ergänzte Name, endend mit einem Graviszeichen (\`) und die Anzahl von Typparametern. Dies gilt für sowohl die generische Schnittstellendefinitionen als auch die konstruierte generische Schnittstellen. Beispielsweise, um suchen `IExample<T>` (`IExample(Of T)` in Visual Basic) oder `IExample<string>` (`IExample(Of String)` in Visual Basic), suchen Sie nach `"IExample`1"".  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> Methode zum Durchführen einer Suche in Groß-/Kleinschreibung der <xref:System.Collections.Hashtable> -Klasse für die <xref:System.Collections.IEnumerable> Schnittstelle.  
  
 Im Codebeispiel wird veranschaulicht, die auch die <xref:System.Type.GetInterface%28System.String%29> -methodenüberladung, und die <xref:System.Type.GetInterfaceMap%2A> Methode.  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Der aktuelle <see cref="T:System.Type" /> stellt einen Typ dar, der dieselbe generische Schnittstelle mit unterschiedlichen Typargumenten implementiert.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Der Schnittstellentyp, für den eine Zuordnung abgerufen werden soll.</param>
        <summary>Gibt eine Schnittstellenzuordnung für den angegebenen Schnittstellentyp zurück.</summary>
        <returns>Ein Objekt, das die Schnittstellenzuordnung für <paramref name="interfaceType" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die schnittstellenzuordnung gibt an, wie eine Schnittstelle in die tatsächlichen Mitglieder in einer Klasse zugeordnet ist, das diese Schnittstelle implementiert.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, Parameter, durch die entsprechenden Typargumente in den Elementen des ersetzt werden, Typs der <xref:System.Reflection.InterfaceMapping> von dieser Methode zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Type.GetInterfaceMap%2A> Methode, um zu bestimmen, wie die <xref:System.IFormatProvider> Schnittstelle ordnet <xref:System.Globalization.CultureInfo> Methoden, und wie die <xref:System.IAppDomainSetup> Schnittstelle zugeordnet <xref:System.AppDomainSetup> Eigenschaften. Beachten Sie, dass, weil die <xref:System.IAppDomainSetup> Schnittstelle definiert einen Satz von Eigenschaften, die zurückgegebene <xref:System.Reflection.InterfaceMapping> Objekt enthält separate <xref:System.Reflection.MethodInfo> Objekte für eine Eigenschaft Get und Set-Accessoren.  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="interfaceType" /> ist nicht durch den aktuellen Typ implementiert.  
  
- oder -  
Das <paramref name="interfaceType" />-Argument verweist nicht auf eine Schnittstelle.  
  
- oder - 

Die aktuelle Instanz oder das <paramref name="interfaceType" />-Argument sind offene generische Typen, d.h. die <see cref="P:System.Type.ContainsGenericParameters" />-Eigenschaft gibt <see langword="true" /> zurück.

- oder - 


 <paramref name="interfaceType" /> ist eine generische Schnittstelle, und der aktuelle Typ ist ein Arraytyp.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der aktuelle <see cref="T:System.Type" /> entspricht einem generischen Typparameter, d. h., <see cref="P:System.Type.IsGenericParameter" /> ist gleich <see langword="true" />.</exception>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt. Abgeleitete Klassen müssen eine Implementation angeben.</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse sämtliche Schnittstellen ab, die vom aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurden.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, die sämtliche vom aktuellen <see cref="T:System.Type" /> implementierten oder geerbten Schnittstellen darstellen.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Type" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Schnittstellen implementiert oder geerbt hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetInterfaces%2A> Methode nicht zurückgegeben Schnittstellen in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Ihr Code muss nicht abhängig von der Reihenfolge, in der Schnittstellen zurückgegeben werden, da, die variieren kann.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Type> Objekte mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode durchsucht, die schnittstelleneinschränkungen und alle Schnittstellen, die von der Klasse oder Schnittstelle Einschränkungen geerbt.  
  
   
  
## Examples  
 Im folgenden Beispiel ruft den Typ der angegebenen Klasse ab und zeigt alle Schnittstellen, die der Typ implementiert oder erbt. Verwenden Sie die folgenden Compilerbefehle zum Kompilieren der Visual Basic-Beispiel:  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein statischer Initialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die angegebenen Member des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des abzurufenden öffentlichen Members enthält.</param>
        <summary>Sucht die öffentlichen Member mit dem angegebenen Namen.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die die öffentlichen Member mit dem angegebenen Namen darstellen, sofern gefunden, andernfalls ein leeres Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet wird. Die Suche enthält öffentliche statisch und öffentlich Instanzmember.  
  
 Mitglieder enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.  
  
 Die <xref:System.Type.GetMember%2A> Methode nicht zurückgegeben Member in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Ihr Code muss nicht abhängig von der Reihenfolge, in der Elemente zurückgegeben werden, da, die variieren kann.  
  
 Diese methodenüberladung wird Klasseninitialisierer (.cctor) nicht gefunden. Um Klasseninitialisierer zu ermitteln, verwenden Sie eine Überladung mit <xref:System.Reflection.BindingFlags>, und geben Sie <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). Erhalten Sie auch die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden ein, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|event|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuelle) möglich Ausblenden nach Namen oder nach Name und Signatur ausblenden.|  
|Geschachtelter Typ|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen, Sentinels enthält und nicht verwaltete Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit dem ein Get und Set-Accessor in der Basisklasse haben, aber die abgeleitete Klasse nur einen Get-Accessor hat, die Eigenschaft der abgeleiteten Klasse blendet die Basisklasseneigenschaft aus, und nicht werden auf den Setter in der Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Mitglieder der <xref:System.Object> liegt keine klasseneinschränkung.  
  
> [!NOTE]
>  Für generische Methoden enthalten nicht die Typargumente in `name`. Z. B. der C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", und nicht für eine Methode namens `MyMethod` Listenfeldsteuerelement mit einem generisches Argument des Typs `int`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle Member der `String` -Klasse, die mit dem Buchstaben c beginnen  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Member enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), um ein leeres Array zurückzugeben.</param>
        <summary>Sucht die angegebenen Member unter Verwendung der angegebenen Bindungseinschränkungen.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die die öffentlichen Member mit dem angegebenen Namen darstellen, sofern gefunden, andernfalls ein leeres Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
 Mitglieder enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.  
  
 Die <xref:System.Type.GetMember%2A> Methode nicht zurückgegeben Member in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Ihr Code muss nicht abhängig von der Reihenfolge, in der Elemente zurückgegeben werden, da, die variieren kann.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, auf welche Member in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Mitglieder in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentliche Mitglieder (d. h. private, interne und geschützte Member) in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` sollen `public` und `protected` statische Member der Hierarchie; `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die Member deklariert die <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Rufen Sie die klasseninitialisierung (.cctor) mithilfe der Überladung dieser Methode geben Sie ".cctor" für `name`, und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) für `bindingAttr`. Erhalten Sie auch die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Mitglieder der <xref:System.Object> liegt keine klasseneinschränkung.  
  
> [!NOTE]
>  Für generische Methoden enthalten nicht die Typargumente in `name`. Z. B. der C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", und nicht für eine Methode namens `MyMethod` Listenfeldsteuerelement mit einem generisches Argument des Typs `int`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle öffentlichen statischen Member von der `myString` -Klasse, die mit dem Buchstaben c beginnen  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Member enthält.</param>
        <param name="type">Der zu suchende Wert.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), um ein leeres Array zurückzugeben.</param>
        <summary>Sucht die angegebenen Member des angegebenen Membertyps unter Verwendung der angegebenen Bindungseinschränkungen.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die die öffentlichen Member mit dem angegebenen Namen darstellen, sofern gefunden, andernfalls ein leeres Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mitglieder enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.  
  
 Die <xref:System.Type.GetMember%2A> Methode nicht zurückgegeben Member in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Ihr Code muss nicht abhängig von der Reihenfolge, in der Elemente zurückgegeben werden, da, die variieren kann.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, auf welche Member in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Mitglieder in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentliche Mitglieder (d. h. private, interne und geschützte Member) in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` sollen `public` und `protected` statische Member der Hierarchie; `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die Member deklariert die <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Rufen Sie die klasseninitialisierung (.cctor) mithilfe der Überladung dieser Methode geben Sie ".cctor" für `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> für `type`, und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) für `bindingAttr`. Erhalten Sie auch die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Mitglieder der <xref:System.Object> liegt keine klasseneinschränkung.  
  
> [!NOTE]
>  Für generische Methoden enthalten nicht die Typargumente in `name`. Z. B. der C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", und nicht für eine Methode namens `MyMethod` Listenfeldsteuerelement mit einem generisches Argument des Typs `int`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle Methoden der `myString` -Klasse, die mit dem Buchstaben c beginnen  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Eine abgeleitete Klasse muss eine Implementierung bereitstellen.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die Member (Eigenschaften, Methoden, Felder, Ereignisse usw.) des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt sämtliche öffentlichen Member des aktuellen <see cref="T:System.Type" /> zurück.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die sämtliche öffentlichen Member des aktuellen <see cref="T:System.Type" /> darstellen.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Reflection.MemberInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Standardmember besitzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mitglieder enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.  
  
 Die <xref:System.Type.GetMembers%2A> Methode nicht zurückgegeben Member in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Ihr Code muss nicht abhängig von der Reihenfolge, in der Elemente zurückgegeben werden, da, die variieren kann.  
  
 Diese methodenüberladung Ruft die <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> methodenüberladung mit <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in Visual Basic). Die Klasseninitialisierer (.cctor) nicht gefunden. Um Klasseninitialisierer zu ermitteln, verwenden Sie eine Überladung mit <xref:System.Reflection.BindingFlags>, und geben Sie <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). Erhalten Sie auch die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden ein, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|event|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuelle) möglich Ausblenden nach Namen oder nach Name und Signatur ausblenden.|  
|Geschachtelter Typ|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen, Sentinels enthält und nicht verwaltete Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit dem ein Get und Set-Accessor in der Basisklasse haben, aber die abgeleitete Klasse nur einen Get-Accessor hat, die Eigenschaft der abgeleiteten Klasse blendet die Basisklasseneigenschaft aus, und nicht werden auf den Setter in der Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> Objekte mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Mitglieder der <xref:System.Object> liegt keine klasseneinschränkung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Type.GetMembers> -methodenüberladung, um Informationen zu allen öffentlichen Membern einer bestimmten Klasse zu sammeln.  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), (<see cref="F:System.Reflection.BindingFlags.Default" />) um ein leeres Array zurückzugeben.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die für den aktuellen <see cref="T:System.Type" /> definierten Member.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Member darstellen, die den angegebenen Bindungseinschränkungen entsprechen.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Reflection.MemberInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine Member definiert sind oder keiner der definierten Member den Bindungseinschränkungen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mitglieder enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.  
  
 Die <xref:System.Type.GetMembers%2A> Methode nicht zurückgegeben Member in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Ihr Code muss nicht abhängig von der Reihenfolge, in der Elemente zurückgegeben werden, da, die variieren kann.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, auf welche Member in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Mitglieder in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentliche Mitglieder (d. h. private, interne und geschützte Member) in die Suche eingeschlossen werden sollen. Nur geschützte und internen Member in Basisklassen werden zurückgegeben. Private Member in Basisklassen werden nicht zurückgegeben.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` sollen `public` und `protected` statische Member der Hierarchie; `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die Member deklariert die <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.  
  
 Beim Aufruf dieser Methode nur die `Public` Flag oder nur die `NonPublic` Flag die angegebenen Member zurück, und alle anderen Flags sind nicht erforderlich.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Rufen Sie die klasseninitialisierung (.cctor) mithilfe der Überladung dieser Methode müssen Sie angeben <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). Erhalten Sie auch die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.  
  
 Wenn die aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> Objekte mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Mitglieder der <xref:System.Object> liegt keine klasseneinschränkung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> -methodenüberladung, um die Erfassung von Informationen über alle öffentlichen Instanzmember einer bestimmten Klasse.  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine bestimmte Methode des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</param>
        <summary>Sucht die öffentliche Methode mit dem angegebenen Namen.</summary>
        <returns>Ein Objekt, das die öffentliche Methode mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet wird. Die Suche enthält öffentliche Instanzmethoden für statisch und öffentlich zur Verfügung.  
  
 Wenn eine Methode überladen ist, und verfügt über mehr als eine öffentliche Methode, die <xref:System.Type.GetMethod%28System.String%29> -Methode löst eine <xref:System.Reflection.AmbiguousMatchException> Ausnahme. Im folgenden Beispiel wird eine Ausnahme ausgelöst, da es mehr als eine öffentliche Überladung von gibt der <xref:System.Int32.ToString%2A?displayProperty=nameWithType> Methode.  Andererseits, da die `Person.ToString` methodenüberschreibungen <xref:System.Object.ToString%2A?displayProperty=nameWithType> und ist daher nicht überladen, <xref:System.Type.GetMethod%28System.String%29> besteht im Abrufen der <xref:System.Reflection.MethodInfo> Objekt.  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 Sie können eine zum Abrufen einer bestimmten Methode die folgenden Aktionen ausführen:  
  
-   Rufen Sie die <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> Methode, und geben Sie einen `bindingAttr` Argument, das die Methode eindeutig identifiziert. Z. B. wenn die Ausnahme ausgelöst wird, da ein Typ ein statischer und eine Überladung für die Instanz hat, können Sie angeben einer `bindingAttr` Argument <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.  
  
-   Rufen Sie eine Überladung von der <xref:System.Type.GetMethod%2A> Methode, enthält eine `types` Parameter, die die Typen der Parameter der Methode definiert.  
  
-   Rufen Sie die <xref:System.Type.GetMethods> Methode zum Abrufen von einem Array, das alle öffentlichen Methoden, die auf einen Typ gehören. Sie können dann durchlaufen, um die doppelte Methoden, die mit dem Namen identifizieren `name`.  
  
 Wenn die aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> liegt keine klasseneinschränkung.  
  
> [!NOTE]
>  Für generische Methoden enthalten nicht die Typargumente in `name`. Z. B. der C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", und nicht für eine Methode namens `MyMethod` Listenfeldsteuerelement mit einem generisches Argument des Typs `int`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Methode namens `MethodA`.  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden mit dem angegebenen Namen gefunden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht die angegebene Methode unter Verwendung der angegebenen Bindungseinschränkungen.</summary>
        <returns>Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können festgelegt werden, welche Methoden in die Suche einbezogen werden:  
  
-   Geben Sie <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> oder <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> um ein Ergebnis zurückgegeben.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> öffentliche Methoden in der Suche eingeschlossen werden sollen.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> auf nicht öffentliche Methoden (d.h. private, interne und geschützte Methoden) in die Suche einbeziehen.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> sollen `public` und `protected` statische Member der Hierarchie; `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> Suchen Sie nur die Methoden, die deklariert die <xref:System.Type>, nicht die Methoden, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn eine Methode überladen wird und mehr als einer Überladung Einschränkungen der `bindingAttr` -Argument, löst die Methode eine <xref:System.Reflection.AmbiguousMatchException> Ausnahme. Im folgenden Beispiel wird eine Ausnahme ausgelöst, da:  
  
-   Der `TestClass` Typ verfügt über zwei öffentliche Überladungen der `DisplayValue` Methode `DisplayValue(String)` und `DisplayValue(String, Object[])`.  
  
-   Die `TestClass` Typ verfügt über zwei öffentliche Überladungen der `Equals` -Methode, von denen geerbt wird, von <xref:System.Object>: `Equals(TestClass)` und `Equals(Object)`.  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 Sie können eine zum Abrufen einer bestimmten Methode die folgenden Aktionen ausführen:  
  
-   Ändern Sie die bindungseinschränkungen entsprechen. Im vorherigen Beispiel versucht, eine öffentliche Instanz abzurufen `Equals` Methode, die durch den Typ deklariert und nicht geerbt erfolgreich abruft `Equals(TestClass)`.  
  
-   Rufen Sie eine Überladung von der <xref:System.Type.GetMethod%2A> Methode, enthält eine `types` Parameter, die die Typen der Parameter der Methode definiert.  
  
-   Rufen Sie die <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> Methode zum Abrufen von einem Array, das alle Methoden, die auf einen Typ gehören, die die angegebenen Bindungsattribute aufweisen. Sie können dann durchlaufen, um die doppelte Methoden, die mit dem Namen identifizieren `name`. Dieser Ansatz wird veranschaulicht, in dem vorherigen Beispiel-Handler für die <xref:System.Reflection.AmbiguousMatchException> Ausnahme.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> liegt keine klasseneinschränkung.  
  
> [!NOTE]
>  Für generische Methoden enthalten nicht die Typargumente in `name`. Z. B. der C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", und nicht für eine Methode namens `MyMethod` Listenfeldsteuerelement mit einem generisches Argument des Typs `int`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Methode, die den angegebenen Bindungsflags entspricht.  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.  
  
- oder -  
Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</param>
        <summary>Sucht die angegebene öffentliche Methode, deren Parameter den angegebenen Argumenttypen entsprechen.</summary>
        <returns>Ein Objekt, das die öffentliche Methode darstellt, deren Parameter den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet wird. Die Suche enthält öffentliche Instanzmethoden für statisch und öffentlich zur Verfügung.  
  
> [!NOTE]
>  Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden. Sie können nur Parameter auslassen, beim Aufrufen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> liegt keine klasseneinschränkung.  
  
> [!NOTE]
>  Die `name` Parameter kann keine Typargumente enthalten. Z. B. der C#-Code `GetMethod("MyGenericMethod<int>")` sucht nach einer Methode mit dem Textnamen "`MyGenericMethod<int>`", und nicht für eine Methode namens `MyGenericMethod` Listenfeldsteuerelement mit einem generisches Argument des Typs `int`. Verwenden Sie stattdessen `GetMethod("MyGenericMethod")` mit dem entsprechenden Parameter in der `types` Array.  
  
   
  
## Examples  
 Das folgende Beispiel sucht nach bestimmten Überladungen der `MethodA`, eine Vielzahl von Argumenttypen angeben.  
  
> [!NOTE]
>  Die [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Beispiel erfordert die `/unsafe` -Compileroption.  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 Das folgende Beispiel ruft <xref:System.Reflection.MethodInfo> Objekte, die darstellen, die `Add` Methoden eines nicht generischen Typs (der <xref:System.Collections.ArrayList> Klasse), ein offener generischer Typ (der <xref:System.Collections.Generic.List%601> Klasse), und einen geschlossenen generischen Typ (der `List(Of String)` Typ.  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 Das Beispiel definiert eine `GetAddMethod` Methode, die die entsprechende abruft <xref:System.Reflection.MethodInfo> Objekt. Bereitstellen der `types` Argument für ein offener generischer Typ, ruft der <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> Methode. Bereitstellen der `types` Argument für einen geschlossenen generischen Typ, der Wert abgerufen, der die <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden mit dem angegebenen Namen und den angegebenen Parametern gefunden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="types" /> ist <see langword="null" />.  
  
- oder -  
Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.  
  
- oder -  
Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht die angegebene öffentliche Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die öffentliche Methode darstellt, die den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl nicht der Standardbinder verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, der verarbeitet `modifiers`. `ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und behandelt nur die Parameter, die als Verweis übergeben werden.  
  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet wird. Die Suche enthält öffentliche Instanzmethoden für statisch und öffentlich zur Verfügung.  
  
> [!NOTE]
>  Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden. Sie können nur Parameter auslassen, beim Aufrufen.  
  
 Wenn die aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> liegt keine klasseneinschränkung.  
  
> [!NOTE]
>  Für generische Methoden enthalten nicht die Typargumente in `name`. Z. B. der C#-Code `GetMethod("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", und nicht für eine Methode namens `MyMethod` Listenfeldsteuerelement mit einem generisches Argument des Typs `int`. Verwenden Sie stattdessen `GetMethod("MyMethod")` mit dem entsprechenden Parameter in der `types` Array.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden mit dem angegebenen Namen und den angegebenen Parametern gefunden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="types" /> ist <see langword="null" />.  
  
- oder -  
Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="modifiers" /> ist mehrdimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
- oder -  
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.  
  
- oder -  
Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht unter Verwendung der angegebenen Bindungseinschränkungen nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl nicht der Standardbinder verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, der verarbeitet `modifiers`. `ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und behandelt nur die Parameter, die als Verweis übergeben werden.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können festgelegt werden, welche Methoden in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Methoden in der Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentliche Methoden (d.h. private, interne und geschützte Methoden) in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` sollen `public` und `protected` statische Member der Hierarchie; `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die Methoden, die deklariert die <xref:System.Type>, nicht die Methoden, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden. Sie können nur Parameter auslassen, beim Aufrufen.  
  
 Wenn die aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> liegt keine klasseneinschränkung.  
  
> [!NOTE]
>  Für generische Methoden enthalten nicht die Typargumente in `name`. Z. B. der C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", und nicht für eine Methode namens `MyMethod` Listenfeldsteuerelement mit einem generisches Argument des Typs `int`.  
  
   
  
## Examples  
 Das folgende Beispiel sucht nach bestimmten Überladungen der `MethodA`, bindungseinschränkungen und eine Vielzahl von Argumenttypen angeben.  
  
> [!NOTE]
>  Die [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Beispiel erfordert die `/unsafe` -Compileroption.  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="types" /> ist <see langword="null" />.  
  
- oder -  
Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="modifiers" /> ist mehrdimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
- oder -  
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="callConvention">Das Objekt, das die Regeln für Reihenfolge und Layout der Argumente, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.  
  
- oder -  
Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen, und verwendet dabei die angegebenen Bindungseinschränkungen und die angegebene Aufrufkonvention.</summary>
        <returns>Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl nicht der Standardbinder verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, der verarbeitet `modifiers`. `ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und behandelt nur die Parameter, die als Verweis übergeben werden.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `GetXXX` Methoden ein, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|event|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuelle) möglich Ausblenden nach Namen oder nach Name und Signatur ausblenden.|  
|Geschachtelter Typ|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen, Sentinels enthält und nicht verwaltete Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit dem ein Get und Set-Accessor in der Basisklasse haben, aber die abgeleitete Klasse nur einen Get-Accessor hat, die Eigenschaft der abgeleiteten Klasse blendet die Basisklasseneigenschaft aus, und nicht werden auf den Setter in der Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können festgelegt werden, welche Methoden in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Methoden in der Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentliche Methoden (d.h. private, interne und geschützte Methoden) in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` sollen `public` und `protected` statische Member der Hierarchie; `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die Methoden, die deklariert die <xref:System.Type>, nicht die Methoden, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden. Sie können nur Parameter auslassen, beim Aufrufen.  
  
 Wenn die aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> liegt keine klasseneinschränkung.  
  
> [!NOTE]
>  Für generische Methoden enthalten nicht die Typargumente in `name`. Z. B. der C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", und nicht für eine Methode namens `MyMethod` Listenfeldsteuerelement mit einem generisches Argument des Typs `int`.  
  
   
  
## Examples  
 Das folgende Beispiel sucht nach bestimmten Überladungen der `MethodA`, Angeben von bindungseinschränkungen, Aufrufkonventionen, und eine Vielzahl von Argumenttypen.  
  
> [!NOTE]
>  Die [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Beispiel erfordert die `/unsafe` -Compileroption.  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="types" /> ist <see langword="null" />.  
  
- oder -  
Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="modifiers" /> ist mehrdimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
- oder -  
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="callConvention">Das Objekt, das die Regeln für Reihenfolge und Layout der Argumente, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und den Prozess angibt, der den Stapel bereinigt.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer Methode, die keine Parameter akzeptiert.  
  
- oder -  
 <see langword="null" />. Wenn <paramref name="types" /> <see langword="null" /> ist, wird keine Übereinstimmung von Argumenten überprüft.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen und der angegebenen Aufrufkonvention nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl nicht der Standardbinder verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, der verarbeitet `modifiers`. `ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und behandelt nur die Parameter, die als Verweis übergeben werden.  
  
 Wenn `types` `null` ist, wird keine Übereinstimmung von Argumenten überprüft.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können festgelegt werden, welche Methoden in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Methoden in der Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Methoden (d.h. private, interne und geschützte Methoden) in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` sollen `public` und `protected` statische Member der Hierarchie; `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die Methoden, die deklariert die <xref:System.Type>, nicht die Methoden, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="modifiers" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <exception cref="T:System.NotSupportedException">Der aktuelle Typ ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" /> oder <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die Methoden des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt sämtliche öffentlichen Methoden des aktuellen <see cref="T:System.Type" /> zurück.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MethodInfo" />-Objekten, die alle für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Member darstellen.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Reflection.MethodInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine öffentlichen Methoden definiert sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetMethods%2A> Methode nicht zurückgegeben Methoden in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Ihr Code muss nicht abhängig von der Reihenfolge, in der Methoden zurückgegeben werden, da, die variieren kann.  
  
 Konstruktoren sind nicht im Array der Methoden, die von diesem Aufruf zurückgegebenen enthalten. Stellen Sie einen separaten Aufruf von `GetConstructors()` Konstruktormethoden abgerufen.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden ein, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|event|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuelle) möglich Ausblenden nach Namen oder nach Name und Signatur ausblenden.|  
|Geschachtelter Typ|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen, Sentinels enthält und nicht verwaltete Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit dem ein Get und Set-Accessor in der Basisklasse haben, aber die abgeleitete Klasse nur einen Get-Accessor hat, die Eigenschaft der abgeleiteten Klasse blendet die Basisklasseneigenschaft aus, und nicht werden auf den Setter in der Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
> [!NOTE]
>  Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden. Sie können nur Parameter auslassen, beim Aufrufen.  
  
 Wenn die aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> Objekte mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> liegt keine klasseneinschränkung.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die für den aktuellen <see cref="T:System.Type" /> definierten Methoden.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MethodInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Methoden darstellen, die den angegebenen Bindungseinschränkungen entsprechen.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Reflection.MethodInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine Methoden definiert sind oder keine der definierten Methoden den Bindungseinschränkungen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetMethods%2A> Methode nicht zurückgegeben Methoden in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Ihr Code muss nicht abhängig von der Reihenfolge, in der Methoden zurückgegeben werden, da, die variieren kann.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können festgelegt werden, welche Methoden in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Methoden in der Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Methoden (d.h. private, interne und geschützte Methoden) in die Suche einbeziehen. Nur geschützte und interne Methoden in Basisklassen werden zurückgegeben. private Methoden in Basisklassen werden nicht zurückgegeben.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` sollen `public` und `protected` statische Member der Hierarchie; `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die Methoden, die deklariert die <xref:System.Type>, nicht die Methoden, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden. Sie können nur Parameter auslassen, beim Aufrufen.  
  
 Wenn die aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> Objekte mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> liegt keine klasseneinschränkung.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Klasse mit zwei öffentliche Methoden und eine geschützte Methode, eine `Type` -Objekt entsprechende `MyTypeClass`Ruft alle öffentliche und nicht öffentlichen Methoden und ihre Namen angezeigt.  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen bestimmten Typ ab, der im aktuellen <see cref="T:System.Type" /> geschachtelt ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des abzurufenden geschachtelten Typs enthält.</param>
        <summary>Sucht den öffentlichen geschachtelten Typ mit dem angegebenen Namen.</summary>
        <returns>Ein Objekt, das den öffentlichen geschachtelten Typ mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet wird.  
  
 Verwenden Sie den einfachen Namen der geschachtelten Klasse für `name`. Kennzeichnen Sie ihn nicht mit dem Namen der äußeren Klasse. Verwenden Sie für eine geschachtelte generische Klasse, d. h. der ergänzte Name - aus, fügen Sie ein Graviszeichen und die Anzahl der generischen Argumente. Verwenden Sie z. B. die Zeichenfolge "innere\`1" zum Abrufen des generisches der geschachtelten Klasse `Inner<T>` (`Inner(Of T)` in Visual Basic). Fügen Sie keine sprachspezifische Syntax für Parameter vom Typ.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden ein, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|event|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuelle) möglich Ausblenden nach Namen oder nach Name und Signatur ausblenden.|  
|Geschachtelter Typ|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen, Sentinels enthält und nicht verwaltete Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit dem ein Get und Set-Accessor in der Basisklasse haben, aber die abgeleitete Klasse nur einen Get-Accessor hat, die Eigenschaft der abgeleiteten Klasse blendet die Basisklasseneigenschaft aus, und nicht werden auf den Setter in der Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die geschachtelten Typen von der Class-Einschränkung.  
  
 Wenn ein geschachtelter Typ generisch ist, gibt diese Methode die generische Typdefinition. Dies gilt auch, wenn der einschließenden generischen Typs ein geschlossener konstruierter Typ ist.  
  
> [!NOTE]
>  Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ definiert, die in c#, Visual Basic oder C++, dessen geschachtelten Typen sind alle generisch, auch wenn sie keine eigenen generischen Parameter verfügen. Dies gilt nicht unbedingt für geschachtelte Typen in dynamischen Assemblys definiert, oder Kompilieren mit der [Ilasm.exe (IL-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Weitere Informationen über geschachtelte generische Typen und zum Erstellen von geschachtelten generischer Typen von generischen Typdefinitionen, finden Sie unter <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des abzurufenden geschachtelten Typs enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen den angegebenen geschachtelten Typ.</summary>
        <returns>Ein Objekt, das den geschachtelten Typ darstellt, der den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls<see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie den einfachen Namen der geschachtelten Klasse für `name`. Kennzeichnen Sie ihn nicht mit dem Namen der äußeren Klasse. Verwenden Sie für eine geschachtelte generische Klasse, d. h. der ergänzte Name - aus, fügen Sie ein Graviszeichen und die Anzahl der generischen Parameter. Verwenden Sie z. B. die Zeichenfolge "innere\`1" zum Abrufen des generisches der geschachtelten Klasse `Inner<T>` (`Inner(Of T)` in Visual Basic). Fügen Sie keine sprachspezifische Syntax für Parameter vom Typ.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Flags können verwendet werden, definieren Sie die geschachtelte Filtertypen in die Suche eingeschlossen werden sollen:  
  
-   Geben Sie <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> oder <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> ein Ergebnis zurückgegeben.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> öffentliche geschachtelte Typen in die Suche eingeschlossen.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> nicht öffentlichen geschachtelte Typen (d.h. private, interne und geschützte geschachtelte Typen) in die Suche eingeschlossen.  
  
 Diese Methode gibt nur die geschachtelten Typen des aktuellen Typs zurück. Die Basisklassen des aktuellen Typs werden nicht durchsucht. Um Typen zu suchen, die geschachtelt sind in Basisklassen, müssen Sie die Vererbungshierarchie aufrufen durchlaufen <xref:System.Type.GetNestedType%2A> auf jeder Ebene.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> werden ignoriert.  
  
 Beim Aufruf dieser Methode nur die <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> Flag oder nur die <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Flag gibt zurück, der angegebenen geschachtelten Typen und alle anderen Flags sind nicht erforderlich.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die geschachtelten Typen von der Class-Einschränkung.  
  
 Wenn ein geschachtelter Typ generisch ist, gibt diese Methode die generische Typdefinition. Dies gilt auch, wenn der einschließenden generischen Typs ein geschlossener konstruierter Typ ist.  
  
> [!NOTE]
>  Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ definiert, die in c#, Visual Basic oder C++, dessen geschachtelten Typen sind alle generisch, auch wenn sie keine eigenen generischen Parameter verfügen. Dies gilt nicht unbedingt für geschachtelte Typen in dynamischen Assemblys definiert, oder Kompilieren mit der [Ilasm.exe (IL-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Weitere Informationen über geschachtelte generische Typen und zum Erstellen von geschachtelten generischer Typen von generischen Typdefinitionen, finden Sie unter <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die im aktuellen <see cref="T:System.Type" /> geschachtelten Typen ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die im aktuellen <see cref="T:System.Type" /> geschachtelten öffentlichen Typen zurück.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, das die im aktuellen <see cref="T:System.Type" /> geschachtelten öffentlichen Typen darstellt (die Suche ist nicht rekursiv) oder ein leeres Array vom Typ <see cref="T:System.Type" />, wenn im aktuellen <see cref="T:System.Type" /> keine öffentlichen Typen geschachtelt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetNestedTypes%2A> Methode nicht zurückgegeben Typen in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Ihr Code muss nicht abhängig von der Reihenfolge, in der Typen zurückgegeben werden, da, die variieren kann.  
  
 Nur die öffentlichen Typen sofort in den aktuellen Typ geschachtelt werden zurückgegeben. die Suche ist nicht rekursiv.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden ein, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|event|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuelle) möglich Ausblenden nach Namen oder nach Name und Signatur ausblenden.|  
|Geschachtelter Typ|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen, Sentinels enthält und nicht verwaltete Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit dem ein Get und Set-Accessor in der Basisklasse haben, aber die abgeleitete Klasse nur einen Get-Accessor hat, die Eigenschaft der abgeleiteten Klasse blendet die Basisklasseneigenschaft aus, und nicht werden auf den Setter in der Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die geschachtelten Typen von der Class-Einschränkung.  
  
 Wenn ein geschachtelter Typ generisch ist, gibt diese Methode die generische Typdefinition. Dies gilt auch, wenn der einschließenden generischen Typs ein geschlossener konstruierter Typ ist.  
  
> [!NOTE]
>  Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ definiert, die in c#, Visual Basic oder C++, dessen geschachtelten Typen sind alle generisch, auch wenn sie keine eigenen generischen Parameter verfügen. Dies gilt nicht unbedingt für geschachtelte Typen in dynamischen Assemblys definiert, oder Kompilieren mit der [Ilasm.exe (IL-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Weitere Informationen über geschachtelte generische Typen und zum Erstellen von geschachtelten generischer Typen von generischen Typdefinitionen, finden Sie unter <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine geschachtelte Klasse und ein `struct` in `MyClass`, und anschließend ruft Objekte der geschachtelten Typen mit dem Typ der `MyClass`.  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die im aktuellen <see cref="T:System.Type" /> geschachtelten Typen.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, das alle im aktuellen <see cref="T:System.Type" /> geschachtelten Typen darstellt, die mit den angegebenen Bindungseinschränkungen übereinstimmen (die Suche ist nicht rekursiv) oder ein leeres Array vom Typ <see cref="T:System.Type" />, wenn keine geschachtelten Typen gefunden werden, die mit den Bindungseinschränkungen übereinstimmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach geschachtelte Typen ist nicht rekursiv.  
  
 Die <xref:System.Type.GetNestedTypes%2A> Methode nicht zurückgegeben Typen in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Ihr Code muss nicht abhängig von der Reihenfolge, in der Typen zurückgegeben werden, da, die variieren kann.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Flags können verwendet werden, definieren Sie die geschachtelte Filtertypen in die Suche eingeschlossen werden sollen:  
  
-   Geben Sie <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> oder <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> ein Ergebnis zurückgegeben.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> öffentliche geschachtelte Typen in die Suche eingeschlossen.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> nicht öffentlichen geschachtelte Typen (d.h. private, interne und geschützte geschachtelte Typen) in die Suche eingeschlossen.  
  
 Diese Methode gibt nur die geschachtelten Typen des aktuellen Typs zurück. Die Basisklassen des aktuellen Typs werden nicht durchsucht. Um Typen zu suchen, die geschachtelt sind in Basisklassen, müssen Sie die Vererbungshierarchie aufrufen durchlaufen <xref:System.Type.GetNestedTypes%2A> auf jeder Ebene.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> werden ignoriert.  
  
 Beim Aufruf dieser Methode nur die <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> Flag oder nur die <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Flag gibt zurück, der angegebenen geschachtelten Typen und alle anderen Flags sind nicht erforderlich.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die geschachtelten Typen von der Class-Einschränkung.  
  
 Wenn ein geschachtelter Typ generisch ist, gibt diese Methode die generische Typdefinition. Dies gilt auch, wenn der einschließenden generischen Typs ein geschlossener konstruierter Typ ist.  
  
> [!NOTE]
>  Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ definiert, die in c#, Visual Basic oder C++, dessen geschachtelten Typen sind alle generisch, auch wenn sie keine eigenen generischen Parameter verfügen. Dies gilt nicht unbedingt für geschachtelte Typen in dynamischen Assemblys definiert, oder Kompilieren mit der [Ilasm.exe (IL-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Weitere Informationen über geschachtelte generische Typen und zum Erstellen von geschachtelten generischer Typen von generischen Typdefinitionen, finden Sie unter <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel werden zwei geschachtelte öffentliche Klassen und zwei geschachtelte geschützten Klassen erstellt und zeigt Informationen zu Klassen, die die angegebenen bindungseinschränkungen entsprechen.  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die Eigenschaften des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt sämtliche öffentlichen Eigenschaften des aktuellen <see cref="T:System.Type" /> zurück.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.PropertyInfo" />-Objekten, die alle öffentlichen Eigenschaften des aktuellen <see cref="T:System.Type" /> darstellen.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Reflection.PropertyInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine öffentlichen Eigenschaften besitzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Überladung entspricht dem Aufrufen der <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> -Überladung mit einem `bindingAttr` Argument gleich `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# geschrieben und `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic. Gibt alle öffentliche und statische Eigenschaften, die durch den vom aktuellen Typ definiert <xref:System.Type> Objekt als auch solche, die von Basistypen geerbt.  
  
 Eine Eigenschaft ist Reflektion als öffentlich betrachtet, wenn es sich um mindestens einen Accessor enthält, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic kombinieren Sie die Werte mit `Or`) anfordern.  
  
 Die <xref:System.Type.GetProperties%2A> Methode nicht zurückgegeben Eigenschaften in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Ihr Code muss nicht abhängig von der Reihenfolge, in der Eigenschaften zurückgegeben werden, da, die variieren kann.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden ein, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|event|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuelle) möglich Ausblenden nach Namen oder nach Name und Signatur ausblenden.|  
|Geschachtelter Typ|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen, Sentinels enthält und nicht verwaltete Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit dem ein Get und Set-Accessor in der Basisklasse haben, aber die abgeleitete Klasse nur einen Get-Accessor hat, die Eigenschaft der abgeleiteten Klasse blendet die Basisklasseneigenschaft aus, und nicht werden auf den Setter in der Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> Objekte mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die Eigenschaften der Class-Einschränkung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `GetProperties`-Methode gezeigt.  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die Eigenschaften des aktuellen <see cref="T:System.Type" />.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.PropertyInfo" />-Objekten, die sämtliche Eigenschaften des aktuellen <see cref="T:System.Type" /> darstellen, die den angegebenen Bindungseinschränkungen entsprechen.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Reflection.PropertyInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Eigenschaften besitzt oder keine der Eigenschaften den Bindungseinschränkungen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft ist Reflektion als öffentlich betrachtet, wenn es sich um mindestens einen Accessor enthält, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic kombinieren Sie die Werte mit `Or`) anfordern.  
  
 Die <xref:System.Type.GetProperties%2A> Methode nicht zurückgegeben Eigenschaften in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration. Ihr Code muss nicht abhängig von der Reihenfolge, in der Eigenschaften zurückgegeben werden, da, die variieren kann.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Flags können verwendet werden, definieren Sie die geschachtelte Filtertypen in die Suche eingeschlossen werden sollen:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Eigenschaften in die Suche eingeschlossen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Eigenschaften (d.h. private, interne und geschützten Eigenschaften) in die Suche einbeziehen. Nur geschützte und interne Eigenschaften für Basisklassen werden zurückgegeben. Private Eigenschaften für Basisklassen werden nicht zurückgegeben.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` sollen `public` und `protected` statische Member der Hierarchie; `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die deklarierten Eigenschaften der <xref:System.Type>, nicht über Eigenschaften, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Eine Eigenschaft ist Reflektion als öffentlich betrachtet, wenn es sich um mindestens einen Accessor enthält, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic kombinieren Sie die Werte mit `Or`) anfordern.  
  
 Wenn die aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> Objekte mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die Eigenschaften der Class-Einschränkung.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine Klasse namens `PropertyClass` sechs Eigenschaften enthält: zwei sind öffentlich, ist eine privat, eine geschützt ist, eine interne ist (`Friend` in Visual Basic), und eine interne geschützt ist (`Protected Friend` in Visual Basic). Anschließend werden einige grundlegende Informationen (dem Eigenschaftennamen und der Typ, ob es sich um Lese-/Schreibzugriff, und die Sichtbarkeit der seine `get` und `set` Accessoren) für die Eigenschaften, die die angegebenen bindungseinschränkungen entsprechen.  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine bestimmte Eigenschaft des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</param>
        <summary>Sucht die öffentliche Eigenschaft mit dem angegebenen Namen.</summary>
        <returns>Ein Objekt, das die öffentliche Eigenschaft mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet wird. Die Suche enthält öffentliche statisch und öffentlich Instanzeigenschaften.  
  
 Eine Eigenschaft ist Reflektion als öffentlich betrachtet, wenn es sich um mindestens einen Accessor enthält, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic kombinieren Sie die Werte mit `Or`) anfordern.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die Eigenschaften der Class-Einschränkung.  
  
 Situationen, in denen <xref:System.Reflection.AmbiguousMatchException> tritt auf, umfassen Folgendes:  
  
-   Ein Typ enthält zwei indizierte Eigenschaften mit dem gleichen Namen, jedoch eine unterschiedliche Anzahl von Parametern. Um die Mehrdeutigkeit zu beheben, verwenden Sie eine Überladung von der <xref:System.Type.GetProperty%2A> Methode, die Parametertypen angibt.  
  
-   Ein abgeleiteter Typ deklariert eine Eigenschaft, die eine geerbte Eigenschaft mit dem gleichen Namen, mit verbirgt die `new` Modifizierer (`Shadows` in Visual Basic). Um die Mehrdeutigkeit zu beheben, verwenden die <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> methodenüberladung, und fügen die <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> Flag, um die Suche auf Elemente zu beschränken, die nicht geerbt werden.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Eigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] bieten eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft einen Standardwert für seinen Datentyp sein. Z. B. wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index 3 ab. Sie können die Eigenschaft überladen.  
  
 In C#, dieses Feature wird einen Indexer aufgerufen und kann nicht namentlich verwiesen werden. Standardmäßig wird ein C#-Indexer in den Metadaten, wie eine indizierte Eigenschaft mit dem Namen "Item" angezeigt wird. Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut, um den Namen des Indexers in den Metadaten zu ändern. Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer, der mit dem Namen <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen Sprachen als C# -Code erstellt haben auch die Namen als Element.  
  
 Um zu bestimmen, ob ein Typ eine Standardeigenschaft verfügt, verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut. Wenn der Typ hat <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.  
  
   
  
## Examples  
 Das folgende Beispiel ruft die `Type` Objekt einer benutzerdefinierten Klasse ruft eine Eigenschaft dieser Klasse ab und zeigt den Eigenschaftennamen.  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 Intern wird diese Eigenschaft in den Metadaten mit dem Namen "Element". bezeichnet Jeder Versuch, die erste `PropertyInfo` mithilfe von Reflektion dieser internen Name angeben muss, um ordnungsgemäß zurück der `PropertyInfo` Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften mit dem angegebenen Namen gefunden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Eigenschaft enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht die angegebene Eigenschaft unter Verwendung der angegebenen Bindungseinschränkungen.</summary>
        <returns>Ein Objekt, das die Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft ist Reflektion als öffentlich betrachtet, wenn es sich um mindestens einen Accessor enthält, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic kombinieren Sie die Werte mit `Or`) anfordern.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können festgelegt werden, welche Eigenschaften in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Eigenschaften in die Suche eingeschlossen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Eigenschaften (d.h. private, interne und geschützten Eigenschaften) in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` sollen `public` und `protected` statische Member der Hierarchie; `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die deklarierten Eigenschaften der <xref:System.Type>, nicht über Eigenschaften, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die Eigenschaften der Class-Einschränkung.  
  
 Situationen, in denen <xref:System.Reflection.AmbiguousMatchException> tritt auf, umfassen Folgendes:  
  
-   Ein Typ enthält zwei indizierte Eigenschaften mit dem gleichen Namen, jedoch eine unterschiedliche Anzahl von Parametern. Um die Mehrdeutigkeit zu beheben, verwenden Sie eine Überladung von der <xref:System.Type.GetProperty%2A> Methode, die Parametertypen angibt.  
  
-   Ein abgeleiteter Typ deklariert eine Eigenschaft, die eine geerbte Eigenschaft mit den gleichen Namen ausblendet mithilfe der `new` Modifizierer (`Shadows` in Visual Basic). Um die Mehrdeutigkeit zu beheben, schließen <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> um die Suche auf Elemente zu beschränken, die nicht geerbt werden.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Eigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] bieten eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft einen Standardwert für seinen Datentyp sein. Z. B. wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index 3 ab. Sie können die Eigenschaft überladen.  
  
 In C#, dieses Feature wird einen Indexer aufgerufen und kann nicht namentlich verwiesen werden. Standardmäßig wird ein C#-Indexer in den Metadaten, wie eine indizierte Eigenschaft mit dem Namen "Item" angezeigt wird. Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut, um den Namen des Indexers in den Metadaten zu ändern. Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer, der mit dem Namen <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen Sprachen als C# -Code erstellt haben auch die Namen als Element.  
  
 Um zu bestimmen, ob ein Typ eine Standardeigenschaft verfügt, verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut. Wenn der Typ hat <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.  
  
   
  
## Examples  
 Im folgende Beispiel ruft den Typ einer benutzerdefinierten Klasse ab, ruft eine Eigenschaft dieser Klasse ab und zeigt den Namen der Eigenschaft in Übereinstimmung mit den angegebenen bindungseinschränkungen entsprechen.  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <summary>Sucht die öffentliche Eigenschaft mit dem angegebenen Namen und Rückgabetyp.</summary>
        <returns>Ein Objekt, das die öffentliche Eigenschaft mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft ist Reflektion als öffentlich betrachtet, wenn es sich um mindestens einen Accessor enthält, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic kombinieren Sie die Werte mit `Or`) anfordern.  
  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet wird. Die Suche enthält öffentliche statisch und öffentlich Instanzeigenschaften.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die Eigenschaften der Class-Einschränkung.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Eigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] bieten eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft einen Standardwert für seinen Datentyp sein. Z. B. wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index 3 ab. Sie können die Eigenschaft überladen.  
  
 In C#, dieses Feature wird einen Indexer aufgerufen und kann nicht namentlich verwiesen werden. Standardmäßig wird ein C#-Indexer in den Metadaten, wie eine indizierte Eigenschaft mit dem Namen "Item" angezeigt wird. Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut, um den Namen des Indexers in den Metadaten zu ändern. Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer, der mit dem Namen <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen Sprachen als C# -Code erstellt haben auch die Namen als Element.  
  
 Um zu bestimmen, ob ein Typ eine Standardeigenschaft verfügt, verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut. Wenn der Typ hat <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine Klasse mit einer Eigenschaft, und ruft den Namen und Typ der Eigenschaft ab.  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften mit dem angegebenen Namen gefunden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />, oder <paramref name="returnType" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</param>
        <summary>Sucht die angegebene öffentliche Eigenschaft, deren Parameter den angegebenen Argumenttypen entsprechen.</summary>
        <returns>Ein Objekt, das die öffentliche Eigenschaft darstellt, deren Parameter den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft ist Reflektion als öffentlich betrachtet, wenn es sich um mindestens einen Accessor enthält, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic kombinieren Sie die Werte mit `Or`) anfordern.  
  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet wird. Die Suche enthält öffentliche statisch und öffentlich Instanzeigenschaften.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die Eigenschaften der Class-Einschränkung.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Eigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] bieten eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft einen Standardwert für seinen Datentyp sein. Z. B. wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index 3 ab. Sie können die Eigenschaft überladen.  
  
 In C#, dieses Feature wird einen Indexer aufgerufen und kann nicht namentlich verwiesen werden. Standardmäßig wird ein C#-Indexer in den Metadaten, wie eine indizierte Eigenschaft mit dem Namen "Item" angezeigt wird. Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut, um den Namen des Indexers in den Metadaten zu ändern. Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer, der mit dem Namen <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen Sprachen als C# -Code erstellt haben auch die Namen als Element.  
  
 Um zu bestimmen, ob ein Typ eine Standardeigenschaft verfügt, verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut. Wenn der Typ hat <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.  
  
   
  
## Examples  
 Das folgende Beispiel ruft die `Type` Objekt einer Klasse eine benutzerdefinierte, ruft die Eigenschaft dieser Klasse ab und zeigt den Namen und Typ der Eigenschaft gemäß der übergebenen Argumente `GetProperty`.  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Argumenttypen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.</exception>
        <exception cref="T:System.NullReferenceException">Ein Element von <paramref name="types" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</param>
        <summary>Sucht die angegebene öffentliche Eigenschaft, deren Parameter den angegebenen Argumenttypen entsprechen.</summary>
        <returns>Ein Objekt, das die öffentliche Eigenschaft darstellt, deren Parameter den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft ist Reflektion als öffentlich betrachtet, wenn es sich um mindestens einen Accessor enthält, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic kombinieren Sie die Werte mit `Or`) anfordern.  
  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet wird. Die Suche enthält öffentliche statisch und öffentlich Instanzeigenschaften.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die Eigenschaften der Class-Einschränkung.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Eigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] bieten eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft einen Standardwert für seinen Datentyp sein. Z. B. wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index 3 ab. Sie können die Eigenschaft überladen.  
  
 In C#, dieses Feature wird einen Indexer aufgerufen und kann nicht namentlich verwiesen werden. Standardmäßig wird ein C#-Indexer in den Metadaten, wie eine indizierte Eigenschaft mit dem Namen "Item" angezeigt wird. Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut, um den Namen des Indexers in den Metadaten zu ändern. Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer, der mit dem Namen <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen Sprachen als C# -Code erstellt haben auch die Namen als Element.  
  
 Um zu bestimmen, ob ein Typ eine Standardeigenschaft verfügt, verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut. Wenn der Typ hat <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Argumenttypen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.</exception>
        <exception cref="T:System.NullReferenceException">Ein Element von <paramref name="types" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht die angegebene öffentliche Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die öffentliche Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft ist Reflektion als öffentlich betrachtet, wenn es sich um mindestens einen Accessor enthält, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic kombinieren Sie die Werte mit `Or`) anfordern.  
  
 Obwohl nicht der Standardbinder verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, der verarbeitet `modifiers`. `ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und behandelt nur die Parameter, die als Verweis übergeben werden.  
  
 Die Suche nach `name` Groß-/Kleinschreibung beachtet wird. Die Suche enthält öffentliche statisch und öffentlich Instanzeigenschaften.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die Eigenschaften der Class-Einschränkung.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Eigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] bieten eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft einen Standardwert für seinen Datentyp sein. Z. B. wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index 3 ab. Sie können die Eigenschaft überladen.  
  
 In C#, dieses Feature wird einen Indexer aufgerufen und kann nicht namentlich verwiesen werden. Standardmäßig wird ein C#-Indexer in den Metadaten, wie eine indizierte Eigenschaft mit dem Namen "Item" angezeigt wird. Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut, um den Namen des Indexers in den Metadaten zu ändern. Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer, der mit dem Namen <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen Sprachen als C# -Code erstellt haben auch die Namen als Element.  
  
 Um zu bestimmen, ob ein Typ eine Standardeigenschaft verfügt, verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut. Wenn der Typ hat <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel eine `Type` -Objekt entsprechende `MyPropertyClass`, und die indizierte Eigenschaft dieser Klasse abgerufen wird, mit den Argumenten, die an die `GetProperty` Methode.  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Argumenttypen sowie Modifizierern entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="modifiers" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <exception cref="T:System.NullReferenceException">Ein Element von <paramref name="types" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Eigenschaft enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
- oder -  
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht anhand der angegebenen Bindungseinschränkungen nach der angegebenen Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft ist Reflektion als öffentlich betrachtet, wenn es sich um mindestens einen Accessor enthält, die öffentlich ist. Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic kombinieren Sie die Werte mit `Or`) anfordern.  
  
 Obwohl nicht der Standardbinder verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, der verarbeitet `modifiers`. `ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und behandelt nur die Parameter, die als Verweis übergeben werden.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden ein, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|event|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuelle) möglich Ausblenden nach Namen oder nach Name und Signatur ausblenden.|  
|Geschachtelter Typ|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen, Sentinels enthält und nicht verwaltete Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit dem ein Get und Set-Accessor in der Basisklasse haben, aber die abgeleitete Klasse nur einen Get-Accessor hat, die Eigenschaft der abgeleiteten Klasse blendet die Basisklasseneigenschaft aus, und nicht werden auf den Setter in der Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können festgelegt werden, welche Eigenschaften in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Eigenschaften in die Suche eingeschlossen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Eigenschaften (d.h. private, interne und geschützten Eigenschaften) in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` sollen `public` und `protected` statische Member der Hierarchie; `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die deklarierten Eigenschaften der <xref:System.Type>, nicht über Eigenschaften, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit den Typparametern, die durch die entsprechenden Typargumente ersetzt.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition, sucht diese Methode die Eigenschaften der Class-Einschränkung.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Eigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] bieten eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft einen Standardwert für seinen Datentyp sein. Z. B. wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index 3 ab. Sie können die Eigenschaft überladen.  
  
 In C#, dieses Feature wird einen Indexer aufgerufen und kann nicht namentlich verwiesen werden. Standardmäßig wird ein C#-Indexer in den Metadaten, wie eine indizierte Eigenschaft mit dem Namen "Item" angezeigt wird. Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut, um den Namen des Indexers in den Metadaten zu ändern. Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer, der mit dem Namen <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen Sprachen als C# -Code erstellt haben auch die Namen als Element.  
  
 Um zu bestimmen, ob ein Typ eine Standardeigenschaft verfügt, verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut. Wenn der Typ hat <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="modifiers" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <exception cref="T:System.NullReferenceException">Ein Element von <paramref name="types" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Eigenschaft enthält.</param>
        <param name="bindingAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.  
  
- oder -  
0 (null), damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl eines überladenen Members, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
- oder -  
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.  
  
- oder -  
Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen nach der angegebenen Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl nicht der Standardbinder verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, der verarbeitet `modifiers`. `ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und behandelt nur die Parameter, die als Verweis übergeben werden.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können festgelegt werden, welche Eigenschaften in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` um ein Ergebnis zurückgegeben.  
  
-   Geben Sie `BindingFlags.Public` öffentliche Eigenschaften in die Suche eingeschlossen.  
  
-   Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Eigenschaften (d.h. private, interne und geschützten Eigenschaften) in die Suche einbeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` sollen `public` und `protected` statische Member der Hierarchie; `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die deklarierten Eigenschaften der <xref:System.Type>, nicht über Eigenschaften, die nur geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="types" /> ist <see langword="null" />.  
  
- oder -  
Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="modifiers" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <exception cref="T:System.NotSupportedException">Der aktuelle Typ ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" /> oder <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Type" />-Objekt ab, das den angegebenen Typ darstellt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den aktuellen <see cref="T:System.Type" /> ab.</summary>
        <returns>Der aktuelle <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Angeben vollständig gekennzeichneter Typnamen</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Der durch die Assembly bezeichnete Name des abzurufenden Typs. Siehe <see cref="P:System.Type.AssemblyQualifiedName" />. Wenn sich der Typ in der aktuell ausgeführten Assembly oder in Mscorlib.dll befindet, ist eine Angabe des Typnamens einschließlich des qualifizierenden Namespace ausreichend.</param>
        <summary>Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Bei der Suche wird die Groß-/Kleinschreibung beachtet.</summary>
        <returns>Der Typ mit dem angegebenen Namen, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Können Sie die <xref:System.Type.GetType%2A> Methode zum Abrufen einer <xref:System.Type> Objekt für einen Typ in einer anderen Assembly, wenn Sie die Assembly qualifizierten Namen kennen, die aus abgerufen werden können <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> führt zum Laden der Assembly im angegebenen `typeName`. Sie können auch laden eine Assembly unter Verwendung der <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> -Methode und anschließend auf die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> -Methode zum Abrufen <xref:System.Type> Objekte. Wenn ein Typ in einer Assembly mit dem Programm zur Kompilierzeit bekannt ist, ist es effizienter, verwenden Sie `typeof` in C# oder `GetType` -Operator in Visual Basic.
  
> [!NOTE]
>  Wenn `typeName` kann nicht gefunden werden, den Aufruf der <xref:System.Type.GetType%28System.String%29> Methodenrückgabe `null`. Es löst keine Ausnahme aus. Um zu steuern, ob eine Ausnahme wird ausgelöst, rufen Sie eine Überladung von der <xref:System.Type.GetType%2A> Methode mit einem `throwOnError` Parameter.  
  
 <xref:System.Type.GetType%2A> funktioniert nur für Assemblys, die vom Datenträger geladen. Aufrufen <xref:System.Type.GetType%2A> zum Nachschlagen eines Typs in einer dynamischen Assembly definiert, definiert der <xref:System.Reflection.Emit> Services erhalten Sie möglicherweise inkonsistentes Verhalten. Das Verhalten abhängig, ob die dynamische Assembly persistent, d. h. ist, wird erstellt, mit der `RunAndSave` oder `Save` Zugriff auf die Modi für die <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> Enumeration. Wenn die dynamische Assembly persistent ist und bevor Sie auf den Datenträger geschrieben wurde `GetType` wird aufgerufen, das Ladeprogramm die gespeicherte Assembly sucht, auf dem Datenträger, lädt die Assembly und ruft den Typ aus dieser Assembly ab. Wenn die Assembly nicht gespeichert wurde, wenn auf dem Datenträger `GetType` aufgerufen wird, wird der Methodenrückgabe `null`. `GetType` flüchtige dynamische Assemblys versteht nicht; aus diesem Grund Aufrufen `GetType` zum Abrufen eines Typs in eine vorübergehende dynamische Assembly gibt `null`.  
  
 Mit `GetType` für ein dynamisches Modul, abonnieren das <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> Ereignis, und rufen `GetType` vor dem Speichern. Andernfalls erhalten Sie zwei Kopien der Assembly im Speicher.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden ein, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|event|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuelle) möglich Ausblenden nach Namen oder nach Name und Signatur ausblenden.|  
|Geschachtelter Typ|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen, Sentinels enthält und nicht verwaltete Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit dem ein Get und Set-Accessor in der Basisklasse haben, aber die abgeleitete Klasse nur einen Get-Accessor hat, die Eigenschaft der abgeleiteten Klasse blendet die Basisklasseneigenschaft aus, und nicht werden auf den Setter in der Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Arrays oder COM-Typen werden nicht für durchsucht, es sei denn, sie bereits in der Tabelle der verfügbaren Klassen geladen wurden.  
  
 `typeName` Der Typname kann durch den Namespace oder eine Assembly qualifizierten Namen, der Angabe eines Assemblynamens enthält qualifiziert werden. Siehe <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Wenn `typeName` umfasst den Namespace, jedoch nicht den Assemblynamen eingeben, sucht diese Methode nur die Assembly des aufrufenden Objekts und die Datei "mscorlib.dll", in dieser Reihenfolge. Wenn TypeName vollqualifizierten mit dem Assemblynamen für teilweise oder vollständig ist, sucht diese Methode, in der angegebenen Assembly. Wenn die Assembly einen starken Namen aufweist, muss ein vollständigen Assemblynamen.  
  
 Die <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft gibt einen vollqualifizierten Typnamen einschließlich geschachtelte Typen, Assemblyname und generische Typargumente. Alle Compiler, die die common Language Runtime unterstützen, werden der einfache Name einer geschachtelten Klasse geben an, und Reflektion erstellt einen ergänzten Namen in Übereinstimmung mit den folgenden Konventionen abgefragt.  
  
> [!NOTE]
>  In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt wird, und kann als Teil der Assembly-Zeichenfolgen angegeben werden. Z. B. "ProcessorArchitecture = Msil". Es ist jedoch nicht enthalten in der Zeichenfolge, die vom der <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft aus Kompatibilitätsgründen. Außerdem können Sie Typen laden, indem Sie erstellen eine <xref:System.Reflection.AssemblyName> -Objekt und die Übergabe an eine entsprechende Überladung von der <xref:System.Reflection.Assembly.Load%2A> Methode. Anschließend können Sie die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> -Methode zum Laden von Typen aus der Assembly. Siehe auch <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Delimiter|Bedeutung|  
|---------------|-------------|  
|Umgekehrter Schrägstrich (\\)|Escape-Zeichen.|  
|Graviszeichen (') | Steht vor einer oder mehreren Ziffern, die die Anzahl von Typparametern, die am Ende des Namens eines generischen Typs darstellt.|  
|Eckige Klammern ([])|Schließen Sie eine generischen Typargumentliste für einen konstruierten generischen Typ; Schließen Sie in einer Liste der Typargumente eine Assembly qualifizierten Typnamen ein.|  
|Komma (,)|Der Name der Assembly wird vorangestellt.|  
|Punkt (.)|Bezeichnet die Namespacebezeichner.|  
|Pluszeichen (+)|Steht vor einer geschachtelten Klasse.|  
  
 Der vollqualifizierte Name für eine Klasse kann beispielsweise wie folgt aussehen:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Wenn der Namespace z.B. TopNamespace.Sub, würde die Zeichenfolge auf das Pluszeichen (+), ein Escapezeichen vorangestellt haben (\\) zu verhindern, dass es als geschachteltes Trennzeichen interpretiert wird. Reflektion gibt diese Zeichenfolge wie folgt aus:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Ein "++" wird "\\+\\+", und ein "\\"wird"\\\\".  
  
 Dieser qualifizierte Name persistent gespeichert werden kann, und später verwendet, um das Laden der <xref:System.Type>. Suchen und Laden eine <xref:System.Type>, verwenden Sie <xref:System.Type.GetType%2A> entweder mit dem Typ oder einen Namen geben nur mit dem Namen der Assembly qualifizierten Typ. <xref:System.Type.GetType%2A> mit dem Namen nur sucht die <xref:System.Type> in der Assembly des Aufrufers, und klicken Sie dann in der System-Assembly. <xref:System.Type.GetType%2A> mit der Assembly qualifizierten Typnamen sucht die <xref:System.Type> in jeder Assembly.  
  
 Namen können nachfolgende Zeichen enthalten, zusätzliche Informationen über den Typ, z. B., ob der Typ ein Verweistyp, ein Zeigertyp oder einen Arraytyp ist. Verwenden Sie zum Abrufen der Typname ohne diese nachfolgenden Zeichen `t.GetElementType().ToString()`, wobei `t` ist der Typ.  
  
 Leerzeichen sind in allen Komponenten von Typnamen mit Ausnahme der Assemblyname relevant. Der Assemblyname Leerzeichen vor dem Trennzeichen ',' relevant, aber Leerzeichen nach dem Trennzeichen ',' werden ignoriert.  
  
 Der Name eines generischen Typs endet mit einem Graviszeichen (\`) gefolgt von Ziffern, die die Anzahl der Argumente des generischen Typs darstellt. Dieser Name-mangling dient zum Zulassen von Compilern zur Unterstützung von generischer Typen mit demselben Namen aber mit einer unterschiedlichen Anzahl von Typparametern, im gleichen Gültigkeitsbereich auftritt. Reflektion gibt z. B. die ergänzten Namen `Tuple`1` and `Tupel`2` die generischen Methoden `Tuple(Of T)` und `Tuple(Of T0, T1)` in Visual Basic oder `Tuple<T>` und Tupel`\<T0, T1>` in Visual c#.  
  
 Bei generischen Typen wird die Typargumentliste in Klammern gesetzt, und die Typargumente durch Kommas getrennt. Zum Beispiel eine generische <xref:System.Collections.Generic.Dictionary%602> verfügt über zwei Typparameter. Ein <xref:System.Collections.Generic.Dictionary%602> von `MyType` mit Schlüsseln vom Typ <xref:System.String> kann wie folgt dargestellt werden:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Um eine Assembly qualifizierten Typnamen in einer Liste der Typargumente angeben, schließen Sie die Assembly qualifizierten Typnamen in eckige Klammern ein. Andernfalls werden die Kommas, die trennen die Teile der Assembly qualifizierten Namen, interpretiert, als Trennzeichen für zusätzliche Typargumente. Z. B. eine <xref:System.Collections.Generic.Dictionary%602> von `MyType` fromMyAssembly.dll, mit Schlüsseln vom Typ <xref:System.String>, könnte wie folgt angegeben werden:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Ein Typ mit assemblyqualifikation kann in Klammern eingeschlossen werden, nur, wenn er in einer Liste der Parameter angezeigt wird. Die Regeln für die Suche von Assemblys für qualifizierte und unvollständigen Typen in Typparameterlisten sind identisch mit den Regeln für den qualifizierten und nicht qualifizierte nicht generische Typen.  
  
 Nullable-Typen sind ein besonderer Fall von generischen Typen. Beispielsweise eine auf NULL festlegbare <xref:System.Int32> wird dargestellt, durch die Zeichenfolge "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  In c#, C++ und Visual Basic können Sie auch auf NULL festlegbare Typen, die mithilfe von Operatoren abrufen. Z. B. die NULL-Werte zulassen <xref:System.Boolean> Typ wird zurückgegeben, indem `typeof(Nullable<bool>)` in c# durch `Nullable<Boolean>::typeid` in C++, und durch `GetType(Nullable(Of Boolean))` in Visual Basic.  
  
 Die folgende Tabelle zeigt die Syntax, mit `GetType` für verschiedene Typen.  
  
|Zum Abrufen|Mit|  
|------------|---------|  
|Ein NULL-Werte zulässt <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Ein nicht verwalteter Zeiger auf `MyType`|`Type.GetType("MyType*")`|  
|Ein nicht verwalteter Zeiger auf einen Zeiger auf `MyType`|`Type.GetType("MyType**")`|  
|Ein verwalteter Zeiger oder Verweis auf `MyType`|`Type.GetType("MyType&")`. Beachten Sie, dass Verweise im Gegensatz zu Zeigern auf eine Ebene beschränkt sind.|  
|Eine übergeordnete Klasse und eine geschachtelte Klasse.|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Ein eindimensionales Array mit einer unteren Grenze von 0|`Type.GetType("MyType[]")`|  
|Ein eindimensionales Array mit einem Unbekannter unterer Grenze|`Type.GetType("MyType[*]")`|  
|Ein Array mit n-dimensionalen|Ein Komma (,) innerhalb der Klammern eine insgesamt n-1 Mal. Z. B. `System.Object[,,]` stellt ein dreidimensionales `Object` Array.|  
|Ein Array von eindimensionale arrays|`Type.GetType("MyType[][]")`|  
|Ein rechteckiges zweidimensionales Array mit Unbekannter unterer Grenze|`Type.GetType("MyType[,]")`|  
|Ein generischer Typ mit einem Typargument|``Type.GetType("MyGenericType`1[MyType]")``|  
|Ein generischer Typ mit zwei Typargumente|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Ein generischer Typ mit zwei Argumenten der Assembly qualifizierten Typnamen|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|Ein mit assemblyqualifikation, generischer Typ mit einem Argument für die Assembly qualifizierten Typnamen|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Ein generischer Typ, dessen Typargument eines generischen Typs mit zwei Argumente des Typs ist.|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 Das folgende Beispiel ruft den Typ des `System.Int32` und verwendet das Typobjekt zum Anzeigen der <xref:System.Type.FullName%2A> Eigenschaft `System.Int32`.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.IO.IOException" /> ab.  
  
</para>
          </block>  
  
 Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und die Assembly wurde mit einer höheren Version kompiliert.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Angeben vollständig gekennzeichneter Typnamen</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Der durch die Assembly bezeichnete Name des abzurufenden Typs. Siehe <see cref="P:System.Type.AssemblyQualifiedName" />. Wenn sich der Typ in der aktuell ausgeführten Assembly oder in Mscorlib.dll befindet, ist eine Angabe des Typnamens einschließlich des qualifizierenden Namespace ausreichend.</param>
        <param name="throwOnError"><see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" />, damit <see langword="null" /> zurückgegeben wird. Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle. Informationen finden Sie im Abschnitt für Ausnahmen.</param>
        <summary>Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Bei der Suche wird die Groß-/Kleinschreibung beachtet. Dabei wird angegeben, ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird.</summary>
        <returns>Der Typ mit dem angegebenen Namen. Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird. In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst. Informationen finden Sie im Abschnitt für Ausnahmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Können Sie die <xref:System.Type.GetType%2A> Methode zum Abrufen einer <xref:System.Type> Objekt für einen Typ in einer anderen Assembly, wenn Sie die Assembly qualifizierten Namen kennen, die aus abgerufen werden können <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> führt zum Laden der Assembly im angegebenen `typeName`. Sie können auch laden eine Assembly unter Verwendung der <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> -Methode und anschließend auf die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> -Methode zum Abrufen <xref:System.Type> Objekte. Wenn ein Typ in einer Assembly mit dem Programm zur Kompilierzeit bekannt ist, ist es effizienter, verwenden Sie `typeof` in C# oder `GetType` -Operator in Visual Basic.
  
 `GetType` funktioniert nur für Assemblys, die vom Datenträger geladen. Aufrufen `GetType` zum Nachschlagen eines Typs in einer dynamischen Assembly definiert, definiert der <xref:System.Reflection.Emit> Services erhalten Sie möglicherweise inkonsistentes Verhalten. Das Verhalten abhängig, ob die dynamische Assembly persistent, d. h. ist, wird erstellt, mit der `RunAndSave` oder `Save` Zugriff auf die Modi für die <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> Enumeration. Wenn die dynamische Assembly persistent ist und bevor Sie auf den Datenträger geschrieben wurde `GetType` wird aufgerufen, das Ladeprogramm die gespeicherte Assembly sucht, auf dem Datenträger, lädt die Assembly und ruft den Typ aus dieser Assembly ab. Wenn die Assembly nicht gespeichert wurde, wenn auf dem Datenträger `GetType` aufgerufen wird, wird der Methodenrückgabe `null`. `GetType` flüchtige dynamische Assemblys versteht nicht; aus diesem Grund Aufrufen `GetType` zum Abrufen eines Typs in eine vorübergehende dynamische Assembly gibt `null`.  
  
 Mit `GetType` für ein dynamisches Modul, abonnieren das <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> Ereignis, und rufen `GetType` vor dem Speichern. Andernfalls erhalten Sie zwei Kopien der Assembly im Speicher.  
  
 Die `throwOnError` Parameter gibt an, was geschieht, wenn der Typ wurde nicht gefunden, und auch bestimmte andere Ausnahmebedingungen unterdrückt, wie im Abschnitt für Ausnahmen beschrieben. Einige Ausnahmen werden ausgelöst, unabhängig vom Wert der `throwOnError`. Wenn der Typ befindet sich aber nicht geladen werden, z. B. eine <xref:System.TypeLoadException> wird ausgelöst, selbst wenn `throwOnError` ist `false`.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden ein, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|event|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuelle) möglich Ausblenden nach Namen oder nach Name und Signatur ausblenden.|  
|Geschachtelter Typ|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen, Sentinels enthält und nicht verwaltete Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit dem ein Get und Set-Accessor in der Basisklasse haben, aber die abgeleitete Klasse nur einen Get-Accessor hat, die Eigenschaft der abgeleiteten Klasse blendet die Basisklasseneigenschaft aus, und nicht werden auf den Setter in der Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Arrays oder COM-Typen werden nicht für durchsucht, es sei denn, sie bereits in der Tabelle der verfügbaren Klassen geladen wurden.  
  
 `typeName` Der Typname kann durch den Namespace oder eine Assembly qualifizierten Namen, der Angabe eines Assemblynamens enthält qualifiziert werden. Siehe <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Wenn `typeName` umfasst den Namespace, jedoch nicht den Assemblynamen eingeben, sucht diese Methode nur die Assembly des aufrufenden Objekts und die Datei "mscorlib.dll", in dieser Reihenfolge. Wenn TypeName vollqualifizierten mit dem Assemblynamen für teilweise oder vollständig ist, sucht diese Methode, in der angegebenen Assembly. Wenn die Assembly einen starken Namen aufweist, muss ein vollständigen Assemblynamen.  
  
 Die <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft gibt einen vollqualifizierten Typnamen einschließlich geschachtelte Typen, Assemblyname und generischen Argumente zurück. Alle Compiler, die die common Language Runtime unterstützen, werden der einfache Name einer geschachtelten Klasse geben an, und Reflektion erstellt einen ergänzten Namen in Übereinstimmung mit den folgenden Konventionen abgefragt.  
  
> [!NOTE]
>  In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt wird, und kann als Teil der Assembly-Zeichenfolgen angegeben werden. Z. B. "ProcessorArchitecture = Msil". Es ist jedoch nicht enthalten in der Zeichenfolge, die vom der <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft aus Kompatibilitätsgründen. Außerdem können Sie Typen laden, indem Sie erstellen eine <xref:System.Reflection.AssemblyName> -Objekt und die Übergabe an eine entsprechende Überladung von der <xref:System.Reflection.Assembly.Load%2A> Methode. Anschließend können Sie die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> -Methode zum Laden von Typen aus der Assembly. Siehe auch <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Delimiter|Bedeutung|  
|---------------|-------------|  
|Umgekehrter Schrägstrich (\\)|Escape-Zeichen.|  
|Graviszeichen (') | Steht vor einer oder mehreren Ziffern, die die Anzahl von Typparametern, die am Ende des Namens eines generischen Typs darstellt.|  
|Eckige Klammern ([])|Schließen Sie eine generischen Typargumentliste für einen konstruierten generischen Typ; Schließen Sie in einer Liste der Typargumente eine Assembly qualifizierten Typnamen ein.|  
|Komma (,)|Der Name der Assembly wird vorangestellt.|  
|Punkt (.)|Bezeichnet die Namespacebezeichner.|  
|Pluszeichen (+)|Steht vor einer geschachtelten Klasse.|  
  
 Der vollqualifizierte Name für eine Klasse kann beispielsweise wie folgt aussehen:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Wenn der Namespace z.B. TopNamespace.Sub, würde die Zeichenfolge auf das Pluszeichen (+), ein Escapezeichen vorangestellt haben (\\) zu verhindern, dass es als geschachteltes Trennzeichen interpretiert wird. Reflektion gibt diese Zeichenfolge wie folgt aus:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Ein "++" wird "\\+\\+", und ein "\\"wird"\\\\".  
  
 Dieser qualifizierte Name persistent gespeichert werden kann, und später verwendet, um das Laden der <xref:System.Type>. Suchen und Laden eine <xref:System.Type>, verwenden Sie <xref:System.Type.GetType%2A> entweder mit dem Typ oder einen Namen geben nur mit dem Namen der Assembly qualifizierten Typ. <xref:System.Type.GetType%2A> mit dem Namen nur sucht die <xref:System.Type> in der Assembly des Aufrufers, und klicken Sie dann in der System-Assembly. <xref:System.Type.GetType%2A> mit der Assembly qualifizierten Typnamen sucht die <xref:System.Type> in jeder Assembly.  
  
 Namen können nachfolgende Zeichen enthalten, zusätzliche Informationen über den Typ, z. B., ob der Typ ein Verweistyp, ein Zeigertyp oder einen Arraytyp ist. Verwenden Sie zum Abrufen der Typname ohne diese nachfolgenden Zeichen `t.GetElementType().ToString()`, wobei `t` ist der Typ.  
  
 Leerzeichen sind in allen Komponenten von Typnamen mit Ausnahme der Assemblyname relevant. Der Assemblyname Leerzeichen vor dem Trennzeichen ',' relevant, aber Leerzeichen nach dem Trennzeichen ',' werden ignoriert.  
  
 Der Name eines generischen Typs endet mit einem Graviszeichen (\`) gefolgt von Ziffern, die die Anzahl der Argumente des generischen Typs darstellt. Dieser Name-mangling dient zum Zulassen von Compilern zur Unterstützung von generischer Typen mit demselben Namen aber mit einer unterschiedlichen Anzahl von Typparametern, im gleichen Gültigkeitsbereich auftritt. Reflektion gibt z. B. die ergänzten Namen `Tuple`1` and `Tupel`2` die generischen Methoden `Tuple(Of T)` und `Tuple(Of T0, T1)` in Visual Basic oder `Tuple<T>` und Tupel`\<T0, T1>` in Visual c#.  
  
 Bei generischen Typen wird die Typargumentliste in Klammern gesetzt, und die Typargumente durch Kommas getrennt. Zum Beispiel eine generische <xref:System.Collections.Generic.Dictionary%602> verfügt über zwei Typparameter. Ein <xref:System.Collections.Generic.Dictionary%602> von `MyType` mit Schlüsseln vom Typ <xref:System.String> kann wie folgt dargestellt werden:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Um eine Assembly qualifizierten Typnamen in einer Liste der Typargumente angeben, schließen Sie die Assembly qualifizierten Typnamen in eckige Klammern ein. Andernfalls werden die Kommas, die trennen die Teile der Assembly qualifizierten Namen, interpretiert, als Trennzeichen für zusätzliche Typargumente. Z. B. eine <xref:System.Collections.Generic.Dictionary%602> von `MyType` aus mit Schlüsseln vom Typ "MeineAssembly.dll" <xref:System.String>, könnte wie folgt angegeben werden:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Ein Typ mit assemblyqualifikation kann in Klammern eingeschlossen werden, nur, wenn er in einer Liste der Parameter angezeigt wird. Die Regeln für die Suche von Assemblys für qualifizierte und unvollständigen Typen in Typparameterlisten sind identisch mit den Regeln für den qualifizierten und nicht qualifizierte nicht generische Typen.  
  
 Nullable-Typen sind ein besonderer Fall von generischen Typen. Beispielsweise eine auf NULL festlegbare <xref:System.Int32> wird dargestellt, durch die Zeichenfolge "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  In c#, C++ und Visual Basic können Sie auch auf NULL festlegbare Typen, die mithilfe von Operatoren abrufen. Z. B. die NULL-Werte zulassen <xref:System.Boolean> Typ wird zurückgegeben, indem `typeof(Nullable<bool>)` in c# durch `Nullable<Boolean>::typeid` in C++, und durch `GetType(Nullable(Of Boolean))` in Visual Basic.  
  
 Die folgende Tabelle zeigt die Syntax, mit `GetType` für verschiedene Typen.  
  
|Zum Abrufen|Mit|  
|------------|---------|  
|Ein NULL-Werte zulässt <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Ein nicht verwalteter Zeiger auf `MyType`|`Type.GetType("MyType*")`|  
|Ein nicht verwalteter Zeiger auf einen Zeiger auf `MyType`|`Type.GetType("MyType**")`|  
|Ein verwalteter Zeiger oder Verweis auf `MyType`|`Type.GetType("MyType&")`. Beachten Sie, dass Verweise im Gegensatz zu Zeigern auf eine Ebene beschränkt sind.|  
|Eine übergeordnete Klasse und eine geschachtelte Klasse.|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Ein eindimensionales Array mit einer unteren Grenze von 0|`Type.GetType("MyArray[]")`|  
|Ein eindimensionales Array mit einem Unbekannter unterer Grenze|`Type.GetType("MyArray[*]")`|  
|Ein Array mit n-dimensionalen|Ein Komma (,) innerhalb der Klammern eine insgesamt n-1 Mal. Z. B. `System.Object[,,]` stellt ein dreidimensionales `Object` Array.|  
|Ein zweidimensionales Array von Arrays|`Type.GetType("MyArray[][]")`|  
|Ein rechteckiges zweidimensionales Array mit Unbekannter unterer Grenze|`Type.GetType("MyArray[,]")`|  
|Ein generischer Typ mit einem Typargument|``Type.GetType("MyGenericType`1[MyType]")``|  
|Ein generischer Typ mit zwei Typargumente|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Ein generischer Typ mit zwei Argumenten der Assembly qualifizierten Typnamen|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|Ein mit assemblyqualifikation, generischer Typ mit einem Argument für die Assembly qualifizierten Typnamen|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Ein generischer Typ, dessen Typargument eines generischen Typs mit zwei Argumente des Typs ist.|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 Das folgende Beispiel ruft den Typ des `System.Int32` und verwendet das Typobjekt zum Anzeigen der <xref:System.Type.FullName%2A> Eigenschaft `System.Int32`. Wenn ein Typobjekt auf eine Assembly, die nicht vorhanden ist verweist, wird in diesem Beispiel wird eine Ausnahme ausgelöst.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.  
  
- oder -  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen. 
- oder -  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.  
  
- oder -  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.  
  
- oder -  
 <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax, beispielsweise "MyType[,*,]".  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.IO.IOException" /> ab.  
  
</para>
          </block>  
  
 Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und die Assembly wurde mit einer höheren Version kompiliert.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Angeben vollständig gekennzeichneter Typnamen</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeName">Der durch die Assembly bezeichnete Name des abzurufenden Typs. Siehe <see cref="P:System.Type.AssemblyQualifiedName" />. Wenn sich der Typ in der aktuell ausgeführten Assembly oder in Mscorlib.dll befindet, ist eine Angabe des Typnamens einschließlich des qualifizierenden Namespace ausreichend.</param>
        <param name="throwOnError"><see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" />, damit <see langword="null" /> zurückgegeben wird. Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle. Informationen finden Sie im Abschnitt für Ausnahmen.</param>
        <param name="ignoreCase"><see langword="true" />, um ohne Beachtung der Groß-/Kleinschreibung nach <paramref name="typeName" /> zu suchen, <see langword="false" />, um mit Beachtung der Groß-/Kleinschreibung nach <paramref name="typeName" /> zu suchen.</param>
        <summary>Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Dabei wird angegeben, ob bei der Suche Groß- und Kleinschreibung berücksichtigt werden soll und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird.</summary>
        <returns>Der Typ mit dem angegebenen Namen. Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird. In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst. Informationen finden Sie im Abschnitt für Ausnahmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Können Sie die <xref:System.Type.GetType%2A> Methode zum Abrufen einer <xref:System.Type> Objekt für einen Typ in einer anderen Assembly, wenn Sie die Assembly qualifizierten Namen kennen, die aus abgerufen werden können <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> führt zum Laden der Assembly im angegebenen `typeName`. Sie können auch laden eine Assembly unter Verwendung der <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> -Methode und anschließend auf die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> -Methode zum Abrufen <xref:System.Type> Objekte. Wenn ein Typ in einer Assembly mit dem Programm zur Kompilierzeit bekannt ist, ist es effizienter, verwenden Sie `typeof` in C# oder `GetType` -Operator in Visual Basic.
  
 `GetType` funktioniert nur für Assemblys, die vom Datenträger geladen. Aufrufen `GetType` zum Nachschlagen eines Typs in einer dynamischen Assembly definiert, definiert der <xref:System.Reflection.Emit> Services erhalten Sie möglicherweise inkonsistentes Verhalten. Das Verhalten abhängig, ob die dynamische Assembly persistent, d. h. ist, wird erstellt, mit der `RunAndSave` oder `Save` Zugriff auf die Modi für die <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> Enumeration. Wenn die dynamische Assembly persistent ist und bevor Sie auf den Datenträger geschrieben wurde `GetType` wird aufgerufen, das Ladeprogramm die gespeicherte Assembly sucht, auf dem Datenträger, lädt die Assembly und ruft den Typ aus dieser Assembly ab. Wenn die Assembly nicht gespeichert wurde, wenn auf dem Datenträger `GetType` aufgerufen wird, wird der Methodenrückgabe `null`. `GetType` flüchtige dynamische Assemblys versteht nicht; aus diesem Grund Aufrufen `GetType` zum Abrufen eines Typs in eine vorübergehende dynamische Assembly gibt `null`.  
  
 Mit `GetType` für ein dynamisches Modul, abonnieren das <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> Ereignis, und rufen `GetType` vor dem Speichern. Andernfalls erhalten Sie zwei Kopien der Assembly im Speicher.  
  
 Die `throwOnError` Parameter gibt an, was geschieht, wenn der Typ wurde nicht gefunden, und auch bestimmte andere Ausnahmebedingungen unterdrückt, wie im Abschnitt für Ausnahmen beschrieben. Einige Ausnahmen werden ausgelöst, unabhängig vom Wert der `throwOnError`. Wenn der Typ befindet sich aber nicht geladen werden, z. B. eine <xref:System.TypeLoadException> wird ausgelöst, selbst wenn `throwOnError` ist `false`.  
  
 Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden ein, wenn für einen Typ reflektieren.  
  
|Memberart|Statisch|Nicht statische|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld ist immer nach Name und Signatur ausblenden.|  
|event|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (virtuelle und nicht virtuelle) möglich Ausblenden nach Namen oder nach Name und Signatur ausblenden.|  
|Geschachtelter Typ|Nein|Nein|  
|Eigenschaft|Nicht zutreffend|Die allgemeinen Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren. Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden. Siehe Hinweis 2 weiter unten.|  
  
1.  Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen, Sentinels enthält und nicht verwaltete Aufrufkonventionen zurückgeben. Dies ist ein binärer Vergleich.  
  
2.  Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden. Wenn Sie eine Eigenschaft mit dem ein Get und Set-Accessor in der Basisklasse haben, aber die abgeleitete Klasse nur einen Get-Accessor hat, die Eigenschaft der abgeleiteten Klasse blendet die Basisklasseneigenschaft aus, und nicht werden auf den Setter in der Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Arrays oder COM-Typen werden nicht für durchsucht, es sei denn, sie bereits in der Tabelle der verfügbaren Klassen geladen wurden.  
  
 `typeName` Der Typname kann durch den Namespace oder eine Assembly qualifizierten Namen, der Angabe eines Assemblynamens enthält qualifiziert werden. Siehe <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Wenn `typeName` umfasst den Namespace, jedoch nicht den Assemblynamen eingeben, sucht diese Methode nur die Assembly des aufrufenden Objekts und die Datei "mscorlib.dll", in dieser Reihenfolge. Wenn TypeName vollqualifizierten mit dem Assemblynamen für teilweise oder vollständig ist, sucht diese Methode, in der angegebenen Assembly. Wenn die Assembly einen starken Namen aufweist, muss ein vollständigen Assemblynamen.  
  
 Die <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft gibt einen vollqualifizierten Typnamen einschließlich geschachtelte Typen, Assemblyname und Typargumente zurück. Alle Compiler, die die common Language Runtime unterstützen, werden der einfache Name einer geschachtelten Klasse geben an, und Reflektion erstellt einen ergänzten Namen in Übereinstimmung mit den folgenden Konventionen abgefragt.  
  
> [!NOTE]
>  In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt wird, und kann als Teil der Assembly-Zeichenfolgen angegeben werden. Z. B. "ProcessorArchitecture = Msil". Es ist jedoch nicht enthalten in der Zeichenfolge, die vom der <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft aus Kompatibilitätsgründen. Außerdem können Sie Typen laden, indem Sie erstellen eine <xref:System.Reflection.AssemblyName> -Objekt und die Übergabe an eine entsprechende Überladung von der <xref:System.Reflection.Assembly.Load%2A> Methode. Anschließend können Sie die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> -Methode zum Laden von Typen aus der Assembly. Siehe auch <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Delimiter|Bedeutung|  
|---------------|-------------|  
|Umgekehrter Schrägstrich (\\)|Escape-Zeichen.|  
|Graviszeichen (') | Steht vor einer oder mehreren Ziffern, die die Anzahl von Typparametern, die am Ende des Namens eines generischen Typs darstellt.|  
|Eckige Klammern ([])|Schließen Sie eine generischen Typargumentliste für einen konstruierten generischen Typ; Schließen Sie in einer Liste der Typargumente eine Assembly qualifizierten Typnamen ein.|  
|Komma (,)|Der Name der Assembly wird vorangestellt.|  
|Punkt (.)|Bezeichnet die Namespacebezeichner.|  
|Pluszeichen (+)|Steht vor einer geschachtelten Klasse.|  
  
 Der vollqualifizierte Name für eine Klasse kann beispielsweise wie folgt aussehen:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Wenn der Namespace z.B. TopNamespace.Sub, würde die Zeichenfolge auf das Pluszeichen (+), ein Escapezeichen vorangestellt haben (\\) zu verhindern, dass es als geschachteltes Trennzeichen interpretiert wird. Reflektion gibt diese Zeichenfolge wie folgt aus:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Ein "++" wird "\\+\\+", und ein "\\"wird"\\\\".  
  
 Dieser qualifizierte Name persistent gespeichert werden kann, und später verwendet, um das Laden der <xref:System.Type>. Suchen und Laden eine <xref:System.Type>, verwenden Sie <xref:System.Type.GetType%2A> entweder mit dem Typ oder einen Namen geben nur mit dem Namen der Assembly qualifizierten Typ. <xref:System.Type.GetType%2A> mit dem Namen nur sucht die <xref:System.Type> in der Assembly des Aufrufers, und klicken Sie dann in der System-Assembly. <xref:System.Type.GetType%2A> mit der Assembly qualifizierten Typnamen sucht die <xref:System.Type> in jeder Assembly.  
  
 Namen können nachfolgende Zeichen enthalten, zusätzliche Informationen über den Typ, z. B., ob der Typ ein Verweistyp, ein Zeigertyp oder einen Arraytyp ist. Verwenden Sie zum Abrufen der Typname ohne diese nachfolgenden Zeichen `t.GetElementType().ToString()`, wobei `t` ist der Typ.  
  
 Leerzeichen sind in allen Komponenten von Typnamen mit Ausnahme der Assemblyname relevant. Der Assemblyname Leerzeichen vor dem Trennzeichen ',' relevant, aber Leerzeichen nach dem Trennzeichen ',' werden ignoriert.  
  
 Der Name eines generischen Typs endet mit einem Graviszeichen (\`) gefolgt von Ziffern, die die Anzahl der Argumente des generischen Typs darstellt. Dieser Name-mangling dient zum Zulassen von Compilern zur Unterstützung von generischer Typen mit demselben Namen aber mit einer unterschiedlichen Anzahl von Typparametern, im gleichen Gültigkeitsbereich auftritt. Reflektion gibt z. B. die ergänzten Namen `Tuple`1` and `Tupel`2` die generischen Methoden `Tuple(Of T)` und `Tuple(Of T0, T1)` in Visual Basic oder `Tuple<T>` und Tupel`\<T0, T1>` in Visual c#.  
  
 Bei generischen Typen wird die Typargumentliste in Klammern gesetzt, und die Typargumente durch Kommas getrennt. Zum Beispiel eine generische <xref:System.Collections.Generic.Dictionary%602> verfügt über zwei Typparameter. Ein <xref:System.Collections.Generic.Dictionary%602> von `MyType` mit Schlüsseln vom Typ <xref:System.String> kann wie folgt dargestellt werden:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Um eine Assembly qualifizierten Typnamen in einer Liste der Typargumente angeben, schließen Sie die Assembly qualifizierten Typnamen in eckige Klammern ein. Andernfalls werden die Kommas, die trennen die Teile der Assembly qualifizierten Namen, interpretiert, als Trennzeichen für zusätzliche Typargumente. Z. B. eine <xref:System.Collections.Generic.Dictionary%602> von `MyType` aus mit Schlüsseln vom Typ "MeineAssembly.dll" <xref:System.String>, könnte wie folgt angegeben werden:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Ein Typ mit assemblyqualifikation kann in Klammern eingeschlossen werden, nur, wenn er in einer Liste der Parameter angezeigt wird. Die Regeln für die Suche von Assemblys für qualifizierte und unvollständigen Typen in Typparameterlisten sind identisch mit den Regeln für den qualifizierten und nicht qualifizierte nicht generische Typen.  
  
 Nullable-Typen sind ein besonderer Fall von generischen Typen. Beispielsweise eine auf NULL festlegbare <xref:System.Int32> wird dargestellt, durch die Zeichenfolge "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  In c#, C++ und Visual Basic können Sie auch auf NULL festlegbare Typen, die mithilfe von Operatoren abrufen. Z. B. die NULL-Werte zulassen <xref:System.Boolean> Typ wird zurückgegeben, indem `typeof(Nullable<bool>)` in c# durch `Nullable<Boolean>::typeid` in C++, und durch `GetType(Nullable(Of Boolean))` in Visual Basic.  
  
 Die folgende Tabelle zeigt die Syntax, mit `GetType` für verschiedene Typen.  
  
|Zum Abrufen|Mit|  
|------------|---------|  
|Ein NULL-Werte zulässt <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Ein nicht verwalteter Zeiger auf `MyType`|`Type.GetType("MyType*")`|  
|Ein nicht verwalteter Zeiger auf einen Zeiger auf `MyType`|`Type.GetType("MyType**")`|  
|Ein verwalteter Zeiger oder Verweis auf `MyType`|`Type.GetType("MyType&")`. Beachten Sie, dass Verweise im Gegensatz zu Zeigern auf eine Ebene beschränkt sind.|  
|Eine übergeordnete Klasse und eine geschachtelte Klasse.|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Ein eindimensionales Array mit einer unteren Grenze von 0|`Type.GetType("MyArray[]")`|  
|Ein eindimensionales Array mit einem Unbekannter unterer Grenze|`Type.GetType("MyArray[*]")`|  
|Ein Array mit n-dimensionalen|Ein Komma (,) innerhalb der Klammern eine insgesamt n-1 Mal. Z. B. `System.Object[,,]` stellt ein dreidimensionales `Object` Array.|  
|Ein zweidimensionales Array von Arrays|`Type.GetType("MyArray[][]")`|  
|Ein rechteckiges zweidimensionales Array mit Unbekannter unterer Grenze|`Type.GetType("MyArray[,]")`|  
|Ein generischer Typ mit einem Typargument|``Type.GetType("MyGenericType`1[MyType]")``|  
|Ein generischer Typ mit zwei Typargumente|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Ein generischer Typ mit zwei Argumenten der Assembly qualifizierten Typnamen|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|Ein mit assemblyqualifikation, generischer Typ mit einem Argument für die Assembly qualifizierten Typnamen|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Ein generischer Typ, dessen Typargument eines generischen Typs mit zwei Argumente des Typs ist.|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.  
  
- oder -  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen. 
- oder -  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.  
  
- oder -  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.  
  
- oder -  
 <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax, beispielsweise "MyType[,*,]".  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und die Assembly wurde mit einer höheren Version kompiliert.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Angeben vollständig gekennzeichneter Typnamen</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">Der Name des abzurufenden Typs. Wenn der <paramref name="typeResolver" />-Parameter bereitgestellt wird, kann der Typname jede Zeichenfolge sein, die vom <paramref name="typeResolver" /> aufgelöst werden kann. Wenn der <paramref name="assemblyResolver" />-Parameter bereitgestellt wird oder wenn die Standardtypauflösung verwendet wird, muss der <paramref name="typeName" /> ein durch die Assembly qualifizierter Name (siehe <see cref="P:System.Type.AssemblyQualifiedName" />) sein, es sei denn, der Typ befindet sich in der gerade ausgeführten Assembly oder in der Datei Mscorlib.dll. In diesem Fall genügt es, den von seinem Namespace qualifizierten Typnamen anzugeben.</param>
        <param name="assemblyResolver">Eine Methode, die die Assembly sucht und zurückgibt, die in <paramref name="typeName" /> angegeben wird. Der Assemblyname wird an den <paramref name="assemblyResolver" /> als ein <see cref="T:System.Reflection.AssemblyName" />-Objekt übergeben. Wenn <paramref name="typeName" /> keinen Namen einer Assembly enthält, wird der <paramref name="assemblyResolver" /> nicht aufgerufen. Wenn der <paramref name="assemblyResolver" /> nicht angegeben wird, wird die Standardassemblyauflösung ausgeführt.  
  
Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern. Andernfalls könnten Berechtigungen für bösartigen Code erweitert werden. Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</param>
        <param name="typeResolver">Eine Methode, die den Typ sucht und zurückgibt, der von <paramref name="typeName" /> von der Assembly angegeben wird, die vom <paramref name="assemblyResolver" /> oder von der Standardassemblyauflösung zurückgegeben wird. Wenn keine Assembly bereitgestellt wird, kann die <paramref name="typeResolver" />-Methode eine Assembly zur Verfügung stellen. Die Methode nimmt auch einen Parameter an, der angibt, ob bei der Suche die Groß- und Kleinschreibung berücksichtigt werden soll; an diesen Parameter wird <see langword="false" /> übergeben.  
  
Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</param>
        <summary>Ruft den Typ mit dem angegebenen Namen ab und stellt optional benutzerdefinierte Methoden bereit, um die Assembly und den Typ aufzulösen.</summary>
        <returns>Der Typ mit dem angegebenen Namen oder <see langword="null" />, wenn der Typ nicht gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendungsszenarien für diese Methode und die Details zu den `assemblyResolver` und `typeResolver` Parameter finden Sie in der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> methodenüberladung.  
  
> [!NOTE]
>  Wenn `typeName` kann nicht gefunden werden, den Aufruf der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> Methodenrückgabe `null`. Es löst keine Ausnahme aus. Um zu steuern, ob eine Ausnahme wird ausgelöst, rufen Sie eine Überladung von der <xref:System.Type.GetType%2A> Methode mit einem `throwOnError` Parameter.  
  
 Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> -methodenüberladung, und geben `false` für die `throwOnError` und `ignoreCase` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.ArgumentException">Ein Fehler tritt auf, wenn <paramref name="typeName" /> in einen Typnamen und einen Assemblynamen zerlegt wird (wenn z. B. der einfache Typname ein Sonderzeichen ohne Escapezeichen enthält).  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</exception>
        <exception cref="T:System.IO.FileLoadException">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.  
  
- oder -  
 <paramref name="typeName" /> enthält einen ungültigen Assemblynamen.  
  
- oder -  
 <paramref name="typeName" /> ist ein gültiger Assemblyname ohne Typnamen.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
- oder -  
Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">Der Name des abzurufenden Typs. Wenn der <paramref name="typeResolver" />-Parameter bereitgestellt wird, kann der Typname jede Zeichenfolge sein, die vom <paramref name="typeResolver" /> aufgelöst werden kann. Wenn der <paramref name="assemblyResolver" />-Parameter bereitgestellt wird oder wenn die Standardtypauflösung verwendet wird, muss der <paramref name="typeName" /> ein durch die Assembly qualifizierter Name (siehe <see cref="P:System.Type.AssemblyQualifiedName" />) sein, es sei denn, der Typ befindet sich in der gerade ausgeführten Assembly oder in der Datei Mscorlib.dll. In diesem Fall genügt es, den von seinem Namespace qualifizierten Typnamen anzugeben.</param>
        <param name="assemblyResolver">Eine Methode, die die Assembly sucht und zurückgibt, die in <paramref name="typeName" /> angegeben wird. Der Assemblyname wird an den <paramref name="assemblyResolver" /> als ein <see cref="T:System.Reflection.AssemblyName" />-Objekt übergeben. Wenn <paramref name="typeName" /> keinen Namen einer Assembly enthält, wird der <paramref name="assemblyResolver" /> nicht aufgerufen. Wenn der <paramref name="assemblyResolver" /> nicht angegeben wird, wird die Standardassemblyauflösung ausgeführt.  
  
Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern. Andernfalls könnten Berechtigungen für bösartigen Code erweitert werden. Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</param>
        <param name="typeResolver">Eine Methode, die den Typ sucht und zurückgibt, der von <paramref name="typeName" /> von der Assembly angegeben wird, die vom <paramref name="assemblyResolver" /> oder von der Standardassemblyauflösung zurückgegeben wird. Wenn keine Assembly bereitgestellt wird, kann die Methode eine Assembly zur Verfügung stellen. Die Methode nimmt auch einen Parameter an, der angibt, ob bei der Suche die Groß- und Kleinschreibung berücksichtigt werden soll; an diesen Parameter wird <see langword="false" /> übergeben.  
  
Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</param>
        <param name="throwOnError"><see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" />, damit <see langword="null" /> zurückgegeben wird. Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle. Informationen finden Sie im Abschnitt für Ausnahmen.</param>
        <summary>Ruft den Typ mit dem angegebenen Namen ab. Dabei wird angegeben, ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird, und optional werden benutzerdefinierte Methoden bereitgestellt, um die Assembly und den Typ aufzulösen.</summary>
        <returns>Der Typ mit dem angegebenen Namen. Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird. In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst. Informationen finden Sie im Abschnitt für Ausnahmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendungsszenarien für diese Methode und die Details zu den `assemblyResolver` und `typeResolver` Parameter finden Sie in der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> methodenüberladung.  
  
 Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> -methodenüberladung, und geben `false` für die `ignoreCase` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.  
  
- oder -  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen. 
- oder -  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.  
  
- oder -  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.  
  
- oder -  
 <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</exception>
        <exception cref="T:System.ArgumentException">Ein Fehler tritt auf, wenn <paramref name="typeName" /> in einen Typnamen und einen Assemblynamen zerlegt wird (wenn z. B. der einfache Typname ein Sonderzeichen ohne Escapezeichen enthält).  
  
- oder -  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax (z. B. "MyType[,*,]").  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.  
  
- oder -  
 <paramref name="typeName" /> enthält einen ungültigen Assemblynamen.  
  
- oder -  
 <paramref name="typeName" /> ist ein gültiger Assemblyname ohne Typnamen.</exception>
        <exception cref="T:System.IO.FileLoadException">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
- oder -  
Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">Der Name des abzurufenden Typs. Wenn der <paramref name="typeResolver" />-Parameter bereitgestellt wird, kann der Typname jede Zeichenfolge sein, die vom <paramref name="typeResolver" /> aufgelöst werden kann. Wenn der <paramref name="assemblyResolver" />-Parameter bereitgestellt wird oder wenn die Standardtypauflösung verwendet wird, muss der <paramref name="typeName" /> ein durch die Assembly qualifizierter Name (siehe <see cref="P:System.Type.AssemblyQualifiedName" />) sein, es sei denn, der Typ befindet sich in der gerade ausgeführten Assembly oder in der Datei Mscorlib.dll. In diesem Fall genügt es, den von seinem Namespace qualifizierten Typnamen anzugeben.</param>
        <param name="assemblyResolver">Eine Methode, die die Assembly sucht und zurückgibt, die in <paramref name="typeName" /> angegeben wird. Der Assemblyname wird an den <paramref name="assemblyResolver" /> als ein <see cref="T:System.Reflection.AssemblyName" />-Objekt übergeben. Wenn <paramref name="typeName" /> keinen Namen einer Assembly enthält, wird der <paramref name="assemblyResolver" /> nicht aufgerufen. Wenn der <paramref name="assemblyResolver" /> nicht angegeben wird, wird die Standardassemblyauflösung ausgeführt.  
  
Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern. Andernfalls könnten Berechtigungen für bösartigen Code erweitert werden. Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</param>
        <param name="typeResolver">Eine Methode, die den Typ sucht und zurückgibt, der von <paramref name="typeName" /> von der Assembly angegeben wird, die vom <paramref name="assemblyResolver" /> oder von der Standardassemblyauflösung zurückgegeben wird. Wenn keine Assembly bereitgestellt wird, kann die Methode eine Assembly zur Verfügung stellen. Die Methode nimmt auch einen Parameter an, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll; an diesen Parameter wird der Wert von <paramref name="ignoreCase" /> übergeben.  
  
Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</param>
        <param name="throwOnError"><see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" />, damit <see langword="null" /> zurückgegeben wird. Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle. Informationen finden Sie im Abschnitt für Ausnahmen.</param>
        <param name="ignoreCase"><see langword="true" />, um ohne Beachtung der Groß-/Kleinschreibung nach <paramref name="typeName" /> zu suchen, <see langword="false" />, um mit Beachtung der Groß-/Kleinschreibung nach <paramref name="typeName" /> zu suchen.</param>
        <summary>Ruft den Typ mit dem angegebenen Namen ab. Dabei wird angegeben, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird, und optional werden benutzerdefinierte Methoden bereitgestellt, um die Assembly und den Typ aufzulösen.</summary>
        <returns>Der Typ mit dem angegebenen Namen. Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird. In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst. Informationen finden Sie im Abschnitt für Ausnahmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese methodenüberladung und ihre zugehörigen Überladungen (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> und <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>), ersetzen die standardmäßige Implementierung von der <xref:System.Type.GetType%2A> -Methode mit flexibler Implementierungen. Durch Ihre eigenen Methoden, die aufgelöst werden, geben Sie die Namen und die Namen der Assemblys, die sie enthalten, können Sie Folgendes tun:  
  
-   Steuern Sie, welche Version einer Assembly aus ein Typs geladen wird.  
  
-   Geben Sie eine andere Stelle, für einen Typnamen zu suchen, das nicht der Namen einer Assembly enthalten ist.  
  
-   Laden von Assemblys mit partiellen Assemblynamen.  
  
-   Zurückgeben von Unterklassen von <xref:System.Type?displayProperty=nameWithType> , die nicht von der common Language Runtime (CLR) erstellt werden.  
  
 Beispielsweise kann in versionstolerante Serialisierung dieser Methode Sie mithilfe eines unvollständigen Namens nach einer "best fit"-Assembly zu suchen. Andere Überladungen der <xref:System.Type.GetType%2A> Methode erforderlich sind, eine Assembly qualifizierter Typname, der die Versionsnummer enthält.  
  
 Alternative Implementierungen des Typsystems möglicherweise Unterklassen der zurückzugebenden <xref:System.Type?displayProperty=nameWithType> , die nicht von der CLR erstellt; alle Typen, die durch andere Überladungen zurückgegeben werden die <xref:System.Type.GetType%2A> Methode werden die Runtime-Typen.  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>Hinweise zur Verwendung  
 Analysieren der Überladung dieser Methode und ihre zugehörigen Überladungen `typeName` in den Namen eines Typs und den Namen einer Assembly, und klicken Sie dann die Namen auflösen. Auflösung des Namens der Assembly tritt auf, vor der Auflösung des Typnamens, da Sie ein Namen im Kontext einer Assembly aufgelöst werden muss.  
  
> [!NOTE]
>  Wenn Sie mit dem Konzept der Assembly qualifizierten Typnamen nicht vertraut sind, finden Sie unter den <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft.  
  
 Wenn `typeName` ist kein Name mit assemblyqualifikation, Assembly-Auflösung wird übersprungen. Nicht qualifizierte Typennamen im Kontext von "mscorlib.dll" oder der aktuell ausgeführten Assembly aufgelöst werden können, oder optional können Sie angeben, eine Assembly in den `typeResolver` Parameter. Die Auswirkungen der ein- oder den Assemblynamen auslassen, für verschiedene Arten der namensauflösung in als Tabelle angezeigt, die [gemischten namensauflösung](#mixed_name_resolution) Abschnitt.  
  
 Hinweise zur allgemeinen Verwendung:  
  
-   Übergeben Sie keine Methoden zum `assemblyResolver` oder `typeResolver` , wenn sie von unbekannten oder nicht vertrauenswürdigen Aufrufern stammen. Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.  
  
    > [!CAUTION]
    >  Mit Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern kann Erhöhung von Berechtigungen für bösartigen Code führen.  
  
-   Wenn Sie weglassen der `assemblyResolver` und/oder `typeResolver` Parameter wird der Wert des der `throwOnError` Parameter übergeben wird, um die Methoden, die standardauflösung ausführen.  
  
-   Wenn `throwOnError` ist `true`, löst diese Methode eine <xref:System.TypeLoadException> beim `typeResolver` gibt `null`, und ein <xref:System.IO.FileNotFoundException> beim `assemblyResolver` gibt `null`.  
  
-   Diese Methode fängt keine Ausnahmen von `assemblyResolver` und `typeResolver`. Sie sind verantwortlich für alle Ausnahmen, die von den Resolvermethoden ausgelöst werden.  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>Auflösen von Assemblys  
 Die `assemblyResolver` -Methode empfängt ein <xref:System.Reflection.AssemblyName> -Objekt, das erstellt wird, durch Analysieren der Zeichenfolge-Assemblyname, der Bestandteil `typeName`. Wenn `typeName` enthält nicht den Namen einer Assembly `assemblyResolver` wird nicht aufgerufen und `null` übergeben wird, um `typeResolver`.  
  
 Wenn `assemblyResolver` ist nicht angegeben wird, Überprüfung wird verwendet, um die Assembly zu suchen. Wenn `assemblyResolver` bereitgestellt wird, wird die <xref:System.Type.GetType%2A> Methode führt keine Standardsuche; in diesem Fall müssen Sie sicherstellen, dass Ihre `assemblyResolver` verarbeiten alle Assemblys, die Sie an sie übergeben werden kann.  
  
 Die `assemblyResolver` Methode zurückgeben soll `null` , wenn die Assembly nicht aufgelöst werden kann. Wenn `assemblyResolver` gibt `null`, `typeResolver` nicht aufgerufen wird und keine weitere Verarbeitung erfolgt; darüber hinaus Wenn `throwOnError` ist `true`, <xref:System.IO.FileNotFoundException> ausgelöst.  
  
 Wenn die <xref:System.Reflection.AssemblyName> übergebene `assemblyResolver` ist eine partielle Name, eine oder mehrere Teile sind `null`. Wenn keine Version, beispielsweise die <xref:System.Reflection.AssemblyName.Version%2A> Eigenschaft `null`. Wenn die <xref:System.Reflection.AssemblyName.Version%2A> -Eigenschaft, die <xref:System.Reflection.AssemblyName.CultureInfo%2A> -Eigenschaft, und die <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> Methode geben `null`, und klicken Sie dann nur der einfache Namen der Assembly angegeben wurde. Die `assemblyResolver` Methode verwenden kann, oder ignorieren Sie alle Teile des Namens der Assembly.  
  
 Die Auswirkungen der Optionen für die namensauflösung von anderen Assembly werden angezeigt, wie eine Tabelle in der [gemischten namensauflösung](#mixed_name_resolution) Abschnitt für einfache und die Assembly qualifizierten Typnamen.  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>Auflösen von Typen  
 Wenn `typeName` gibt keinen Namen einer Assembly, `typeResolver` wird immer aufgerufen. Wenn `typeName` gibt den Namen einer Assembly `typeResolver` wird nur aufgerufen, wenn der Name der Assembly erfolgreich aufgelöst wird. Wenn `assemblyResolver` oder Standardassembly gibt `null`, `typeResolver` wird nicht aufgerufen.  
  
 Die `typeResolver` erhält die Methode drei Argumente:  
  
-   Die Assembly zu suchen oder `null` Wenn `typeName` enthält keinen Namen einer Assembly.  
  
-   Der einfache Name des Typs. Im Falle eines geschachtelten Typs ist ist dies die äußersten enthaltenden Typ. Im Fall von einem generischen Typ ist dies der einfache Name des generischen Typs.  
  
-   Ein boolescher Wert, der `true` Wenn Namen die Groß-/Kleinschreibung ignoriert werden.  
  
 Die Implementierung bestimmt die Möglichkeit, die diese Argumente verwendet werden. Die `typeResolver` Methode zurückgeben soll `null` , wenn er nicht auflösen kann. Wenn `typeResolver` gibt `null` und `throwOnError` ist `true`, diese Überladung der <xref:System.Type.GetType%2A> löst eine <xref:System.TypeLoadException>.  
  
 Die Auswirkungen der Optionen für die namensauflösung von anderen Typs werden angezeigt, wie eine Tabelle in der [gemischten namensauflösung](#mixed_name_resolution) Abschnitt für einfache und die Assembly qualifizierten Typnamen.  
  
#### <a name="resolving-nested-types"></a>Auflösen von geschachtelten Typen  
 Wenn `typeName` ist ein geschachtelter Typ, der nur den Namen des äußersten enthaltenden Typ übergeben wird, um `typeResolver`. Wenn `typeResolver` diesen Typ zurückgibt, die <xref:System.Type.GetNestedType%2A> Methode rekursiv aufgerufen wird, bis der innerste geschachtelte Typ behoben wurde.  
  
#### <a name="resolving-generic-types"></a>Auflösen von generischen Typen  
 Die <xref:System.Type.GetType%2A> rekursiv aufgerufen, um generische Typen aufzulösen: Um den generischen Typ selbst zu beheben und dann seiner Typargumente aufgelöst. Wenn ein Argument vom Typ generisch ist, wird <xref:System.Type.GetType%2A> rekursiv aufgerufen, um seiner Typargumente lösen und so weiter.  
  
 Die Kombination von `assemblyResolver` und `typeResolver` zum Auflösen von allen Ebenen der diese Rekursion in der Lage sein, dass Sie müssen bereitstellen. Nehmen wir beispielsweise an, die Sie angeben, ein `assemblyResolver` , steuert das Laden von `MyAssembly`. Angenommen, Sie möchten den generischen Typ aufgelöst `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic). Sie können den folgenden Namen für den generischen Typ übergeben:  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 Beachten Sie, dass `MyType` ist das Argument nur auf die Assembly qualifizierten Typnamen. Die Namen der <xref:System.Collections.Generic.Dictionary%602> und <xref:System.String> Klassen sind nicht für die Assembly qualifizierten. Ihre `typeResolver` muss entweder eine Assembly können Handle sein oder `null`, da er erhält `null` für <xref:System.Collections.Generic.Dictionary%602> und <xref:System.String>. Es kann für diesen Fall behandeln, indem Sie eine Überladung aufrufen der <xref:System.Type.GetType%2A> -Methode, die eine Zeichenfolge akzeptiert, da beide mit dem nicht qualifizierten Typnamen in "mscorlib.dll" sind:  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 Die `assemblyResolver` Methode wird für den Wörterbuchtyp und den String-Datentyp nicht aufgerufen, da diese Namen nicht mit assemblyqualifikation sind.  
  
 Nehmen wir nun an, die anstelle von `System.String`, ist der erste generische Argumenttyp `YourType`, von `YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 Da diese Assembly weder "mscorlib.dll" als auch der aktuell ausgeführten Assembly ist, können Sie nicht auflösen `YourType` ohne einen Namen mit assemblyqualifikation. Da Ihre `assemblyResolve` werden rekursiv aufgerufen werden, es muss in diesem Fall können. Anstatt `null` für andere Assemblys als `MyAssembly`, führt es jetzt Laden einer Assembly, die mit dem angegebenen <xref:System.Reflection.AssemblyName> Objekt.  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 Zurück zum [Hinweise zur Verwendung](#usage_notes).  
  
#### <a name="resolving-type-names-with-special-characters"></a>Auflösen von Namen mit Sonderzeichen  
 Bestimmte Zeichen haben eine besondere Bedeutung in der Assembly qualifizierten Namen. Wenn ein einfacher Typname diese Zeichen enthält, führen die Zeichen Analysefehler auf, wenn es sich bei der einfache Namen einer Assembly qualifizierten Namen gehört. Um die Analysefehler zu vermeiden, Sie müssen mit Escapezeichen versehen die Sonderzeichen mit einem umgekehrten Schrägstrich, bevor Sie die Assembly qualifizierten Namen zu übergeben, können die <xref:System.Type.GetType%2A> Methode. Wenn ein Typ mit dem Namen wird z. B. `Strange]Type`, das Escape-Zeichen muss vorab die eckige Klammer wie folgt hinzugefügt werden: `Strange\]Type`.  
  
> [!NOTE]
>  Namen mit solchen Sonderzeichen können nicht in Visual Basic oder c# erstellt werden, aber Sie können mithilfe von Microsoft intermediate Language (MSIL) oder durch Ausgeben von dynamischen Assemblys erstellt werden.  
  
 Die folgende Tabelle zeigt die Sonderzeichen für Typnamen.  
  
|Zeichen|Bedeutung|  
|---------------|-------------|  
|`,` (Komma)|Trennzeichen für die Assembly qualifizierten Namen.|  
|`[]` (eckige Klammern)|Gibt Sie als Suffixpaar einen Arraytyp an; als Trennzeichenpaar einschließt generischen Argument-Listen und die Assembly qualifizierten Namen.|  
|`&` (kaufmännisches und-Zeichen)|Gibt an, dass ein Typ ein Verweistyp ist, als Suffix.|  
|`*` (Sternchen)|Gibt an, dass ein Typ ein Zeigertyp ist, als Suffix.|  
|`+` (plus)|Trennzeichen für geschachtelte Typen.|  
|`\` (umgekehrter Schrägstrich)|Escape-Zeichen.|  
  
 Eigenschaften, z. B. <xref:System.Type.AssemblyQualifiedName%2A> Rückgabe Zeichenfolgen korrekt in Escapezeichen eingeschlossen. Müssen Sie ordnungsgemäß mit Escapezeichen versehene Zeichenfolgen zum Übergeben der <xref:System.Type.GetType%2A> Methode. Im Gegenzug die <xref:System.Type.GetType%2A> Methode übergibt ordnungsgemäß mit Escapezeichen versehene Namen `typeResolver` und die Standardmethoden für Typ Auflösung. Wenn Sie einen Namen, einem Namen ohne Escapezeichen in Vergleichen `typeResolver`, müssen Sie die Escape-Zeichen entfernen.  
  
 Zurück zum [Hinweise zur Verwendung](#usage_notes).  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>Gemischte namensauflösung  
 Die folgende Tabelle enthält die Interaktionen zwischen `assemblyResolver`, `typeResolver`, und die standardnamensauflösung für alle Kombinationen der Typname und Assemblyname in `typeName`:  
  
|Inhalt des Typnamens|Assembly-Resolver-Methode|Typ-Resolver-Methode|Ergebnis|  
|---------------------------|------------------------------|--------------------------|------------|  
|Typ ","-assembly|NULL|NULL|Entspricht dem Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> -methodenüberladung.|  
|Typ ","-assembly|bereitgestellt|NULL|`assemblyResolver` Gibt die Assembly zurück oder `null` Falls die Assembly aufgelöst werden kann. Wenn die Assembly aufgelöst wird, wird die <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Überladung wird verwendet, um den Typ aus der Assembly zu laden; andernfalls ist es nicht versucht, den Typ aufzulösen.|  
|Typ ","-assembly|NULL|bereitgestellt|Konvertieren den Namen der Assembly entspricht einer <xref:System.Reflection.AssemblyName> -Objekt ab, und rufen die <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> -methodenüberladung, um die Assembly zu erhalten. Wenn die Assembly aufgelöst wird, erfolgt eine Übergabe an `typeResolver`ist, andernfalls `typeResolver` wird nicht aufgerufen, und es gibt keinen weiteren Versuch, den Typ aufzulösen.|  
|Typ ","-assembly|bereitgestellt|bereitgestellt|`assemblyResolver` Gibt die Assembly zurück oder `null` Falls die Assembly aufgelöst werden kann. Wenn die Assembly aufgelöst wird, erfolgt eine Übergabe an `typeResolver`ist, andernfalls `typeResolver` wird nicht aufgerufen, und es gibt keinen weiteren Versuch, den Typ aufzulösen.|  
|Typ|NULL, der bereitgestellt wird|NULL|Entspricht dem Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> -methodenüberladung. Da der Name der Assembly nicht angegeben ist, werden nur "mscorlib.dll" und die derzeit ausgeführte Assembly durchsucht. Wenn `assemblyResolver` bereitgestellt wird, werden diese ignoriert wird.|  
|Typ|NULL, der bereitgestellt wird|bereitgestellt|`typeResolver` wird aufgerufen, und `null` für die Assembly übergeben wird. `typeResolver` bieten einen Typ von einer Assembly aus, einschließlich der Assemblys, die sie für den Zweck lädt ab. Wenn `assemblyResolver` bereitgestellt wird, werden diese ignoriert wird.|  
|Assembly|NULL, der bereitgestellt wird|NULL, der bereitgestellt wird|Ein <xref:System.IO.FileLoadException> ausgelöst wird, da der Name der Assembly als handele es sich um eine Assembly qualifizierter Typname analysiert wird. Dies führt zu einem ungültigen Assemblynamen.|  
  
 Zurück zu: [Hinweise zur Verwendung](#usage_notes), [Auflösen von Assemblys](#resolving_assemblies), [Auflösen von Typen](#resolving_types).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.  
  
- oder -  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen. 
- oder -  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.  
  
- oder -  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.  
  
- oder -  
 <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</exception>
        <exception cref="T:System.ArgumentException">Ein Fehler tritt auf, wenn <paramref name="typeName" /> in einen Typnamen und einen Assemblynamen zerlegt wird (wenn z. B. der einfache Typname ein Sonderzeichen ohne Escapezeichen enthält).  
  
- oder -  
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax (z. B. "MyType[,*,]").  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.  
  
- oder -  
 <paramref name="typeName" /> enthält einen ungültigen Assemblynamen.  
  
- oder -  
 <paramref name="typeName" /> ist ein gültiger Assemblyname ohne Typnamen.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
- oder -  
Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="args">Ein Array von Objekten, deren Typen bestimmt werden sollen.</param>
        <summary>Ruft die Typen der Objekte im angegebenen Array ab.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der entsprechenden Elemente in <paramref name="args" /> darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Type.GetTypeArray%2A> Methode, um die Liste der Typen der Elemente eines Arrays.  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> ist <see langword="null" />.  
  
- oder -  
Mindestens eines der Elemente in <paramref name="args" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Die Klasseninitialisierer werden aufgerufen, und mindestens einer löst eine Ausnahme aus.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, dessen zugrunde liegender Typcode abgerufen werden soll.</param>
        <summary>Ruft den zugrunde liegenden Typcode des angegebenen <see cref="T:System.Type" /> ab.</summary>
        <returns>Der Code des zugrunde liegenden Typs oder <see cref="F:System.TypeCode.Empty" />, wenn <paramref name="type" /> <see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Erben von <xref:System.Type>, Sie können das Verhalten dieser Methode ändern, durch Überschreiben der <xref:System.Type.GetTypeCodeImpl%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.TypeCode> -Enumeration können verwendet werden. In einen Entscheidungsblock in die `WriteObjectInfo` -Methode, die <xref:System.TypeCode> von einer <xref:System.Object> Parameter überprüft und eine entsprechende Meldung in die Konsole geschrieben wird.  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den zugrunde liegenden Typcode dieser <see cref="T:System.Type" />-Instanz zurück.</summary>
        <returns>Der Typcode des zugrunde liegenden Typs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode stellt die Implementierung für die `static` (in c#) oder `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> Methode. Beim Erben von <xref:System.Type>, Sie können angeben, überschreiben diese Methode, um eine eigene Implementierung bereitstellen <xref:System.Type.GetTypeCode%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Typ ab, dem die angegebene Klassen-ID (CLSID) zugeordnet ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">Die CLSID des abzurufenden Typs.</param>
        <summary>Ruft den Typ ab, dem die angegebene Klassen-ID (CLSID) zugeordnet ist.</summary>
        <returns><see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetTypeFromCLSID%2A> Methode unterstützt spät gebundener Zugriff auf nicht verwaltete COM-Objekte aus .NET Framework-apps, wenn Sie wissen, dass der Klassenbezeichner (CLSID) des COM-Objekts.  Die Klassen-ID für COM-Klassen ist in den Schlüssel HKEY_CLASSES_ROOT\CLSID der Registrierung definiert. Sie können den Wert der Abrufen der <xref:System.Type.IsCOMObject%2A> Eigenschaft, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt.  
  
> [!TIP]
>  Rufen Sie die <xref:System.Type.GetTypeFromProgID%2A> -Methode für den Zugriff mit spätem Binden für COM-Objekte, deren Programmbezeichner (ProgID), der für die Sie kennen.  
  
 Instanziieren ein nicht verwaltetes COM-Objekt aus der CLSID ist ein zweistufiger Prozess:  
  
1.  Abrufen einer <xref:System.Type> Objekt, das darstellt der`__ComObject` , entspricht die CLSID durch Aufrufen der <xref:System.Type.GetTypeFromCLSID%2A> Methode.  
  
2.  Rufen Sie die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> Methode, um das COM-Objekt zu instanziieren.  
  
 Siehe das Beispiel zur Veranschaulichung.  
  
 Die <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> Überladung ignoriert alle Ausnahmen, die auftreten können, bei der Instanziierung einer <xref:System.Type> Objekt auf Grundlage der `clsid` Argument. Beachten Sie, die keine Ausnahme ausgelöst wird, wenn `clsid` wurde in der Registrierung nicht gefunden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die CLSID des Microsoft Word [Anwendungsobjekt](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) einen COM-Typ abrufen, die die Microsoft Word-Anwendung darstellt. Dann instanziiert den Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> -Methode und schließt ihn durch Aufrufen der [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) Methode.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Diese Methode ist für die Verwendung vorgesehen, bei der Arbeit mit COM-Objekte nicht mit .NET Framework-Objekten. Alle verwalteten Objekte, einschließlich derjenigen, die für COM sichtbar sind (d. h. ihre <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> -Attribut ist <see langword="true" />) haben Sie eine GUID, die von zurückgegeben wird das <see cref="P:System.Type.GUID" /> Eigenschaft. Obwohl die Methode zurückgibt, eine <see cref="T:System.Type" /> -Objekt, auf die GUID entspricht, für .NET Framework-Objekten, Sie können nicht verwenden, die <see cref="T:System.Type" /> Objekt zum Erstellen einer Typinstanz durch Aufrufen der <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode, wie im folgenden Beispiel gezeigt.  
  
[! Code-Csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! Code – Vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Stattdessen die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> sollte nur verwendet werden, zum Abrufen der GUID der nicht verwaltete COM-Objekte und die resultierende <see cref="T:System.Type" /> -Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode muss ein nicht verwaltete COM-Objekt darstellen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">Die CLSID des abzurufenden Typs.</param>
        <param name="throwOnError"><see langword="true" />, um mögliche Ausnahmen auszulösen.  
  
- oder -  
 <see langword="false" />, um Ausnahmen zu ignorieren.</param>
        <summary>Ruft den Typ ab, dem die angegebene Klassen-ID (CLSID) zugeordnet ist. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</summary>
        <returns><see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetTypeFromCLSID%2A> Methode unterstützt spät gebundener Zugriff auf nicht verwaltete COM-Objekte aus .NET Framework-apps, wenn Sie wissen, dass der Klassenbezeichner (CLSID) des COM-Objekts.  Die Klassen-ID für COM-Klassen ist in den Schlüssel HKEY_CLASSES_ROOT\CLSID der Registrierung definiert. Sie können den Wert der Abrufen der <xref:System.Type.IsCOMObject%2A> Eigenschaft, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt.  
  
> [!TIP]
>  Rufen Sie die <xref:System.Type.GetTypeFromProgID%2A> -Methode für den Zugriff mit spätem Binden für COM-Objekte, deren Programmbezeichner (ProgID), der für die Sie kennen.  
  
 Instanziieren ein nicht verwaltetes COM-Objekt aus der CLSID ist ein zweistufiger Prozess:  
  
1.  Abrufen einer <xref:System.Type> Objekt, das darstellt der `__ComObject` , entspricht die CLSID durch Aufrufen der <xref:System.Type.GetTypeFromCLSID%2A> Methode.  
  
2.  Rufen Sie die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> Methode, um das COM-Objekt zu instanziieren.  
  
 Siehe das Beispiel zur Veranschaulichung.  
  
 Ausnahmen, z. B. <xref:System.OutOfMemoryException> wird ausgelöst, wenn die Angabe `true` für `throwOnError`, jedoch wird nicht für nicht registrierte CLSIDs fehlerhaft sein.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die CLSID des Microsoft Word [Anwendungsobjekt](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) einen COM-Typ abrufen, die die Microsoft Word-Anwendung darstellt. Dann instanziiert den Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> -Methode und schließt ihn durch Aufrufen der [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) Methode. Wenn beim Laden des Typs ein Fehler auftritt, wird eine Ausnahme ausgelöst.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Diese Methode ist für die Verwendung vorgesehen, bei der Arbeit mit COM-Objekte nicht mit .NET Framework-Objekten. Alle verwalteten Objekte, einschließlich derjenigen, die für COM sichtbar sind (d. h. ihre <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> -Attribut ist <see langword="true" />) haben Sie eine GUID, die von zurückgegeben wird das <see cref="P:System.Type.GUID" /> Eigenschaft. Obwohl die Methode zurückgibt, eine <see cref="T:System.Type" /> -Objekt, auf die GUID entspricht, für .NET Framework-Objekten, Sie können nicht verwenden, die <see cref="T:System.Type" /> Objekt zum Erstellen einer Typinstanz durch Aufrufen der <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode, wie im folgenden Beispiel gezeigt.  
  
[! Code-Csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! Code – Vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Stattdessen die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> sollte nur verwendet werden, zum Abrufen der GUID der nicht verwaltete COM-Objekte und die resultierende <see cref="T:System.Type" /> -Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode muss ein nicht verwaltete COM-Objekt darstellen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">Die CLSID des abzurufenden Typs.</param>
        <param name="server">Der Server, von dem der Typ geladen werden soll. Wenn der Servername <see langword="null" /> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</param>
        <summary>Ruft den Typ, dem die angegebene Klassen-ID (CLSID) zugeordnet ist, vom angegebenen Server ab.</summary>
        <returns><see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetTypeFromCLSID%2A> Methode unterstützt spät gebundener Zugriff auf nicht verwaltete COM-Objekte aus .NET Framework-apps, wenn Sie wissen, dass der Klassenbezeichner (CLSID) des COM-Objekts.  Die Klassen-ID für COM-Klassen ist in den Schlüssel HKEY_CLASSES_ROOT\CLSID der Registrierung definiert. Sie können den Wert der Abrufen der <xref:System.Type.IsCOMObject%2A> Eigenschaft, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt.  
  
> [!TIP]
>  Rufen Sie die <xref:System.Type.GetTypeFromProgID%2A> -Methode für den Zugriff mit spätem Binden für COM-Objekte, deren Programmbezeichner (ProgID), der für die Sie kennen.  
  
 Instanziieren ein nicht verwaltetes COM-Objekt aus der CLSID ist ein zweistufiger Prozess:  
  
1.  Abrufen einer <xref:System.Type> Objekt, das darstellt der `__ComObject` , entspricht die CLSID durch Aufrufen der <xref:System.Type.GetTypeFromCLSID%2A> Methode.  
  
2.  Rufen Sie die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> Methode, um das COM-Objekt zu instanziieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die CLSID des Microsoft Word [Anwendungsobjekt](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) einen COM-Typ abrufen, die die Microsoft Word-Anwendung von einem pullserver namens computer17.central.contoso.com darstellt. Dann instanziiert den Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> -Methode und schließt ihn durch Aufrufen der [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) Methode.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Diese Methode ist für die Verwendung vorgesehen, bei der Arbeit mit COM-Objekte nicht mit .NET Framework-Objekten. Alle verwalteten Objekte, einschließlich derjenigen, die für COM sichtbar sind (d. h. ihre <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> -Attribut ist <see langword="true" />) haben Sie eine GUID, die von zurückgegeben wird das <see cref="P:System.Type.GUID" /> Eigenschaft. Obwohl die Methode zurückgibt, eine <see cref="T:System.Type" /> -Objekt, auf die GUID entspricht, für .NET Framework-Objekten, Sie können nicht verwenden, die <see cref="T:System.Type" /> Objekt zum Erstellen einer Typinstanz durch Aufrufen der <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode, wie im folgenden Beispiel gezeigt.  
  
[! Code-Csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! Code – Vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Stattdessen die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> sollte nur verwendet werden, zum Abrufen der GUID der nicht verwaltete COM-Objekte und die resultierende <see cref="T:System.Type" /> -Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode muss ein nicht verwaltete COM-Objekt darstellen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">Die CLSID des abzurufenden Typs.</param>
        <param name="server">Der Server, von dem der Typ geladen werden soll. Wenn der Servername <see langword="null" /> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</param>
        <param name="throwOnError"><see langword="true" />, um mögliche Ausnahmen auszulösen.  
  
- oder -  
 <see langword="false" />, um Ausnahmen zu ignorieren.</param>
        <summary>Ruft den Typ, dem die angegebene Klassen-ID (CLSID) zugeordnet ist, vom angegebenen Server ab. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</summary>
        <returns><see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetTypeFromCLSID%2A> Methode unterstützt spät gebundener Zugriff auf nicht verwaltete COM-Objekte aus .NET Framework-apps, wenn Sie wissen, dass der Klassenbezeichner (CLSID) des COM-Objekts.  Die Klassen-ID für COM-Klassen ist in den Schlüssel HKEY_CLASSES_ROOT\CLSID der Registrierung definiert. Sie können den Wert der Abrufen der <xref:System.Type.IsCOMObject%2A> Eigenschaft, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt.  
  
> [!TIP]
>  Rufen Sie die <xref:System.Type.GetTypeFromProgID%2A> -Methode für den Zugriff mit spätem Binden für COM-Objekte, deren Programmbezeichner (ProgID), der für die Sie kennen.  
  
 Instanziieren ein nicht verwaltetes COM-Objekt aus der CLSID ist ein zweistufiger Prozess:  
  
1.  Abrufen einer <xref:System.Type> Objekt, das darstellt der `__ComObject` , entspricht die CLSID durch Aufrufen der <xref:System.Type.GetTypeFromCLSID%2A> Methode.  
  
2.  Rufen Sie die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> Methode, um das COM-Objekt zu instanziieren.  
  
 Ausnahmen, z. B. <xref:System.OutOfMemoryException> wird ausgelöst, wenn die Angabe `true` für `throwOnError`, jedoch wird nicht für nicht registrierte CLSIDs fehlerhaft sein.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die CLSID des Microsoft Word [Anwendungsobjekt](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) einen COM-Typ abrufen, die die Microsoft Word-Anwendung von einem pullserver namens computer17.central.contoso.com darstellt. Dann instanziiert den Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> -Methode und schließt ihn durch Aufrufen der [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) Methode. Wenn beim Laden des Typs ein Fehler auftritt, wird eine Ausnahme ausgelöst.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Diese Methode ist für die Verwendung vorgesehen, bei der Arbeit mit COM-Objekte nicht mit .NET Framework-Objekten. Alle verwalteten Objekte, einschließlich derjenigen, die für COM sichtbar sind (d. h. ihre <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> -Attribut ist <see langword="true" />) haben Sie eine GUID, die von zurückgegeben wird das <see cref="P:System.Type.GUID" /> Eigenschaft. Obwohl die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> Methode gibt eine <see cref="T:System.Type" /> Objekt, das die GUID für einen bestimmten verwalteten Objekt entspricht, kann nicht verwendet <see cref="T:System.Type" /> Objekt zum Erstellen einer Typinstanz durch Aufrufen der <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode, wie im folgenden Beispiel zeigt.  
  
[! Code-Csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! Code – Vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Stattdessen die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> sollte nur verwendet werden, zum Abrufen der GUID der nicht verwaltete COM-Objekte und die resultierende <see cref="T:System.Type" /> -Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode muss ein nicht verwaltete COM-Objekt darstellen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Das Objekt, das auf den Typ verweist.</param>
        <summary>Ruft den Typ ab, auf den das angegebene Typhandle verweist.</summary>
        <returns>Der Typ, auf den das angegebene <see cref="T:System.RuntimeTypeHandle" /> verweist, oder <see langword="null" />, wenn die <see cref="P:System.RuntimeTypeHandle.Value" />-Eigenschaft von <paramref name="handle" /> den Wert <see langword="null" /> hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Handles gelten nur in der Anwendungsdomäne, in der sie abgerufen wurden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Type.GetTypeFromHandle%2A> -Methode zum Abrufen einer <xref:System.Type> -Objekt aus einer <xref:System.RuntimeTypeHandle> gebotenen die <xref:System.Type.GetTypeHandle%2A> Methode.  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Typ ab, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">Die ProgID des abzurufenden Typs.</param>
        <summary>Ruft den Typ ab, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist. Wenn beim Laden des <see cref="T:System.Type" /> ein Fehler auftritt, wird NULL zurückgegeben.</summary>
        <returns>Der Typ, dem die angegebene ProgID zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird bereitgestellt für COM-Unterstützung. Versionsabhängige Programm-IDs werden nicht in Microsoft .NET Framework verwendet, da diese durch das Konzept des Namespace ersetzt wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">Die ProgID des abzurufenden Typs.</param>
        <param name="throwOnError"><see langword="true" />, um mögliche Ausnahmen auszulösen.  
  
- oder -  
 <see langword="false" />, um Ausnahmen zu ignorieren.</param>
        <summary>Ruft den Typ ab, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</summary>
        <returns>Der Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird bereitgestellt für COM-Unterstützung. Programm-IDs werden nicht in Microsoft .NET Framework verwendet, da diese durch das Konzept des Namespace ersetzt wurden.  
  
   
  
## Examples  
 Im folgende Beispiel ruft einen Typ ab, durch Übergeben einer ProgID, die angibt, ob eine Ausnahme ausgelöst, wenn die Programm-ID ungültig ist. Das Beispiel zeigt anschließend die ClassID im Zusammenhang mit der Programm-ID sowie alle entsprechenden Ausnahmemeldung.  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Die angegebene ProgID ist nicht registriert.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">Die ProgID des abzurufenden Typs.</param>
        <param name="server">Der Server, von dem der Typ geladen werden soll. Wenn der Servername <see langword="null" /> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</param>
        <summary>Ruft den Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, vom angegebenen Server ab. Wenn bei Laden des Typs ein Fehler auftritt, wird NULL zurückgegeben.</summary>
        <returns>Der Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird bereitgestellt für COM-Unterstützung. Programm-IDs werden nicht in Microsoft .NET Framework verwendet, da diese durch das Konzept des Namespace ersetzt wurden.  
  
   
  
## Examples  
 Im folgende Beispiel ruft einen Typ ab, durch die Übergabe einer ProgID und die Server-Namens. Klicken Sie dann die ClassID angezeigt, die ProgID, oder löst eine Ausnahme aus, wenn die ProgID oder den Namen des Servers ungültig ist.  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="prodID" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">Die ProgID des abzurufenden <see cref="T:System.Type" />.</param>
        <param name="server">Der Server, von dem der Typ geladen werden soll. Wenn der Servername <see langword="null" /> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</param>
        <param name="throwOnError"><see langword="true" />, um mögliche Ausnahmen auszulösen.  
  
- oder -  
 <see langword="false" />, um Ausnahmen zu ignorieren.</param>
        <summary>Ruft den Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, vom angegebenen Server ab. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</summary>
        <returns>Der Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird bereitgestellt für COM-Unterstützung. Programm-IDs werden nicht in Microsoft .NET Framework verwendet, da diese durch das Konzept des Namespace ersetzt wurden.  
  
   
  
## Examples  
 Im folgende Beispiel ruft einen Typ ab, durch die Übergabe einer ProgID und die Server-Namens. Das Beispiel zeigt anschließend die ClassID im Zusammenhang mit der Programm-ID angibt, ob eine Ausnahme ausgelöst, wenn die ProgID oder den Namen des Servers ungültig ist.  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Die angegebene progID ist nicht registriert.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, für das das Typhandle abgerufen werden soll.</param>
        <summary>Ruft das Handle für den <see cref="T:System.Type" />-Wert eines angegebenen Objekts ab.</summary>
        <returns>Das Handle für den <see cref="T:System.Type" /> des angegebenen <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Handles gelten nur in der Anwendungsdomäne, in der sie abgerufen wurden.  
  
   
  
## Examples  
 Das folgende Beispiel definiert die Klasse `MyClass1`, ruft eine Instanz davon ab, und ruft das Runtime-Handle des Objekts ab.  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dem <see cref="T:System.Type" /> zugeordnete GUID ab.</summary>
        <value>Die dem <see cref="T:System.Type" /> zugeordnete GUID.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine GUID bezieht sich auf einen Typ mit dem <xref:System.Runtime.InteropServices.GuidAttribute> Attribut.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Klasse `MyClass1` erstellt mit einer öffentlichen Methode, eine `Type` -Objekt entsprechende `MyClass1`, und ruft die <xref:System.Guid> -Struktur unter Verwendung der `GUID` Eigenschaft der `Type` Klasse.  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> einen anderen Typ umfasst oder auf einen anderen Typ verweist, d. h. ob der aktuelle <see cref="T:System.Type" /> ein Array oder ein Zeiger ist oder als Verweis übergeben wird.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> ein Array oder ein Zeiger ist oder als Verweis übergeben wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beispielsweise Type.GetType("Int32[]"). HasElementType gibt `true`, wohingegen Type.GetType("Int32"). HasElementType gibt `false`. HasElementType gibt außerdem zurück `true` für "Int32 *" und "Int32 &".  
  
 Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ oder einen Typparameter in der Definition eines generischen Typs oder generische Methode muss diese Eigenschaft gibt immer `false`.  
  
   
  
## Examples  
 Im folgenden Beispiel zurückgegeben `true` oder `false` abhängig davon, ob das Objekt ein Array, ein Verweistyp oder ein Zeiger ist.  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.HasElementType" />-Eigenschaft und bestimmt, ob der aktuelle <see cref="T:System.Type" /> einen anderen Typ umfasst oder auf einen solchen verweist, d. h. ob der aktuelle <see cref="T:System.Type" /> ein Array oder Zeiger ist oder als Verweis übergeben wird.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Type" /> ein Array oder ein Zeiger ist oder als Verweis übergeben wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beispielsweise Type.GetType("Int32[]"). HasElementTypeImpl gibt `true`, wohingegen Type.GetType("Int32"). HasElementTypeImpl gibt `false`. HasElementTypeImpl gibt außerdem zurück `true` für "Int32 *" und "Int32 &".  
  
   
  
## Examples  
 Das folgende Beispiel definiert die Klasse `MyTypeDelegator`, welche Außerkraftsetzungen der `HasElementTypeImpl` Methode. Die Hauptklasse überprüft die `HasElementType` -Eigenschaft und zeigt das Element eingeben.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen bestimmten Member vom aktuellen <see cref="T:System.Type" /> auf.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des Konstruktors, der Methode, der Eigenschaft oder des Feldmembers enthält, der bzw. die aufgerufen werden soll.  
  
- oder -  
Eine leere Zeichenfolge ("") zum Aufrufen des Standardmembers.  
  
- oder -  
Für <see langword="IDispatch" />-Member eine Zeichenfolge, die die DispID darstellt, z. B. "[DispID=3]".</param>
        <param name="invokeAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird. Der Zugriff kann aus einem der <see langword="BindingFlags" /> wie <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> usw. bestehen. Die Art der Suche muss nicht angegeben werden. Wenn die Art der Suche nicht angegeben ist, werden <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> verwendet.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
- oder -  
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll. Beachten Sie, dass möglicherweise ein <see cref="T:System.Reflection.Binder" />-Objekt explizit definiert werden muss, um erfolgreich Methodenüberladungen mit Variablenargumenten aufrufen zu können.</param>
        <param name="target">Das Objekt, für das der angegebene Member aufgerufen werden soll.</param>
        <param name="args">Ein Array mit den Argumenten, die dem aufzurufenden Member übergeben werden sollen.</param>
        <summary>Ruft den angegebenen Member auf, der den angegebenen Bindungseinschränkungen und der angegebenen Argumentliste entspricht.</summary>
        <returns>Ein Objekt, das den Rückgabewert des aufgerufenen Members darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Sie können keine <xref:System.Type.InvokeMember%2A> , eine generische Methode aufzurufen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, auf welche Member in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Public` öffentliche Mitglieder in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentliche Mitglieder (d. h. private und geschützte Member) in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` auf statische Member der Hierarchie enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die Member deklariert die <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Aufrufflags können verwendet werden, um anzugeben, welche Aktion mit dem Element:  
  
-   `CreateInstance` Um einen Konstruktor aufzurufen. `name` wird ignoriert. Mit anderen Aufrufflags nicht gültig.  
  
-   `InvokeMethod` Um eine Methode, jedoch nicht auf einen Konstruktor oder Typinitialisierer aufzurufen. Ungültig mit `SetField` oder `SetProperty`. Wenn `InvokeMethod` wird angegeben, indem selbst `BindingFlags.Public`, `BindingFlags.Instance`, und `BindingFlags.Static` werden automatisch mit eingeschlossen.  
  
-   `GetField` um den Wert eines Felds zu erhalten. Ungültig mit `SetField`.  
  
-   `SetField` um den Wert eines Felds festzulegen. Ungültig mit `GetField`.  
  
-   `GetProperty` Um eine Eigenschaft zu erhalten. Ungültig mit `SetProperty`.  
  
-   `SetProperty` Um eine Eigenschaft festzulegen. Ungültig mit `GetProperty`.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Eine Methode wird aufgerufen werden, wenn beide der folgenden Bedingungen zutreffen:  
  
-   Die Anzahl von Parametern in der Deklaration der Methode entspricht der Anzahl der Argumente in der `args` Array (es sei denn, die Standardargumente für den Member definiert sind und `BindingFlags.OptionalParamBinding` angegeben ist).  
  
-   Der Typ jedes Arguments kann von der Binder in den Typ des Parameters konvertiert werden.  
  
 Der Binder findet alle übereinstimmenden Methoden. Diese Methoden gefunden werden, basierend auf den Typ der Bindung, die angefordert (<xref:System.Reflection.BindingFlags> Werte `InvokeMethod`, `GetProperty`und so weiter). Der Satz von Methoden wird durch den Namen, Anzahl von Argumenten und einen Satz von Suchabfragen, die in der Binder definiert gefiltert.  
  
 Nachdem die Methode ausgewählt ist, wird es aufgerufen. Barrierefreiheit wird an diesem Punkt überprüft. Die Suche kann gesteuert werden durchsucht, welche Gruppe von Methoden auf Grundlage der Eingabehilfen-Attribut, das der Methode zugeordnet. Die <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Methode der <xref:System.Reflection.Binder> -Klasse ist verantwortlich für das Auswählen der Methode aufgerufen werden. Der Standardbinder wählt die spezifischste Übereinstimmung.  
  
 Zugriffseinschränkungen werden für voll vertrauenswürdigen Code ignoriert. d. h. private Konstruktoren, Methoden, Felder und Eigenschaften und werden können durch aufgerufen <xref:System.Reflection> jedes Mal, wenn der Code vollständig vertrauenswürdig ist.  
  
 Sie können `Type.InvokeMember` für einen bestimmten Wert ein Felds festzulegen, durch Angabe <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Beispielsweise sollten Sie eine öffentliche Feld namens ' F ' für Klasse C und F ist eine `String`, können Sie Code wie z.B.:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 Wenn F# ist eine `String[]`, können Sie Code wie z.B.:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 Das ist das Feld "F" für dieses neue Array initialisiert werden. Sie können auch `Type.InvokeMember` auf eine Position in einem Array festlegen, indem der Index des Werts, und klicken Sie dann den nächsten Wert mit Code wie den folgenden:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 Dies ändert die Zeichenfolge "Z" in das Array, das F in der Zeichenfolge "b" enthält.  
  
 Beim Aufruf einer `IDispatch` Member, Sie können angeben, die DispID statt den Namen des Members, verwenden das Format der Zeichenfolge "[DispID = ##]". Z. B. wenn die DispID MyComMethod 3 ist, können Sie angeben die Zeichenfolge "[DispID = 3]" anstelle von "MyComMethod". Das Aufrufen eines Members durch DispID ist schneller als die Suche nach dem Namen des Members. In eine komplexe aggregationsszenarien ist die DispID manchmal die einzige Möglichkeit, den gewünschten Member aufgerufen werden soll.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, auf nicht öffentliche Member zuzugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> kennzeichnen und Menge oder eine Teilmenge der Berechtigungssatz die nicht öffentlichen Member an des Aufrufers des beschränkt ist zu gewähren davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
   
  
## Examples  
 Im folgenden Beispiel wird `InvokeMember` den Zugriff auf Member eines Typs.  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> enthält keine <see langword="CreateInstance" />, und <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> ist kein gültiges <see cref="T:System.Reflection.BindingFlags" />-Attribut.  
  
- oder -  
 <paramref name="invokeAttr" /> enthält keines der folgenden Bindungsflags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.  
  
- oder -  
 <paramref name="invokeAttr" /> enthält <see langword="CreateInstance" /> in Kombination mit <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.  
  
- oder -  
 <paramref name="invokeAttr" /> enthält sowohl <see langword="GetField" /> als auch <see langword="SetField" />.  
  
- oder -  
 <paramref name="invokeAttr" /> enthält sowohl <see langword="GetProperty" /> als auch <see langword="SetProperty" />.  
  
- oder -  
 <paramref name="invokeAttr" /> enthält <see langword="InvokeMethod" /> in Kombination mit <see langword="SetField" /> oder <see langword="SetProperty" />.  
  
- oder -  
 <paramref name="invokeAttr" /> enthält <see langword="SetField" />, und <paramref name="args" /> enthält mehr als ein Element.  
  
- oder -  
Diese Methode wird für ein COM-Objekt aufgerufen, und eines der folgenden Bindungsflags wurde nicht übergeben: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> oder <see langword="BindingFlags.PutRefDispProperty" />.  
  
- oder -  
Eines der benannten Parameterarrays enthält eine Zeichenfolge, die <see langword="null" /> ist.</exception>
        <exception cref="T:System.MethodAccessException">Der angegebene Member ist ein Klasseninitialisierer.</exception>
        <exception cref="T:System.MissingFieldException">Das Feld oder die Eigenschaft wurde nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde keine Methode gefunden, die den Argumenten in <paramref name="args" /> entspricht.  
  
- oder -  
Das aktuelle <see cref="T:System.Type" />-Objekt stellt einen Typ dar, der offene Typparameter enthält. Das bedeutet, dass <see cref="P:System.Type.ContainsGenericParameters" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <exception cref="T:System.Reflection.TargetException">Der angegebene Member kann nicht für <paramref name="target" /> aufgerufen werden.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mehrere Methoden entsprechen den Bindungskriterien.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode wird von .NET Compact Framework derzeit nicht unterstützt.</exception>
        <exception cref="T:System.InvalidOperationException">Die durch <paramref name="name" /> dargestellte Methode enthält mindestens einen nicht angegebenen generischen Typparameter. Das bedeutet, dass die <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />-Eigenschaft der Methode <see langword="true" /> zurückgibt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Legen Sie für den Zugriff auf nicht öffentliche Member unabhängig von deren Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des Konstruktors, der Methode, der Eigenschaft oder des Feldmembers enthält, der bzw. die aufgerufen werden soll.  
  
- oder -  
Eine leere Zeichenfolge ("") zum Aufrufen des Standardmembers.  
  
- oder -  
Für <see langword="IDispatch" />-Member eine Zeichenfolge, die die DispID darstellt, z. B. "[DispID=3]".</param>
        <param name="invokeAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird. Der Zugriff kann aus einem der <see langword="BindingFlags" /> wie <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> usw. bestehen. Die Art der Suche muss nicht angegeben werden. Wenn die Art der Suche nicht angegeben ist, werden <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> verwendet.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
- oder -  
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll. Beachten Sie, dass möglicherweise ein <see cref="T:System.Reflection.Binder" />-Objekt explizit definiert werden muss, um erfolgreich Methodenüberladungen mit Variablenargumenten aufrufen zu können.</param>
        <param name="target">Das Objekt, für das der angegebene Member aufgerufen werden soll.</param>
        <param name="args">Ein Array mit den Argumenten, die dem aufzurufenden Member übergeben werden sollen.</param>
        <param name="culture">Das Objekt, das das zu verwendende Globalisierungsgebietsschema darstellt, das für gebietsspezifische Konvertierungen wie die Konvertierung einer numerischen <see cref="T:System.String" /> in einen <see cref="T:System.Double" /> erforderlich sein kann.  
  
- oder -  
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet werden soll.</param>
        <summary>Ruft den angegebenen Member auf, der den angegebenen Bindungseinschränkungen sowie der angegebenen Argumentliste und Kultur entspricht.</summary>
        <returns>Ein Objekt, das den Rückgabewert des aufgerufenen Members darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl nicht der Standardbinder verarbeitet <xref:System.Globalization.CultureInfo> (die `culture` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, der verarbeitet `culture`.  
  
> [!NOTE]
>  Sie können keine <xref:System.Type.InvokeMember%2A> , eine generische Methode aufzurufen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, auf welche Member in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Public` öffentliche Mitglieder in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentliche Mitglieder (d. h. private, interne und geschützte Member) in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` auf statische Member der Hierarchie enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die Member deklariert die <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Aufrufflags können verwendet werden, um anzugeben, welche Aktion mit dem Element:  
  
-   `CreateInstance` Um einen Konstruktor aufzurufen. `name` wird ignoriert. Mit anderen Aufrufflags nicht gültig.  
  
-   `InvokeMethod` Um eine Methode, jedoch nicht auf einen Konstruktor oder Typinitialisierer aufzurufen. Ungültig mit `SetField` oder `SetProperty`. Wenn `InvokeMethod` wird angegeben, indem selbst `BindingFlags.Public`, `BindingFlags.Instance`, und `BindingFlags.Static` werden automatisch mit eingeschlossen.  
  
-   `GetField` um den Wert eines Felds zu erhalten. Ungültig mit `SetField`.  
  
-   `SetField` um den Wert eines Felds festzulegen. Ungültig mit `GetField`.  
  
-   `GetProperty` Um eine Eigenschaft zu erhalten. Ungültig mit `SetProperty`.  
  
-   `SetProperty` Um eine Eigenschaft festzulegen. Ungültig mit `GetProperty`.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Eine Methode wird aufgerufen werden, wenn beide der folgenden Bedingungen zutreffen:  
  
-   Die Anzahl von Parametern in der Deklaration der Methode entspricht der Anzahl der Argumente in der `args` Array (es sei denn, die Standardargumente für den Member definiert sind und `BindingFlags.OptionalParamBinding` angegeben ist).  
  
-   Der Typ jedes Arguments kann von der Binder in den Typ des Parameters konvertiert werden.  
  
 Der Binder findet alle übereinstimmenden Methoden. Diese Methoden gefunden werden, basierend auf den Typ der Bindung, die angefordert (<xref:System.Reflection.BindingFlags> Werte `InvokeMethod`, `GetProperty`und so weiter). Der Satz von Methoden wird durch den Namen, Anzahl von Argumenten und einen Satz von Suchabfragen, die in der Binder definiert gefiltert.  
  
 Nachdem die Methode ausgewählt ist, wird es aufgerufen. Barrierefreiheit wird an diesem Punkt überprüft. Die Suche kann gesteuert werden durchsucht, welche Gruppe von Methoden auf Grundlage der Eingabehilfen-Attribut, das der Methode zugeordnet. Die <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Methode der <xref:System.Reflection.Binder> -Klasse ist verantwortlich für das Auswählen der Methode aufgerufen werden. Der Standardbinder wählt die spezifischste Übereinstimmung.  
  
 Zugriffseinschränkungen werden für voll vertrauenswürdigen Code ignoriert. d. h. können private Konstruktoren, Methoden, Felder und Eigenschaften werden zugegriffen und durch Reflektion aufgerufen werden, wenn der Code vollständig vertrauenswürdig ist.  
  
 Sie können `Type.InvokeMember` für einen bestimmten Wert ein Felds festzulegen, durch Angabe <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Beispielsweise sollten Sie eine öffentliche Feld namens ' F ' für Klasse C und F ist eine `String` können Sie Code wie z.B.:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 Wenn F# ist eine `String[]`, können Sie Code wie z.B.:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 Das ist das Feld "F" für dieses neue Array initialisiert werden. Sie können auch `Type.InvokeMember` auf eine Position in einem Array festlegen, indem der Index des Werts, und klicken Sie dann den nächsten Wert mit Code wie den folgenden:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 Dies ändert die Zeichenfolge "Z" in das Array, das F in der Zeichenfolge "b" enthält.  
  
 Beim Aufruf einer `IDispatch` Member können Sie angeben, die DispID statt den Namen des Members, verwenden das Format der Zeichenfolge "[DispID = ##]". Z. B. wenn die DispID MyComMethod 3 ist, können Sie angeben die Zeichenfolge "[DispID = 3]" anstelle von "MyComMethod". Das Aufrufen eines Members durch DispID ist schneller als die Suche nach dem Namen des Members. In eine komplexe aggregationsszenarien ist die DispID manchmal die einzige Möglichkeit, den gewünschten Member aufgerufen werden soll.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, auf nicht öffentliche Member zuzugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> kennzeichnen und Menge oder eine Teilmenge der Berechtigungssatz die nicht öffentlichen Member an des Aufrufers des beschränkt ist zu gewähren davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> enthält keine <see langword="CreateInstance" />, und <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> ist kein gültiges <see cref="T:System.Reflection.BindingFlags" />-Attribut.  
  
- oder -  
 <paramref name="invokeAttr" /> enthält keines der folgenden Bindungsflags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.  
  
- oder -  
 <paramref name="invokeAttr" /> enthält <see langword="CreateInstance" /> in Kombination mit <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.  
  
- oder -  
 <paramref name="invokeAttr" /> enthält sowohl <see langword="GetField" /> als auch <see langword="SetField" />.  
  
- oder -  
 <paramref name="invokeAttr" /> enthält sowohl <see langword="GetProperty" /> als auch <see langword="SetProperty" />.  
  
- oder -  
 <paramref name="invokeAttr" /> enthält <see langword="InvokeMethod" /> in Kombination mit <see langword="SetField" /> oder <see langword="SetProperty" />.  
  
- oder -  
 <paramref name="invokeAttr" /> enthält <see langword="SetField" />, und <paramref name="args" /> enthält mehr als ein Element.  
  
- oder -  
Diese Methode wird für ein COM-Objekt aufgerufen, und eines der folgenden Bindungsflags wurde nicht übergeben: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> oder <see langword="BindingFlags.PutRefDispProperty" />.  
  
- oder -  
Eines der benannten Parameterarrays enthält eine Zeichenfolge, die <see langword="null" /> ist.</exception>
        <exception cref="T:System.MethodAccessException">Der angegebene Member ist ein Klasseninitialisierer.</exception>
        <exception cref="T:System.MissingFieldException">Das Feld oder die Eigenschaft wurde nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde keine Methode gefunden, die den Argumenten in <paramref name="args" /> entspricht.  
  
- oder -  
Das aktuelle <see cref="T:System.Type" />-Objekt stellt einen Typ dar, der offene Typparameter enthält. Das bedeutet, dass <see cref="P:System.Type.ContainsGenericParameters" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <exception cref="T:System.Reflection.TargetException">Der angegebene Member kann nicht für <paramref name="target" /> aufgerufen werden.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mehrere Methoden entsprechen den Bindungskriterien.</exception>
        <exception cref="T:System.InvalidOperationException">Die durch <paramref name="name" /> dargestellte Methode enthält mindestens einen nicht angegebenen generischen Typparameter. Das bedeutet, dass die <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />-Eigenschaft der Methode <see langword="true" /> zurückgibt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Legen Sie für den Zugriff auf nicht öffentliche Member unabhängig von deren Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="namedParameters" Type="System.String[]" Index="7" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des Konstruktors, der Methode, der Eigenschaft oder des Feldmembers enthält, der bzw. die aufgerufen werden soll.  
  
- oder -  
Eine leere Zeichenfolge ("") zum Aufrufen des Standardmembers.  
  
- oder -  
Für <see langword="IDispatch" />-Member eine Zeichenfolge, die die DispID darstellt, z. B. "[DispID=3]".</param>
        <param name="invokeAttr">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird. Der Zugriff kann aus einem der <see langword="BindingFlags" /> wie <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> usw. bestehen. Die Art der Suche muss nicht angegeben werden. Wenn die Art der Suche nicht angegeben ist, werden <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> verwendet.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
- oder -  
Ein Nullverweis (Nothing in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll. Beachten Sie, dass möglicherweise ein <see cref="T:System.Reflection.Binder" />-Objekt explizit definiert werden muss, um erfolgreich Methodenüberladungen mit Variablenargumenten aufrufen zu können.</param>
        <param name="target">Das Objekt, für das der angegebene Member aufgerufen werden soll.</param>
        <param name="args">Ein Array mit den Argumenten, die dem aufzurufenden Member übergeben werden sollen.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="args" />-Array zugeordnet sind. Die einem Parameter zugeordneten Attribute werden in der Signatur des Members gespeichert.  
  
Der Standardbinder verarbeitet diesen Parameter nur, wenn eine COM-Komponente aufgerufen wird.</param>
        <param name="culture">Das <see cref="T:System.Globalization.CultureInfo" />-Objekt, das das zu verwendende Globalisierungsgebietsschema darstellt, das für gebietsspezifische Konvertierungen wie die Konvertierung einer numerischen Zeichenfolge in einen Double erforderlich sein kann.  
  
- oder -  
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet werden soll.</param>
        <param name="namedParameters">Ein Array mit den Namen der Parameter, an die die Elemente des <paramref name="args" />-Arrays übergeben werden.</param>
        <summary>Ruft nach Überschreiben in einer abgeleiteten Klasse den angegebenen Member auf, der den angegebenen Bindungseinschränkungen sowie der angegebenen Argumentliste, den Modifizierern und der Kultur entspricht.</summary>
        <returns>Ein Objekt, das den Rückgabewert des aufgerufenen Members darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` Ruft eine Konstruktor- oder einen Methodenmember, ruft ab oder legt ein Eigenschaftenelement, ruft ab oder legt einen Feld-Datenmember oder abgerufen oder festgelegt ein Element eines Arraymitglieds.  
  
> [!NOTE]
>  Sie können keine <xref:System.Type.InvokeMember%2A> , eine generische Methode aufzurufen.  
  
 Beim Aufruf einer `IDispatch` Member können Sie angeben, die DispID statt den Namen des Members, verwenden das Format der Zeichenfolge "[DispID = ##]". Z. B. wenn die DispID MyComMethod 3 ist, können Sie angeben die Zeichenfolge "[DispID = 3]" anstelle von "MyComMethod". Das Aufrufen eines Members durch DispID ist schneller als die Suche nach dem Namen des Members. In eine komplexe aggregationsszenarien ist die DispID manchmal die einzige Möglichkeit, den gewünschten Member aufgerufen werden soll.  
  
 Obwohl nicht der Standardbinder verarbeitet <xref:System.Reflection.ParameterModifier> oder <xref:System.Globalization.CultureInfo> (die `modifiers` und `culture` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, der verarbeitet `modifiers` und `culture`. `ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und behandelt nur die Parameter, die als Verweis übergeben werden.  
  
 Jeder Parameter im `namedParameters`-Array ruft den Wert im entsprechenden Element im `args`-Array ab. Wenn die Länge von `args` größer als die Länge von `namedParameters` ist, werden die restlichen Argumentwerte in der Reihenfolge übergeben.  
  
 Die `namedParameters` Array kann verwendet werden, um die Reihenfolge der Argumente in einem Eingabearray ändern. Angenommen, die Methode `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) und das Eingabearray `{ 42, "x" }`, Eingabe-Array, kann unverändert in übergeben werden `args` Wenn das Array `{ "b", "a" }` für angegeben wird `namedParameters`.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, auf welche Member in die Suche einbezogen werden:  
  
-   Geben Sie `BindingFlags.Public` öffentliche Mitglieder in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.NonPublic` nicht öffentliche Mitglieder (d. h. private, interne und geschützte Member) in die Suche eingeschlossen werden sollen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` auf statische Member der Hierarchie enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die Funktionsweise der Suche ändern:  
  
-   `BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.  
  
-   `BindingFlags.DeclaredOnly` Suchen Sie nur die Member deklariert die <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Aufrufflags können verwendet werden, um anzugeben, welche Aktion mit dem Element:  
  
-   `CreateInstance` Um einen Konstruktor aufzurufen. `name` wird ignoriert. Mit anderen Aufrufflags nicht gültig.  
  
-   `InvokeMethod` Um eine Methode, jedoch nicht auf einen Konstruktor oder Typinitialisierer aufzurufen. Ungültig mit `SetField` oder `SetProperty`. Wenn `InvokeMethod` wird angegeben, indem selbst `BindingFlags.Public`, `BindingFlags.Instance`, und `BindingFlags.Static` werden automatisch mit eingeschlossen.  
  
-   `GetField` um den Wert eines Felds zu erhalten. Ungültig mit `SetField`.  
  
-   `SetField` um den Wert eines Felds festzulegen. Ungültig mit `GetField`.  
  
-   `GetProperty` Um eine Eigenschaft zu erhalten. Ungültig mit `SetProperty`.  
  
-   `SetProperty` Um eine Eigenschaft festzulegen. Ungültig mit `GetProperty`.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Eine Methode wird aufgerufen werden, wenn beide der folgenden Bedingungen zutreffen:  
  
-   Die Anzahl von Parametern in der Deklaration der Methode entspricht der Anzahl der Argumente in der `args` Array (es sei denn, die Standardargumente für den Member definiert sind und `BindingFlags.OptionalParamBinding` angegeben ist).  
  
-   Der Typ jedes Arguments kann von der Binder in den Typ des Parameters konvertiert werden.  
  
 Der Binder findet alle übereinstimmenden Methoden. Diese Methoden gefunden werden, basierend auf den Typ der Bindung, die angefordert (<xref:System.Reflection.BindingFlags> Werte `InvokeMethod`, `GetProperty`und so weiter). Der Satz von Methoden wird durch den Namen, Anzahl von Argumenten und einen Satz von Suchabfragen, die in der Binder definiert gefiltert.  
  
 Nachdem die Methode ausgewählt ist, wird es aufgerufen. Barrierefreiheit wird an diesem Punkt überprüft. Die Suche kann gesteuert werden durchsucht, welche Gruppe von Methoden auf Grundlage der Eingabehilfen-Attribut, das der Methode zugeordnet. Die <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Methode der <xref:System.Reflection.Binder> -Klasse ist verantwortlich für das Auswählen der Methode aufgerufen werden. Der Standardbinder wählt die spezifischste Übereinstimmung.  
  
 `InvokeMember` kann verwendet werden, zum Aufrufen von Methoden mit Parametern, die über Standardwerte verfügen. Um auf diese Methoden zu binden, muss für die Reflektion <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> angegeben werden. Für einen Parameter, die einen Standardwert verfügt, Sie können einen anderen Wert angeben, oder geben Sie <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> auf den Standardwert verwenden.  
  
 Betrachten Sie beispielsweise eine Methode z. B. MyMethod (Int x, "float" y = 2.0). Um diese Methode mit dem nur das erste Argument als MyMethod(4) aufzurufen, übergeben Sie einen der oben genannten Bindungsflags und zwei Argumente, d. h. 4 für das erste Argument übergeben und `Missing.Value` für das zweite Argument. Es sei denn, Sie verwenden `Missing.Value`, dürfen nicht ausgelassen werden optionale Parameter mit dem `Invoke` Methode. Wenn Sie dies tun müssen, verwenden Sie `InvokeMember` stattdessen.  
  
 Zugriffseinschränkungen werden für voll vertrauenswürdigen Code ignoriert. d. h. private Konstruktoren, Methoden, Felder und Eigenschaften und werden können durch aufgerufen <xref:System.Reflection> jedes Mal, wenn der Code vollständig vertrauenswürdig ist.  
  
 Sie können `Type.InvokeMember` für einen bestimmten Wert ein Felds festzulegen, durch Angabe <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Beispielsweise sollten Sie eine öffentliche Feld namens ' F ' für Klasse C und F ist eine `String`, können Sie Code wie z.B.:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 Wenn F# ist eine `String[]`, können Sie Code wie z.B.:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 Das ist das Feld "F" für dieses neue Array initialisiert werden. Sie können auch `Type.InvokeMember` auf eine Position in einem Array festlegen, indem der Index des Werts, und klicken Sie dann den nächsten Wert mit Code wie den folgenden:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 Dies ändert die Zeichenfolge "Z" in das Array, das F in der Zeichenfolge "b" enthält.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, auf nicht öffentliche Member zuzugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> kennzeichnen und Menge oder eine Teilmenge der Berechtigungssatz die nicht öffentlichen Member an des Aufrufers des beschränkt ist zu gewähren davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> enthält keine <see langword="CreateInstance" />, und <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="args" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.  
  
- oder -  
 <paramref name="invokeAttr" /> ist kein gültiges <see cref="T:System.Reflection.BindingFlags" />-Attribut.  
  
- oder -  
 <paramref name="invokeAttr" /> enthält keines der folgenden Bindungsflags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.  
  
- oder -  
 <paramref name="invokeAttr" /> enthält <see langword="CreateInstance" /> in Kombination mit <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.  
  
- oder -  
 <paramref name="invokeAttr" /> enthält sowohl <see langword="GetField" /> als auch <see langword="SetField" />.  
  
- oder -  
 <paramref name="invokeAttr" /> enthält sowohl <see langword="GetProperty" /> als auch <see langword="SetProperty" />.  
  
- oder -  
 <paramref name="invokeAttr" /> enthält <see langword="InvokeMethod" /> in Kombination mit <see langword="SetField" /> oder <see langword="SetProperty" />.  
  
- oder -  
 <paramref name="invokeAttr" /> enthält <see langword="SetField" />, und <paramref name="args" /> enthält mehr als ein Element.  
  
- oder -  
Das benannte Parameterarray ist größer als das Argumentarray.  
  
- oder -  
Diese Methode wird für ein COM-Objekt aufgerufen, und eines der folgenden Bindungsflags wurde nicht übergeben: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> oder <see langword="BindingFlags.PutRefDispProperty" />.  
  
- oder -  
Eines der benannten Parameterarrays enthält eine Zeichenfolge, die <see langword="null" /> ist.</exception>
        <exception cref="T:System.MethodAccessException">Der angegebene Member ist ein Klasseninitialisierer.</exception>
        <exception cref="T:System.MissingFieldException">Das Feld oder die Eigenschaft wurde nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde keine Methode gefunden, die den Argumenten in <paramref name="args" /> entspricht.  
  
- oder -  
Es wurde kein Member gefunden, dessen Argumentnamen in <paramref name="namedParameters" /> angegeben sind.  
  
- oder -  
Das aktuelle <see cref="T:System.Type" />-Objekt stellt einen Typ dar, der offene Typparameter enthält. Das bedeutet, dass <see cref="P:System.Type.ContainsGenericParameters" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <exception cref="T:System.Reflection.TargetException">Der angegebene Member kann nicht für <paramref name="target" /> aufgerufen werden.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mehrere Methoden entsprechen den Bindungskriterien.</exception>
        <exception cref="T:System.InvalidOperationException">Die durch <paramref name="name" /> dargestellte Methode enthält mindestens einen nicht angegebenen generischen Typparameter. Das bedeutet, dass die <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />-Eigenschaft der Methode <see langword="true" /> zurückgibt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Legen Sie für den Zugriff auf nicht öffentliche Member unabhängig von deren Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> abstrakt ist und überschrieben werden muss.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> abstrakt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.IsAbstract%2A> -Eigenschaft gibt `true` in den folgenden Fällen:  
  
-   Der aktuelle Typ ist abstrakt. d. h. es kann nicht instanziiert werden und dienen nur als Basisklasse für abgeleitete Klassen. Abstrakte Klassen sind in c# mit markiert die [abstrakte](~/docs/csharp/language-reference/keywords/abstract.md) Schlüsselwort in Visual Basic markiert sind mit den [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) Schlüsselwort.  
  
-   Der aktuelle Typ ist eine Schnittstelle.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein Array von <xref:System.Type> Objekte, die die folgenden Typen darstellen: Typ gibt enthält `true` , wenn das angegebene Objekt `abstract`ist, andernfalls gibt `false`.  
  
-   `AbstractClass`, eine abstrakte Klasse (eine Klasse als markiert `abstract` in C# geschrieben und `MustInherit` in Visual Basic).  
  
-   `DerivedClass`, eine Klasse, die von erbt `AbstractClass`.  
  
-   `SingleClass`, einer nicht vererbbaren Klasse. Es wird definiert als `sealed` in C# geschrieben und `NotInheritable` in Visual Basic.  
  
-   `ITypeInfo`, eine Schnittstelle.  
  
-   `ImplementingClass`, eine Klasse, implementiert die `ITypeInfo` Schnittstelle.  
  
 Gibt die Methode zurück `true` nur für `AbstractClass`, die abstrakte Klasse, und `ITypeInfo`, die Schnittstelle.  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob für <see langword="AnsiClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist.</summary>
        <value><see langword="true" />, wenn für <see langword="AnsiClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.TypeAttributes.StringFormatMask> wählt die Zeichenfolgenformatattribute. Die Zeichenfolge Formatattribute zur Verbesserung der Interoperabilität von definieren, wie Zeichenfolgen interpretiert werden soll.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein generischer Typ, der diese Eigenschaft bezieht sich auf die Definition des generischen Typs, von dem der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.  
  
   
  
## Examples  
 Im folgenden Beispiel ruft die Feldinformationen und überprüft, ob die `AnsiClass` Attribut.  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Typ ein Array ist.</summary>
        <value><see langword="true" />, wenn der aktuelle Typ ein Array ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.IsArray%2A> -Eigenschaft gibt `false` für die <xref:System.Array> Klasse. Sie gibt überdies `false` , wenn die aktuelle Instanz ist eine <xref:System.Type> -Objekt, das einen Auflistungstyp oder eine Schnittstelle, die mit Auflistungen, z. B. funktionieren darstellt <xref:System.Collections.IEnumerable> oder <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Verwenden Sie z. B. Code, um für ein Array zu überprüfen:  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 Wenn der aktuelle Typ ein generischer Typ oder einen Typparameter in der Definition einer generischen Typ-oder Methodendefinition darstellt, gibt diese Eigenschaft immer `false`.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Type.IsArray%2A> Eigenschaft.  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsArray" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein Array ist.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Type" /> ein Array ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Instanz von der <xref:System.Array> Klasse zurückgeben muss `false` da es sich um ein Objekt, das nicht in ein Array handelt.  
  
   
  
## Examples  
 Im folgende Beispiel überschreibt die `IsArrayImpl` -Methode in der die `MyTypeDelegator` -Klasse überprüft, ob eine Variable ein Array, und das Ergebnis wird angezeigt.  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c">Der Typ, der mit dem aktuellen Typ verglichen werden soll.</param>
        <summary>Bestimmt, ob eine Instanz eines angegebenen Typs einer Variablen des aktuellen Typs zugewiesen werden kann.</summary>
        <returns><see langword="true" />, wenn eine der folgenden Bedingungen erfüllt ist: 
-   <paramref name="c" /> und die aktuelle Instanz haben denselben Typ.  
  
-   <paramref name="c" /> ist entweder direkt oder indirekt von der aktuellen Instanz abgeleitet. <paramref name="c" /> wird direkt von der aktuellen Instanz abgeleitet, wenn es von der aktuellen Instanz erbt; <paramref name="c" /> wird indirekt von der aktuellen Instanz abgeleitet, wenn es von einer Folge von einer oder mehr Klassen erbt, die von der aktuellen Instanz erben.  
  
–   Die aktuelle Instanz ist eine Schnittstelle, die von <paramref name="c" /> implementiert wird.  
  
-   <paramref name="c" /> ist ein generischer Typparameter, und die aktuelle Instanz stellt eine der Einschränkungen von <paramref name="c" /> dar.  
  
Im folgenden Beispiel handelt es sich bei der aktuellen Instanz um ein <see cref="T:System.Type" />-Objekt, das die Klasse <see cref="T:System.IO.Stream" /> darstellt. Bei <c>GenericWithConstraint</c> handel es sich um einen generische Typ, dessen generischer Typparameter vom Typ <see cref="T:System.IO.Stream" /> sein muss. Wenn der generische Typparameter an <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> übergeben wird,zeigt dies, dass eine Instanz des generischen Typparameters einem <see cref="T:System.IO.Stream" />-Objekt zugewiesen werden kann.  
  
[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)] 
-   <paramref name="c" /> stellt einen Werttyp dar, und die aktuelle Instanz stellt <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic) dar.  
  
 <see langword="false" />, wenn keine dieser Bedingungen erfüllt sind oder wenn <paramref name="c" /><see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.IsAssignableFrom%2A> Methode kann verwendet werden, um zu bestimmen, ob eine Instanz von `c` zugewiesen werden zu einer Instanz des aktuellen Typs, die Methode ist besonders hilfreich, wenn Sie Objekte behandeln, deren Typen zur Entwurfszeit nicht bekannt sind, und ermöglicht für bedingte Zuweisung, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 Diese Methode so wird sichergestellt, dass eine einzige Zeile Code, wie die folgenden zur Laufzeit, ohne dass ausgeführt werden ein <xref:System.InvalidCastException> Ausnahme oder eine ähnliche Ausnahme:  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
> [!NOTE]
>  Eine generische Typdefinition ist nicht von einem geschlossenen konstruierten Typ zugewiesen werden. D. h. Sie können keine geschlossenen konstruierten Typs zuweisen `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic), eine Variable vom Typ `MyGenericList<T>`.  
  
 Wenn die `c` Parameter ist vom Typ <xref:System.Reflection.Emit.TypeBuilder>, das Ergebnis basiert darauf, dass der Typ, der erstellt werden soll. Im folgenden Codebeispiel wird veranschaulicht, dies mithilfe eines integrierten Typs, der mit dem Namen `B`.  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die `IsAssignableFrom` Methode definiert Klassen, ganzzahlige Arrays und Generika.  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob für <see langword="AutoClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist.</summary>
        <value><see langword="true" />, wenn für <see langword="AutoClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.TypeAttributes.StringFormatMask> wählt die Zeichenfolgenformatattribute. Die Zeichenfolge Formatattribute zur Verbesserung der Interoperabilität von definieren, wie Zeichenfolgen interpretiert werden soll.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die Definition des generischen Typs aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Felder des aktuellen Typs automatisch von der Common Language Runtime angelegt werden.</summary>
        <value><see langword="true" />, wenn die <see cref="P:System.Type.Attributes" />-Eigenschaft des aktuellen Typs <see cref="F:System.Reflection.TypeAttributes.AutoLayout" /> umfasst; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist zur Vereinfachung bereitgestellt. Alternativ können Sie die <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> Enumerationswert, der die Attribute des Typs Layout und anschließend testen Sie, ob wählen <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> festgelegt ist. Die <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, und <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> Enumerationswerte geben die Möglichkeit, die die Felder des Typs im Arbeitsspeicher angeordnet werden.  
  
 Für dynamische Typen können Sie angeben <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> beim Erstellen des Typs. Im Code, gelten die <xref:System.Runtime.InteropServices.StructLayoutAttribute> -Attribut mit der <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> Enumerationswert, der Typ, auf die Laufzeit die geeignete Methode zum Anordnen der Klasse bestimmen können.  
  
> [!NOTE]
>  Können keine der <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> Methode, um zu bestimmen, ob die <xref:System.Runtime.InteropServices.StructLayoutAttribute> auf einen Typ angewendet wurde.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die Definition des generischen Typs aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft wird bestimmt durch `MyGenericType<T>.`  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Instanz des Typs und zeigt die <xref:System.Type.IsAutoLayout%2A> Eigenschaft.  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">Metadaten und selbstbeschreibende Komponenten</related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> als Verweis übergeben wird.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis übergeben wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie in den tatsächlichen Typ dereferenzieren den Typ, der als Verweis übergeben wurde, und rufen dann <xref:System.Type.GetElementType%2A> für diesen Typ.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung des der `IsByRef` Eigenschaft zu überprüfen, ob es sich bei ein angegebenen Typ als Verweis übergeben wird. Im Beispiel wird die Klasse `MyTypeDelegator`, welche Außerkraftsetzungen der `HasElementTypeImpl` Methode. Die Hauptklasse überprüft die `HasElementType` -Eigenschaft und zeigt das Element eingeben.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsByRef" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> als Verweis übergeben wird.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis übergeben wird, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> eine Klasse oder ein Delegat ist, d. h. weder ein Werttyp noch eine Schnittstelle.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> eine Klasse ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt `true` für Klassen als auch für Delegaten. Es gibt `false` für Werttypen (für Strukturen und Enumerationen) selbst wenn sie verschachtelt sind.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `true`. Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Eigenschaft `true` ist die generische Typdefinition der Definition einer Klasse; d. h. kein definiert eine Schnittstelle oder ein Werttyp.  
  
> [!NOTE]
>  Diese Eigenschaft gibt `true` für `Type` Instanzen, die darstellen, die <xref:System.Enum> und <xref:System.ValueType> Klassen. Diese beiden Klassen sind die Basistypen für Enumerationen und Werttypen, aber sie sind nicht Enumerationen oder Werttypen selbst. Weitere Informationen finden Sie unter den <xref:System.Type.IsValueType%2A> und <xref:System.Type.IsEnum%2A> Eigenschaften.  
  
 Die <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> Enumerationswert kennzeichnet eine Typdeklaration als Klasse oder Schnittstelle. Sowohl Klassen als auch Werttypen werden jedoch mit markiert die <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> Attribut. Wenn Sie den Wert des Attributes-Eigenschaft und die Verwendung eines Typs Abrufen der <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> um zu bestimmen, ob ein Typ eine Klasse anstelle eines Werttyps ist, müssen Sie auch Aufrufen der <xref:System.Type.IsValueType%2A> Eigenschaft. Das Beispiel für die <xref:System.Reflection.TypeAttributes> Enumeration enthält zusätzliche Informationen als auch beispielsweise.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Instanz eines Typs und gibt an, ob der Typ eine Klasse ist.  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> ein COM-Objekt ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> ein COM-Objekt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt `false` für COM-Schnittstellen, da diese keine Objekte sind. COM-Schnittstellen können von Microsoft .NET Framework-Objekte implementiert werden.  
  
 Sie können auch eine COM-Klasse zu laden und erhalten eine `Type` -Objekt für diese COM-Klasse unter Verwendung der [Tlbimp.exe (Type Library Importer-Tool)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) Tool.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die Definition des generischen Typs aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsCOMObject" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein COM-Objekt ist.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Type" /> ein COM-Objekt ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt `false` für COM-Schnittstellen, da diese keine Objekte sind. COM-Schnittstellen können von Microsoft .NET Framework-Objekte implementiert werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses Objekt einen konstruierten generischen Typ darstellt. Sie können Instanzen eines konstruierten generischen Typs erstellen.</summary>
        <value><see langword="true" />, wenn dieses Objekt einen konstruierten generischen Typ darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein konstruierter generischer Typ wurde explizite Typen, die für alle generischen Typparameter angegeben. Es ist auch als einen geschlossenen generischen Typ bezeichnet.  
  
 Wenn diese Eigenschaft ist `true`, Sie können Instanzen des aktuellen Typs erstellen, wenn es sich um `false`, ist nicht möglich.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Kontext fängt Aufrufe auf die Member ab, und erzwingt Richtlinien, die auf die Klasse, z. B. Synchronisierung angewendet werden. Ausführlichere Informationen über Remotekontext finden Sie unter <xref:System.Runtime.Remoting.Contexts.Context>.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, und <xref:System.Type.IsPrimitive%2A> Eigenschaften der <xref:System.Type> Klasse. Er überprüft, ob der angegebene Typ in den Kontext aufgenommen werden kann, ob es als Verweis gemarshallt werden kann und ob der Typ ein primitiver Datentyp ist.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert die <see cref="P:System.Type.IsContextful" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
 Ein Kontext fängt Aufrufe auf die Member ab, und erzwingt Richtlinien, die auf die Klasse, z. B. Synchronisierung angewendet werden.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung des der `IsContextfulImpl` Methode.  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> eine Enumeration darstellt.</summary>
        <value><see langword="true" />, wenn der aktuelle <see cref="T:System.Type" /> eine Enumeration darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt `true` für eine Enumeration, aber nicht für die <xref:System.Enum> -Typ selbst.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die Definition des generischen Typs aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die `IsEnum` Eigenschaft.  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Der zu überprüfende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der angegebene Wert im aktuellen Enumerationstyp vorhanden ist.</summary>
        <returns><see langword="true" />, wenn der angegebene Wert ein Member des aktuellen Enumerationstyps ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Der aktuelle Typ ist keine Enumeration.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> ist ein Typ, der nicht der zugrunde liegende Typ einer Enumeration sein kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="other">Der COM-Typ, der auf Äquivalenz mit dem aktuellen Typ überprüft wird.</param>
        <summary>Bestimmt, ob zwei COM-Typen die gleiche Identität haben und äquivalente Typen aufweisen können.</summary>
        <returns><see langword="true" />, wenn die COM-Typen äquivalent sind, andernfalls <see langword="false" />. Diese Methode gibt auch <see langword="false" /> zurück, wenn ein Typ in einer Assembly enthalten ist, die zum Ausführen geladen wird, und der andere in einer Assembly enthalten ist, die in den reflektionsbezogenen Kontext geladen wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], die common Language Runtime unterstützt das Einbetten von Typinformationen für COM-Typen direkt in verwaltete Assemblys, statt die verwalteten Assemblys, die Typinformationen für COM-Typen aus Interop abrufen Assemblys. Da die eingebettete Typinformation nur die Typen und Member enthält, die tatsächlich von einer verwalteten Assembly verwendet werden, können zwei verwaltete Assemblys möglicherweise sehr unterschiedliche Ansichten desselben COM-Typs haben. Jede verwaltete Assembly besitzt ein anderes <xref:System.Type>-Objekt, das eine Ansicht des COM-Typs darstellt. Die Common Language Runtime unterstützt Typäquivalenz zwischen diesen unterschiedlichen Ansichten für Schnittstellen, Strukturen, Enumerationen und Delegaten.  
  
 Typäquivalenz bedeutet, dass ein COM-Objekt, das von einer verwalteten Assembly an eine andere übergeben wird, für den entsprechenden verwalteten Typ in der empfangenden Assembly bereitgestellt werden kann. Die <xref:System.Type.IsEquivalentTo%2A> Methode ermöglicht es eine Assembly aus, um zu bestimmen, dass ein COM-Objekt, das von einer anderen Assembly erhalten die gleiche COM-Identität als eines der ersten eigenen eingebettete Interop-Assemblytyp ist und daher auf diesen Typ umgewandelt werden kann.  
  
 Weitere Informationen finden Sie unter [Typäquivalenz und eingebettete Interop-Typen](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Felder des aktuellen Typs an den explizit angegebenen Offsets angelegt werden.</summary>
        <value><see langword="true" />, wenn die <see cref="P:System.Type.Attributes" />-Eigenschaft des aktuellen Typs <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /> umfasst; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist zur Vereinfachung bereitgestellt. Alternativ können Sie die <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> Enumerationswert, der die Attribute des Typs Layout und anschließend testen Sie, ob wählen <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> festgelegt ist. Die <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, und <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> Enumerationswerte geben die Möglichkeit, die die Felder des Typs im Arbeitsspeicher angeordnet werden.  
  
 Für dynamische Typen können Sie angeben <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> beim Erstellen des Typs. Im Code, gelten die <xref:System.Runtime.InteropServices.StructLayoutAttribute> -Attribut mit der <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> Enumerationswert, der Typ, um anzugeben, dass die Offsets, die an dem die Felder starten explizit angegeben werden.  
  
> [!NOTE]
>  Können keine der <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> Methode, um zu bestimmen, ob die <xref:System.Runtime.InteropServices.StructLayoutAttribute> auf einen Typ angewendet wurde.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die Definition des generischen Typs aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz eines Typs erstellt und zeigt den Wert der <xref:System.Type.IsExplicitLayout%2A> Eigenschaft. Er verwendet den `MySystemTime` Klasse, die auch im Codebeispiel für <xref:System.Runtime.InteropServices.StructLayoutAttribute>.  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">Metadaten und selbstbeschreibende Komponenten</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Typ- oder Methodendefinition darstellt.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Type" />-Objekt einen Typparameter einer generischen Typ- oder Methodendefinition darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> generische Typparameter darstellende – Objekte abgerufen werden können, durch den Aufruf der <xref:System.Type.GetGenericArguments%2A> -Methode der ein <xref:System.Type> -Objekt, das eine generische Typdefinition darstellt, oder die <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> -Methode der ein <xref:System.Reflection.MethodInfo> -Objekt, das eine generische Methode darstellt die Definition.  
  
-   Für eine generische Typ- oder Methodendefinition der <xref:System.Type.IsGenericParameter%2A> -Eigenschaft gibt `true` für jedes Element des resultierenden Arrays.  
  
-   Für einen geschlossenen konstruierten Typ oder Methode die <xref:System.Type.IsGenericParameter%2A> -Eigenschaft gibt `false` für jedes Element des Arrays, zurückgegeben von der <xref:System.Type.GetGenericArguments%2A> Methode.  
  
-   Bei einem offenen konstruierten Typ oder die Methode hat einige Elemente des Arrays handelt es sich möglicherweise um bestimmte Typen, und möglicherweise andere Parameter vom Typ. <xref:System.Type.IsGenericParameter%2A> Gibt `false` für die Typen und `true` für die Typparameter an. Im Codebeispiel für die <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft wird mit einer Mischung aus Typen und die Typparameter eine generische Klasse veranschaulicht.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Type.IsGenericParameter%2A> Eigenschaft für generische Typparameter in einem generischen Typ zu testen.  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflektion und generische Typen</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Vorgehensweise: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ ein generischer Typ ist.</summary>
        <value><see langword="true" /> Wenn der aktuelle Typ ein generischer Typ ist. andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Type.IsGenericType%2A> Eigenschaft, um zu bestimmen, ob eine <xref:System.Type> -Objekt einen generischen Typ darstellt. Verwenden der <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft, um zu bestimmen, ob eine <xref:System.Type> -Objekt ein offener Typ oder einen geschlossenen konstruierten Typ darstellt.  
  
> [!NOTE]
>  Die <xref:System.Type.IsGenericType%2A> -Eigenschaft gibt `false` Wenn der unmittelbaren Typ nicht generisch ist. Z. B. ein Array, dessen Elemente vom Typ `A<int>` (`A(Of Integer)` in Visual Basic) ist nicht selbst ein generischer Typ.  
  
 Die folgende Tabelle enthält die Invarianten Bedingungen für Begriffe in Reflektion mit generischen Methoden verwendet.  
  
|Begriff|Invariante|  
|----------|---------------|  
|generische Typdefinition|Die <xref:System.Type.IsGenericTypeDefinition%2A>-Eigenschaft ist `true`.<br /><br /> Definiert einen generischen Typ an. Ein konstruierter Typ erstellt durch Aufrufen der <xref:System.Type.MakeGenericType%2A> Methode für eine <xref:System.Type> Objekt, das eine generische Typdefinition darstellt, und ein Array der Argumente des Typs angeben.<br /><br /> <xref:System.Type.MakeGenericType%2A> kann nur für generische Typdefinitionen aufgerufen werden.<br /><br /> Generische Typdefinition ist ein generischer Typ (der <xref:System.Type.IsGenericType%2A> Eigenschaft `true`), das Gegenteil trifft jedoch nicht.|  
|generischer Typ|Die <xref:System.Type.IsGenericType%2A>-Eigenschaft ist `true`.<br /><br /> Hierbei kann es sich um eine generische Typdefinition, einen offenen konstruierten Typ oder ein geschlossener konstruierter Typ sein.<br /><br /> Beachten Sie, dass ein, dessen Elementtyp Arraytyp ist generisch ist selbst ein generischer Typ. Das gleiche gilt für eine <xref:System.Type> Objekt, das einen Zeiger auf einen generischen Typ darstellt.|  
|Öffnen Sie die konstruierten Typ|Die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft ist `true`.<br /><br /> Beispiele sind ein generischer Typ, der nicht zugewiesene Typparameter verfügt, ein Typ, der in der Definition eines generischen Typs oder ein offener Typ geschachtelt ist oder ein generischer Typ, der für die ein Typargument verfügt die <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft `true`.<br /><br /> Es ist nicht möglich, eine Instanz eines offenen konstruierten Typs zu erstellen.<br /><br /> Beachten Sie, dass nicht alle offene konstruierte Typen generisch sind. Beispielsweise wird ein Array, dessen Elementtyp ist der Definition eines generischen Typs, ist nicht generisch, und ein Zeiger auf ein offener Typ ist nicht generisch.|  
|geschlossener konstruierter Typ|Die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft ist `false`.<br /><br /> Bei einer untersuchten rekursiven der Typ weist nicht zugewiesene generische Parameter.|  
|generischer Typparameter|Die <xref:System.Type.IsGenericParameter%2A>-Eigenschaft ist `true`.<br /><br /> Die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft ist `true`.<br /><br /> In einer generischen Typdefinition ein Platzhalter für einen Typ, der später zugewiesen wird.|  
|generisches Typargument|Kann beliebigen Typs, einschließlich der einen generischen Typparameter sein.<br /><br /> Typargumente angegeben werden, als ein Array von <xref:System.Type> Objekte übergeben, um die <xref:System.Type.MakeGenericType%2A> Methode, wenn Sie einen konstruierten generischen Typ erstellen. Wenn Instanzen des resultierenden Typs erstellt werden, sind die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft muss sein `false` für alle Typargumente.|  
  
 Im folgenden Codebeispiel und Tabelle veranschaulichen einige dieser Bedingungen und Invarianten. Die `Derived` Klasse ist von besonderem Interesse, da ihr Basistyp einen konstruierten Typ ist, die eine Mischung von Typen und Parameter vom Typ in der Liste der Typargumente aufweist.  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 Die folgende Tabelle zeigt Beispiele, die für die Klassen zu erstellen und verwenden `Base`, `Derived`, und `G`. Wenn die C++ und C#-Code identisch ist, wird nur ein Eintrag angezeigt.  
  
|Beispiel|Invarianten|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|Für diesen Typ:<br /><br /> <xref:System.Type.IsGenericType%2A> ist `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> ist `true`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> ist `true`.|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|Für diesen Typ:<br /><br /> <xref:System.Type.IsGenericType%2A> ist `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> ist `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> ist `true`.|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|Für den Typ der Variable `d`:<br /><br /> <xref:System.Type.IsGenericType%2A> ist `false` da `d` ist ein Array.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> ist `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> ist `false`.|  
|`T`, `U`, und `V` (bei allen Vorkommen)|<xref:System.Type.IsGenericParameter%2A> ist `true`.<br /><br /> <xref:System.Type.IsGenericType%2A> ist `false` , da es keine Möglichkeit gibt, um einen Typparameter auf generische Typen zu beschränken.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> ist `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> ist `true` da `T`, `U`, und `V` sind selbst generische Typparameter. Dies bedeutet alles über Typargumente nicht, die sie später zugewiesen sind.|  
|Der Typ des Felds `F`|<xref:System.Type.IsGenericType%2A> ist `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> ist `false` , da der Typparameter, der ein Typ zugewiesen wurde `G`. Beachten Sie, dass dies dem Aufruf der <xref:System.Type.MakeGenericType%2A> Methode.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> ist `true` da der Typ des Felds `F` verfügt über ein Typargument, das ein offener Typ ist. Der konstruierte Typ geöffnet ist da dessen Typargument (d. h. `Base`) ist eine generische Typdefinition. Dies ist der rekursiven Natur der der <xref:System.Type.IsGenericType%2A> Eigenschaft.|  
|Die geschachtelte Klasse `Nested`|<xref:System.Type.IsGenericType%2A> ist `true`, obwohl die `Nested` Klasse verfügt über keine generischen Typparameter selbst, aus, weil sie in einem generischen Typ geschachtelt ist.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> ist `true`. D. h., rufen Sie die <xref:System.Type.MakeGenericType%2A> -Methode und Angeben der Typparameter des einschließenden Typs `Derived`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> ist `true` , da der einschließende Typ, `Derived`, verfügt über generische Typparameter. Dies ist der rekursiven Natur der der <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft.|  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt den Wert von der <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, und <xref:System.Type.ContainsGenericParameters%2A> Eigenschaften für die Typen, die im Abschnitt "Hinweise" beschrieben. Beschreibungen der Eigenschaftswerte finden Sie unter der zugehörigen Tabelle unter "Hinweise".  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflektion und generische Typen</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Vorgehensweise: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> eine generische Typdefinition darstellt, aus der andere generische Typen konstruiert werden können.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Type" />-Objekt eine generische Typdefinition darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine generische Typdefinition ist eine Vorlage aus der anderen Typen konstruiert werden können. Z. B. von der generischen Typdefinition `G<T>` (ausgedrückt in C#-Syntax; `G(Of T)` in Visual Basic oder `generic <typename T> ref class G` in C++) können Sie zu erstellen und den Typ instanziieren `G<int>` (`G(Of Integer)` in Visual Basic), durch den Aufruf der <xref:System.Type.MakeGenericType%2A> -Methode mit einer Liste mit generischen Argument der <xref:System.Int32> Typ. Erhält eine <xref:System.Type> Objekt, das diese darstellt konstruierter Typ, der <xref:System.Type.GetGenericTypeDefinition%2A> Methode ruft die generische Typdefinition zurück, erneut.  
  
 Verwenden der <xref:System.Type.IsGenericTypeDefinition%2A> Eigenschaft, um zu bestimmen, ob Sie neue Typen aus dem aktuellen Typ erstellen können. Wenn die <xref:System.Type.IsGenericTypeDefinition%2A> -Eigenschaft gibt `true`, rufen Sie die <xref:System.Type.MakeGenericType%2A> Methode, um die neuen generischen Typen erstellen.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt Informationen zu einem Typ, einschließlich, und zwar unabhängig davon, ob es sich um eine generische Typdefinition ist. Informationen werden für einen konstruierten Typ, für die generische Typdefinition, und einem normalen Typ angezeigt.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflektion und generische Typen</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Vorgehensweise: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> ein <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />-Attribut hat, was bedeutet, dass er aus einer COM-Typbibliothek importiert wurde.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Type" /> ein <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> hat, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die Definition des generischen Typs aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft wird bestimmt durch `MyGenericType<T>.`  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o">Das mit dem aktuellen Typ zu vergleichende Objekt.</param>
        <summary>Bestimmt, ob das angegebene Objekt eine Instanz des aktuellen <see cref="T:System.Type" /> ist.</summary>
        <returns><see langword="true" />, wenn der aktuelle <see langword="Type" /> in der Vererbungshierarchie des von <paramref name="o" /> dargestellten Objekts vorhanden ist oder wenn der aktuelle <see langword="Type" /> eine Schnittstelle ist, die von <paramref name="o" /> implementiert wird. <see langword="false" />, wenn keine dieser Bedingungen zutrifft, wenn <paramref name="o" /> den Wert <see langword="null" /> hat oder wenn der aktuelle <see langword="Type" /> ein offener generischer Typ ist (d. h. <see cref="P:System.Type.ContainsGenericParameters" /> gibt <see langword="true" /> zurück).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
> [!NOTE]
>  Ein konstruierter Typ ist keine Instanz der generischen Typdefinition. D. h. `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) ist keine Instanz des `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `IsInstanceOfType`-Methode gezeigt.  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> eine Schnittstelle ist, d. h. weder eine Klasse noch ein Werttyp.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> eine Schnittstelle ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> kennzeichnet eine Typdeklaration als Klasse, Schnittstelle oder eines Werttyps.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Schnittstelle, überprüft, ob der Schnittstellentyp und gibt an, ob eine Klasse verfügt über die `IsInterface` Eigenschaftensatz.  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Felder des aktuellen Typs sequenziell angelegt werden, in der Reihenfolge, in der sie definiert oder an die Metadaten ausgegeben wurden.</summary>
        <value><see langword="true" />, wenn die <see cref="P:System.Type.Attributes" />-Eigenschaft des aktuellen Typs <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /> umfasst; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist zur Vereinfachung bereitgestellt. Alternativ können Sie die <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> Enumerationswert, der die Attribute des Typs Layout und anschließend testen Sie, ob wählen <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> festgelegt ist. Die <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, und <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> Enumerationswerte geben die Möglichkeit, die die Felder des Typs im Arbeitsspeicher angeordnet werden.  
  
 Für dynamische Typen können Sie angeben <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> beim Erstellen des Typs. Im Code, gelten die <xref:System.Runtime.InteropServices.StructLayoutAttribute> -Attribut mit der <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> Enumerationswert, der Typ, um anzugeben, das Layout ist sequenziell.  
  
> [!NOTE]
>  Können keine der <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> Methode, um zu bestimmen, ob die <xref:System.Runtime.InteropServices.StructLayoutAttribute> auf einen Typ angewendet wurde.  
  
 Weitere Informationen finden Sie in Abschnitt 9.1.2 der Spezifikation für die Common Language Infrastructure (CLI)-Dokumentation "Partition II: Metadatendefinition and Semantics". Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](https://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](https://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die Definition des generischen Typs aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Instanz einer Klasse für den die <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> Enumerationswert in der <xref:System.Runtime.InteropServices.StructLayoutAttribute> -Klasse festgelegt wurde, überprüft, ob die <xref:System.Type.IsLayoutSequential%2A> -Eigenschaft, und zeigt das Ergebnis.  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">Metadaten und selbstbeschreibende Komponenten</related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> als Verweis gemarshallt wird.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis gemarshallt wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt die `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, und <xref:System.Type.IsPrimitive%2A> Eigenschaften der <xref:System.Type> Klasse. Er überprüft, ob der angegebene Typ in den Kontext aufgenommen werden kann, ob es als Verweis gemarshallt werden kann und ob der Typ ein primitiver Datentyp ist.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert die <see cref="P:System.Type.IsMarshalByRef" />-Eigenschaft und bestimmt, ob der <see cref="T:System.Type" /> als Verweis gemarshallt wird.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis gemarshallt wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob der angegebene Typ als Verweis gemarshallt wird und das Ergebnis wird angezeigt.  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das aktuelle <see cref="T:System.Type" />-Objekt einen Typ darstellt, dessen Definition in der Definition eines anderen Typs geschachtelt ist.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Type" /> in einem anderen Typ geschachtelt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.IsNested%2A> -Eigenschaft gibt `true` für alle geschachtelten Typen, unabhängig der Sichtbarkeit. Um zur gleichen Zeit für die Schachtelung und Sichtbarkeit zu testen, verwenden Sie die verwandten Eigenschaften <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, oder <xref:System.Type.IsNestedPublic%2A>.  
  
> [!NOTE]
>  Die <xref:System.Reflection.TypeAttributes.VisibilityMask> Enumerationsmember wählt die Visibility-Attribute für einen Typ.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Arten von Sichtbarkeit. Klicken Sie dann den Wert einer Reihe von Sichtbarkeit im Zusammenhang abgerufen, <xref:System.Type> Eigenschaften für den übergeordneten Typ und jeder der geschachtelten Typen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Assembly sichtbar ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Assembly sichtbar ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wählt die Visibility-Attribute.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Arten von Sichtbarkeit. Klicken Sie dann den Wert einer Reihe von Sichtbarkeit im Zusammenhang abgerufen, <xref:System.Type> Eigenschaften für den übergeordneten Typ und jeder der geschachtelten Typen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die sowohl zur eigenen Familie als auch zur eigenen Assembly gehören.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die sowohl zur eigenen Familie als auch zur eigenen Assembly gehören, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wählt die Visibility-Attribute.  
  
> [!NOTE]
>  Die Sprachen c# und Visual Basic beinhalten keine Semantik, mit denen Sie einen geschachtelten Typ definieren, der nur für geschützte Typen in seiner eigenen Assembly sichtbar ist. `protected internal` Einblick in C# geschrieben und `Protected Friend` Sichtbarkeit in Visual Basic definiert einen geschachtelten Typ, der sowohl für geschützte Typen und Typen in der gleichen Assembly sichtbar ist.  
  
 Ein <xref:System.Type> des Objekts-Familie wird definiert als alle Objekte des gleichen <xref:System.Type> und seiner Untertypen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Arten von Sichtbarkeit. Klicken Sie dann den Wert einer Reihe von Sichtbarkeit im Zusammenhang abgerufen, <xref:System.Type> Eigenschaften für den übergeordneten Typ und jeder der geschachtelten Typen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Familie sichtbar ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Familie sichtbar ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wählt die Visibility-Attribute.  
  
 Ein <xref:System.Type> des Objekts-Familie wird definiert als alle Objekte der genauen gleichen <xref:System.Type> und seiner Untertypen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Arten von Sichtbarkeit. Klicken Sie dann den Wert einer Reihe von Sichtbarkeit im Zusammenhang abgerufen, <xref:System.Type> Eigenschaften für den übergeordneten Typ und jeder der geschachtelten Typen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die zur eigenen Familie oder zur eigenen Assembly gehören.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die zur eigenen Familie oder zur eigenen Assembly gehören, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Sichtbarkeit eines Typs ist `protected internal` in c# oder `Protected Friend` in Visual Basic die <xref:System.Type.IsNestedFamORAssem%2A> -Eigenschaft gibt `true`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wählt die Visibility-Attribute.  
  
 Ein <xref:System.Type> des Objekts-Familie wird definiert als alle Objekte der genauen gleichen <xref:System.Type> und seiner Untertypen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Arten von Sichtbarkeit. Klicken Sie dann den Wert einer Reihe von Sichtbarkeit im Zusammenhang abgerufen, <xref:System.Type> Eigenschaften für den übergeordneten Typ und jeder der geschachtelten Typen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und als privat deklariert ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und als privat deklariert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wählt die Visibility-Attribute.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Arten von Sichtbarkeit. Klicken Sie dann den Wert einer Reihe von Sichtbarkeit im Zusammenhang abgerufen, <xref:System.Type> Eigenschaften für den übergeordneten Typ und jeder der geschachtelten Typen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine Klasse geschachtelt und als öffentlich deklariert ist.</summary>
        <value><see langword="true" />, wenn die Klasse geschachtelt und als öffentlich deklariert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wählt die Visibility-Attribute.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Arten von Sichtbarkeit. Klicken Sie dann den Wert einer Reihe von Sichtbarkeit im Zusammenhang abgerufen, <xref:System.Type> Eigenschaften für den übergeordneten Typ und jeder der geschachtelten Typen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> nicht als öffentlich deklariert ist.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Type" /> nicht als öffentlich deklariert und kein geschachtelter Typ ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft nicht geschachtelten Typen. Verwenden Sie die <xref:System.Type.IsNestedPublic%2A> Eigenschaft stattdessen.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft `false`.  
  
   
  
## Examples  
 Dieses Beispiel verwendet die `IsNotPublic` Eigenschaft, um die Sichtbarkeit des Typs abzurufen.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, warum Sie nicht verwenden können `IsPublic` und `IsNotPublic` für geschachtelte Klassen.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 Ignorieren Sie für geschachtelte Klassen, die Ergebnisse der `IsPublic` und `IsNotPublic` und achten Sie nur auf die Ergebnisse der `IsNestedPublic` und `IsNestedPrivate`. Die Ausgabe der Reflektion für dieses Codefragment würde wie folgt lauten:  
  
|Klasse|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|A|false|true|false|false|  
|B|false|false|true|false|  
|C|false|false|false|true|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> ein Zeiger ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> ein Zeiger ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ oder einen Typparameter in der Definition eines generischen Typs oder generische Methode muss diese Eigenschaft gibt immer `false`.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der `IsPointer` Eigenschaft.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsPointer" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein Zeiger ist.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Type" /> ein Zeiger ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> zu den primitiven Typen gehört.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> zu den primitiven Typen gehört, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die primitiven Typen sind <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, und <xref:System.Single>.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ oder einen Typparameter in der Definition eines generischen Typs oder generische Methode muss diese Eigenschaft gibt immer `false`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, und <xref:System.Type.IsPrimitive%2A> Eigenschaften der <xref:System.Type> Klasse. Er überprüft, ob der angegebene Typ in den Kontext aufgenommen werden kann, ob es als Verweis gemarshallt werden kann und ob der Typ ein primitiver Datentyp ist.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsPrimitive" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> zu den primitiven Typen gehört.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Type" /> zu den primitiven Typen gehört, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die primitiven Typen sind <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, und <xref:System.Single>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob der angegebene Typ ein primitiver Typ ist, und das Ergebnis wird angezeigt.  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> als öffentlich deklariert ist.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Type" /> als öffentlich deklariert und kein geschachtelter Typ ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie keine geschachtelten Typen. Verwenden Sie <xref:System.Type.IsNestedPublic%2A> stattdessen.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft `true`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wählt die Visibility-Attribute.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Instanz von `MyTestClass`, überprüft, ob die `IsPublic` -Eigenschaft, und das Ergebnis wird angezeigt.  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 Ignorieren Sie für geschachtelte Klassen, die Ergebnisse der `IsPublic` und `IsNotPublic` und achten Sie nur auf die Ergebnisse der <xref:System.Type.IsNestedPublic%2A> und <xref:System.Type.IsNestedPrivate%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> als versiegelt deklariert ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> als versiegelt deklariert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `true`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Instanz von einem `sealed` Klasse, sucht die `IsSealed` -Eigenschaft, und zeigt das Ergebnis.  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist und daher wichtige Vorgänge ausführen darf.</summary>
        <value><see langword="true" />, wenn der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist, <see langword="false" />, wenn er sicherheitstransparent ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, und <xref:System.Type.IsSecurityTransparent%2A> Eigenschaften melden die Transparenzebene eines Typs mit der aktuellen Vertrauensebene an, wie durch die common Language Runtime (CLR) festgelegt. Die Kombinationen dieser Eigenschaften werden in der folgenden Tabelle dargestellt:  
  
|Sicherheitsstufe|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Kritisch|`true`|`false`|`false`|  
|Safe ist kritisch|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.  
  
> [!IMPORTANT]
>  Für teilweise vertrauenswürdigen Assemblys ist der Wert dieser Eigenschaft hängt von der aktuellen Vertrauensebene der Assembly. Wenn die Assembly in einer teilweise vertrauenswürdigen Anwendungsdomäne (z. B. in einer Sandkastenanwendungsdomäne) geladen wird, ignoriert die Laufzeit die sicherheitsanmerkungen der Assembly. Die Assembly und alle seine Typen werden als transparent behandelt. Die Runtime achtet auf den der sicherheitsanmerkungen einer teilweise vertrauenswürdigen Assembly an, nur, wenn die Assembly in eine voll vertrauenswürdige Anwendungsdomäne (z. B. in der Standardanwendungsdomäne einer Desktopanwendung) geladen ist. Im Gegensatz dazu ist eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) immer mit voller Vertrauenswürdigkeit unabhängig von der Vertrauensebene der Anwendungsdomäne geladen, damit der aktuellen Vertrauensebene immer voll vertrauenswürdig ist. Sie können die aktuellen Vertrauensebenen von Assemblys und Anwendungsdomänen bestimmen, mit der <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> und <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> Eigenschaften.  
  
 Weitere Informationen über Reflektion und Transparenz finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Weitere Informationen zur Transparenz, finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Sicherheitsüberlegungen für die Reflektion</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Änderungen der Sicherheit in .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist, d. h. ob er wichtige Vorgänge ausführen darf und ob von transparentem Code auf ihn zugegriffen werden kann.</summary>
        <value><see langword="true" />, wenn der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist, <see langword="false" /> wenn er sicherheitstransparent oder sicherheitsrelevant ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, und <xref:System.Type.IsSecurityTransparent%2A> Eigenschaften melden die Transparenzebene eines Typs mit der aktuellen Vertrauensebene an, wie durch die common Language Runtime (CLR) festgelegt. Die Kombinationen dieser Eigenschaften werden in der folgenden Tabelle dargestellt:  
  
|Sicherheitsstufe|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Kritisch|`true`|`false`|`false`|  
|Safe ist kritisch|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.  
  
> [!IMPORTANT]
>  Für teilweise vertrauenswürdigen Assemblys ist der Wert dieser Eigenschaft hängt von der aktuellen Vertrauensebene der Assembly. Wenn die Assembly in einer teilweise vertrauenswürdigen Anwendungsdomäne (z. B. in einer Sandkastenanwendungsdomäne) geladen wird, ignoriert die Laufzeit die sicherheitsanmerkungen der Assembly. Die Assembly und alle seine Typen werden als transparent behandelt. Die Runtime achtet auf den der sicherheitsanmerkungen einer teilweise vertrauenswürdigen Assembly an, nur, wenn die Assembly in eine voll vertrauenswürdige Anwendungsdomäne (z. B. in der Standardanwendungsdomäne einer Desktopanwendung) geladen ist. Im Gegensatz dazu ist eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) immer mit voller Vertrauenswürdigkeit unabhängig von der Vertrauensebene der Anwendungsdomäne geladen, damit der aktuellen Vertrauensebene immer voll vertrauenswürdig ist. Sie können die aktuellen Vertrauensebenen von Assemblys und Anwendungsdomänen bestimmen, mit der <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> und <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> Eigenschaften.  
  
 Weitere Informationen über Reflektion und Transparenz finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Weitere Informationen zur Transparenz, finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Sicherheitsüberlegungen für die Reflektion</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Änderungen der Sicherheit in .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitstransparent ist und daher keine wichtigen Vorgänge ausführen kann.</summary>
        <value><see langword="true" />, wenn der Typ auf der aktuellen Vertrauensebene sicherheitstransparent ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft gibt `true`, <xref:System.Type.IsSecurityCritical%2A> und <xref:System.Type.IsSecuritySafeCritical%2A> Eigenschaften zurückgeben `false`.  
  
 Die <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, und <xref:System.Type.IsSecurityTransparent%2A> Eigenschaften melden die Transparenzebene eines Typs mit der aktuellen Vertrauensebene an, wie durch die common Language Runtime (CLR) festgelegt. Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.  
  
> [!IMPORTANT]
>  Für teilweise vertrauenswürdigen Assemblys ist der Wert dieser Eigenschaft hängt von der aktuellen Vertrauensebene der Assembly. Wenn die Assembly in einer teilweise vertrauenswürdigen Anwendungsdomäne (z. B. in einer Sandkastenanwendungsdomäne) geladen wird, ignoriert die Laufzeit die sicherheitsanmerkungen der Assembly. Die Assembly und alle seine Typen werden als transparent behandelt. Die Runtime achtet auf den der sicherheitsanmerkungen einer teilweise vertrauenswürdigen Assembly an, nur, wenn die Assembly in eine voll vertrauenswürdige Anwendungsdomäne (z. B. in der Standardanwendungsdomäne einer Desktopanwendung) geladen ist. Im Gegensatz dazu ist eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) immer mit voller Vertrauenswürdigkeit unabhängig von der Vertrauensebene der Anwendungsdomäne geladen, damit der aktuellen Vertrauensebene immer voll vertrauenswürdig ist. Sie können die aktuellen Vertrauensebenen von Assemblys und Anwendungsdomänen bestimmen, mit der <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> und <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> Eigenschaften.  
  
 Weitere Informationen über Reflektion und Transparenz finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Weitere Informationen zur Transparenz, finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Sicherheitsüberlegungen für die Reflektion</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Änderungen der Sicherheit in .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> serialisierbar ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> serialisierbar ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Typen, die in .NET Standard definiert sind nicht gekennzeichnet sind, mit <xref:System.SerializableAttribute>. Stattdessen bestimmt jeder .NET Implementierung, ob ein Typ serialisierbar ist. Zur Laufzeit können Sie die <xref:System.Type.IsSerializable%2A> Eigenschaft, um zu bestimmen, ob diese Implementierung unterstützt die Serialisierung einer Instanz des Typs. Weitere Informationen und ein Beispiel finden Sie unter [so bestimmen, ob ein .NET Standard-Objekt serialisierbar ist](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die Definition des generischen Typs aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Instanz von `MyTestClass` -Klasse, die [Serializable]-Attribut festgelegt, und überprüft die `IsSerializable` -Eigenschaft für `true` oder `false`.  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Typ einen Namen besitzt, der eine Sonderbehandlung erfordert.</summary>
        <value><see langword="true" />, wenn der Typ einen Namen besitzt, der eine Sonderbehandlung erfordert, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Namen, die mit beginnen oder einen Unterstrich (_), Eigenschaftenaccessoren und Überladen von Methoden enthalten, sind Beispiele für Typen, die von einigen Compilern möglicherweise eine besondere Behandlung erfordern.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die Definition des generischen Typs aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c">Der Typ, der mit dem aktuellen Typ verglichen werden soll.</param>
        <summary>Bestimmt, ob der aktuelle <see cref="T:System.Type" /> vom angegebenen <see cref="T:System.Type" /> abgeleitet ist.</summary>
        <returns><see langword="true" />, wenn der aktuelle <see langword="Type" /> von <paramref name="c" /> abgeleitet ist, andernfalls <see langword="false" />. Diese Methode gibt auch dann <see langword="false" /> zurück, wenn <paramref name="c" /> und der aktuelle <see langword="Type" /> gleich sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Type.IsSubclassOf%2A> Methode, um eine der folgenden festzulegen:  
  
-   Gibt an, ob eine Klasse von einem anderen abgeleitet ist.  
  
-   Ob ein Typ abgeleitet <xref:System.ValueType>. Allerdings die <xref:System.Type.IsValueType%2A> ist eine effizientere Möglichkeit zu bestimmen, ob ein Typ ein Werttyp ist.  
  
-   Ob ein Typ abgeleitet <xref:System.Enum>. Allerdings die <xref:System.Type.IsEnum%2A> Methode ist eine effizientere Möglichkeit zu bestimmen, ob ein Typ eine Enumeration ist.  
  
-   Gibt an, ob ein Typ einen Delegaten, also ist, ob es entweder abgeleitet <xref:System.Delegate> oder <xref:System.MulticastDelegate>.  
  
 Die <xref:System.Type.IsSubclassOf%2A> Methode kann nicht verwendet werden, um zu bestimmen, ob eine Schnittstelle von einer anderen Schnittstelle abgeleitet wird, oder gibt an, ob eine Klasse eine Schnittstelle implementiert. Verwenden der <xref:System.Type.IsAssignableFrom%2A> -Methode für diesen Zweck, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter darstellt in der Definition einer generischen Typ-oder Methodendefinition, abgeleitet aus der Class-Einschränkung oder <xref:System.Object?displayProperty=nameWithType> keine klasseneinschränkung verfügt.  
  
> [!NOTE]
>  Außer in Verbindung mit Schnittstellen, <xref:System.Type.IsSubclassOf%2A> ist die Umkehrung von <xref:System.Type.IsAssignableFrom%2A>. D. h. wenn `t1.IsSubclassOf(t2)` ist `true`, klicken Sie dann `t2.IsAssignableFrom(t1)` auch `true`.  
  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Klasse namens `Class1` und eine abgeleitete Klasse, die mit dem Namen `DerivedC1`. Ruft die <xref:System.Type.IsSubclassOf%2A> Methode, um anzugeben, dass `DerivedC1` ist eine Unterklasse von `Class1`.  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> ist <see langword="null" />.</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob für <see langword="UnicodeClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist.</summary>
        <value><see langword="true" />, wenn für <see langword="UnicodeClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.TypeAttributes.StringFormatMask> wird verwendet, um die Attribute der Zeichenfolge-Format auszuwählen. Die Zeichenfolge Formatattribute zur Verbesserung der Interoperabilität von definieren, wie Zeichenfolgen interpretiert werden soll.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die Definition des generischen Typs aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> ein Werttyp ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> ein Werttyp ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Werttypen sind Datentypen, die als Sequenzen von Bits dargestellt werden. Werttypen sind keine Klassen oder Schnittstellen. Werttypen werden als "struct" in einigen Programmiersprachen bezeichnet. Enumerationen sind ein Sonderfall von Werttypen.  
  
 Diese Eigenschaft gibt `false` für die <xref:System.ValueType> Klasse, da <xref:System.ValueType> ist kein Werttyp selbst. Es ist die Basisklasse für alle Typen mit Werten aus, und daher kann jeder Werttyp zugewiesen werden, damit. Dies wäre nicht möglich, wenn <xref:System.ValueType> selbst wurde ein Werttyp. Werttypen sind geschachtelt, wenn sie ein Feld des Typs zugewiesen werden <xref:System.ValueType>.  
  
 Diese Eigenschaft gibt `true` für Enumerationen, aber nicht für die <xref:System.Enum> -Typ selbst. Ein Beispiel zur Veranschaulichung dieses Verhaltens finden Sie unter <xref:System.Type.IsEnum%2A>.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Variable vom Typ `MyEnum`, überprüft, ob die `IsValueType` -Eigenschaft, und das Ergebnis wird angezeigt.  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert die <see cref="P:System.Type.IsValueType" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein Werttyp ist, also weder eine Klasse noch eine Schnittstelle.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Type" /> ein Werttyp ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird bereitgestellt, um die Implementierung von anderen Systemen zu aktivieren. Es wird nicht in der Regel im Anwendungscode verwendet.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob auf den <see cref="T:System.Type" /> aus Code von außerhalb der Assembly zugegriffen werden kann.</summary>
        <value><see langword="true" />, wenn der aktuelle <see cref="T:System.Type" /> ein öffentlicher Typ oder ein öffentlicher geschachtelter Typ ist, sodass alle einschließenden Typen öffentlich sind, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um zu bestimmen, ob ein Teil der öffentlichen Schnittstelle einer Komponente-Assembly ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft, zwei Klassen, von denen nur, die eine außerhalb der Assembly sichtbar ist.  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein Array des aktuellen Typs darstellt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein eindimensionales Array vom aktuellen Typ mit einer unteren Grenze von 0 (null) darstellt.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das ein eindimensionales Array vom aktuellen Typ mit einer unteren Grenze von 0 (null) darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.MakeArrayType%2A> Methode bietet eine Möglichkeit zum Generieren von Arraytypen, deren Elementtypen werden zur Laufzeit berechnet.  
  
 **Beachten Sie** die common Language Runtime wird unterschieden zwischen Vektoren (d. h. eindimensionale Arrays, die immer nullbasiert sind) und mehrdimensionale Arrays. Ein Vektor, der immer nur eine Dimension hat, ist nicht identisch mit der ein mehrdimensionales Array, das nur eine Dimension besitzt. Überladung dieser Methode kann nur zum Erstellen von vektortypen verwendet werden, und es ist die einzige Möglichkeit, einen Vector-Typ zu erstellen. Verwenden der <xref:System.Type.MakeArrayType%28System.Int32%29> -methodenüberladung, um mehrdimensionale von Arraytypen zu erstellen.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt Array `ref` (`ByRef` in Visual Basic), und Zeigertypen für die `Test` Klasse.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt. Abgeleitete Klassen müssen eine Implementation angeben.</exception>
        <exception cref="T:System.TypeLoadException">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.  
  
- oder -  
Der aktuelle Typ ist ein <see langword="ByRef" />-Typ. Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rank">Die Anzahl von Dimensionen für das Array. Diese Zahl muss kleiner oder gleich 32 sein.</param>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein Array vom aktuellen Typ mit der angegebenen Anzahl von Dimensionen darstellt.</summary>
        <returns>Ein Objekt, das ein Array vom aktuellen Typ mit der angegebenen Anzahl von Dimensionen darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.MakeArrayType%2A> Methode bietet eine Möglichkeit zum Generieren von Arraytypen, deren Elementtypen werden zur Laufzeit berechnet.  
  
> [!NOTE]
>  Die common Language Runtime wird unterschieden zwischen Vektoren (d. h. eindimensionale Arrays, die immer nullbasiert sind) und mehrdimensionale Arrays. Ein Vektor, der immer nur eine Dimension hat, ist nicht identisch mit der ein mehrdimensionales Array, das nur eine Dimension besitzt. Überladung dieser Methode können keine vektortyp erstellen; Wenn `rank` ist 1, Überladung dieser Methode gibt einen mehrdimensionales Array-Typ, der eine Dimension besitzt. Verwenden der <xref:System.Type.MakeArrayType> -methodenüberladung, um die vektortypen zu erstellen.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt Array `ref` (`ByRef` in Visual Basic), und Zeigertypen für die `Test` Klasse.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="rank" /> ist ungültig. Beispielsweise 0 oder ein negativer Wert.</exception>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</exception>
        <exception cref="T:System.TypeLoadException">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.  
  
- oder -  
Der aktuelle Typ ist ein <see langword="ByRef" />-Typ. Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.  
  
- oder -  
 <paramref name="rank" /> ist größer als 32.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das beim Übergeben als <see langword="ref" />-Parameter (<see langword="ByRef" />-Parameter in Visual Basic) den aktuellen Typ darstellt.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das beim Übergeben als <see langword="ref" />-Parameter (<see langword="ByRef" />-Parameter in Visual Basic) den aktuellen Typ darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.MakeByRefType%2A> Methode bietet eine Möglichkeit zum generieren `ref` Typen (`ByRef` in Visual Basic) für Parameter aufgeführt.  
  
 Verwenden die Syntax der Microsoft intermediate Language (MSIL), wenn die aktuelle <xref:System.Type> -Objekt stellt <xref:System.Int32>, diese Methode gibt eine <xref:System.Type> Objekt darstellt `Int32&`.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt Array `ref` (`ByRef` in Visual Basic), und Zeigertypen für die `Test` Klasse.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</exception>
        <exception cref="T:System.TypeLoadException">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.  
  
- oder -  
Der aktuelle Typ ist ein <see langword="ByRef" />-Typ. Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericSignatureType">
      <MemberSignature Language="C#" Value="public static Type MakeGenericSignatureType (Type genericTypeDefinition, params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericSignatureType(class System.Type genericTypeDefinition, class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericSignatureType(System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericSignatureType (genericTypeDefinition As Type, ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericSignatureType(Type ^ genericTypeDefinition, ... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="static member MakeGenericSignatureType : Type * Type[] -&gt; Type" Usage="System.Type.MakeGenericSignatureType (genericTypeDefinition, typeArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericTypeDefinition" Type="System.Type" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeArguments" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="genericTypeDefinition">To be added.</param>
        <param name="typeArguments">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Ein Array von Typen, die die Typparameter des aktuellen generischen Typs ersetzen sollen.</param>
        <summary>Ersetzt die Typparameter der aktuellen generischen Typdefinition durch die Elemente eines Arrays von Typen und gibt ein <see cref="T:System.Type" />-Objekt zurück, das den resultierenden konstruierten Typ darstellt.</summary>
        <returns>Ein <see cref="T:System.Type" />, der den konstruierten Typ darstellt, der durch Ersetzen der Typparameter des aktuellen generischen Typs durch die Elemente von <paramref name="typeArguments" /> erstellt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.MakeGenericType%2A> Methode können Sie Code schreiben, der spezifische Typen zugewiesen werden, um die Typparameter einer generischen Typdefinition, wodurch eine <xref:System.Type> -Objekt, das einen bestimmten konstruierten Typ darstellt. Sie können dies verwenden <xref:System.Type> Objekt, das zur Laufzeit Instanzen des konstruierten Typs zu erstellen.  
  
 Typen mit erstellt <xref:System.Type.MakeGenericType%2A> geöffnet sein können, das heißt, einige ihrer Typargumente Typparameter von einschließenden generischen Methoden und Typen sein kann. Sie können solche offenen konstruierten Typen verwenden, wenn Sie dynamische Assemblys ausgeben. Betrachten Sie z. B. die Klassen `Base` und `Derived` in den folgenden Code.  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 Zum generieren `Derived` in eine dynamische Assembly, ist es erforderlich, um den Basistyp zu erstellen. Zu diesem Zweck rufen Sie die <xref:System.Type.MakeGenericType%2A> Methode für eine <xref:System.Type> Objekt, das die Klasse darstellt `Base`, verwenden die generischen Typargumente <xref:System.Int32> und der Typparameter `V` aus `Derived`. Da beide Typen und generische Typparameter durch dargestellt werden <xref:System.Type> Objekte, die ein Array mit diesen beiden kann übergeben werden, um die <xref:System.Type.MakeGenericType%2A> Methode.  
  
> [!NOTE]
>  Ein konstruierter Typ wie z. B. `Base<int, V>` ist nützlich, wenn Code ausgegeben, aber Sie können nicht aufgerufen werden die <xref:System.Type.MakeGenericType%2A> Methode für diesen Typ da es sich nicht um eine generische Typdefinition ist. Um einen geschlossenen konstruierten Typ zu erstellen, die instanziiert werden kann, rufen Sie zuerst die <xref:System.Type.GetGenericTypeDefinition%2A> -Methode zum Abrufen einer <xref:System.Type> Objekt, das die generische Typdefinition darstellt, und rufen Sie anschließend <xref:System.Type.MakeGenericType%2A> mit den gewünschten Typargumenten.  
  
 Die <xref:System.Type> zurückgegebenes Objekt <xref:System.Type.MakeGenericType%2A> ist identisch mit der <xref:System.Type> durch den Aufruf der <xref:System.Object.GetType%2A> Methode den resultierenden konstruierten Typ, oder die <xref:System.Object.GetType%2A> -Methode einer jeglichen konstruierter Typ, der aus der gleichen generischen erstellt wurde Geben Sie die Definition, die mit den gleichen Argumenten des Typs.  
  
> [!NOTE]
>  Ein Array von generischen Typen ist selbst ein generischer Typ. Sie können nicht aufrufen <xref:System.Type.MakeGenericType%2A> Geben Sie auf ein Array wie z. B. `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic). Erstellen Sie einen geschlossenen generischen Typ von `C<T>[]`, rufen Sie <xref:System.Type.GetElementType%2A> zum Abrufen der generischen Typdefinition `C<T>`; Aufrufen <xref:System.Type.MakeGenericType%2A> auf die Definition des generischen Typs auf den konstruierten Typ zu erstellen, und rufen Sie schließlich die <xref:System.Type.MakeArrayType%2A> Methode für Der konstruierte Typ zum Erstellen des Arraytyps. Das gleiche gilt für Zeigertypen und `ref` Typen (`ByRef` in Visual Basic).  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
## <a name="nested-types"></a>Geschachtelte Typen  
 Wenn ein generischer Typ mit c#, C++ oder Visual Basic definiert ist, sind seine geschachtelten Typen alle generisch. Dies gilt auch, wenn die geschachtelten Typen keine eigenen Typparameter verfügen, da alle drei Sprachen die Typparameter von einschließenden Typen in den Typparameterlisten von geschachtelten Typen enthalten. Betrachten Sie die folgenden Klassen:  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 Der Typparameterliste der geschachtelten Klasse `Inner` verfügt über zwei Typparameter, `T` und `U`, das erste Argument ist der Typparameter seiner einschließenden Klasse. Auf ähnliche Weise der Typparameterliste der geschachtelten Klasse `Innermost1` verfügt über drei Typparameter, `T`, `U`, und `V`, mit `T` und `U` stammen aus den einschließenden Klassen. Die geschachtelte Klasse `Innermost2` verfügt über zwei Typparameter, `T` und `U`, das den einschließenden Klassen stammen.  
  
 Wenn die Parameterliste des einschließenden Typs mehrere Typparameter aufweist, sind alle Typparameter in der Reihenfolge, in der Typparameterliste des geschachtelten Typs enthalten.  
  
 Um einen generischen Typ aus der generischen Typdefinition für einen geschachtelten Typ zu konstruieren, rufen die <xref:System.Type.MakeGenericType%2A> Methode mit dem Array formatiert, durch die Verkettung von Arrays Argument Typ aller einschließenden Typen, ab der äußersten generische Typ, und bis hin zu den Geben Sie Argumentarray des geschachtelten Typs selbst, wenn es einen eigenen Typparameter aufweist. Zum Erstellen einer Instanz von `Innermost1`, rufen Sie die <xref:System.Type.MakeGenericType%2A> -Methode mit einem Array von drei Typen, T, U und V zugewiesen werden soll. Zum Erstellen einer Instanz von `Innermost2`, rufen Sie die <xref:System.Type.MakeGenericType%2A> -Methode mit einem Array von Typen, T und u zugewiesen werden  
  
 Die Sprachen weitergegeben werden, die Typparameter von einschließenden Typen auf diese Weise, sodass Sie die Typparameter eines einschließenden Typs verwenden können, um Felder von geschachtelten Typen zu definieren. Andernfalls wäre die Typparameter nicht im Gültigkeitsbereich des Hauptteils der geschachtelten Typen. Es ist möglich, geschachtelte Typen zu definieren, ohne die Weitergabe der Typparameter von einschließenden Typen, durch das Ausgeben von Code in dynamischen Assemblys oder mithilfe der [Ilasm.exe (IL-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md). Betrachten Sie den folgenden Code aus, für die MSIL-Assembler:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 In diesem Beispiel ist es nicht möglich, definieren Sie ein Feld vom Typ `T` oder `U` in Klasse `Innermost`, da die Typparameter nicht im Gültigkeitsbereich befinden. Der folgende Assemblercode definiert die geschachtelte Klassen, die das zu erreichen, die bei der in C++, Visual Basic und C#-Definition:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 Sie können die [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) geschachtelte Klassen, die in der allgemeinen Sprachen definiert und untersuchen durch dieses Benennungsschema.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Type.MakeGenericType%2A> Methode zum Erstellen von eines konstruierten Typs aus der generischen Typdefinition für den <xref:System.Collections.Generic.Dictionary%602> Typ. Den konstruierte Typ darstellt, ein <xref:System.Collections.Generic.Dictionary%602> von `Test` Objekte mit Zeichenfolgenschlüsseln.  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Typ stellt keine generische Typdefinition dar. Das heißt, <see cref="P:System.Type.IsGenericTypeDefinition" /> gibt <see langword="false" /> zurück.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArguments" /> ist <see langword="null" />.  
  
- oder -  
Ein beliebiges Element von <paramref name="typeArguments" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente im <paramref name="typeArguments" /> entspricht nicht der Anzahl von Typparametern in der aktuellen generischen Typdefinition.  
  
- oder -  
Ein beliebiges Element von <paramref name="typeArguments" /> erfüllt nicht die Einschränkungen, die für den entsprechenden Typparameter des aktuellen generischen Typs angegeben wurden.  
  
- oder -  
 <paramref name="typeArguments" /> enthält ein Element, das ein Zeigertyp (<see cref="P:System.Type.IsPointer" /> gibt <see langword="true" /> zurück), vom Typ „by-ref“ (<see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück) oder <see cref="T:System.Void" /> ist.</exception>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt. Abgeleitete Klassen müssen eine Implementation angeben.</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Reflektion und generische Typen</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Vorgehensweise: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das einen Zeiger auf den aktuellen Typ darstellt.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das einen Zeiger auf den aktuellen Typ darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.MakePointerType%2A> Methode bietet eine Möglichkeit zum Generieren von Zeigertypen für Parameterlisten.  
  
 Verwenden die Syntax der Microsoft intermediate Language (MSIL), wenn die aktuelle <xref:System.Type> -Objekt stellt <xref:System.Int32>, diese Methode gibt eine <xref:System.Type> Objekt darstellt `Int32*`.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt Array `ref` (`ByRef` in Visual Basic), und Zeigertypen für die `Test` Klasse.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</exception>
        <exception cref="T:System.TypeLoadException">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.  
  
- oder -  
Der aktuelle Typ ist ein <see langword="ByRef" />-Typ. Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Reflection.MemberTypes" />-Wert ab, der angibt, dass dieser Member ein Typ oder ein geschachtelter Typ ist.</summary>
        <value>Ein <see cref="T:System.Reflection.MemberTypes" />-Wert, der angibt, dass dieser Member ein Typ oder ein geschachtelter Typ ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft überschreibt <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>. Wenn Sie daher eine Reihe von untersuchen <xref:System.Reflection.MemberInfo> Objekte – z. B. das von zurückgegebene Array <xref:System.Type.GetMembers%2A> : die <xref:System.Reflection.MemberInfo.MemberType%2A> -Eigenschaft gibt <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> Wenn ein angegebenes Element ein geschachtelter Typ ist.  
  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die Definition des generischen Typs aus der der Typ konstruiert wurde. Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die `MemberType` Feld als Parameter an die `GetMember` Methode:  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt einen in den <see cref="T:System.Type" />-Informationen fehlenden Wert dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `Missing` Feld in einem Aufruf über Reflektion, um den Standardwert eines Parameters zu erhalten. Wenn die `Missing` Feld für einen Parameterwert übergeben, und es gibt keinen Standardwert für diesen Parameter ein <xref:System.ArgumentException> ausgelöst.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Verwendung der `Missing` Feld, eine Methode mit ihren Standardargumenten aufzurufen.  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 Dieser Code erzeugt die folgende Ausgabe:  
  
 eine = 10 b = 55.3 c = 12  
  
 eine = 10 b = 1.3 c = 1  
  
 eine = 10 b 1.2 c = 1 =  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Modul (die DLL) ab, in dem der aktuelle <see cref="T:System.Type" /> definiert ist.</summary>
        <value>Das Modul, in dem der aktuelle <see cref="T:System.Type" /> definiert ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gibt das Modul in der Definition des generischen Typs definiert wurde. Beispielsweise wird bei der Erstellung einer Instanz von `MyGenericStack<int>`, <xref:System.Type.Module%2A> -Eigenschaft für den konstruierten Typ gibt das Modul, in dem `MyGenericStack<T>` definiert ist.  
  
 Auf ähnliche Weise, wenn die aktuelle <xref:System.Type> stellt einen generischen Parameter `T`, diese Eigenschaft gibt die Assembly, die den generischen Typ enthält, die definiert `T`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, eine Verwendung von der <xref:System.Type.Namespace%2A> und `Module` Eigenschaften und die <xref:System.Type.ToString%2A> -Methode der <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Namen des aktuellen Typs ab.</summary>
        <value>Der Name des aktuellen Typs.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namespace von <see cref="T:System.Type" /> ab.</summary>
        <value>Der Namespace des <see cref="T:System.Type" />; <see langword="null" />, wenn die aktuelle Instanz über keinen Namespace verfügt oder einen generischen Parameter darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Namespace ist eine logische während der Entwurfszeit Benennung der Einfachheit halber, der hauptsächlich zum Definieren des Bereichs in einer Anwendung und Organisieren von Klassen und anderen Typen in einer hierarchischen Struktur. Vom Standpunkt der Runtime gibt es keine Namespaces.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierter generischen Typ darstellt, diese Eigenschaft gibt den Namespace, die generische Typdefinition enthält. Auf ähnliche Weise, wenn die aktuelle <xref:System.Type> stellt einen generischen Parameter `T`, diese Eigenschaft gibt den Namespace, die generische Typdefinition enthält, die definiert `T`.  
  
 Wenn die aktuelle <xref:System.Type> -Objekt einen generischen Parameter darstellt, gibt diese Eigenschaft `null`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, eine Verwendung von der `Namespace` und <xref:System.Type.Module%2A> Eigenschaften und die <xref:System.Type.ToString%2A> -Methode der <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Angeben vollständig gekennzeichneter Typnamen</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left">Das erste zu vergleichende Objekt.</param>
        <param name="right">Das zweite zu vergleichende Objekt.</param>
        <summary>Gibt an, ob zwei <see cref="T:System.Type" />-Objekte gleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left">Das erste zu vergleichende Objekt.</param>
        <param name="right">Das zweite zu vergleichende Objekt.</param>
        <summary>Gibt an, ob zwei <see cref="T:System.Type" />-Objekte ungleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Klassenobjekt ab, über das dieser Member abgerufen wurde.</summary>
        <value>Das <see langword="Type" />-Objekt, über das dieses <see cref="T:System.Type" />-Objekt abgerufen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für <xref:System.Type> Objekte, die der Wert dieser Eigenschaft ist immer identisch mit dem Wert, der die <xref:System.Type.DeclaringType%2A> Eigenschaft.  
  
   
  
## Examples  
 Dieses Beispiel zeigt den reflektierten Typ einer geschachtelten Klasse.  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">Der durch die Assembly bezeichnete Name des abzurufenden <see cref="T:System.Type" />.</param>
        <param name="throwIfNotFound"><see langword="true" />, damit eine <see cref="T:System.TypeLoadException" /> ausgelöst wird, wenn der Typ nicht gefunden wird. <see langword="false" />, damit <see langword="null" /> zurückgegeben wird, wenn der Typ nicht gefunden wird. Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle. Informationen finden Sie im Abschnitt für Ausnahmen.</param>
        <param name="ignoreCase"><see langword="true" />, um ohne Beachtung der Groß-/Kleinschreibung nach <paramref name="typeName" /> zu suchen; <see langword="false" />, um mit Beachtung der Groß-/Kleinschreibung nach <paramref name="typeName" /> zu suchen.</param>
        <summary>Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Dabei wird angegeben, ob bei der Suche die Groß- und Kleinschreibung berücksichtigt werden soll und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird. Der Typ wird für die Reflektion, nicht für Ausführung geladen.</summary>
        <returns>Der Typ mit dem angegebenen Namen, sofern gefunden, andernfalls <see langword="null" />. Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwIfNotFound" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird. In einigen Fällen wird unabhängig vom Wert von <paramref name="throwIfNotFound" /> eine Ausnahme ausgelöst. Informationen finden Sie im Abschnitt für Ausnahmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Assembly, die den Typ nicht in den ReflectionOnly-Kontext geladen ist, verwenden die <xref:System.Type.ReflectionOnlyGetType%2A> Methode ist gleichbedeutend mit dem ersten Laden der Assembly für die Reflektion, mit der <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> -Methode, und Laden Sie dann durch Aufrufen des Typs der der Assembly <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> Methode. Weitere Informationen zu Namen mit assemblyqualifikation finden Sie unter den <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> Eigenschaft. Weitere Informationen zum Angeben der Typnamen finden Sie unter den <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> -methodenüberladung.  
  
 Wenn die Assembly bereits für die Ausführung geladen ist, wird eine weitere Kopie in den ReflectionOnly Kontext geladen.  
  
 Die `throwIfNotFound` Parameter gibt an, was geschieht, wenn der Typ wurde nicht gefunden, und auch bestimmte andere Ausnahmebedingungen unterdrückt, wie im Abschnitt für Ausnahmen beschrieben. Einige Ausnahmen werden ausgelöst, unabhängig vom Wert der `throwIfNotFound`. Wenn die Assembly nicht gültig ist, z. B. eine <xref:System.BadImageFormatException> wird ausgelöst, selbst wenn `throwIfNotFound` ist `false`.  
  
 Weitere Informationen zu den ReflectionOnly Kontext verwenden, finden Sie unter [Vorgehensweise: Laden von Assemblys in den reflexionsbezogenen Kontext](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwIfNotFound" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.  
  
- oder -  
 <paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen. 
- oder -  
 <paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.  
  
- oder -  
 <paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.  
  
- oder -  
 <paramref name="typeName" /> stellt ein Array mit <see cref="T:System.TypedReference" />-Objekten dar.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> enthält keinen Assemblynamen.  
  
- oder -  
 <paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax (z.B. „MyType[,*,]“).  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
- oder -  
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwIfNotFound" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
- oder -  
Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Angeben vollständig gekennzeichneter Typnamen</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md">Vorgehensweise: Laden von Assemblys in den auf Reflektion beschränkten Kontext</related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> ab, der das Layout des aktuellen Typs beschreibt.</summary>
        <value>Ruft ein <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> ab, das den allgemeinen Layoutfunktionen des aktuellen Typs beschreibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> wird nicht zurückgegeben werden, indem die <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> Methode. Verwenden Sie stattdessen diese Eigenschaft, um sie zu erhalten.  
  
   
  
## Examples  
 Das folgende Codebeispiel definiert zunächst eine Klasse, einer Struktur und eine Struktur mit speziellen Layoutattribute (Strukturen innerhalb der Klasse geschachtelt sind). Anschließend wird die <xref:System.Type.StructLayoutAttribute%2A> -Eigenschaft zum Abrufen einer <xref:System.Runtime.InteropServices.StructLayoutAttribute> für jeden Typ, und zeigt die Eigenschaften der Attribute.  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="rgszNames">Das übergebene Array von zuzuordnenden Namen.</param>
        <param name="cNames">Die Anzahl der zuzuordnenden Namen.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</param>
        <param name="rgDispId">Das vom Aufrufer zugewiesene Array, das die IDs entsprechend den Namen empfängt.</param>
        <summary>Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetIDsOfNames`, finden Sie unter der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Die zurückzugebenden Typinformationen.</param>
        <param name="lcid">Der Gebietsschemabezeichner für die Typinformationen.</param>
        <param name="ppTInfo">Ein Zeiger auf das angeforderte Objekt mit den Typinformationen.</param>
        <summary>Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfo`, finden Sie unter der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Zeigt auf einen Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</param>
        <summary>Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfoCount`, finden Sie unter der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Bezeichnet den Member.</param>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</param>
        <param name="wFlags">Flags, die den Kontext des Aufrufs beschreiben.</param>
        <param name="pDispParams">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</param>
        <param name="pVarResult">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</param>
        <param name="pExcepInfo">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</param>
        <param name="puArgErr">Der Index des ersten Arguments mit einem Fehler.</param>
        <summary>Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::Invoke`, finden Sie unter der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see langword="String" /> zurück, der den Namen des aktuellen <see langword="Type" /> darstellt.</summary>
        <returns>Ein <see cref="T:System.String" />, der den Namen des aktuellen <see cref="T:System.Type" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den vollqualifizierten Namespace der common Language Runtime und den Namen für alle primitiven Typen. Z. B. die C#-Anweisung, `(long)0.Type().ToString()` "System. Int64" anstelle von "Int64" zurückgegeben.  
  
 Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ, der den Typ und seiner Typargumente durch Namespace und durch den geschachtelten Typ, aber nicht von der Assembly gekennzeichnet sind. Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode gibt den nicht qualifizierten Namen des Typparameters zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, eine Verwendung von der <xref:System.Type.Namespace%2A> und <xref:System.Type.Module%2A> Eigenschaften und die `ToString` -Methode der <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 Im folgenden Beispiel wird die Zeichenfolgen, die zurückgegeben werden, indem die <xref:System.Type.ToString%2A> Methode und die `Name`, <xref:System.Type.FullName%2A>, und <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaften.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Handle für den aktuellen <see cref="T:System.Type" /> ab.</summary>
        <value>Das Handle für den aktuellen <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` Kapselt einen Zeiger auf eine interne Datenstruktur, die den Typ darstellt. Dieses Handle ist während der Prozesslebensdauer eindeutig. Das Handle ist gültig, nur in der Anwendungsdomäne, in der sie abgerufen wurden.  
  
   
  
## Examples  
 Im folgenden Beispiel gibt das Handle des entsprechenden Typs zurück, und übergibt das Handle für eine Methode, die den Typ aus dem Handle abgerufen und angezeigt.  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Eigenschaft wird von .NET Compact Framework derzeit nicht unterstützt.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Initialisierer für den Typ ab.</summary>
        <value>Ein Objekt, das den Namen des Klassenkonstruktors von <see cref="T:System.Type" /> enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasseninitialisierer stehen auch über die <xref:System.Type.FindMembers%2A> -Methode, oder durch Überladungen der <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, und <xref:System.Type.GetConstructors%2A> Methoden, die <xref:System.Reflection.BindingFlags> als Parameter.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, gibt diese Eigenschaft `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt den von der Common Language Runtime bereitgestellten Typ an, der diesen Typ darstellt.</summary>
        <value>Der Systemtyp, der <see cref="T:System.Type" />zugrunde liegt.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>