<Type Name="Tuple&lt;T1,T2,T3,T4,T5,T6,T7,TRest&gt;" FullName="System.Tuple&lt;T1,T2,T3,T4,T5,T6,T7,TRest&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c4104fd3573b1019e77761503a22437044c8581f" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70461316" /></Metadata><TypeSignature Language="C#" Value="public class Tuple&lt;T1,T2,T3,T4,T5,T6,T7,TRest&gt; : IComparable, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Tuple`8&lt;T1, T2, T3, T4, T5, T6, T7, TRest&gt; extends System.Object implements class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.IComparable" />
  <TypeSignature Language="DocId" Value="T:System.Tuple`8" />
  <TypeSignature Language="VB.NET" Value="Public Class Tuple(Of T1, T2, T3, T4, T5, T6, T7, TRest)&#xA;Implements IComparable, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename TRest&gt;&#xA;public ref class Tuple : IComparable, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt; = class&#xA;    interface IStructuralEquatable&#xA;    interface IStructuralComparable&#xA;    interface IComparable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T1" />
    <TypeParameter Name="T2" />
    <TypeParameter Name="T3" />
    <TypeParameter Name="T4" />
    <TypeParameter Name="T5" />
    <TypeParameter Name="T6" />
    <TypeParameter Name="T7" />
    <TypeParameter Name="TRest" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T1">Der Typ der ersten Komponente des Tupels.</typeparam>
    <typeparam name="T2">Der Typ der zweiten Komponente des Tupels.</typeparam>
    <typeparam name="T3">Der Typ der dritten Komponente des Tupels.</typeparam>
    <typeparam name="T4">Der Typ der vierten Komponente des Tupels.</typeparam>
    <typeparam name="T5">Der Typ der fünften Komponente des Tupels.</typeparam>
    <typeparam name="T6">Der Typ der sechsten Komponente des Tupels.</typeparam>
    <typeparam name="T7">Der Typ der siebten Komponente des Tupels.</typeparam>
    <typeparam name="TRest">Ein beliebiges generisches <see langword="Tuple" />-Objekt, das die Typen der restlichen Komponenten des Tupels definiert.</typeparam>
    <summary>Stellt ein *n*-Tupel mit *n* größer oder gleich 8 dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Tupel ist eine Datenstruktur, die über eine bestimmte Anzahl und Sequenz von Werten verfügt. Die <xref:System.Tuple%608> -Klasse stellt ein *n*-Tupel mit acht oder mehr Komponenten dar.  
  
 Sie können ein <xref:System.Tuple%608> -Objekt mit genau acht Komponenten instanziieren, indem Sie <xref:System.Tuple.Create%2A?displayProperty=nameWithType> die statische-Methode aufrufen. Im folgenden Beispiel wird ein 8-Tupel (oktupel) erstellt, das Primzahlen enthält, die kleiner als 20 sind. Beachten Sie, dass der Typrückschluss verwendet wird, um den Typ der einzelnen Komponenten zu bestimmen.  
  
 [!code-csharp[System.Tuple.Create#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/createntuple.cs#17)]
 [!code-vb[System.Tuple.Create#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/createntuple.vb#17)]  
  
 Sie können auch ein n-Tuple-Objekt mit acht oder mehr Komponenten instanziieren, indem <xref:System.Tuple%608.%23ctor%2A> Sie den-Konstruktor aufrufen. Im folgenden Beispiel wird der <xref:System.Tuple%608.%23ctor%2A> -Konstruktor verwendet, um ein 8-Tupel zu erstellen, das dem im vorherigen Beispiel erstellten Tupel entspricht.  
  
 [!code-csharp[System.Tuple\`8.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.class/cs/octuple1.cs#1)]
 [!code-vb[System.Tuple\`8.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.class/vb/octuple1.vb#1)]  
  
> [!NOTE]
>  Wenn Sie ein n-Tupel mit neun oder mehr Komponenten erstellen möchten, müssen Sie <xref:System.Tuple%608.%23ctor%2A> den-Konstruktor aufrufen. Die statischen Factorymethoden <xref:System.Tuple> der-Klasse unterstützen die Erstellung `Tuple` von-Objekten mit mehr als acht Komponenten nicht.  
  
 Wenn Sie ein n-Tupel mit acht oder mehr Komponenten mit dem <xref:System.Tuple%608.%23ctor%2A> -Konstruktor instanziieren möchten, geben Sie ein generisches `rest` `Tuple` -Objekt als-Parameter an, um die achten bis *n*. Komponenten des Tupels zu definieren. Durch das Schachteln `Tuple` von generischen Objekten auf diese Weise können Sie ein Tupel erstellen, das keine praktische Einschränkung der Anzahl seiner Komponenten aufweist.  
  
 Im folgenden Beispiel wird ein 17-Tupel erstellt, das auffüllungs Daten für die Stadt von Detroit, Michigan, für jede nationale Volkszählung zwischen 1860 und 2000 enthält. Die erste Komponente des Tupels ist der Name der Stadt. Die zweite Komponente ist das Startdatum der Datenreihe, und die dritte Komponente ist die Auffüllung am Startdatum. Jede nachfolgende Komponente stellt die Auffüllung in Intervallen von zehn Jahren bereit. Das 17-Tupel wird erstellt, indem ein <xref:System.Tuple%603> -Objekt in <xref:System.Tuple%608> einem-Objekt geschachtelt wird. (Das heißt, das <xref:System.Tuple%603> -Objekt wird als Wert `rest` des-Parameters im <xref:System.Tuple%608> -Klassenkonstruktor angegeben.) Dieses <xref:System.Tuple%608> Objekt ist seinerseits in einem äußeren <xref:System.Tuple%608> Objekt enthalten. (Das heißt, das <xref:System.Tuple%608> -Objekt wird als Wert `rest` des-Parameters im-Klassenkonstruktor des äußeren <xref:System.Tuple%608> Objekts bereitgestellt.)  
  
 [!code-csharp[System.Tuple.Create#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/example.cs#19)]
 [!code-vb[System.Tuple.Create#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/example.vb#19)]  
  
 Sie können den Wert der ersten sieben Komponenten des Tupels abrufen <xref:System.Tuple%607.Item1%2A> <xref:System.Tuple%607.Item3%2A>, <xref:System.Tuple%607.Item6%2A> <xref:System.Tuple%607.Item5%2A> <xref:System.Tuple%607.Item2%2A> <xref:System.Tuple%607.Item4%2A>indem Sie die schreibgeschützten Eigenschaften,,,,, und <xref:System.Tuple%607.Item7%2A> Instanzeigenschaften verwenden. Alle zusätzlichen Komponenten sind eingebettet und können aus der <xref:System.Tuple%608.Rest%2A> -Eigenschaft abgerufen werden. Im vorherigen Beispiel rufen die <xref:System.Tuple%608.Item1%2A> through <xref:System.Tuple%608.Item7%2A> -Eigenschaften die ersten bis siebten Komponenten des Tupels ab. Die acht bis vier vier Komponenten sind im Tupel enthalten, das auf der zweiten Ebene eingebettet ist, und werden durch die `Rest.Item1` Eigenschaften durch `Rest.Item7` dargestellt. Die fünfzehnten bis 17-Komponenten sind im Tupel enthalten, das auf der dritten Ebene eingebettet ist, und werden durch die `Rest.Rest.Item1` `Rest.Rest.Item3` -Eigenschaften dargestellt.  
  
 Tupel werden üblicherweise auf vier verschiedene Arten verwendet:  
  
-   , Um einen einzelnen Satz von Daten darzustellen. Ein Tupel kann z. b. einen Datenbankdaten Satz darstellen, und seine Komponenten können einzelne Felder des Datensatzes darstellen.  
  
-   , Um einen einfachen Zugriff auf ein DataSet und die Bearbeitung von Daten zu ermöglichen.  
  
-   , Wenn mehrere Werte aus einer Methode ohne Verwendung von `out` Parametern (in C#) oder `ByRef` Parametern (in Visual Basic) zurückgegeben werden sollen. Im vorherigen Beispiel wird beispielsweise die berechnete Statistik zusammen mit dem Namen der Stadt in einem <xref:System.Tuple%607> -Objekt zurückgegeben.  
  
-   , Wenn mehrere Werte über einen einzelnen Parameter an eine Methode übergeben werden sollen. Beispielsweise verfügt die <xref:System.Threading.Thread.Start%28System.Object%29?displayProperty=nameWithType> -Methode über einen einzelnen Parameter, mit dem Sie einen Wert für die Methode angeben können, die der Thread beim Start ausführt. Wenn Sie ein <xref:System.Tuple%607> -Objekt als Methoden Argument bereitstellen, können Sie die Start Routine des Threads mit sieben Datenelementen bereitstellen.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Tuple" />
    <altmember cref="T:System.Tuple`1" />
    <altmember cref="T:System.Tuple`2" />
    <altmember cref="T:System.Tuple`3" />
    <altmember cref="T:System.Tuple`4" />
    <altmember cref="T:System.Tuple`5" />
    <altmember cref="T:System.Tuple`6" />
    <altmember cref="T:System.Tuple`7" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Tuple (T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T1 item1, !T2 item2, !T3 item3, !T4 item4, !T5 item5, !T6 item6, !T7 item7, !TRest rest) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.#ctor(`0,`1,`2,`3,`4,`5,`6,`7)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (item1 As T1, item2 As T2, item3 As T3, item4 As T4, item5 As T5, item6 As T6, item7 As T7, rest As TRest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);" />
      <MemberSignature Language="F#" Value="new Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt; : 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'Rest -&gt; Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;" Usage="new System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt; (item1, item2, item3, item4, item5, item6, item7, rest)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
        <Parameter Name="item3" Type="T3" />
        <Parameter Name="item4" Type="T4" />
        <Parameter Name="item5" Type="T5" />
        <Parameter Name="item6" Type="T6" />
        <Parameter Name="item7" Type="T7" />
        <Parameter Name="rest" Type="TRest" />
      </Parameters>
      <Docs>
        <param name="item1">Der Wert der ersten Komponente des Tupels.</param>
        <param name="item2">Der Wert der zweiten Komponente des Tupels.</param>
        <param name="item3">Der Wert der dritten Komponente des Tupels.</param>
        <param name="item4">Der Wert der vierten Komponente des Tupels.</param>
        <param name="item5">Der Wert der fünften Komponente des Tupels.</param>
        <param name="item6">Der Wert der sechsten Komponente des Tupels.</param>
        <param name="item7">Der Wert der siebten Komponente des Tupels.</param>
        <param name="rest">Ein beliebiges generisches <see langword="Tuple" />-Objekt, das die Werte der restlichen Komponenten des Tupels enthält.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Tuple`8" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch die statische <xref:System.Tuple.Create%2A?displayProperty=nameWithType> -Methode verwenden, um ein 8-Tuple-Objekt (Octuple) zu instanziieren, ohne explizit die Typen seiner Komponenten angeben zu müssen. Im folgenden Beispiel wird die <xref:System.Tuple.Create%2A?displayProperty=nameWithType> -Methode verwendet, um ein 8-Tuple-Objekt zu instanziieren, das Primzahlen enthält, die kleiner als 20 sind.  
  
 [!code-csharp[System.Tuple.Create#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/createntuple.cs#17)]
 [!code-vb[System.Tuple.Create#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/createntuple.vb#17)]  
  
 Dies entspricht dem folgenden-Befehl für den <xref:System.Tuple%607.%23ctor%2A> -Klassenkonstruktor.  
  
 [!code-csharp[System.Tuple\`8.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.class/cs/octuple1.cs#1)]
 [!code-vb[System.Tuple\`8.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.class/vb/octuple1.vb#1)]  
  
 Die statische <xref:System.Tuple.Create%2A?displayProperty=nameWithType> -Methode kann jedoch nicht verwendet werden, um ein tupelobjekt mit mehr als acht Komponenten zu erstellen.  
  
 Wenn Sie den <xref:System.Tuple%608.%23ctor%2A> -Konstruktor verwenden, um ein n-Tupel mit acht oder mehr Komponenten zu erstellen `rest` , verwenden Sie den-Parameter, um ein ngeschütztes n-Tupel zu erstellen, das zwischen 1 und sieben Komponenten aufweist. Wenn Sie aufeinander folgende Schachtelungs Ebenen verwenden, können Sie ein n-Tupel erstellen, das über eine praktisch unbegrenzte Anzahl von Komponenten verfügt. Um z. b. ein 25-Tupel zu erstellen, instanziieren <xref:System.Tuple%608> Sie ein-Objekt mit drei Schachtelungs Ebenen wie folgt:  
  
-   Das äußerste <xref:System.Tuple%608> Objekt enthält die ersten bis siebten Komponenten. Die- <xref:System.Tuple%608> Eigenschaft ermöglicht den Zugriff auf ein-Objekt auf der ersten Schachtelungs Ebene. <xref:System.Tuple%608.Rest%2A>  
  
-   Das äußerste <xref:System.Tuple%608> geschachtelte Objekt enthält die acht bis 14 <xref:System.Tuple%608.Rest%2A> -Komponenten, und die-Eigenschaft <xref:System.Tuple%608> ermöglicht den Zugriff auf ein-Objekt auf der zweiten Ebene der Schachtelung.  
  
-   Das <xref:System.Tuple%608> -Objekt auf der <xref:System.Tuple%604>  zweiten Ebene der Schachtelung enthält die 15 bis 20 ersten Komponenten, und die- Eigenschaft ermöglicht den Zugriff auf ein Objekt auf der dritten Ebene der Schachtelung. <xref:System.Tuple%608.Rest%2A>  
  
-   Bei dem innersten Tupel handelt <xref:System.Tuple%604> es sich um ein-Objekt, das die 20 Sekunden bis zu 20-Fünftel-Komponenten enthält.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein 17-Tupel erstellt, das auffüllungs Daten für die Stadt von Detroit, Michigan, für jede Volkszählung von 1860 bis 2000 enthält. Die erste Komponente des Tupels ist der Name der Stadt. Bei der zweiten Komponente handelt es sich um das Startdatum der Datenreihe, wobei es sich bei der dritten Komponente um die Auffüllung am Startdatum handelt. Jede nachfolgende Komponente stellt die Auffüllung in Intervallen von zehn Jahren bereit. In diesem Beispiel werden zwei Schachtelungs Ebenen verwendet, um das 17-Tupel zu erstellen: Es definiert ein 7-Tupel, dessen dritte bis siebte Komponenten auffüllungs Daten für 1860 bis 1900, ein geschachteltes 7-Tupel, das auffüllungs Daten für 1910 bis 1970 enthält, und ein internes geschachteltes 3-Tupel. , das auffüllungs Daten für 1980 bis 2000 enthält.  
  
 [!code-csharp[System.Tuple.Create#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/example.cs#19)]
 [!code-vb[System.Tuple.Create#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/example.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="rest" /> ist kein generisches <see langword="Tuple" />-Objekt.</exception>
        <altmember cref="M:System.Tuple.Create``8(``0,``1,``2,``3,``4,``5,``6,``7)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="tuple.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob das aktuelle <see cref="T:System.Tuple`8" />-Objekt gleich einem angegebenen Objekt ist.</summary>
        <returns><see langword="true" />, wenn die aktuelle Instanz gleich dem angegebenen Objekt ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `obj` -Parameter wird als gleich der aktuellen Instanz betrachtet, wenn er alle der folgenden Bedingungen erfüllt:  
  
-   Es handelt sich <xref:System.Tuple%608> um ein-Objekt.  
  
-   Sie verfügt über die gleiche Gesamtzahl von Komponenten, die denselben Typ wie die aktuelle Instanz haben.  
  
-   Die Komponenten (einschließlich der zugehörigen Komponenten) entsprechen denen der aktuellen Instanz. Gleichheit wird durch den Standard Gleichheits Vergleich für jede Komponente bestimmt.  
  
   
  
## Examples  
 Im folgenden Beispiel werden fünf <xref:System.Tuple%608> Objekte definiert, die Primzahlen enthalten. Anschließend vergleicht er das erste-Objekt mit jedem der restlichen Objekte. Wie die Ausgabe zeigt, sind nur das erste und das <xref:System.Tuple%608> letzte-Objekt gleich, da Sie über eine identische Anzahl von Komponenten mit identischen Werten verfügen.  
  
 [!code-csharp[System.Tuple\`8.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.equals/cs/equals1.cs#1)]
 [!code-vb[System.Tuple\`8.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="tuple.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Berechnet den Hashcode für das aktuelle <see cref="T:System.Tuple`8" />-Objekt.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item1">
      <MemberSignature Language="C#" Value="public T1 Item1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T1 Item1" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item1" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item1 As T1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T1 Item1 { T1 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item1 : 'T1" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T1</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der ersten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts ab.</summary>
        <value>Der Wert der ersten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ der <xref:System.Tuple%608.Item1%2A> Komponente kann auf zwei Arten dynamisch bestimmt werden:  
  
-   Durch Aufrufen der `GetType` -Methode für den Wert, der von der <xref:System.Tuple%608.Item1%2A> -Eigenschaft zurückgegeben wird.  
  
-   Durch Abrufen des <xref:System.Type> Objekts, das das <xref:System.Tuple%608> Objekt darstellt, und Abrufen des ersten Elements aus dem Array, das von seiner <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> -Methode zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein 17-Tuple-Objekt erstellt, das auffüllungs Daten für die Stadt von Detroit, Michigan, von 1860 bis 2000 enthält. Die erste Komponente des 17-Tupels ist der Name der Stadt. Im Beispiel wird die <xref:System.Tuple%608.Item1%2A> -Eigenschaft verwendet, um den Namen der Stadt im Tabellenheader anzuzeigen, bevor die auffüllungs Daten angezeigt werden.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item2">
      <MemberSignature Language="C#" Value="public T2 Item2 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T2 Item2" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item2" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item2 As T2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T2 Item2 { T2 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item2 : 'T2" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item2" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T2</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der zweiten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts ab.</summary>
        <value>Der Wert der zweiten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ der <xref:System.Tuple%608.Item2%2A> Komponente kann auf zwei Arten dynamisch bestimmt werden:  
  
-   Durch Aufrufen der `GetType` -Methode für den Wert, der von der <xref:System.Tuple%608.Item2%2A> -Eigenschaft zurückgegeben wird.  
  
-   Durch Abrufen des <xref:System.Type> Objekts, das das <xref:System.Tuple%608> Objekt darstellt, und Abrufen des zweiten Elements aus dem Array, das von seiner <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> -Methode zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein 17-Tuple-Objekt erstellt, das auffüllungs Daten für die Stadt von Detroit, Michigan, von 1860 bis 2000 enthält. Die zweite Komponente des 17-Tupels ist das erste Jahr der Datenreihe. Im Beispiel wird der-Wert der <xref:System.Tuple%608.Item2%2A> -Eigenschaft einer Variablen zugewiesen, und dann wird diese Variable verwendet, um das Jahr darzustellen, dessen Daten angezeigt werden.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item3">
      <MemberSignature Language="C#" Value="public T3 Item3 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T3 Item3" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item3" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item3 As T3" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T3 Item3 { T3 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item3 : 'T3" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item3" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T3</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der dritten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts ab.</summary>
        <value>Der Wert der dritten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ der <xref:System.Tuple%608.Item3%2A> Komponente kann auf zwei Arten dynamisch bestimmt werden:  
  
-   Durch Aufrufen der `GetType` -Methode für den Wert, der von der <xref:System.Tuple%608.Item3%2A> -Eigenschaft zurückgegeben wird.  
  
-   Durch Abrufen des <xref:System.Type> Objekts, das das <xref:System.Tuple%608> Objekt darstellt, und Abrufen des dritten Elements aus dem Array, das von seiner <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> -Methode zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein 17-Tuple-Objekt erstellt, das auffüllungs Daten für die Stadt von Detroit, Michigan, von 1860 bis 2000 enthält. Die dritte Komponente des 17-Tupels ist die Population in 1860. Im Beispiel wird die <xref:System.Tuple%608.Item3%2A> -Eigenschaft verwendet, um den auffüllungs Wert anzuzeigen und um die Jahresrate der Einwohner Wechsel zwischen 1860 und 1870 zu berechnen.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item4">
      <MemberSignature Language="C#" Value="public T4 Item4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T4 Item4" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item4" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item4 As T4" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T4 Item4 { T4 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item4 : 'T4" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T4</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der vierten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts ab.</summary>
        <value>Der Wert der vierten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ der <xref:System.Tuple%608.Item4%2A> Komponente kann auf zwei Arten dynamisch bestimmt werden:  
  
-   Durch Aufrufen der `GetType` -Methode für den Wert, der von der <xref:System.Tuple%608.Item4%2A> -Eigenschaft zurückgegeben wird.  
  
-   Durch Abrufen des <xref:System.Type> Objekts, das das <xref:System.Tuple%608> Objekt darstellt, und Abrufen des vierten Elements aus dem Array, das von seiner <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> -Methode zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein 17-Tuple-Objekt erstellt, das auffüllungs Daten für die Stadt von Detroit, Michigan, von 1860 bis 2000 enthält. Die vierte Komponente des 17-Tupels ist die Population in 1870. Im Beispiel wird die <xref:System.Tuple%608.Item4%2A> -Eigenschaft verwendet, um den auffüllungs Wert anzuzeigen und um die Jahresrate der Einwohner Wechsel zwischen 1870 und 1880 zu berechnen.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item5">
      <MemberSignature Language="C#" Value="public T5 Item5 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T5 Item5" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item5 As T5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T5 Item5 { T5 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item5 : 'T5" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item5" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T5</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der fünften Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts ab.</summary>
        <value>Der Wert der fünften Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ der <xref:System.Tuple%608.Item5%2A> Komponente kann auf zwei Arten dynamisch bestimmt werden:  
  
-   Durch Aufrufen der `GetType` -Methode für den Wert, der von der <xref:System.Tuple%608.Item5%2A> -Eigenschaft zurückgegeben wird.  
  
-   Durch Abrufen des <xref:System.Type> Objekts, das das <xref:System.Tuple%608> Objekt darstellt, und Abrufen des fünften Elements aus dem Array, das von seiner <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> -Methode zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein 17-Tuple-Objekt erstellt, das auffüllungs Daten für die Stadt von Detroit, Michigan, von 1860 bis 2000 enthält. Die fünfte Komponente des 17-Tupels ist die Population in 1880. Im Beispiel wird die <xref:System.Tuple%608.Item5%2A> -Eigenschaft verwendet, um den auffüllungs Wert anzuzeigen und um die Jahresrate der Einwohner Wechsel zwischen 1880 und 1890 zu berechnen.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item6">
      <MemberSignature Language="C#" Value="public T6 Item6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T6 Item6" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item6" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item6 As T6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T6 Item6 { T6 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item6 : 'T6" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T6</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der sechsten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts ab.</summary>
        <value>Der Wert der sechsten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ der <xref:System.Tuple%608.Item6%2A> Komponente kann auf zwei Arten dynamisch bestimmt werden:  
  
-   Durch Aufrufen der `GetType` -Methode für den Wert, der von der <xref:System.Tuple%608.Item6%2A> -Eigenschaft zurückgegeben wird.  
  
-   Durch Abrufen des <xref:System.Type> Objekts, das das <xref:System.Tuple%608> Objekt darstellt, und Abrufen des sechsten Elements aus dem Array, das von seiner <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> -Methode zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein 17-Tuple-Objekt erstellt, das auffüllungs Daten für die Stadt von Detroit, Michigan, von 1860 bis 2000 enthält. Die sechste Komponente des 17-Tupels ist die Population in 1890. Im Beispiel wird die <xref:System.Tuple%608.Item6%2A> -Eigenschaft verwendet, um den auffüllungs Wert anzuzeigen und um die Jahresrate der Einwohner Wechsel zwischen 1890 und 1900 zu berechnen.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item7">
      <MemberSignature Language="C#" Value="public T7 Item7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T7 Item7" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item7" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item7 As T7" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T7 Item7 { T7 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item7 : 'T7" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T7</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der siebten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts ab.</summary>
        <value>Der Wert der siebten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ der <xref:System.Tuple%608.Item7%2A> Komponente kann auf zwei Arten dynamisch bestimmt werden:  
  
-   Durch Aufrufen der `GetType` -Methode für den Wert, der von der <xref:System.Tuple%608.Item7%2A> -Eigenschaft zurückgegeben wird.  
  
-   , Indem das <xref:System.Type> Objekt abgerufen wird, das <xref:System.Tuple%608> das Objekt darstellt, und das siebte Element aus dem Array abzurufen, das von seiner <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> -Methode zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein 17-Tuple-Objekt erstellt, das auffüllungs Daten für die Stadt von Detroit, Michigan, von 1860 bis 2000 enthält. Die siebte Komponente des 17-Tupels ist die Population in 1900. Im Beispiel wird die <xref:System.Tuple%608.Item7%2A> -Eigenschaft verwendet, um den auffüllungs Wert anzuzeigen und um die Jahresrate der Einwohner Wechsel zwischen 1900 und 1910 zu berechnen.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rest">
      <MemberSignature Language="C#" Value="public TRest Rest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TRest Rest" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Rest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rest As TRest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TRest Rest { TRest get(); };" />
      <MemberSignature Language="F#" Value="member this.Rest : 'Rest" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Rest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TRest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die restlichen Komponenten des aktuellen <see cref="T:System.Tuple`8" />-Objekts ab.</summary>
        <value>Der Wert der restlichen Komponenten des aktuellen <see cref="T:System.Tuple`8" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Tuple%608.Rest%2A> -Eigenschaft gibt ein `Tuple` -Objekt zurück, das den Zugriff auf die achten, aber *n*-ten Komponenten des Tupels ermöglicht. Abhängig von der Gesamtanzahl der Komponenten im Tupel können die Werte der acht bis 14 vier Komponenten aus den über-Eigenschaften des durch das `Tuple` -Objekt <xref:System.Tuple%608.Item1%2A> durch <xref:System.Tuple%608.Item7%2A> das-Objekt abgerufen werden. Anschließend können Sie die- <xref:System.Tuple%608.Rest%2A> Eigenschaft eines <xref:System.Tuple%608> geschachtelten-Objekts verwenden, `Tuple` um das Objekt auf der nächsten Schachtelungs Ebene abzurufen.  
  
 Sie können die Anzahl der Komponenten in einem `Tuple` von der <xref:System.Tuple%608.Rest%2A> -Eigenschaft zurückgegebenen Objekt dynamisch ermitteln, indem Sie die Ziffer aus dem Typnamen extrahieren. Dies wird im folgenden Beispiel veranschaulicht.  
  
 [!code-vb[System.Tuple\`8.Item1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/rest.vb#2)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein 17-Tuple-Objekt erstellt, das auffüllungs Daten für die Stadt von Detroit, Michigan, von 1860 bis 2000 enthält. Die siebte Komponente des 17-Tupels ist die Population in 1900. Im Beispiel wird die <xref:System.Tuple%608.Rest%2A> -Eigenschaft verwendet, um die Werte der acht bis 14-Komponenten abzurufen, und <xref:System.Tuple%608.Rest%2A> die- <xref:System.Tuple%608> Eigenschaft des-Objekts wird verwendet, um die Werte der restlichen Komponenten abzurufen.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">Ein Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
        <param name="comparer">Ein Objekt, das benutzerdefinierte Regeln für Vergleiche bereitstellt.</param>
        <summary>Vergleicht das aktuelle <see cref="T:System.Tuple`8" />-Objekt anhand eines angegebenen Vergleichs mit einem angegebenen Objekt und gibt eine ganze Zahl zurück, die angibt, ob sich das aktuelle Element in der Sortierreihenfolge vor dem angegebenen Element, dahinter oder an derselben Position befindet.</summary>
        <returns>Eine ganze Zahl mit Vorzeichen, die die relative Position dieser Instanz und von <paramref name="other" /> in der Sortierreihenfolge angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Beschreibung 
 </description></listheader><item><term> Eine negative ganze Zahl 
 </term><description> Diese Instanz geht <paramref name="other" /> voran.  
  
 </description></item><item><term> Zero 
 </term><description> Diese Instanz und <paramref name="other" /> befinden sich in der Sortierreihenfolge an der gleichen Position.  
  
 </description></item><item><term> Eine positive ganze Zahl 
 </term><description> Diese Instanz folgt <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellenimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Tuple%608>-Instanz in eine <xref:System.Collections.IStructuralComparable>-Schnittstelle umgewandelt wird.  
  
 Mit dieser Methode können Sie angepasste Vergleiche von <xref:System.Tuple%608> Objekten definieren. Beispielsweise können Sie diese Methode zum <xref:System.Tuple%608> Sortieren von Objekten basierend auf dem Wert einer bestimmten Komponente verwenden.  
  
 Obwohl diese Methode direkt aufgerufen werden kann, wird Sie am häufigsten von Auflistungs Sortiermethoden aufgerufen, <xref:System.Collections.IComparer> die Parameter zum Sortieren der Member einer Auflistung enthalten. Beispielsweise wird Sie von <xref:System.Array.Sort%28System.Array%2CSystem.Collections.IComparer%29?displayProperty=nameWithType> der-Methode und der <xref:System.Collections.SortedList.Add%2A> -Methode eines <xref:System.Collections.SortedList> -Objekts aufgerufen, das mit dem <xref:System.Collections.SortedList.%23ctor%28System.Collections.IComparer%29?displayProperty=nameWithType> -Konstruktor instanziiert wird.  
  
> [!CAUTION]
>  Die <xref:System.Tuple%608.System%23Collections%23IStructuralComparable%23CompareTo%2A> -Methode ist für die Verwendung in Sortiervorgängen vorgesehen. Er sollte nicht verwendet werden, wenn der Hauptzweck eines Vergleichs darin besteht, zu bestimmen, ob zwei Objekte gleich sind. Um zu ermitteln, ob zwei Objekte gleich sind, <xref:System.Tuple%608.System%23Collections%23IStructuralEquatable%23Equals%2A> müssen Sie die-Methode aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array von <xref:System.Tuple%608> -Objekten erstellt, das auffüllungs Daten für vier US-Städte von 1940 bis 2000 enthält. Die erste Komponente des octupels ist der Name der Stadt. Die verbleibenden sechs Komponenten stellen die Auffüllung in Abständen von 10 Jahren zwischen 1940 und 2000 dar.  
  
 Die `PopulationComparer` -Klasse stellt <xref:System.Collections.IComparer> eine-Implementierung bereit, mit der das Array von oktupeln nach einer seiner Komponenten sortiert werden kann. Zwei Werte werden für die `PopulationComparer` -Klasse im Konstruktor bereitgestellt: die Position der Komponente, die die Sortierreihenfolge definiert, und ein <xref:System.Boolean> Wert, der angibt, ob die tupelobjekte in aufsteigender oder absteigender Reihenfolge sortiert werden sollen.  
  
 Das Beispiel zeigt dann die Elemente im Array in unsortierten Reihenfolge an, sortiert sie nach der dritten Komponente (die Population in 1950) und zeigt Sie an und sortiert Sie dann nach der achten Komponente (die Population in 2000) und zeigt Sie an.  
  
 [!code-csharp[System.Tuple\`8.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.compareto/cs/compareto2.cs#2)]
 [!code-vb[System.Tuple\`8.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.compareto/vb/compareto2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="other" /> ist kein <see cref="T:System.Tuple`8" />-Objekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">Das Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <param name="comparer">Ein Objekt, das die Methode definiert, mit der ermittelt wird, ob die beiden Objekte gleich sind.</param>
        <summary>Gibt einen Wert zurück, der auf Grundlage einer angegebenen Vergleichsmethode angibt, ob das aktuelle <see cref="T:System.Tuple`8" />-Objekt gleich einem angegebenen Objekt ist.</summary>
        <returns><see langword="true" />, wenn die aktuelle Instanz gleich dem angegebenen Objekt ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Tuple%608>-Instanz in eine <xref:System.Collections.IStructuralEquatable>-Schnittstelle umgewandelt wird.  
  
 Die <xref:System.Collections.IEqualityComparer.Equals%2A?displayProperty=nameWithType> -Implementierung wird nur aufgerufen `other` , wenn `null`nicht ist, und wenn Sie erfolgreich C#in ein <xref:System.Tuple%608> -Objekt Visual Basic umgewandelt werden kann, das die gleiche Gesamtzahl von Komponenten hat (einschließlich der in "- `Tuple` Objekte") derselben Typen wie die aktuelle Instanz. Die <xref:System.Tuple%608.System%23Collections%23IStructuralEquatable%23Equals%28System.Object%2CSystem.Collections.IEqualityComparer%29> -Methode übergibt zuerst <xref:System.Tuple%608.Item1%2A> die Werte der <xref:System.Tuple%608> -Objekte, die mit der <xref:System.Collections.IEqualityComparer.Equals%2A?displayProperty=nameWithType> -Implementierung verglichen werden sollen. Wenn dieser Methodenaufruf zurück `true`gibt, wird die-Methode erneut aufgerufen und <xref:System.Tuple%608.Item2%2A> die Werte der beiden <xref:System.Tuple%608> -Objekte übermittelt. Dies wird so lange fortgesetzt, `false` bis der Methoden Rückruf beim Vergleich eines bestimmten paar von Werten zurück <xref:System.Tuple%608.Rest%2A> gibt oder die beiden Werte an die-Methode weitergegeben werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Ein Objekt, dessen <see cref="M:System.Collections.IEqualityComparer.GetHashCode(System.Object)" />-Methode den Hashcode des aktuellen <see cref="T:System.Tuple`8" />-Objekts berechnet</param>
        <summary>Berechnet mit einer angegebenen Berechnungsmethode den Hash für das aktuelle <see cref="T:System.Tuple`8" />-Objekt.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Tuple%608>-Instanz in eine <xref:System.Collections.IStructuralEquatable>-Schnittstelle umgewandelt wird.  
  
 Die-Methode umschließt lediglich einen aufzurufenden Rückruf der- `comparer` <xref:System.Collections.IEqualityComparer.GetHashCode%2A?displayProperty=nameWithType> Implementierung des Objekts.  
  
 Der Algorithmus, der zum Berechnen des Hashcodes verwendet wird, sollte den gleichen Hashcode <xref:System.Tuple%608> für zwei Objekte zurückgeben, die als gleich betrachtet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
        <summary>Vergleicht das aktuelle <see cref="T:System.Tuple`8" />-Objekt mit einem angegebenen Objekt und gibt eine Ganzzahl zurück, die darauf hinweist, ob sich das aktuelle Objekt in der Sortierreihenfolge vor oder hinter dem angegebenen Objekt oder an der gleichen Position befindet.</summary>
        <returns>Eine ganze Zahl mit Vorzeichen, die die relative Position dieser Instanz und von <paramref name="obj" /> in der Sortierreihenfolge angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Beschreibung 
 </description></listheader><item><term> Eine negative ganze Zahl 
 </term><description> Diese Instanz geht <paramref name="obj" /> voran.  
  
 </description></item><item><term> Zero 
 </term><description> Diese Instanz und <paramref name="obj" /> befinden sich in der Sortierreihenfolge an der gleichen Position.  
  
 </description></item><item><term> Eine positive ganze Zahl 
 </term><description> Diese Instanz folgt <paramref name="obj" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Tuple%608>-Instanz in eine <xref:System.IComparable>-Schnittstelle umgewandelt wird.  
  
 Diese Methode stellt die <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> Implementierung für die <xref:System.Tuple%608> -Klasse bereit. Obwohl die-Methode direkt aufgerufen werden kann, wird Sie am häufigsten von den Standard Überladungen von Auflistungs Sortiermethoden (z <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> . <xref:System.Collections.SortedList.Add%2A?displayProperty=nameWithType>b. und) aufgerufen, um die Elemente einer Auflistung zu sortieren.  
  
> [!CAUTION]
>  Die <xref:System.Tuple%608.System%23IComparable%23CompareTo%2A> -Methode ist für die Verwendung in Sortiervorgängen vorgesehen. Er sollte nicht verwendet werden, wenn der Hauptzweck eines Vergleichs darin besteht, zu bestimmen, ob zwei Objekte gleich sind. Um zu ermitteln, ob zwei Objekte gleich sind, <xref:System.Tuple%608.Equals%28System.Object%29?displayProperty=nameWithType> müssen Sie die-Methode aufzurufen.  
  
 Diese Methode verwendet den standardobjektcomparer zum Vergleichen der einzelnen Komponenten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array von oktupeln erstellt, deren Komponenten ganze Zahlen sind, die einen Bereich von Primzahlen enthalten. Das Beispiel zeigt die Elemente des Arrays in unsortierter Reihenfolge an, sortiert das Array und zeigt dann das Array in sortierter Reihenfolge an. Die Ausgabe zeigt, dass das Array nach <xref:System.Tuple%608.Item1%2A>oder der ersten Komponente des Tupels sortiert wurde. Beachten Sie, dass das Beispiel die <xref:System.Tuple%608.System%23IComparable%23CompareTo%28System.Object%29> -Methode nicht direkt aufruft. Diese Methode wird implizit von der <xref:System.Array.Sort%28System.Array%29> -Methode für jedes Element im Array aufgerufen.  
  
 [!code-csharp[System.Tuple\`8.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.compareto/cs/compareto1.cs#1)]
 [!code-vb[System.Tuple\`8.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.compareto/vb/compareto1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="obj" /> ist kein <see cref="T:System.Tuple`8" />-Objekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.CompilerServices.ITuple.Item">
      <MemberSignature Language="C#" Value="object System.Runtime.CompilerServices.ITuple.Item[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Runtime.CompilerServices.ITuple.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.System#Runtime#CompilerServices#ITuple#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Item(index As Integer) As Object Implements ITuple.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Runtime::CompilerServices::ITuple::Item[int] { System::Object ^ get(int index); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.CompilerServices.ITuple.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.CompilerServices.ITuple.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">Der Index des angegebenen Elements <see langword="Tuple" />. <paramref name="index" /> kann von 0 bis <see langword="Item1" /> reichen, bis zu einer Zahl weniger als die Anzahl der Elemente in <see langword="Tuple" />.</param>
        <summary>Ruft den Wert des angegebenen Elements <see langword="Tuple" /> ab.</summary>
        <value>Der Wert des <see langword="Tuple" />-Elements an der angegebenen Position.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Tuple%608.System%23Runtime%23CompilerServices%23ITuple%23Item%2A?displayProperty=nameWithType> -Eigenschaft ist eine explizite Schnittstellen Implementierung. Um dies aufzurufen, müssen Sie das <xref:System.Tuple%608> Objekt in ein <xref:System.Runtime.CompilerServices.ITuple> Schnittstellen Objekt umwandeln oder konvertieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="index" /> ist größer gleich <see cref="P:System.Tuple`8.System#Runtime#CompilerServices#ITuple#Length" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.CompilerServices.ITuple.Length">
      <MemberSignature Language="C#" Value="int System.Runtime.CompilerServices.ITuple.Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Runtime.CompilerServices.ITuple.Length" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.System#Runtime#CompilerServices#ITuple#Length" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Length As Integer Implements ITuple.Length" />
      <MemberSignature Language="C++ CLI" Value="property int System::Runtime::CompilerServices::ITuple::Length { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.CompilerServices.ITuple.Length" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.CompilerServices.ITuple.Length</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente im <see langword="Tuple" /> ab.</summary>
        <value>Die Anzahl der Elemente im <see langword="Tuple" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Tuple%608.System%23Runtime%23CompilerServices%23ITuple%23Length%2A> -Eigenschaft ist eine explizite Schnittstellen Implementierung. Um dies aufzurufen, müssen Sie den <xref:System.Tuple%608> Typ in ein <xref:System.Runtime.CompilerServices.ITuple> Schnittstellen Objekt umwandeln oder konvertieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="tuple.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die den Wert dieser <see cref="T:System.Tuple`8" />-Instanz darstellt.</summary>
        <returns>Die Zeichenfolgendarstellung dieses <see cref="T:System.Tuple`8" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die von dieser Methode zurückgegebene Zeichenfolge hat das Format (*item1*, *item2*, *item3*, `Item5, Item6, Item7` *item4*,, *Item8*...), wobei *item1*, *item2*, *item3*, *item4*, *Item5*,  *Item6*und *Item7* stellen <xref:System.Tuple%608.Item1%2A>die Werte der Eigenschaften, <xref:System.Tuple%608.Item5%2A> <xref:System.Tuple%608.Item4%2A> <xref:System.Tuple%608.Item2%2A>, <xref:System.Tuple%608.Item3%2A>,,, <xref:System.Tuple%608.Item6%2A>und <xref:System.Tuple%608.Item7%2A> dar. *Item8* stellt den Wert <xref:System.Tuple%608> der- `Next.Item1` Eigenschaft des-Objekts dar. Der Wert aller zusätzlichen, unter beschriebenen Komponenten folgt *Item8*. Wenn einer der Eigenschaftswerte ist `null`, wird er als <xref:System.String.Empty?displayProperty=nameWithType>dargestellt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein 17-Tupel erstellt, das auffüllungs Daten für die Stadt von Detroit, Michigan, von 1860 bis 1900 enthält. Anschließend wird die <xref:System.Tuple%608.ToString%2A> -Methode verwendet, um die Daten des Tupels anzuzeigen.  
  
 [!code-csharp[System.Tuple\`8.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Tuple\`8.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
