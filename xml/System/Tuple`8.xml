<Type Name="Tuple&lt;T1,T2,T3,T4,T5,T6,T7,TRest&gt;" FullName="System.Tuple&lt;T1,T2,T3,T4,T5,T6,T7,TRest&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="eeb36d11bfb1a44d4fb76dfd2f0f2000cfe57d40" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36429213" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Tuple&lt;T1,T2,T3,T4,T5,T6,T7,TRest&gt; : IComparable, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Tuple`8&lt;T1, T2, T3, T4, T5, T6, T7, TRest&gt; extends System.Object implements class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.IComparable" />
  <TypeSignature Language="DocId" Value="T:System.Tuple`8" />
  <TypeSignature Language="VB.NET" Value="Public Class Tuple(Of T1, T2, T3, T4, T5, T6, T7, TRest)&#xA;Implements IComparable, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename TRest&gt;&#xA;public ref class Tuple : IComparable, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt; = class&#xA;    interface IStructuralEquatable&#xA;    interface IStructuralComparable&#xA;    interface IComparable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T1" />
    <TypeParameter Name="T2" />
    <TypeParameter Name="T3" />
    <TypeParameter Name="T4" />
    <TypeParameter Name="T5" />
    <TypeParameter Name="T6" />
    <TypeParameter Name="T7" />
    <TypeParameter Name="TRest" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="T1">Der Typ der ersten Komponente des Tupels.</typeparam>
    <typeparam name="T2">Der Typ der zweiten Komponente des Tupels.</typeparam>
    <typeparam name="T3">Der Typ der dritten Komponente des Tupels.</typeparam>
    <typeparam name="T4">Der Typ der vierten Komponente des Tupels.</typeparam>
    <typeparam name="T5">Der Typ der fünften Komponente des Tupels.</typeparam>
    <typeparam name="T6">Der Typ der sechsten Komponente des Tupels.</typeparam>
    <typeparam name="T7">Der Typ der siebten Komponente des Tupels.</typeparam>
    <typeparam name="TRest">Ein beliebiges generisches <see langword="Tuple" />-Objekt, das die Typen der restlichen Komponenten des Tupels definiert.</typeparam>
    <summary>Stellt ein *n*-Tupel mit *n* größer oder gleich 8 dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Tupel ist eine Datenstruktur, die eine bestimmte Anzahl und die Sequenz von Werten aufweist. Die <xref:System.Tuple%608> -Klasse stellt eine *n*- Tupel, die acht oder mehr Komponenten enthält.  
  
 Instanziieren Sie ein <xref:System.Tuple%608> Objekt genau mit acht Komponenten durch Aufrufen der statischen <xref:System.Tuple.Create%2A?displayProperty=nameWithType> Methode. Das folgende Beispiel erstellt ein 8-Tupel (Oktupel), die Primzahlen enthält, die kleiner als 20 sind. Beachten Sie, dass der Typrückschluss verwendet, um den Typ der einzelnen Komponenten zu bestimmen.  
  
 [!code-csharp[System.Tuple.Create#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/createntuple.cs#17)]
 [!code-vb[System.Tuple.Create#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/createntuple.vb#17)]  
  
 Sie können auch ein n-Tupel-Objekt, mit acht oder mehr Komponenten instanziieren, durch Aufrufen der <xref:System.Tuple%608.%23ctor%2A> Konstruktor. Im folgenden Beispiel wird die <xref:System.Tuple%608.%23ctor%2A> Konstruktor, um ein 8-Tupel zu erstellen, die im vorherigen Beispiel erstellten Tupel entspricht.  
  
 [!code-csharp[System.Tuple\`8.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.class/cs/octuple1.cs#1)]
 [!code-vb[System.Tuple\`8.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.class/vb/octuple1.vb#1)]  
  
> [!NOTE]
>  Um ein n-Tupel mit neun oder mehr Komponenten zu erstellen, rufen Sie die <xref:System.Tuple%608.%23ctor%2A> Konstruktor. Von den statischen Factorymethoden der <xref:System.Tuple> Klasse unterstützen nicht die Erstellung von `Tuple` Objekte mit mehr als acht Komponenten.  
  
 Ein n-Tupel zu instanziieren, das über acht oder mehr Komponenten mit verfügt die <xref:System.Tuple%608.%23ctor%2A> Konstruktor, geben Sie ein generisches `Tuple` -Objekt als die `rest` -Parameter zur Definition der achte bis *n*te-Komponente des Tupels. Vom generischen Schachtelung `Tuple` -Objekte auf diese Weise können Sie ein Tupel, das keine praktische Begrenzung für die Anzahl der zugehörigen Komponenten verfügt erstellen.  
  
 Das folgende Beispiel erstellt ein 17-Tupel, die Daten der Auffüllung für den Ort Detroit, Michigan, für jede nationale Erhebung von 1860 bis 2000 enthält. Die erste Komponente des Tupels ist der Name des Orts. Die zweite Komponente ist das Startdatum der Datenreihen, und die dritte Komponente ist die Auffüllung beim Startdatum. Jede nachfolgende Komponente enthält die Auffüllung in Abständen von zehn Jahren. 17-Tupel wird erstellt, indem die Schachtelung einer <xref:System.Tuple%603> Objekt innerhalb einer <xref:System.Tuple%608> Objekt. (Ist, wird die <xref:System.Tuple%603> -Objekt bereitgestellt wird, als Wert des der `rest` Parameter in der <xref:System.Tuple%608> Klassenkonstruktor.) Dies <xref:System.Tuple%608> Objekt in ein äußeres wiederum geschachtelt ist, <xref:System.Tuple%608> Objekt. (Ist, die <xref:System.Tuple%608> -Objekt bereitgestellt wird, als Wert für die `rest` Parameter in der äußeren <xref:System.Tuple%608> Klassenkonstruktor des Objekts.)  
  
 [!code-csharp[System.Tuple.Create#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/example.cs#19)]
 [!code-vb[System.Tuple.Create#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/example.vb#19)]  
  
 Sie können den Wert des ersten sieben Komponenten des Tupels abrufen, indem Sie mithilfe der schreibgeschützten <xref:System.Tuple%607.Item1%2A>, <xref:System.Tuple%607.Item2%2A>, <xref:System.Tuple%607.Item3%2A>, <xref:System.Tuple%607.Item4%2A>, <xref:System.Tuple%607.Item5%2A>, <xref:System.Tuple%607.Item6%2A>, und <xref:System.Tuple%607.Item7%2A> Instanzeigenschaften. Alle zusätzlichen Komponenten geschachtelt sind und abgerufen werden können, aus der <xref:System.Tuple%608.Rest%2A> Eigenschaft. Im vorherigen Beispiel der <xref:System.Tuple%608.Item1%2A> über <xref:System.Tuple%608.Item7%2A> Eigenschaften abgerufen werden zwischen dem ersten und siebten Komponente des Tupels. Das achte bis vierzehnte Komponente enthalten sind, in das Tupel, das auf der zweiten Ebene geschachtelt ist, und werden durch dargestellt die `Rest.Item1` über `Rest.Item7` Eigenschaften. Das fünfzehnte bis siebzehnte Komponente enthalten sind, in das Tupel, das auf der dritten Ebene geschachtelt ist, und werden durch dargestellt die `Rest.Rest.Item1` Obwohl `Rest.Rest.Item3` Eigenschaften.  
  
 Tupel werden häufig in vier verschiedene Arten verwendet:  
  
-   Um einen einzelnen Satz von Daten darzustellen. Beispielsweise ein Tupel kann ein Datenbankeintrag darstellen, und seine Komponenten können einzelne Felder des Datensatzes darstellen.  
  
-   Einfacher Zugriff auf und Bearbeitung von einem DataSet bereitzustellen.  
  
-   Mehrere Werte zurückgeben, von einer Methode ohne Verwendung eines `out` Parameter (in c#) oder `ByRef` Parameter (in Visual Basic). Das vorherige Beispiel gibt z. B. seine berechnete Statistik, zusammen mit dem Namen der Stadt, in einem <xref:System.Tuple%607> Objekt.  
  
-   Mehrere Werte an eine Methode über einen einzelnen Parameter übergeben. Z. B. die <xref:System.Threading.Thread.Start%28System.Object%29?displayProperty=nameWithType> Methode verfügt über einen einzelnen Parameter, mit dem Sie einen Wert für die Methode angeben, die beim Start der Thread ausgeführt wird. Wenn Sie angeben, ein <xref:System.Tuple%607> -Objekt als Methodenargument können Sie die Startroutine mit sieben Elementen von Daten angeben.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Tuple" />
    <altmember cref="T:System.Tuple`1" />
    <altmember cref="T:System.Tuple`2" />
    <altmember cref="T:System.Tuple`3" />
    <altmember cref="T:System.Tuple`4" />
    <altmember cref="T:System.Tuple`5" />
    <altmember cref="T:System.Tuple`6" />
    <altmember cref="T:System.Tuple`7" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Tuple (T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T1 item1, !T2 item2, !T3 item3, !T4 item4, !T5 item5, !T6 item6, !T7 item7, !TRest rest) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.#ctor(`0,`1,`2,`3,`4,`5,`6,`7)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (item1 As T1, item2 As T2, item3 As T3, item4 As T4, item5 As T5, item6 As T6, item7 As T7, rest As TRest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);" />
      <MemberSignature Language="F#" Value="new Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt; : 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'Rest -&gt; Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;" Usage="new System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt; (item1, item2, item3, item4, item5, item6, item7, rest)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="item1" Type="T1" />
        <Parameter Name="item2" Type="T2" />
        <Parameter Name="item3" Type="T3" />
        <Parameter Name="item4" Type="T4" />
        <Parameter Name="item5" Type="T5" />
        <Parameter Name="item6" Type="T6" />
        <Parameter Name="item7" Type="T7" />
        <Parameter Name="rest" Type="TRest" />
      </Parameters>
      <Docs>
        <param name="item1">Der Wert der ersten Komponente des Tupels.</param>
        <param name="item2">Der Wert der zweiten Komponente des Tupels.</param>
        <param name="item3">Der Wert der dritten Komponente des Tupels.</param>
        <param name="item4">Der Wert der vierten Komponente des Tupels.</param>
        <param name="item5">Der Wert der fünften Komponente des Tupels.</param>
        <param name="item6">Der Wert der sechsten Komponente des Tupels.</param>
        <param name="item7">Der Wert der siebten Komponente des Tupels.</param>
        <param name="rest">Ein beliebiges generisches <see langword="Tuple" />-Objekt, das die Werte der restlichen Komponenten des Tupels enthält.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Tuple`8" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch mithilfe der statischen <xref:System.Tuple.Create%2A?displayProperty=nameWithType> Methode, um ein 8-Tupel (Oktupel)-Objekt zu instanziieren, ohne die Typen seiner Komponenten explizit angeben zu müssen. Im folgenden Beispiel wird die <xref:System.Tuple.Create%2A?displayProperty=nameWithType> Methode, um ein 8-Tupel-Objekt nicht instanziieren, die Primzahlen enthält, die kleiner als 20 sind.  
  
 [!code-csharp[System.Tuple.Create#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/createntuple.cs#17)]
 [!code-vb[System.Tuple.Create#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/createntuple.vb#17)]  
  
 Dies ist gleichbedeutend mit dem folgenden Aufruf der <xref:System.Tuple%607.%23ctor%2A> Klassenkonstruktor.  
  
 [!code-csharp[System.Tuple\`8.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.class/cs/octuple1.cs#1)]
 [!code-vb[System.Tuple\`8.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.class/vb/octuple1.vb#1)]  
  
 Allerdings die statische <xref:System.Tuple.Create%2A?displayProperty=nameWithType> Methode kann nicht verwendet werden, um ein Tupelobjekt mit mehr als acht Komponenten zu erstellen.  
  
 Bei Verwendung der <xref:System.Tuple%608.%23ctor%2A> Konstruktor zum Erstellen einer n-Tupel mit acht oder mehr Komponenten, Sie verwenden die `rest` Parameter, um ein geschachtelte n-Tupel, verfügt ein bis sieben Komponenten erstellen. Mithilfe von aufeinander folgenden Schachtelungsebenen können Sie ein n-Tupel erstellen, die eine praktisch unbegrenzte Anzahl von Komponenten enthält. Um ein 25-Tupel zu erstellen, instanziieren Sie z. B. eine <xref:System.Tuple%608> -Objekt mit drei Schachtelungsebenen wie folgt:  
  
-   Bewirkt die äußerste <xref:System.Tuple%608> Objekt enthält, zwischen dem ersten und siebten Komponenten. Die <xref:System.Tuple%608.Rest%2A> Eigenschaft ermöglicht den Zugriff auf ein <xref:System.Tuple%608> Objekt auf der ersten Ebene der Schachtelung.  
  
-   Das äußerste geschachtelte <xref:System.Tuple%608> Objekt enthält die achte bis vierzehnte Komponente, und die zugehörige <xref:System.Tuple%608.Rest%2A> Eigenschaft ermöglicht den Zugriff auf ein <xref:System.Tuple%608> Objekt auf der zweiten Ebene der Schachtelung.  
  
-   Die <xref:System.Tuple%608> Objekt auf der zweiten Ebene der Schachtelung enthält die fünfzehnte bis 21.-Komponenten, und die zugehörige <xref:System.Tuple%608.Rest%2A> Eigenschaft ermöglicht den Zugriff auf ein <xref:System.Tuple%604> Objekt auf der dritten Ebene der Schachtelung.  
  
-   Das innerste Tupel ist ein <xref:System.Tuple%604> -Objekt, das die zweiundzwanzigsten bis 25. Komponenten enthält.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein 17-Tupel, die Daten der Auffüllung für den Ort Detroit, Michigan, für jede Erhebung von 1860 bis 2000 enthält. Die erste Komponente des Tupels ist der Name des Orts. Die zweite Komponente ist das Startdatum der Reihen von Daten, und die dritte Komponente ist die Auffüllung beim Startdatum. Jede nachfolgende Komponente enthält die Auffüllung in Abständen von zehn Jahren. Im Beispiel wird mit zwei Ebenen der Schachtelung 17-Tupel erstellen: er definiert ein 7-Tupel, deren dritte bis siebte Komponenten enthalten, Auffüllung Daten für 1860 bis 1900 ein geschachteltes 7-Tupel, die Auffüllung für 1910 bis 1970 enthält, und eine innere verschachtelte 3-Tupel Auffüllung Daten enthält für 1980 bis 2000.  
  
 [!code-csharp[System.Tuple.Create#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple.create/cs/example.cs#19)]
 [!code-vb[System.Tuple.Create#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple.create/vb/example.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rest" /> ist kein generisches <see langword="Tuple" />-Objekt.</exception>
        <altmember cref="M:System.Tuple.Create``8(``0,``1,``2,``3,``4,``5,``6,``7)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="tuple.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob das aktuelle <see cref="T:System.Tuple`8" />-Objekt gleich einem angegebenen Objekt ist.</summary>
        <returns>
          <see langword="true" />, wenn die aktuelle Instanz gleich dem angegebenen Objekt ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `obj` Parameter gilt die aktuelle Instanz gleich sein, wenn sie die folgenden Bedingungen erfüllt:  
  
-   Es ist ein <xref:System.Tuple%608> Objekt.  
  
-   Er verfügt über die gleiche Gesamtzahl von Komponenten, die der gleichen Typen wie die aktuelle Instanz sind.  
  
-   Seine Komponenten (einschließlich seiner geschachtelten Komponenten) sind, die denen der aktuellen Instanz entsprechen. Die Gleichheit wird durch den Standardgleichheitsvergleich für die einzelnen Komponenten festgelegt.  
  
   
  
## Examples  
 Das folgende Beispiel definiert fünf <xref:System.Tuple%608> Objekte, die Primzahlen enthalten. Es vergleicht dann das erste Objekt mit jedem der verbleibenden Objekte. Wie die Ausgabe zeigt nur die ersten und letzten <xref:System.Tuple%608> Objekte gleich sind, da sie eine identische Anzahl von Komponenten mit identischen Werten aufweisen.  
  
 [!code-csharp[System.Tuple\`8.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.equals/cs/equals1.cs#1)]
 [!code-vb[System.Tuple\`8.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="tuple.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Berechnet den Hashcode für das aktuelle <see cref="T:System.Tuple`8" />-Objekt.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item1">
      <MemberSignature Language="C#" Value="public T1 Item1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T1 Item1" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item1" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item1 As T1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T1 Item1 { T1 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item1 : 'T1" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T1</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der ersten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts ab.</summary>
        <value>Der Wert der ersten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den Typ des dynamisch bestimmen die <xref:System.Tuple%608.Item1%2A> -Komponente in zwei Arten:  
  
-   Durch Aufrufen der `GetType` Methode auf dem Wert, der von zurückgegeben wird die <xref:System.Tuple%608.Item1%2A> Eigenschaft.  
  
-   Durch Abrufen der <xref:System.Type> Objekt, das darstellt der <xref:System.Tuple%608> -Objekt und das Abrufen des ersten Elements aus dem Array, das von zurückgegebene seine <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein 17-Tupel-Objekt, das Auffüllung Daten für den Ort Detroit, Michigan, von 1860 bis 2000 enthält. Die erste Komponente des Tupels 17-ist der Name des Orts. Im Beispiel wird die <xref:System.Tuple%608.Item1%2A> -Eigenschaft den Namen der Stadt im Tabellenkopf angezeigt werden, vor dem Anzeigen der Daten auffüllen.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item2">
      <MemberSignature Language="C#" Value="public T2 Item2 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T2 Item2" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item2" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item2 As T2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T2 Item2 { T2 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item2 : 'T2" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item2" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T2</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der zweiten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts ab.</summary>
        <value>Der Wert der zweiten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den Typ des dynamisch bestimmen die <xref:System.Tuple%608.Item2%2A> -Komponente in zwei Arten:  
  
-   Durch Aufrufen der `GetType` Methode auf dem Wert, der von zurückgegeben wird die <xref:System.Tuple%608.Item2%2A> Eigenschaft.  
  
-   Durch Abrufen der <xref:System.Type> Objekt, das darstellt der <xref:System.Tuple%608> -Objekt und das zweite Element aus dem Array, das von zurückgegebene abrufen seiner <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein 17-Tupel-Objekt, das Auffüllung Daten für den Ort Detroit, Michigan, von 1860 bis 2000 enthält. Die zweite Komponente des Tupels 17-ist der Datenreihen des ersten Jahrs. Im Beispiel weist den Wert der <xref:System.Tuple%608.Item2%2A> Eigenschaft zu einer Variablen zugewiesen und dann verwendet, die diese Variable, um das Jahr darzustellen, deren Daten werden angezeigt.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item3">
      <MemberSignature Language="C#" Value="public T3 Item3 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T3 Item3" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item3" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item3 As T3" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T3 Item3 { T3 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item3 : 'T3" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item3" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T3</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der dritten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts ab.</summary>
        <value>Der Wert der dritten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den Typ des dynamisch bestimmen die <xref:System.Tuple%608.Item3%2A> -Komponente in zwei Arten:  
  
-   Durch Aufrufen der `GetType` Methode auf dem Wert, der von zurückgegeben wird die <xref:System.Tuple%608.Item3%2A> Eigenschaft.  
  
-   Durch das Abrufen der <xref:System.Type> Objekt, das darstellt der <xref:System.Tuple%608> -Objekt und das Abrufen des dritten Elements aus dem Array, das vom zurückgegeben wird seine <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein 17-Tupel-Objekt, das Auffüllung Daten für den Ort Detroit, Michigan, von 1860 bis 2000 enthält. Der dritte Komponente des 17-Tupel ist die Auffüllung in 1860. Im Beispiel wird die <xref:System.Tuple%608.Item3%2A> Eigenschaft, um die Einwohnerzahl anzuzeigen und zu den jährliche Änderungsrate Auffüllung zwischen 1860 und 1870 berechnen.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item4">
      <MemberSignature Language="C#" Value="public T4 Item4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T4 Item4" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item4" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item4 As T4" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T4 Item4 { T4 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item4 : 'T4" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T4</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der vierten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts ab.</summary>
        <value>Der Wert der vierten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den Typ des dynamisch bestimmen die <xref:System.Tuple%608.Item4%2A> -Komponente in zwei Arten:  
  
-   Durch Aufrufen der `GetType` Methode auf dem Wert, der von zurückgegeben wird die <xref:System.Tuple%608.Item4%2A> Eigenschaft.  
  
-   Durch Abrufen der <xref:System.Type> Objekt, das darstellt der <xref:System.Tuple%608> Objekt und dem Abrufen von das vierte Element aus dem Array, das vom zurückgegeben wird seine <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein 17-Tupel-Objekt, das Auffüllung Daten für den Ort Detroit, Michigan, von 1860 bis 2000 enthält. Der vierte Komponente des 17-Tupel ist die Auffüllung von 1870. Im Beispiel wird die <xref:System.Tuple%608.Item4%2A> Eigenschaft, um die Einwohnerzahl anzuzeigen und zu den jährliche Änderungsrate Auffüllung zwischen 1870 und 1880 berechnen.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item5">
      <MemberSignature Language="C#" Value="public T5 Item5 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T5 Item5" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item5 As T5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T5 Item5 { T5 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item5 : 'T5" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item5" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T5</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der fünften Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts ab.</summary>
        <value>Der Wert der fünften Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den Typ des dynamisch bestimmen die <xref:System.Tuple%608.Item5%2A> -Komponente in zwei Arten:  
  
-   Durch Aufrufen der `GetType` Methode auf dem Wert, der von zurückgegeben wird die <xref:System.Tuple%608.Item5%2A> Eigenschaft.  
  
-   Durch Abrufen der <xref:System.Type> Objekt, das darstellt der <xref:System.Tuple%608> -Objekt und das Abrufen des fünften Elements aus dem Array, das von zurückgegebene seine <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein 17-Tupel-Objekt, das Auffüllung Daten für den Ort Detroit, Michigan, von 1860 bis 2000 enthält. Der fünfte Komponente des 17-Tupel ist die Auffüllung in 1880. Im Beispiel wird die <xref:System.Tuple%608.Item5%2A> Eigenschaft, um die Einwohnerzahl anzuzeigen und zu den jährliche Änderungsrate Auffüllung zwischen 1880 und 1890 berechnen.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item6">
      <MemberSignature Language="C#" Value="public T6 Item6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T6 Item6" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item6" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item6 As T6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T6 Item6 { T6 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item6 : 'T6" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T6</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der sechsten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts ab.</summary>
        <value>Der Wert der sechsten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den Typ des dynamisch bestimmen die <xref:System.Tuple%608.Item6%2A> -Komponente in zwei Arten:  
  
-   Durch Aufrufen der `GetType` Methode auf dem Wert, der von zurückgegeben wird die <xref:System.Tuple%608.Item6%2A> Eigenschaft.  
  
-   Durch das Abrufen der <xref:System.Type> Objekt, das darstellt der <xref:System.Tuple%608> -Objekt und das Abrufen des sechsten Elements aus dem Array, das vom zurückgegeben wird seine <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein 17-Tupel-Objekt, das Auffüllung Daten für den Ort Detroit, Michigan, von 1860 bis 2000 enthält. Der sechste Komponente des 17-Tupel ist die Auffüllung in 1890. Im Beispiel wird die <xref:System.Tuple%608.Item6%2A> Eigenschaft zur Anzeige des Werts für die Auffüllung und die jährliche Änderungsrate Auffüllung zwischen 1890 und 1900 zu berechnen.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item7">
      <MemberSignature Language="C#" Value="public T7 Item7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T7 Item7" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Item7" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Item7 As T7" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T7 Item7 { T7 get(); };" />
      <MemberSignature Language="F#" Value="member this.Item7 : 'T7" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Item7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T7</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert der siebten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts ab.</summary>
        <value>Der Wert der siebten Komponente des aktuellen <see cref="T:System.Tuple`8" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den Typ des dynamisch bestimmen die <xref:System.Tuple%608.Item7%2A> -Komponente in zwei Arten:  
  
-   Durch Aufrufen der `GetType` Methode auf dem Wert, der von zurückgegeben wird die <xref:System.Tuple%608.Item7%2A> Eigenschaft.  
  
-   Durch das Abrufen von der <xref:System.Type> Objekt, das darstellt der <xref:System.Tuple%608> -Objekt und das Abrufen des siebten Elements aus dem Array, das von zurückgegebene seine <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein 17-Tupel-Objekt, das Auffüllung Daten für den Ort Detroit, Michigan, von 1860 bis 2000 enthält. Der siebte Komponente des 17-Tupel ist die Auffüllung in 1900. Im Beispiel wird die <xref:System.Tuple%608.Item7%2A> Eigenschaft, um die Einwohnerzahl anzuzeigen und zu den jährliche Änderungsrate Auffüllung zwischen 1900 und 1910 berechnen.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rest">
      <MemberSignature Language="C#" Value="public TRest Rest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TRest Rest" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.Rest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rest As TRest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TRest Rest { TRest get(); };" />
      <MemberSignature Language="F#" Value="member this.Rest : 'Rest" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.Rest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TRest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die restlichen Komponenten des aktuellen <see cref="T:System.Tuple`8" />-Objekts ab.</summary>
        <value>Der Wert der restlichen Komponenten des aktuellen <see cref="T:System.Tuple`8" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Tuple%608.Rest%2A> Eigenschaft gibt eine geschachtelte `Tuple` Objekt, das zwar den Zugriff auf das achte ermöglicht *n*te-Komponente des Tupels. Abhängig von der Gesamtzahl der Komponenten im Tupel, die Werte der achten bis vierzehnten Komponenten abgerufen werden aus der geschachtelten `Tuple` des Objekts <xref:System.Tuple%608.Item1%2A> über <xref:System.Tuple%608.Item7%2A> Eigenschaften. Anschließend können Sie die <xref:System.Tuple%608.Rest%2A> eine geschachtelte Eigenschaft <xref:System.Tuple%608> abzurufenden Objekts die `Tuple` Objekt auf der Ebene der Schachtelung.  
  
 Sie können dynamisch bestimmen die Anzahl der Komponenten in einem geschachtelten `Tuple` von zurückgegebene Objekt der <xref:System.Tuple%608.Rest%2A> Eigenschaft, indem die Ziffer aus seinem Typnamen extrahiert. Dies wird im folgenden Beispiel veranschaulicht.  
  
 [!code-vb[System.Tuple\`8.Item1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/rest.vb#2)]  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein 17-Tupel-Objekt, das Auffüllung Daten für den Ort Detroit, Michigan, von 1860 bis 2000 enthält. Der siebte Komponente des 17-Tupel ist die Auffüllung in 1900. Im Beispiel wird die <xref:System.Tuple%608.Rest%2A> Eigenschaft zum Abrufen der Werte der achten bis vierzehnten Komponenten, und es verwendet die <xref:System.Tuple%608.Rest%2A> Eigenschaft des geschachtelten <xref:System.Tuple%608> Objekt zum Abrufen der Werte der verbleibenden Komponenten.  
  
 [!code-csharp[System.Tuple\`8.Item1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.item1/cs/item1.cs#1)]
 [!code-vb[System.Tuple\`8.Item1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.item1/vb/item1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">Ein Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
        <param name="comparer">Ein Objekt, das benutzerdefinierte Regeln für Vergleiche bereitstellt.</param>
        <summary>Vergleicht das aktuelle <see cref="T:System.Tuple`8" />-Objekt anhand eines angegebenen Vergleichs mit einem angegebenen Objekt und gibt eine ganze Zahl zurück, die angibt, ob sich das aktuelle Element in der Sortierreihenfolge vor dem angegebenen Element, dahinter oder an derselben Position befindet.</summary>
        <returns>Eine ganze Zahl mit Vorzeichen, die die relative Position dieser Instanz und von <paramref name="other" /> in der Sortierreihenfolge angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Wert  </term><description> Beschreibung  </description></listheader><item><term> Eine negative ganze Zahl  </term><description> Diese Instanz steht vor <paramref name="other" />.  </description></item><item><term> 0 (null)  </term><description> Diese Instanz und <paramref name="other" /> befinden sich in der Sortierreihenfolge an der gleichen Position.  </description></item><item><term> Eine positive ganze Zahl  </term><description> Diese Instanz folgt <paramref name="other" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellenimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Tuple%608>-Instanz in eine <xref:System.Collections.IStructuralComparable>-Schnittstelle umgewandelt wird.  
  
 Mit dieser Methode können Sie benutzerdefinierte Vergleiche von definieren <xref:System.Tuple%608> Objekte. Beispielsweise können Sie diese Methode, um die Reihenfolge <xref:System.Tuple%608> Objekte basierend auf den Wert einer bestimmten Komponente.  
  
 Obwohl diese Methode direkt aufgerufen werden kann, ist es meist bezeichnet Auflistung sortieren Methoden wie <xref:System.Collections.IComparer> Parameter zum Anordnen der Elemente einer Auflistung. Wird z. B. von aufgerufen der <xref:System.Array.Sort%28System.Array%2CSystem.Collections.IComparer%29?displayProperty=nameWithType> Methode und die <xref:System.Collections.SortedList.Add%2A> Methode von einer <xref:System.Collections.SortedList> -Objekt, das mit instanziiert wird der <xref:System.Collections.SortedList.%23ctor%28System.Collections.IComparer%29?displayProperty=nameWithType> Konstruktor.  
  
> [!CAUTION]
>  Die <xref:System.Tuple%608.System%23Collections%23IStructuralComparable%23CompareTo%2A> Methode ist für die Verwendung in Sortiervorgängen vorgesehen. Es sollte nicht verwendet werden, wenn der primäre Zweck eines Vergleichs ist, um zu bestimmen, ob zwei Objekte gleich sind. Um zu bestimmen, ob zwei Objekte gleich sind, rufen Sie die <xref:System.Tuple%608.System%23Collections%23IStructuralEquatable%23Equals%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein Array von <xref:System.Tuple%608> Objekte, die Daten der Auffüllung für vier US-Orte von 1940 bis 2000 enthält. Erste Komponente der Oktupel ist der Name des Orts. Die verbleibenden sechs Komponenten stellen die Auffüllung in Intervallen von 10 Jahre von 1940 auf 2000 dar.  
  
 Die `PopulationComparer` -Klasse bietet eine <xref:System.Collections.IComparer> Implementierung, die das Array von Oktupel durch eine der zugehörigen Komponenten sortiert werden kann. Zwei Werte werden bereitgestellt, um die `PopulationComparer` Klasse in ihrem Konstruktor: die Position der Komponente, die die Sortierreihenfolge festlegt und ein <xref:System.Boolean> Wert, der angibt, ob die Tupelobjekte in aufsteigender oder absteigender Reihenfolge sortiert werden sollen.  
  
 Im Beispiel werden dann die Elemente im Array in unsortierter Reihenfolge angezeigt, sortiert sie nach der dritten Komponente (die Auffüllung in 1950) und zeigt an, und klicken Sie dann sortiert sie nach der achten Komponente (die Auffüllung in 2000) und angezeigt.  
  
 [!code-csharp[System.Tuple\`8.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.compareto/cs/compareto2.cs#2)]
 [!code-vb[System.Tuple\`8.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.compareto/vb/compareto2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="other" /> ist kein <see cref="T:System.Tuple`8" />-Objekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">Das Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <param name="comparer">Ein Objekt, das die Methode definiert, mit der ermittelt wird, ob die beiden Objekte gleich sind.</param>
        <summary>Gibt einen Wert zurück, der auf Grundlage einer angegebenen Vergleichsmethode angibt, ob das aktuelle <see cref="T:System.Tuple`8" />-Objekt gleich einem angegebenen Objekt ist.</summary>
        <returns>
          <see langword="true" />, wenn die aktuelle Instanz gleich dem angegebenen Objekt ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Tuple%608>-Instanz in eine <xref:System.Collections.IStructuralEquatable>-Schnittstelle umgewandelt wird.  
  
 Die <xref:System.Collections.IEqualityComparer.Equals%2A?displayProperty=nameWithType> Implementierung wird nur aufgerufen, wenn `other` nicht `null`, und ob es erfolgreich sein kann (in c#) umgewandelt oder konvertiert (in Visual Basic) einer <xref:System.Tuple%608> -Objekt, das die gleichen Gesamtzahl der Komponenten (einschließlich jenen in geschachtelten `Tuple` Objekte) des dieselben Typen wie die aktuelle Instanz. Die <xref:System.Tuple%608.System%23Collections%23IStructuralEquatable%23Equals%28System.Object%2CSystem.Collections.IEqualityComparer%29> -Methode übergibt zuerst die <xref:System.Tuple%608.Item1%2A> Werte von der <xref:System.Tuple%608> zu zu vergleichenden Objekte die <xref:System.Collections.IEqualityComparer.Equals%2A?displayProperty=nameWithType> Implementierung. Wenn dieser Methodenaufruf zurückgegeben `true`, die-Methode erneut aufgerufen und an die <xref:System.Tuple%608.Item2%2A> Werte der beiden <xref:System.Tuple%608> Objekte. Dieser Vorgang wird fortgesetzt, bis der Methodenaufruf zurückgegeben `false` Wenn vergleicht ein bestimmtes Tabellenpaar Werte oder die beiden <xref:System.Tuple%608.Rest%2A> Werte werden an die Methode übergeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Ein Objekt, dessen <see cref="M:System.Collections.IEqualityComparer.GetHashCode(System.Object)" />-Methode den Hashcode des aktuellen <see cref="T:System.Tuple`8" />-Objekts berechnet</param>
        <summary>Berechnet mit einer angegebenen Berechnungsmethode den Hash für das aktuelle <see cref="T:System.Tuple`8" />-Objekt.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Tuple%608>-Instanz in eine <xref:System.Collections.IStructuralEquatable>-Schnittstelle umgewandelt wird.  
  
 Die Methode einfach einen Aufruf umschließt die `comparer` des Objekts <xref:System.Collections.IEqualityComparer.GetHashCode%2A?displayProperty=nameWithType> Implementierung.  
  
 Der Algorithmus verwendet, um den Hash berechnen sollte den gleichen Hashcode zurückgeben, für zwei <xref:System.Tuple%608> Objekte, die als gleich betrachtet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
        <summary>Vergleicht das aktuelle <see cref="T:System.Tuple`8" />-Objekt mit einem angegebenen Objekt und gibt eine Ganzzahl zurück, die darauf hinweist, ob sich das aktuelle Objekt in der Sortierreihenfolge vor oder hinter dem angegebenen Objekt oder an der gleichen Position befindet.</summary>
        <returns>Eine ganze Zahl mit Vorzeichen, die die relative Position dieser Instanz und von <paramref name="obj" /> in der Sortierreihenfolge angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Wert  </term><description> Beschreibung  </description></listheader><item><term> Eine negative ganze Zahl  </term><description> Diese Instanz steht vor <paramref name="obj" />.  </description></item><item><term> 0 (null)  </term><description> Diese Instanz und <paramref name="obj" /> befinden sich in der Sortierreihenfolge an der gleichen Position.  </description></item><item><term> Eine positive ganze Zahl  </term><description> Diese Instanz folgt <paramref name="obj" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Tuple%608>-Instanz in eine <xref:System.IComparable>-Schnittstelle umgewandelt wird.  
  
 Diese Methode stellt der <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> Implementierung für die <xref:System.Tuple%608> Klasse. Obwohl die Methode direkt aufgerufen werden kann, wird es am häufigsten aufgerufen durch die standardüberladungen Auflistung sortieren Methoden, wie z. B. <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> und <xref:System.Collections.SortedList.Add%2A?displayProperty=nameWithType>, um die Elemente einer Auflistung zu bestellen.  
  
> [!CAUTION]
>  Die <xref:System.Tuple%608.System%23IComparable%23CompareTo%2A> Methode ist für die Verwendung in Sortiervorgängen vorgesehen. Es sollte nicht verwendet werden, wenn der primäre Zweck eines Vergleichs ist, um zu bestimmen, ob zwei Objekte gleich sind. Um zu bestimmen, ob zwei Objekte gleich sind, rufen Sie die <xref:System.Tuple%608.Equals%28System.Object%29?displayProperty=nameWithType> Methode.  
  
 Diese Methode verwendet den Standardvergleich für das Objekt, jede Komponente verglichen werden soll.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein Array von Oktupel, dessen Komponenten um Ganzzahlen handelt, die einen Bereich von Primzahlen enthalten. Das Beispiel zeigt die Elemente des Arrays in unsortierter Reihenfolge, sortiert das Array und zeigt dann das Array in sortierter Reihenfolge. Die Ausgabe zeigt, dass es sich bei der Sortierung des Arrays von <xref:System.Tuple%608.Item1%2A>, oder die erste Komponente des Tupels. Beachten Sie, die im Beispiel nicht direkt aufgerufen wird die <xref:System.Tuple%608.System%23IComparable%23CompareTo%28System.Object%29> Methode. Diese Methode aufgerufen wird, implizit von der <xref:System.Array.Sort%28System.Array%29> Methode für jedes Element im Array.  
  
 [!code-csharp[System.Tuple\`8.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.compareto/cs/compareto1.cs#1)]
 [!code-vb[System.Tuple\`8.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.compareto/vb/compareto1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> ist kein <see cref="T:System.Tuple`8" />-Objekt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.CompilerServices.ITuple.Item">
      <MemberSignature Language="C#" Value="object System.Runtime.CompilerServices.ITuple.Item[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Runtime.CompilerServices.ITuple.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.System#Runtime#CompilerServices#ITuple#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Item(index As Integer) As Object Implements ITuple.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Runtime.CompilerServices.ITuple.Item[int] { System::Object ^ get(int index); };" />
      <MemberSignature Language="F#" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.System.Runtime.CompilerServices.ITuple.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.CompilerServices.ITuple.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der Index des angegebenen Elements <see langword="Tuple" />. <c>index</c> kann von 0 (null) für <see langword="Item1" /> bis eins weniger als die Anzahl der Elemente in <see langword="Tuple" /> reichen.</param>
        <summary>Ruft den Wert des angegebenen Elements <see langword="Tuple" /> ab.</summary>
        <value>Der Wert des <see langword="Tuple" />-Elements an der angegebenen Position.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Tuple%608.System%23Runtime%23CompilerServices%23ITuple%23Item%2A?displayProperty=nameWithType> Eigenschaft ist eine explizite schnittstellenimplementierung. Um sie aufzurufen, müssen Sie umgewandelt oder konvertiert die <xref:System.Tuple%608> -Objekt an eine <xref:System.Runtime.CompilerServices.ITuple> -Schnittstellenobjekt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0.  Oder:  <paramref name="index" /> ist größer oder gleich <see cref="P:System.Tuple`8.System#Runtime#CompilerServices#ITuple#Length" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.CompilerServices.ITuple.Length">
      <MemberSignature Language="C#" Value="int System.Runtime.CompilerServices.ITuple.Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Runtime.CompilerServices.ITuple.Length" />
      <MemberSignature Language="DocId" Value="P:System.Tuple`8.System#Runtime#CompilerServices#ITuple#Length" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Length As Integer Implements ITuple.Length" />
      <MemberSignature Language="C++ CLI" Value="property int System.Runtime.CompilerServices.ITuple.Length { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Tuple&lt;'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'Rest&gt;.System.Runtime.CompilerServices.ITuple.Length" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.CompilerServices.ITuple.Length</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente im <see langword="Tuple" /> ab.</summary>
        <value>Die Anzahl der Elemente im <see langword="Tuple" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Tuple%608.System%23Runtime%23CompilerServices%23ITuple%23Length%2A> Eigenschaft ist eine explizite schnittstellenimplementierung. Um sie aufzurufen, müssen Sie umgewandelt oder konvertiert die <xref:System.Tuple%608> Geben Sie an einer <xref:System.Runtime.CompilerServices.ITuple> -Schnittstellenobjekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Tuple`8.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="tuple.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die den Wert dieser <see cref="T:System.Tuple`8" />-Instanz darstellt.</summary>
        <returns>Die Zeichenfolgendarstellung dieses <see cref="T:System.Tuple`8" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die von dieser Methode zurückgegebene Zeichenfolge hat das Format (*Item1*, *Item2*, *Item3*, *Item4*, `Item5, Item6, Item7`, * Item8*...), wobei *Item1*, *Item2*, *Item3*, *Item4*, *Item5*, *Item6*, und *Item7* stellen die Werte von der <xref:System.Tuple%608.Item1%2A>, <xref:System.Tuple%608.Item2%2A>, <xref:System.Tuple%608.Item3%2A>, <xref:System.Tuple%608.Item4%2A>, <xref:System.Tuple%608.Item5%2A>, <xref:System.Tuple%608.Item6%2A>, und <xref:System.Tuple%608.Item7%2A> Eigenschaften. *Item8* stellt den Wert der <xref:System.Tuple%608> des Objekts `Next.Item1` Eigenschaft. Folgen Sie der Wert der geschachtelten zusätzlichen Komponenten *Item8*. Wenn einer der Eigenschaftswerte `null`, liegt als <xref:System.String.Empty?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein 17-Tupel, die Daten der Auffüllung für den Ort Detroit, Michigan, von 1860 zu 1900 enthält. Es verwendet dann die <xref:System.Tuple%608.ToString%2A> -Methode zum Anzeigen der Daten des Tupels.  
  
 [!code-csharp[System.Tuple\`8.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.tuple`8.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Tuple\`8.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.tuple`8.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>