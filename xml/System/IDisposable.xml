<Type Name="IDisposable" FullName="System.IDisposable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e6f09f058e95a1c2b8012337b159919a47416da0" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83513244" /></Metadata><TypeSignature Language="C#" Value="public interface IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IDisposable" />
  <TypeSignature Language="VB.NET" Value="Public Interface IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IDisposable" />
  <TypeSignature Language="F#" Value="type IDisposable = interface" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Mechanismus für die Freigabe nicht verwalteter Ressourcen bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die primäre Verwendung dieser Schnittstelle besteht darin, nicht verwaltete Ressourcen freizugeben. Der Garbage Collector gibt den Arbeitsspeicher, der einem verwalteten Objekt zugeordnet ist, automatisch frei, wenn dieses Objekt nicht mehr verwendet wird. Es ist jedoch nicht möglich, vorherzusagen, wann Garbage Collection auftreten werden. Außerdem hat der Garbage Collector keine Kenntnis von nicht verwalteten Ressourcen wie z. b. Fenster Handles oder geöffneten Dateien und Streams.  
  
 Verwenden Sie die <xref:System.IDisposable.Dispose%2A>-Methode dieser Schnittstelle, um nicht verwaltete Ressourcen explizit in Verbindung mit dem Garbage Collector freizugeben. Der Consumer eines Objekts kann diese Methode aufzurufen, wenn das Objekt nicht mehr benötigt wird.  
  
> [!WARNING]
>  Es ist eine Breaking Change, die <xref:System.IDisposable>-Schnittstelle zu einer vorhandenen Klasse hinzuzufügen. Da bereits vorhandene Consumer ihres Typs <xref:System.IDisposable.Dispose%2A>nicht abrufen können, können Sie nicht sicher sein, dass nicht verwaltete Ressourcen, die von Ihrem Typ aufbewahrt werden, freigegeben werden.  
  
 Da die <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>-Implementierung vom Consumer eines Typs aufgerufen wird, wenn die Ressourcen, die sich im Besitz einer Instanz befinden, nicht mehr benötigt werden, sollten Sie entweder das verwaltete Objekt in einem <xref:System.Runtime.InteropServices.SafeHandle> einschließen (die empfohlene Alternative), oder Sie sollten <xref:System.Object.Finalize%2A?displayProperty=nameWithType> überschreiben, um nicht verwaltete Ressourcen freizugeben, falls der Consumer vergisst, <xref:System.IDisposable.Dispose%2A>aufzurufen.  
  
> [!IMPORTANT]
>  Im .NET Framework unterstützt der C++ Compiler die deterministische Freigabe von Ressourcen und lässt keine direkte Implementierung der <xref:System.IDisposable.Dispose%2A>-Methode zu.  
  
 Ausführliche Informationen zur Verwendung dieser Schnittstelle und der <xref:System.Object.Finalize%2A?displayProperty=nameWithType>-Methode finden Sie [in den Themen](~/docs/standard/garbage-collection/index.md) zur automatischen Speicher Bereinigung und zur [Implementierung einer](~/docs/standard/garbage-collection/implementing-dispose.md) verwerfen-Methode.  
  
## <a name="using-an-object-that-implements-idisposable"></a>Verwenden eines Objekts, das iverwerfimplementiert  
 Wenn Ihre APP einfach ein Objekt verwendet, das die <xref:System.IDisposable>-Schnittstelle implementiert, sollten Sie die <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>-Implementierung des Objekts abrufen, wenn Sie die Verwendung abgeschlossen haben. Abhängig von ihrer Programmiersprache können Sie dies auf zwei Arten erreichen:  
  
-   Mithilfe eines sprach Konstrukts, wie z. b. C# der `using`-Anweisung in und Visual Basic.  
  
-   Durch umwickeln des Aufrufes der <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> Implementierung in einer `try`/`finally` Blocks.  
  
> [!NOTE]
>  Dokumentation für Typen, die implementieren <xref:System.IDisposable> beachten Sie, dass diese Tatsache und eine Erinnerung enthalten, um die <xref:System.IDisposable.Dispose%2A> Implementierung aufzurufen.  
  
<a name="Using"></a>   
### <a name="the-c-and-visual-basic-using-statement"></a>Die C# -und-Visual Basic using-Anweisung  
 Wenn Ihre Sprache ein Konstrukt wie die [using](~/docs/csharp/language-reference/keywords/using.md) -Anweisung in C# und die [using](~/docs/visual-basic/language-reference/statements/using-statement.md) -Anweisung in Visual Basic unterstützt, können Sie Sie verwenden, anstatt <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> selbst explizit aufrufen. Im folgenden Beispiel wird dieser Ansatz verwendet, um eine `WordCount` Klasse zu definieren, die Informationen über eine Datei und die Anzahl der darin aufgeführten Wörter beibehält.  
  
 [!code-csharp[System.IDisposable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling1.cs#1)]
 [!code-vb[System.IDisposable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling1.vb#1)]  
  
 Die `using`-Anweisung ist eigentlich eine syntaktische Möglichkeit. Zum Zeitpunkt der Kompilierung implementiert der sprach Compiler die Intermediate Language (IL) für eine `try`/`finally` Block.  
  
 Weitere Informationen zur `using`-Anweisung finden Sie in den Themen [using-Anweisung](~/docs/visual-basic/language-reference/statements/using-statement.md) oder using- [Anweisung](~/docs/csharp/language-reference/keywords/using-statement.md) .  
  
### <a name="the-tryfinally-block"></a>Der try/endlich-Block  
 Wenn Ihre Programmiersprache ein Konstrukt wie die `using`-Anweisung in C# oder Visual Basic nicht unterstützt, oder wenn Sie diese nicht verwenden möchten, können Sie die <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>-Implementierung aus dem `finally`-Block einer `try`/`finally`-Anweisung abrufen. Im folgenden Beispiel wird der `using`-Block im vorherigen Beispiel durch einen `try`/`finally` Block ersetzt.  
  
 [!code-csharp[System.IDisposable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling2.cs#2)]
 [!code-vb[System.IDisposable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling2.vb#2)]  
  
 Weitere Informationen zum `try`/`finally` Muster finden [Sie unter try... Catch... Schließlich Statement](~/docs/visual-basic/language-reference/statements/try-catch-finally-statement.md), [try-endlich](~/docs/csharp/language-reference/keywords/try-finally.md)oder [try-endlich-Anweisung](https://msdn.microsoft.com/library/514400c1-c322-4bf3-9e48-3047240b8a82).  
  
## <a name="implementing-idisposable"></a>Implementieren von IDisposable  
 Sie sollten <xref:System.IDisposable> nur implementieren, wenn der Typ nicht verwaltete Ressourcen direkt verwendet. Die Consumer ihres Typs können Ihre <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>-Implementierung aufzurufen, um Ressourcen freizugeben, wenn die Instanz nicht mehr benötigt wird. Um Fälle zu behandeln, in denen Sie <xref:System.IDisposable.Dispose%2A>nicht aufzurufen, sollten Sie entweder eine von <xref:System.Runtime.InteropServices.SafeHandle> abgeleitete Klasse verwenden, um die nicht verwalteten Ressourcen zu wrappen, oder Sie sollten die <xref:System.Object.Finalize%2A?displayProperty=nameWithType>-Methode für einen Verweistyp überschreiben. In beiden Fällen verwenden Sie die <xref:System.IDisposable.Dispose%2A>-Methode, um die Bereinigung durchzuführen, die nach der Verwendung der nicht verwalteten Ressourcen erforderlich ist, z. b. das freigeben, freigeben oder Zurücksetzen der nicht verwalteten Ressourcen.  
  
> [!IMPORTANT]
>  Wenn Sie eine Basisklasse definieren, die nicht verwaltete Ressourcen verwendet und die über Unterklassen verfügen, die verworfen werden sollen, sollten Sie die <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>-Methode implementieren und eine zweite Überladung von `Dispose`bereitstellen, wie im nächsten Abschnitt erläutert.  
  
<a name="BaseClasses"></a>   
## <a name="idisposable-and-the-inheritance-hierarchy"></a>Iverwerfund die Vererbungs Hierarchie  
 Eine Basisklasse mit Unterklassen, die gelöscht werden sollten, muss wie folgt <xref:System.IDisposable> implementieren. Sie sollten dieses Muster immer dann verwenden, wenn Sie <xref:System.IDisposable> für einen beliebigen Typ implementieren, der nicht `sealed` ist (`NotInheritable` in Visual Basic).  
  
-   Es sollte eine öffentliche, nicht virtuelle <xref:System.IDisposable.Dispose> Methode und eine geschützte virtuelle `Dispose(Boolean disposing)` Methode bereitstellen.  
  
-   Die <xref:System.IDisposable.Dispose>-Methode muss `Dispose(true)` aufzurufen und die Finalisierung der Leistung unterdrücken.  
  
-   Der Basistyp sollte keine Finalizer enthalten.  
  
 Das folgende Code Fragment gibt das Lösch Muster für Basisklassen wieder. Dabei wird davon ausgegangen, dass der Typ die <xref:System.Object.Finalize%2A?displayProperty=nameWithType> Methode nicht außer Kraft setzt.  
  
 [!code-csharp[System.IDisposable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
 [!code-vb[System.IDisposable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]  
  
 Wenn Sie die <xref:System.Object.Finalize%2A?displayProperty=nameWithType>-Methode außer Kraft setzen, sollte die Klasse das folgende Muster implementieren.  
  
 [!code-csharp[System.IDisposable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
 [!code-vb[System.IDisposable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]  
  
 Unterklassen sollten das verwerfbare Muster wie folgt implementieren:  
  
-   Sie müssen `Dispose(Boolean)` überschreiben und die Basisklassen-`Dispose(Boolean)`-Implementierung aufrufen.  
  
-   Sie können bei Bedarf einen Finalizer bereitstellen. Der Finalizer muss `Dispose(false)` aufrufen.  
  
 Beachten Sie, dass abgeleitete Klassen nicht selbst die <xref:System.IDisposable>-Schnittstelle implementieren und keine Parameter lose <xref:System.IDisposable.Dispose%2A> Methode enthalten. Sie überschreiben nur die `Dispose(Boolean)` Methode der Basisklasse.  
  
 Das folgende Code Fragment reflektiert das Lösch Muster für abgeleitete Klassen. Dabei wird davon ausgegangen, dass der Typ die <xref:System.Object.Finalize%2A?displayProperty=nameWithType> Methode nicht außer Kraft setzt.  
  
 [!code-csharp[System.IDisposable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
 [!code-vb[System.IDisposable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie eine Ressourcen Klasse erstellt wird, die die <xref:System.IDisposable>-Schnittstelle implementiert.  
  
 [!code-cpp[System.IDisposable.Dispose Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CPP/idisposabledispose.cpp#1)]
 [!code-csharp[System.IDisposable.Dispose Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CS/idisposabledispose.cs#1)]
 [!code-vb[System.IDisposable.Dispose Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/VB/idisposabledispose.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" />
    <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implementieren einer Dispose-Methode</related>
  </Docs>
  <Members>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IDisposable.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit" Usage="iDisposable.Dispose " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt anwendungsdefinierte Tasks aus, die mit der Freigabe oder dem Zurücksetzen nicht verwalteter Ressourcen verbunden sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um nicht verwaltete Ressourcen, z. b. Dateien, Streams und Handles, die von einer Instanz der-Klasse, die diese Schnittstelle implementiert, zu schließen oder freizugeben. Gemäß der Konvention wird diese Methode für alle Aufgaben verwendet, die mit der Freigabe von Ressourcen in einem Objekt oder dem Vorbereiten eines Objekts für die Wiederverwendung in Zusammenhang stehen.  
  
> [!WARNING]
>  Wenn Sie eine Klasse verwenden, die die <xref:System.IDisposable>-Schnittstelle implementiert, sollten Sie Ihre <xref:System.IDisposable.Dispose%2A>-Implementierung aufzurufen, wenn Sie die Verwendung der-Klasse abgeschlossen haben. Weitere Informationen finden Sie im Abschnitt "Verwenden eines Objekts, das iverwerfimplementiert" im <xref:System.IDisposable> Thema.  
  
 Wenn Sie diese Methode implementieren, stellen Sie sicher, dass alle gehaltenen Ressourcen freigegeben werden, indem Sie den-Befehl über die Kapselungs Hierarchie Wenn ein Objekt a z. b. ein Objekt b zuordnet und Objekt b ein Objekt C zuordnet, muss die <xref:System.IDisposable.Dispose%2A>-Implementierung von a <xref:System.IDisposable.Dispose%2A> auf B abrufen, das wiederum <xref:System.IDisposable.Dispose%2A> in C aufgerufen werden muss.  
  
> [!IMPORTANT]
>  Der C++ Compiler unterstützt die deterministische Freigabe von Ressourcen und lässt keine direkte Implementierung der <xref:System.IDisposable.Dispose%2A>-Methode zu.  
  
 Ein Objekt muss auch die <xref:System.IDisposable.Dispose%2A>-Methode seiner Basisklasse aufzurufen, wenn die Basisklasse <xref:System.IDisposable>implementiert. Weitere Informationen zum Implementieren von <xref:System.IDisposable> für eine Basisklasse und deren Unterklassen finden Sie im Abschnitt "iverwerfand the Vererbungs Hierarchie" des Themas <xref:System.IDisposable>.  
  
 Wenn die <xref:System.IDisposable.Dispose%2A>-Methode eines Objekts mehrmals aufgerufen wird, muss das Objekt alle Aufrufe nach dem ersten ignorieren. Das-Objekt darf keine Ausnahme auslösen, wenn die <xref:System.IDisposable.Dispose%2A>-Methode mehrmals aufgerufen wird. Andere Instanzmethoden als <xref:System.IDisposable.Dispose%2A> können eine <xref:System.ObjectDisposedException> auslösen, wenn bereits Ressourcen verworfen wurden.  
  
 Benutzer erwarten möglicherweise, dass ein Ressourcentyp eine bestimmte Konvention verwendet, um einen zugewiesenen Zustand oder einen freigegebenen Zustand anzugeben. Ein Beispiel hierfür sind Streamklassen, die üblicherweise als offen oder geschlossen angesehen werden. Der Implementierer einer Klasse, die über eine solche Konvention verfügt, kann eine öffentliche Methode mit einem angepassten Namen implementieren, z. b. `Close`, der die <xref:System.IDisposable.Dispose%2A>-Methode aufruft.  
  
 Da die <xref:System.IDisposable.Dispose%2A>-Methode explizit aufgerufen werden muss, besteht immer die Gefahr, dass die nicht verwalteten Ressourcen nicht freigegeben werden, da der Consumer eines Objekts seine <xref:System.IDisposable.Dispose%2A>-Methode nicht aufrufen kann. Dies kann auf zwei Arten vermieden werden:  
  
-   Wrappen Sie die verwaltete Ressource in einem Objekt, das von <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>abgeleitet ist. Die <xref:System.IDisposable.Dispose%2A>-Implementierung ruft dann die <xref:System.IDisposable.Dispose%2A>-Methode der <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>-Instanzen auf. Weitere Informationen finden Sie im Abschnitt "SafeHandle Alternative" des <xref:System.Object.Finalize%2A?displayProperty=nameWithType> Themas.  
  
-   Implementieren Sie einen Finalizer, um Ressourcen freizugeben, wenn <xref:System.IDisposable.Dispose%2A> nicht aufgerufen wird. Standardmäßig ruft der Garbage Collector automatisch den Finalizer eines Objekts auf, bevor der zugehörige Speicher freigegeben wird. Wenn jedoch die <xref:System.IDisposable.Dispose%2A>-Methode aufgerufen wurde, ist es in der Regel nicht erforderlich, dass der Garbage Collector den Finalizer des verworfenen Objekts aufruft. Um die automatische Finalisierung zu verhindern, können <xref:System.IDisposable.Dispose%2A> Implementierungen die <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>-Methode aufzurufen.  
  
 Wenn Sie ein Objekt verwenden, das auf nicht verwaltete Ressourcen zugreift, wie z. b. eine <xref:System.IO.StreamWriter>, empfiehlt es sich, die Instanz mit einer `using`-Anweisung zu erstellen. Die `using`-Anweisung schließt den Stream automatisch und ruft <xref:System.IDisposable.Dispose%2A> für das-Objekt auf, wenn der Code, der ihn verwendet, abgeschlossen ist. Ein Beispiel finden Sie in der <xref:System.IO.StreamWriter>-Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie die <xref:System.IDisposable.Dispose%2A>-Methode implementieren können.  
  
 [!code-cpp[System.IDisposable.Dispose Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CPP/idisposabledispose.cpp#1)]
 [!code-csharp[System.IDisposable.Dispose Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CS/idisposabledispose.cs#1)]
 [!code-vb[System.IDisposable.Dispose Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/VB/idisposabledispose.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implementieren einer Dispose-Methode</related>
      </Docs>
    </Member>
  </Members>
</Type>
