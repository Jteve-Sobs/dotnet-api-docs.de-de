<Type Name="Char" FullName="System.Char">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d749c6a63f9748e113f570ba94e2982062f0213d" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39854161" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Char : IComparable, IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit char extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;char&gt;, class System.IConvertible, class System.IEquatable`1&lt;char&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Char" />
  <TypeSignature Language="VB.NET" Value="Public Structure Char&#xA;Implements IComparable, IComparable(Of Char), IConvertible, IEquatable(Of Char)" />
  <TypeSignature Language="C++ CLI" Value="public value class Char : IComparable, IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type char = struct&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Char&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein Zeichen als UTF-16-Codeeinheit dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] verwendet die <xref:System.Char> Struktur eine Unicode-Zeichen dar. Der Unicode-Standard gibt jedes Unicode-Zeichen mit einer eindeutigen als Codepunkt bezeichnet skalare 21-Bit-Zahl und definiert die Form der UTF-16-Codierung, die angibt, wie ein Codepunkt in eine Sequenz von mindestens 16-Bit-Werten codiert ist. Jeder 16-Bit-Wert liegt im Bereich von hexadezimal 0 x 0000 bis 0xFFFF und befindet sich in einem <xref:System.Char> Struktur.  Der Wert des einem <xref:System.Char> Objekt ist der Wert numerischer 16-Bit (Ordnungszahl).  
  
 Den folgenden Abschnitten wird der Beziehung zwischen einer <xref:System.Char> -Objekt und ein Zeichen, und Erläutern Sie einige allgemeinen Aufgaben, die mit ausgeführt <xref:System.Char> Instanzen.  
  
 [Char-Objekten, Unicode-Zeichen und Zeichenfolgen](#Relationship)   
 [Zeichen und Zeichenkategorien](#Categories)   
 [Zeichen und Text-Element](#Elements)   
 [Allgemeine Vorgänge](#Operations)   
 [Char-Werten und Interoperabilität](#Interop)  
  
<a name="Relationship"></a>   
## <a name="char-objects-unicode-characters-and-strings"></a>Char-Objekten, Unicode-Zeichen und Zeichenfolgen  
 Ein <xref:System.String> Objekt ist eine sequenzielle Auflistung von <xref:System.Char> Strukturen, die eine Zeichenfolge des Texts darstellt. Die meisten Unicode-Zeichen dargestellt werden können, durch eine einzelne <xref:System.Char> Objekt, aber ein Zeichen, das als Basiszeichen, codiert ist Ersatzzeichenpaar und/oder Zeichenfolge Kombinieren von mehreren dargestellt <xref:System.Char> Objekte. Aus diesem Grund eine <xref:System.Char> Struktur eine <xref:System.String> Objekt ist nicht notwendigerweise Äquivalent in ein einzelnes Unicodezeichen.  
  
 Mehrere 16-Bit-Codeeinheiten werden zur Darstellung der einzelner Unicode-Zeichen in den folgenden Fällen verwendet:  
  
-   Symbole, die ein einzelnes Zeichen oder einem Basiszeichen, gefolgt von einem oder mehreren Kombination von Zeichen bestehen dürfen. Beispielsweise wird das Zeichen "ä" dargestellt, durch ein <xref:System.Char> Objekt, dessen Code 0061 ist, gefolgt von A-Einheit U + ist <xref:System.Char> -Objekt, dessen Codeeinheit U + 0308 ist. (Das Zeichen "ä" kann auch definiert werden, von einem einzelnen <xref:System.Char> -Objekt, das eine Codeeinheit U + 00E4 verfügt.) Das folgende Beispiel zeigt, dass das Zeichen "ä" aus zwei besteht <xref:System.Char> Objekte.  
  
     [!code-csharp[System.Char.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/grapheme1.cs#1)]
     [!code-vb[System.Char.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/grapheme1.vb#1)]  
  
-   Zeichen außerhalb von Unicode-Basic Multilingual Plane (BMP). Unicode unterstützt 16 Ebenen zusätzlich zu der BMP, auf der Ebene 0 darstellt. Ein Unicode-Codepunkt wird durch einen 21-Bit-Wert, der die Ebene enthält, in UTF-32 dargestellt. Beispielsweise stellt U + 1D160 das SYMBOL ACHTE MUSIKNOTE-Zeichen dar. Da UTF-16-Codierung nur 16 Bits verfügt, werden Zeichen außerhalb der BMP von Ersatzzeichenpaaren in UTF-16 dargestellt. Das folgende Beispiel zeigt, dass UTF-32-U + 1D160, das SYMBOL ACHTE MUSIKNOTE-Zeichen U + D834-U + DD60 entspricht. U + D834 ist das hohe Ersatzzeichen. hohe Ersatzzeichen liegen zwischen U + D800 und U + DBFF liegt. U + DD60 ist das niedrige Ersatzzeichen. niedrige Ersatzzeichen liegen zwischen U + DC00 und U + DFFF.  
  
     [!code-csharp[System.Char.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/surrogate1.cs#2)]
     [!code-vb[System.Char.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/surrogate1.vb#2)]  
  
<a name="Categories"></a>   
## <a name="characters-and-character-categories"></a>Zeichen und Zeichenkategorien  
 Eine Unicode-Kategorie gehört jedes Unicode-Zeichen oder Ersatzzeichenpaar gültig. In .NET Framework Unicode-Kategorien dargestellt werden, von einem Mitglied der <xref:System.Globalization.UnicodeCategory> Enumeration und enthalten Werte, z. B. <xref:System.Globalization.UnicodeCategory.CurrencySymbol?displayProperty=nameWithType>, <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType>, und <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType>, z. B.  
  
 Um die Unicode-Kategorie eines Zeichens zu bestimmen, rufen Sie die <xref:System.Char.GetUnicodeCategory%2A> Methode. Im folgende Beispiel ruft z. B. die <xref:System.Char.GetUnicodeCategory%2A> Unicode-Kategorie der einzelnen Zeichen in einer Zeichenfolge angezeigt.  
  
 [!code-csharp[System.Char.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/GetUnicodeCategory3.cs#6)]
 [!code-vb[System.Char.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/GetUnicodeCategory3.vb#6)]  
  
 Intern für Zeichen außerhalb des ASCII-Bereichs (U + 0000 bis U + 00FF) die <xref:System.Char.GetUnicodeCategory%2A> Methode hängt von Unicode-Kategorien, die gemeldet werden, indem die <xref:System.Globalization.CharUnicodeInfo> Klasse. Beginnend mit der [!INCLUDE[net_v462](~/includes/net-v462-md.md)], Unicode-Zeichen werden basierend auf den klassifiziert [Unicode Standard, Version 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/). In Versionen von .NET Framework von der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] auf die [!INCLUDE[net_v461](~/includes/net-v461-md.md)], sie klassifiziert werden, basierend auf [Unicode Standard, Version 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/).  
  
<a name="Elements"></a>   
## <a name="characters-and-text-elements"></a>Zeichen und Text-Element  
 Da ein einzelnes Zeichen kann, von mehreren dargestellt werden <xref:System.Char> Objekte, es ist nicht immer sinnvoll, die Arbeit mit einzelnen <xref:System.Char> Objekte. Im folgende Beispiel konvertiert beispielsweise die Unicode-Codepunkte, die die Aegean Zahlen 0 bis 9 für UTF-16-codierte Codeeinheiten darstellen. Da es fälschlicherweise entspricht <xref:System.Char> Objekte mit Zeichen, er meldet fälschlicherweise, dass die resultierende Zeichenfolge 20 Zeichen aufweist.  
  
 [!code-csharp[System.Char.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/textelements2.cs#3)]
 [!code-vb[System.Char.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/textelements2.vb#3)]  
  
 Erreichen Sie Folgendes ein, um die Annahme zu vermeiden, die eine <xref:System.Char> Objekt stellt ein einzelnes Zeichen.  
  
-   Sie können mit arbeiten eine <xref:System.String> Objekt in seiner Gesamtheit anstatt mit der einzelnen Zeichen darstellen, und Analysieren von linguistischen Inhalt zu arbeiten.  
  
-   Sie können der <xref:System.Globalization.StringInfo> Klasse, um die Arbeit mit den Textelementen anstelle von einzelnen <xref:System.Char> Objekte. Im folgenden Beispiel wird die <xref:System.Globalization.StringInfo> Objekt, das die Anzahl der Textelemente in eine Zeichenfolge zu zählen, die aus der the Aegean besteht Zahlen von 0 (null) bis 9. Da es ein einzelnes Zeichen als ein Ersatzzeichenpaar ansieht, meldet es richtig, dass die Zeichenfolge zehn Zeichen enthält.  
  
     [!code-csharp[System.Char.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/textelements2a.cs#4)]
     [!code-vb[System.Char.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/textelements2a.vb#4)]  
  
-   Wenn eine Zeichenfolge ein Basiszeichens, die mindestens eine Kombination von Zeichen enthält enthält, können Sie rufen die <xref:System.String.Normalize%2A?displayProperty=nameWithType> Methode, um die Teilzeichenfolge in eine einzelne UTF-16-codierte Codeeinheit zu konvertieren. Im folgenden Beispiel wird die <xref:System.String.Normalize%2A?displayProperty=nameWithType> Methode, um die Basiszeichen U + 0061 ist (LATEINISCH Buchstabe A) und die Kombination von Zeichen U + 0308 (Kombinieren von DIÄRESE), U + 00E4 konvertieren (LATEINISCH kleine Buchstaben A mit DIÄRESE).  
  
     [!code-csharp[System.Char.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/normalized.cs#5)]
     [!code-vb[System.Char.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/normalized.vb#5)]  
  
<a name="Operations"></a>   
## <a name="common-operations"></a>Allgemeine Vorgänge  
 Die <xref:System.Char> Struktur bietet Methoden zum Vergleichen von <xref:System.Char> Objekten, konvertieren Sie den Wert des aktuellen <xref:System.Char> Objekt zu einem Objekt eines anderen Typs, und bestimmen Sie die Unicode-Kategorie, der eine <xref:System.Char> Objekt:  
  
|Aufgabe|Verwenden Sie diese `System.Char` Methoden|  
|----------------|-------------------------------------|  
|Vergleichen Sie <xref:System.Char> Objekte|<xref:System.Char.CompareTo%2A> und <xref:System.Char.Equals%2A>|  
|Einen Codepunkt in eine Zeichenfolge konvertieren|<xref:System.Char.ConvertFromUtf32%2A>|  
|Konvertieren einer <xref:System.Char> Objekt oder einem Ersatzzeichenpaar von <xref:System.Char> Objekte einen Codepunkt|Für ein einzelnes Zeichen: <xref:System.Convert.ToInt32%28System.Char%29?displayProperty=nameWithType><br /><br /> Für ein Ersatzzeichenpaar oder ein Zeichen in einer Zeichenfolge: <xref:System.Char.ConvertToUtf32%2A?displayProperty=nameWithType>|  
|Die Unicode-Kategorie eines Zeichens abzurufen|<xref:System.Char.GetUnicodeCategory%2A>|  
|Bestimmt, ob ein Zeichen in einer bestimmten Unicodekategorie, z. B. Zahlen, Buchstaben, Satzzeichen ist, um Zeichen steuern usw.|<xref:System.Char.IsControl%2A>, <xref:System.Char.IsDigit%2A>, <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLetter%2A>, <xref:System.Char.IsLetterOrDigit%2A>, <xref:System.Char.IsLower%2A>, <xref:System.Char.IsLowSurrogate%2A>, <xref:System.Char.IsNumber%2A>, <xref:System.Char.IsPunctuation%2A>, <xref:System.Char.IsSeparator%2A>, <xref:System.Char.IsSurrogate%2A>, <xref:System.Char.IsSurrogatePair%2A>, <xref:System.Char.IsSymbol%2A>, <xref:System.Char.IsUpper%2A>, und <xref:System.Char.IsWhiteSpace%2A>|  
|Konvertieren einer <xref:System.Char> -Objekt, das darstellt, in ein numerischer Werttyp|<xref:System.Char.GetNumericValue%2A>|  
|Konvertiert ein Zeichen in einer Zeichenfolge in eine <xref:System.Char> Objekt|<xref:System.Char.Parse%2A> und <xref:System.Char.TryParse%2A>|  
|Konvertieren einer <xref:System.Char> -Objekt an eine <xref:System.String> Objekt|<xref:System.Char.ToString%2A>|  
|Ändern Sie die Groß-/Kleinschreibung einer <xref:System.Char> Objekt|<xref:System.Char.ToLower%2A>, <xref:System.Char.ToLowerInvariant%2A>, <xref:System.Char.ToUpper%2A>, und <xref:System.Char.ToUpperInvariant%2A>|  
  
<a name="Interop"></a>   
## <a name="char-values-and-interop"></a>Char-Werten und Interoperabilität  
Wenn ein verwalteter <xref:System.Char> Typ, der als Unicode UTF-16-codierte Codeeinheit dargestellt wird, nicht verwalteten Code übergeben wird, der interop-Marshaller wandelt das Zeichen, die standardmäßig auf ANSI festgelegt. Sie anwenden können die <xref:System.Runtime.InteropServices.DllImportAttribute> Plattformaufrufdeklarationen des Attributs auf der Plattform und die <xref:System.Runtime.InteropServices.StructLayoutAttribute> -Attribut auf eine COM-Interop-Deklaration zu steuern, welcher eine gemarshallte Zeichensatz <xref:System.Char> -Typ verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht einige der Methoden in <xref:System.Char>.  
  
 [!code-cpp[System.Char &#91;Type Level&#93;#23](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char [Type Level]/CPP/charstructure.cpp#23)]
 [!code-csharp[System.Char &#91;Type Level&#93;#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char [Type Level]/CS/charstructure.cs#23)]
 [!code-vb[System.Char &#91;Type Level&#93;#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char [Type Level]/VB/charstructure.vb#23)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle Member dieses Typs sind threadsicher. Mitglieder, die angezeigt werden, so ändern Sie den Zustand der Instanz zurück tatsächlich eine neue Instanz initialisiert wird, mit dem neuen Wert an. Wie bei jeder anderen Art werden lesen und Schreiben in eine freigegebene Variable, die eine Instanz dieses Typs enthält durch eine Sperre um Threadsicherheit zu gewährleisten geschützt.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt oder Werttyp und gibt an, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie das angegebene Objekt oder der angegebene Werttyp aufgeführt wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.CompareTo(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(char value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : char -&gt; int&#xA;override this.CompareTo : char -&gt; int" Usage="char.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Ein zu vergleichendes <see cref="T:System.Char" />-Objekt.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen <see cref="T:System.Char" />-Objekt und gibt an, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie das angegebene <see cref="T:System.Char" />-Objekt aufgeführt wird.</summary>
        <returns>Eine Zahl mit Vorzeichen, die die Position dieser Instanz in der Sortierreihenfolge in Bezug auf den <paramref name="value" />-Parameter angibt.  
  
 <list type="table"><listheader><term> Rückgabewert  </term><description> Beschreibung </description></listheader><item><term> Kleiner als 0 (null)  </term><description> Diese Instanz steht vor <paramref name="value" />.  </description></item><item><term> 0 (null)  </term><description> Diese Instanz hat in der Sortierreihenfolge dieselbe Position wie <paramref name="value" />.  </description></item><item><term> Größer als 0 (null)  </term><description> Diese Instanz folgt auf <paramref name="value" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> -Schnittstelle und führt etwas bessere Leistung als die <xref:System.Char.CompareTo%2A?displayProperty=nameWithType> Methode, da es keine konvertieren die `value` Parameter für ein Objekt.  
  
 Beim Vergleich von dieser Methode wird basierend auf den codierten Werten dieser Instanz und `value`, nicht auf ihre lexikografischen Eigenschaften.  
  
 Wenn die <xref:System.Char.CompareTo%2A> Parametertypen für Webmethoden hat weniger Bits (schmaler ist) als den Instanztyp führen einige Programmiersprachen eine implizite erweiternde Konvertierung, die den Wert des Parameters in einen Wert mit mehr Bits transformiert.  
  
 Nehmen wir beispielsweise an, der Instanztyp <xref:System.Int32> und der Parametertyp ist <xref:System.Byte>. Microsoft c#-Compiler generiert den Anweisungen, um den Wert des Parameters als darstellen einer <xref:System.Int32> Objekt und erstellt dann eine <xref:System.Int32.CompareTo%2A?displayProperty=nameWithType> -Methode, die die Werte der vergleicht die <xref:System.Int32> Instanz und die <xref:System.Int32> Parameter Darstellung.  
  
 In der Regel werden implizite erweiternde Konvertierungen für numerische Typen ausgeführt. Ihre bevorzugte Programmiersprache Dokumentation, um festzustellen, ob der Compiler führt eine erweiternde Konvertierungen. Wenn es sich bei den nicht übereinstimmenden Instanz und Parameter-Typen und eine geeignete Konvertierung nicht verfügbar ist, generiert der Compiler Anweisungen, um das Feld des-Parameters, und rufen die <xref:System.Char.CompareTo%2A> -Überladung mit einem <xref:System.Object> Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, generische und nicht generischen Versionen der `CompareTo` Methode für verschiedene Wert- und Verweistypen.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IComparable" />
        <altmember cref="M:System.Char.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="char.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Ein Objekt, mit dem diese Instanz verglichen werden soll, oder <see langword="null" />.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt und gibt an, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie das angegebene <see cref="T:System.Object" /> aufgeführt wird.</summary>
        <returns>Eine Zahl mit Vorzeichen, die die Position dieser Instanz in der Sortierreihenfolge in Bezug auf den <paramref name="value" />-Parameter angibt.  
  
 <list type="table"><listheader><term> Rückgabewert  </term><description> Beschreibung </description></listheader><item><term> Kleiner als 0 (null)  </term><description> Diese Instanz steht vor <paramref name="value" />.  </description></item><item><term> 0 (null)  </term><description> Diese Instanz hat in der Sortierreihenfolge dieselbe Position wie <paramref name="value" />.  </description></item><item><term> Größer als 0 (null)  </term><description> Diese Instanz folgt auf <paramref name="value" />.  Oder:  <paramref name="value" /> ist <see langword="null" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Char.CompareTo%2A> Methode implementiert die <xref:System.IComparable> Schnittstelle.  
  
 Die `value` -Parameter muss sein `null` oder eine Instanz von <xref:System.Char>ist, andernfalls wird eine Ausnahme ausgelöst.  
  
 Beim Vergleich von dieser Methode wird basierend auf den codierten Werten dieser Instanz und `value`, nicht unbedingt ihre lexikografischen Eigenschaften. Jede Instanz von <xref:System.Char>, unabhängig von seinem Wert wird als größer betrachtet `null`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.CompareTo%2A>.  
  
 [!code-cpp[System.Char.CompareTo#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.CompareTo/CPP/compareto.cpp#19)]
 [!code-csharp[System.Char.CompareTo#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.CompareTo/CS/compareto.cs#19)]
 [!code-vb[System.Char.CompareTo#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.CompareTo/VB/compareto.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> ist kein <see cref="T:System.Char" />-Objekt.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="M:System.Char.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConvertFromUtf32">
      <MemberSignature Language="C#" Value="public static string ConvertFromUtf32 (int utf32);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ConvertFromUtf32(int32 utf32) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ConvertFromUtf32(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertFromUtf32 (utf32 As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ConvertFromUtf32(int utf32);" />
      <MemberSignature Language="F#" Value="static member ConvertFromUtf32 : int -&gt; string" Usage="System.char.ConvertFromUtf32 utf32" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf32" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="utf32">Ein 21-Bit-Unicode-Codepunkt.</param>
        <summary>Konvertiert den angegebenen Unicode-Codepunkt in eine UTF-16-codierte Zeichenfolge.</summary>
        <returns>Eine Zeichenfolge aus einem<see cref="T:System.Char" />-Objekt oder einem Ersatzzeichenpaar von <see cref="T:System.Char" />-Objekten, die dem durch den <paramref name="utf32" />-Parameter angegebenen Codepunkt entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode können Sie um einen 21-Bit-Unicode-Codepunkt in eine UTF-16-codierte Zeichenfolge zu konvertieren, bevor die Zeichenfolge mit Methoden wie z. B. <xref:System.Char.IsLowSurrogate%28System.Char%29> und <xref:System.Char.IsHighSurrogate%28System.Char%29>.  
  
 Ein gültigen Codepunkt außerhalb der Basic Multilingual Plane (BMP) führt immer zu einem gültigen Ersatzzeichenpaar. Allerdings kann ein gültigen Codepunkt in der BMP ein gültiges Ergebnis nach der Unicode-Standard nicht ergeben, da keine linguistische Verarbeitung bei der Konvertierung verwendet wird. Aus diesem Grund verwenden die <xref:System.Text.UTF32Encoding?displayProperty=nameWithType> Klasse konvertiert einen Massenimport von UTF-32-Daten in Bulk UTF-16-Daten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Char.ConvertToUtf32%2A> und <xref:System.Char.ConvertFromUtf32%2A> Methoden.  
  
 [!code-cpp[char.cvtutf32#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.cvtutf32/CPP/utf.cpp#1)]
 [!code-csharp[char.cvtutf32#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.cvtutf32/CS/utf.cs#1)]
 [!code-vb[char.cvtutf32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.cvtutf32/VB/utf.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="utf32" /> ist kein gültiger 21-Bit-Unicode-Codepunkt zwischen U+0 und U+10FFFF, ausschließlich des Ersatzzeichenpaarbereichs zwischen U+D800 und U+DFFF.</exception>
        <altmember cref="M:System.Char.ConvertToUtf32(System.Char,System.Char)" />
        <altmember cref="T:System.Text.UTF32Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertToUtf32">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den Wert eines UTF-16-codierten Ersatzzeichenpaars in einen Unicode-Codepunkt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertToUtf32">
      <MemberSignature Language="C#" Value="public static int ConvertToUtf32 (char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ConvertToUtf32(char highSurrogate, char lowSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ConvertToUtf32(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToUtf32 (highSurrogate As Char, lowSurrogate As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ConvertToUtf32(char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="F#" Value="static member ConvertToUtf32 : char * char -&gt; int" Usage="System.char.ConvertToUtf32 (highSurrogate, lowSurrogate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" />
        <Parameter Name="lowSurrogate" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="highSurrogate">Eine hohe Ersatzzeichen-Codeeinheit (d. h. eine Codeeinheit zwischen U+D800 und U+DBFF).</param>
        <param name="lowSurrogate">Eine niedrige Ersatzzeichen-Codeeinheit (d. h. eine Codeeinheit zwischen U+DC00 und U+DFFF).</param>
        <summary>Konvertiert den Wert eines UTF-16-codierten Ersatzzeichenpaars in einen Unicode-Codepunkt.</summary>
        <returns>Der durch den<paramref name="highSurrogate" />-Parameter und den <paramref name="lowSurrogate" />-Parameter dargestellte 21-Bit-Unicode-Codepunkt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um ein Ersatzzeichenpaar in 21-Bit-Unicode-Codepunkt zu konvertieren. Verwenden Sie zum Konvertieren von UTF-16-Daten in UTF-32-Daten, die <xref:System.Text.UTF32Encoding?displayProperty=nameWithType> Klasse.  
  
 Normalerweise stellt UTF-16-Codierung ein einzelnes Unicodezeichen als 16-Bit-Codeeinheit dar. Es unterstützt jedoch auch Surrogate-Paare, mit die ein einzelnes abstraktes Zeichen als zwei 16-Bit-Codeeinheiten dargestellt werden können. Diese beiden <xref:System.Char> Objekte müssen Codeeinheiten, Bereich von U + D800 bis U + DBFF liegt, für das erste (hoch) Ersatzzeichen und U + DC00 bis U + DFFF liegt, für den zweiten (unteren) Ersatz aufweisen. Surrogate-Paare werden unterstützt, nur von UTF-16-Codierung. Diese Methode ermöglicht es sich um ein Zeichen, die durch eine UTF-16-Surrogate-Paar dargestellt wird, in ein Zeichen, die mit UTF-32-Codierung konvertiert werden soll.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Char.ConvertToUtf32%2A> und <xref:System.Char.ConvertFromUtf32%2A> Methoden.  
  
 [!code-cpp[char.cvtutf32#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.cvtutf32/CPP/utf.cpp#1)]
 [!code-csharp[char.cvtutf32#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.cvtutf32/CS/utf.cs#1)]
 [!code-vb[char.cvtutf32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.cvtutf32/VB/utf.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="highSurrogate" /> liegt nicht im Bereich zwischen U+D800 und U+DBFF, oder <paramref name="lowSurrogate" /> liegt nicht im Bereich zwischen U+DC00 und U+DFFF.</exception>
        <altmember cref="M:System.Char.ConvertFromUtf32(System.Int32)" />
        <altmember cref="T:System.Text.UTF32Encoding" />
      </Docs>
    </Member>
    <Member MemberName="ConvertToUtf32">
      <MemberSignature Language="C#" Value="public static int ConvertToUtf32 (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ConvertToUtf32(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ConvertToUtf32(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToUtf32 (s As String, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ConvertToUtf32(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member ConvertToUtf32 : string * int -&gt; int" Usage="System.char.ConvertToUtf32 (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die ein Zeichen oder ein Ersatzzeichenpaar enthält.</param>
        <param name="index">Die Indexposition des Zeichens oder Ersatzzeichenpaars in <c>s</c>.</param>
        <summary>Konvertiert den Wert eines UTF-16-codierten Zeichens oder Ersatzzeichenpaars an der angegebenen Position in einer Zeichenfolge in einen Unicode-Codepunkt.</summary>
        <returns>Der 21-Bit-Unicode-Codepunkt, der durch das Zeichen oder Ersatzzeichenpaar an der Position im <paramref name="s" />-Parameter, die durch den <paramref name="index" />-Parameter angegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um ein paar Zeichens oder Ersatzzeichenpaars in einen 21-Bit-Unicode-Codepunkt zu konvertieren. Verwenden Sie zum Konvertieren von UTF-16-Daten in UTF-32-Daten, die <xref:System.Text.UTF32Encoding?displayProperty=nameWithType> Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Char.ConvertToUtf32%2A> und <xref:System.Char.ConvertFromUtf32%2A> Methoden.  
  
 [!code-cpp[char.cvtutf32#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.cvtutf32/CPP/utf.cpp#1)]
 [!code-csharp[char.cvtutf32#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.cvtutf32/CS/utf.cs#1)]
 [!code-vb[char.cvtutf32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.cvtutf32/VB/utf.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist keine Position in <paramref name="s" />.</exception>
        <exception cref="T:System.ArgumentException">Die angegebene Indexposition enthält ein Ersatzzeichenpaar, und entweder das erste Zeichen im Paar ist kein gültiges hohes Ersatzzeichen oder das zweite Zeichen im Paar ist kein gültiges niedriges Ersatzzeichen.</exception>
        <altmember cref="M:System.Char.ConvertFromUtf32(System.Int32)" />
        <altmember cref="T:System.Text.UTF32Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich einem angegebenen Objekt- oder <see cref="T:System.Char" />-Wert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (char obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(char obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.Equals(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(char obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : char -&gt; bool" Usage="char.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="obj">Ein mit dieser Instanz zu vergleichendes Objekt.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich einem angegebenen <see cref="T:System.Char" />-Objekt ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="obj" /> dem Wert dieser Instanz entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die <xref:System.IEquatable%601?displayProperty=nameWithType> -Schnittstelle und führt etwas bessere Leistung als <xref:System.Char.Equals%28System.Object%29?displayProperty=nameWithType> , da sie nicht mittels Unboxing zu konvertieren muss die `obj` Parameter.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="char.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Objekt, das mit dieser Instanz verglichen werden soll, oder <see langword="null" />.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich einem angegebenen Objekt ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="obj" /> eine Instanz von <see cref="T:System.Char" /> ist, deren Wert gleich dem Wert dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Vergleich von dieser Methode wird basierend auf den codierten Werten dieser Instanz und `obj`, nicht unbedingt ihre lexikografischen Eigenschaften.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.Equals%2A>.  
  
 [!code-cpp[System.Char.Equals#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.Equals/CPP/equals.cpp#20)]
 [!code-csharp[System.Char.Equals#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.Equals/CS/equals.cs#20)]
 [!code-vb[System.Char.Equals#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.Equals/VB/equals.vb#20)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="char.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNumericValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert ein angegebenes numerisches Unicode-Zeichen in eine Gleitkommazahl mit doppelter Genauigkeit.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNumericValue">
      <MemberSignature Language="C#" Value="public static double GetNumericValue (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetNumericValue(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetNumericValue(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNumericValue (c As Char) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetNumericValue(char c);" />
      <MemberSignature Language="F#" Value="static member GetNumericValue : char -&gt; double" Usage="System.char.GetNumericValue c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das zu konvertierende Unicode-Zeichen.</param>
        <summary>Konvertiert das angegebene numerische Unicode-Zeichen in eine Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Der numerische Wert von <paramref name="c" />, wenn das Zeichen eine Zahl darstellt, andernfalls -1.0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `c` Parameter muss den <xref:System.Char> Darstellung eines numerischen Werts. Z. B. wenn `c` ist "5", der zurückgegebene Wert ist 5. Aber wenn `c` "Z", ist der zurückgegebene Wert ist-1.0.  
  
 Ein Zeichen über einen zugeordneten numerischen Wert verfügt nur, wenn es sich um ein Mitglied einer der folgenden wird <xref:System.Globalization.UnicodeCategory> Kategorien: `DecimalDigitNumber`, `LetterNumber`, oder `OtherNumber`.  
  
 Die <xref:System.Char.GetNumericValue%2A> Methode setzt voraus, dass `c` ein einzelnes linguistische Zeichen entspricht, und überprüft, ob das Zeichen in eine dezimale Ziffer konvertiert werden kann. Allerdings werden einige Zahlen im Unicode-Standard dargestellt, durch zwei <xref:System.Char> Objekte, die ein Ersatzzeichenpaar bilden. Zum Beispiel besteht das the Aegean Zahlensystem Codepunkte U + 10107 bis U + 10133. Im folgenden Beispiel wird die <xref:System.Char.ConvertFromUtf32%2A> Methode, um eine Zeichenfolge zu instanziieren, AEGEAN Nummer eins darstellt. Wie die Ausgabe des Beispiels zeigt die <xref:System.Char.GetNumericValue%28System.Char%29> Methode gibt-1 zurück, wenn sie entweder ein hohes Ersatzzeichen oder ein niedriges Ersatzzeichen dieses Zeichens übergeben wird.  
  
 [!code-csharp[System.Char.GetNumericValue#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue1.cs#2)]
 [!code-vb[System.Char.GetNumericValue#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue1.vb#2)]  
  
   
  
## Examples  
 Das folgende Beispiel zeigt <xref:System.Char.GetNumericValue%2A>.  
  
 [!code-cpp[System.Char.GetNumericValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CPP/getnumericvalue.cpp#1)]
 [!code-csharp[System.Char.GetNumericValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue.cs#1)]
 [!code-vb[System.Char.GetNumericValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNumericValue">
      <MemberSignature Language="C#" Value="public static double GetNumericValue (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetNumericValue(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetNumericValue(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNumericValue (s As String, index As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetNumericValue(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member GetNumericValue : string * int -&gt; double" Usage="System.char.GetNumericValue (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ein <see cref="T:System.String" />.</param>
        <param name="index">Die Zeichenposition in <c>s</c>.</param>
        <summary>Konvertiert das numerische Unicode-Zeichen an der angegebenen Position in einer angegebenen Zeichenfolge in eine Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Der numerische Wert des Zeichens an der Position <paramref name="index" /> in <paramref name="s" />, wenn das Zeichen eine Zahl darstellt, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `s` -Parameter muss eine Zeichenfolgendarstellung eines numerischen Werts sein. Z. B. wenn das Zeichen an Position `index` in `s` ist "5", der zurückgegebene Wert ist 5. Aber wenn das Zeichen an Position `index` in `s` ist "Z", wird-1 zurückgegeben.  
  
 Zeichenpositionen in einer Zeichenfolge werden indiziert, beginnend mit 0 (null).  
  
 Ein Zeichen über einen zugeordneten numerischen Wert verfügt nur, wenn es sich um ein Mitglied einer der folgenden wird <xref:System.Globalization.UnicodeCategory> Kategorien: `DecimalDigitNumber`, `LetterNumber`, oder `OtherNumber`.  
  
 Wenn die <xref:System.Char> Objekt an der Position `index` ist das erste Zeichen eines gültigen Ersatzzeichenpaars, das <xref:System.Char.GetNumericValue%28System.String%2CSystem.Int32%29> Methode bestimmt, ob das Ersatzzeichenpaar eine Ziffer bildet. Zum Beispiel besteht das the Aegean Zahlensystem Codepunkte U + 10107 bis U + 10133. Im folgenden Beispiel wird die <xref:System.Char.ConvertFromUtf32%2A> Methode, um eine Zeichenfolge zu instanziieren, das jede Aegean Zahl darstellt. Wie die Ausgabe des Beispiels zeigt die <xref:System.Char.GetNumericValue%28System.String%2CSystem.Int32%29> Methode gibt den richtigen numerischen Wert zurück, wenn sie das hohe Ersatzzeichen einer Aegean Anzahl übergeben wird. Allerdings, wenn er das niedrige Ersatzzeichen übergeben wird, sie nur das niedrige Ersatzzeichen in Isolation betrachtet und gibt-1 zurück.  
  
 [!code-csharp[System.Char.GetNumericValue#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue1.cs#3)]
 [!code-vb[System.Char.GetNumericValue#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue1.vb#3)]  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.GetNumericValue%2A>.  
  
 [!code-cpp[System.Char.GetNumericValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CPP/getnumericvalue.cpp#1)]
 [!code-csharp[System.Char.GetNumericValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue.cs#1)]
 [!code-vb[System.Char.GetNumericValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die letzte Position in <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="char.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den <see cref="T:System.TypeCode" /> für den Werttyp <see cref="T:System.Char" /> zurück.</summary>
        <returns>Die Enumerationskonstante <see cref="F:System.TypeCode.Char" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetUnicodeCategory">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kategorisiert ein Unicode-Zeichen in einer Gruppe, die durch einen der <see cref="T:System.Globalization.UnicodeCategory" />-Werte bezeichnet wird.</summary>
        <altmember cref="M:System.Globalization.CharUnicodeInfo.GetUnicodeCategory(System.Char)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetUnicodeCategory">
      <MemberSignature Language="C#" Value="public static System.Globalization.UnicodeCategory GetUnicodeCategory (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Globalization.UnicodeCategory GetUnicodeCategory(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetUnicodeCategory(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnicodeCategory (c As Char) As UnicodeCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::UnicodeCategory GetUnicodeCategory(char c);" />
      <MemberSignature Language="F#" Value="static member GetUnicodeCategory : char -&gt; System.Globalization.UnicodeCategory" Usage="System.char.GetUnicodeCategory c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.UnicodeCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das zu kategorisierende Unicode-Zeichen.</param>
        <summary>Kategorisiert ein angegebenes Unicode-Zeichen in einer Gruppe, die durch einen der <see cref="T:System.Globalization.UnicodeCategory" />-Werte bezeichnet wird.</summary>
        <returns>Ein <see cref="T:System.Globalization.UnicodeCategory" />-Wert, der die Gruppe bezeichnet, die <paramref name="c" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> Methode gibt nicht immer zurück gleich <xref:System.Globalization.UnicodeCategory> Wert wie die <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> Methode, wenn sie ein bestimmtes Zeichen als Parameter übergeben wird. Die <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> -Methode entwickelt, um die aktuelle Version des Unicode-Standards entsprechen. Im Gegensatz dazu auch die <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> Methode in der Regel gibt die aktuelle Version des Unicode-Standards, können sie die Kategorie eines Zeichens basierend auf einer früheren Version des Standards zurückgeben oder eine Kategorie, die unterscheidet sich vom aktuellen Standard in der Reihenfolge zurückgeben Um Abwärtskompatibilität zu gewährleisten. Daher empfehlen wir die Verwendung der <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> Methode anstelle von <xref:System.Char.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType>.  
  
 Beginnend mit der [!INCLUDE[net_v462](~/includes/net-v462-md.md)], Unicode-Zeichen werden basierend auf den klassifiziert [im Unix-Standard, Version 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/). In Versionen von .NET Framework von der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] auf die [!INCLUDE[net_v461](~/includes/net-v461-md.md)], sind sie klassifiziert, basierend auf [im Unix-Standard, Version 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.GetUnicodeCategory%2A>.  
  
 [!code-cpp[System.Char.GetUnicodeCategory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CPP/getunicodecategory.cpp#1)]
 [!code-csharp[System.Char.GetUnicodeCategory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CS/getunicodecategory.cs#1)]
 [!code-vb[System.Char.GetUnicodeCategory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/VB/getunicodecategory.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Globalization.CharUnicodeInfo.GetUnicodeCategory(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="GetUnicodeCategory">
      <MemberSignature Language="C#" Value="public static System.Globalization.UnicodeCategory GetUnicodeCategory (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Globalization.UnicodeCategory GetUnicodeCategory(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetUnicodeCategory(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnicodeCategory (s As String, index As Integer) As UnicodeCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::UnicodeCategory GetUnicodeCategory(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member GetUnicodeCategory : string * int -&gt; System.Globalization.UnicodeCategory" Usage="System.char.GetUnicodeCategory (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.UnicodeCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ein <see cref="T:System.String" />.</param>
        <param name="index">Die Zeichenposition in <c>s</c>.</param>
        <summary>Kategorisiert das Zeichen an der angegebenen Position in einer angegebenen Zeichenfolge in einer Gruppe, die durch einen der <see cref="T:System.Globalization.UnicodeCategory" />-Werte bezeichnet wird.</summary>
        <returns>Eine <see cref="T:System.Globalization.UnicodeCategory" />-Enumerationskonstante, die die Gruppe bezeichnet, die das Zeichen an der Position <paramref name="index" /> in <paramref name="s" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zeichenpositionen in einer Zeichenfolge werden indiziert, beginnend mit 0 (null).  
  
 Die <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> Methode gibt nicht immer zurück gleich <xref:System.Globalization.UnicodeCategory> Wert wie die <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> Methode, wenn sie ein bestimmtes Zeichen als Parameter übergeben wird. Die <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> -Methode entwickelt, um die aktuelle Version des Unicode-Standards entsprechen. Im Gegensatz dazu auch die <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> Methode in der Regel gibt die aktuelle Version des Unicode-Standards, können sie die Kategorie eines Zeichens basierend auf einer früheren Version des Standards zurückgeben oder eine Kategorie, die unterscheidet sich vom aktuellen Standard in der Reihenfolge zurückgeben Um Abwärtskompatibilität zu gewährleisten. Daher empfehlen wir die Verwendung der <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> Methode anstelle von <xref:System.Char.GetUnicodeCategory%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>.  
  
 Beginnend mit der [!INCLUDE[net_v462](~/includes/net-v462-md.md)], Unicode-Zeichen werden basierend auf den klassifiziert [im Unix-Standard, Version 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/). In Versionen von .NET Framework von der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] auf die [!INCLUDE[net_v461](~/includes/net-v461-md.md)], sind sie klassifiziert, basierend auf [im Unix-Standard, Version 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt <xref:System.Char.GetUnicodeCategory%2A>.  
  
 [!code-cpp[System.Char.GetUnicodeCategory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CPP/getunicodecategory.cpp#1)]
 [!code-csharp[System.Char.GetUnicodeCategory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CS/getunicodecategory.cs#1)]
 [!code-vb[System.Char.GetUnicodeCategory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/VB/getunicodecategory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die letzte Position in <paramref name="s" />.</exception>
        <altmember cref="M:System.Globalization.CharUnicodeInfo.GetUnicodeCategory(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsControl">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob ein angegebenes Unicode-Zeichen als Steuerzeichen kategorisiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Steuerzeichen formatieren und andere nicht druckbare Zeichen, z. B. ACK, BEL, CR, FF, LF und "VT" Die Unicode-standard weist den Codepunkten von \U0000 bis \U001F, \U007F, und von \U0080 bis \U009F, Steuerzeichen. Sind diese Werte entsprechend den Unicode-Standard als Steuerzeichen interpretiert werden, es sei denn, ihre Verwendung andernfalls von einer Anwendung definiert ist. Gültige Zeichen sind Mitglied der <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> Kategorie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsControl">
      <MemberSignature Language="C#" Value="public static bool IsControl (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsControl(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsControl(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsControl (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsControl(char c);" />
      <MemberSignature Language="F#" Value="static member IsControl : char -&gt; bool" Usage="System.char.IsControl c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das auszuwertende Unicode-Zeichen.</param>
        <summary>Gibt an, ob das angegebene Unicode-Zeichen als Steuerzeichen kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="c" /> ein Steuerzeichen ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Steuerzeichen formatieren und andere nicht druckbare Zeichen, z. B. ACK, BEL, CR, FF, LF und "VT" T der Unicode-standard weist den Codepunkten von \U0000 bis \U001F, \U007F, und von \U0080 bis \U009F, Steuerzeichen. Sind diese Werte entsprechend den Unicode-Standard als Steuerzeichen interpretiert werden, es sei denn, ihre Verwendung andernfalls von einer Anwendung definiert ist. Gültige Zeichen sind Mitglied der <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> Kategorie.  
  
   
  
## Examples  
 Das folgende Beispiel listet die Unicode-Codepunkt aller die Steuerzeichen.  
  
 [!code-cpp[System.Char.IsControl#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsControl/CPP/iscontrol1.cpp#1)]
 [!code-csharp[System.Char.IsControl#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsControl/CS/IsControl1.cs#1)]
 [!code-vb[System.Char.IsControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsControl/VB/IsControl1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsControl">
      <MemberSignature Language="C#" Value="public static bool IsControl (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsControl(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsControl(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsControl (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsControl(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsControl : string * int -&gt; bool" Usage="System.char.IsControl (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge.</param>
        <param name="index">Die Position des in <c>s</c> auszuwertenden Zeichens.</param>
        <summary>Gibt an, ob das Zeichen an der angegebenen Position in einer angegebenen Zeichenfolge als Steuerzeichen kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen an der Position <paramref name="index" /> in <paramref name="s" /> ein Steuerzeichen ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zeichenpositionen in einer Zeichenfolge werden indiziert, beginnend mit 0 (null).  
  
 Steuerzeichen formatieren und andere nicht druckbare Zeichen, z. B. ACK, BEL, CR, FF, LF und "VT" Die Unicode-standard weist den Codepunkten von \U0000 bis \U001F, \U007F, und von \U0080 bis \U009F, Steuerzeichen. Sind diese Werte entsprechend den Unicode-Standard als Steuerzeichen interpretiert werden, es sei denn, ihre Verwendung andernfalls von einer Anwendung definiert ist. Gültige Zeichen sind Mitglied der <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> Kategorie.  
  
   
  
## Examples  
 Das folgende Beispiel listet die Zeichen in einer Zeichenfolge und bestimmt, ob alle Steuerzeichen sind.  
  
 [!code-cpp[System.Char.IsControl#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsControl/CPP/iscontrol2.cpp#2)]
 [!code-csharp[System.Char.IsControl#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsControl/CS/IsControl2.cs#2)]
 [!code-vb[System.Char.IsControl#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsControl/VB/IsControl2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die letzte Position in <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsDigit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob ein Unicode-Zeichen als Dezimalzahl kategorisiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gültige Ziffern sind Mitglied der <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> Kategorie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsDigit">
      <MemberSignature Language="C#" Value="public static bool IsDigit (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDigit(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDigit (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDigit(char c);" />
      <MemberSignature Language="F#" Value="static member IsDigit : char -&gt; bool" Usage="System.char.IsDigit c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das auszuwertende Unicode-Zeichen.</param>
        <summary>Gibt an, ob das angegebene Unicode-Zeichen als Dezimalzahl kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="c" /> eine Dezimalzahl ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt, ob eine <xref:System.Char> ist ein Basis-10-Ziffern. Dies steht im Gegensatz zu <xref:System.Char.IsNumber%2A>, der bestimmt, ob eine `Char` alle numerischen Unicode-Kategorie ist. Zahlen werden die Zeichen wie Brüche, Indizes, hoch-, römische Zahlen, Währung Zähler, eingekreisten Zahlen und Ziffern enthalten.  
  
 Gültige Ziffern sind Mitglied der <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> Kategorie.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.IsDigit%2A>.  
  
 [!code-cpp[System.Char.IsDigit#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsDigit/CPP/isdigit.cpp#4)]
 [!code-csharp[System.Char.IsDigit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsDigit/CS/isdigit.cs#4)]
 [!code-vb[System.Char.IsDigit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsDigit/VB/isdigit.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsNumber(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsDigit">
      <MemberSignature Language="C#" Value="public static bool IsDigit (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDigit(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsDigit(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDigit (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDigit(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsDigit : string * int -&gt; bool" Usage="System.char.IsDigit (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge.</param>
        <param name="index">Die Position des in <c>s</c> auszuwertenden Zeichens.</param>
        <summary>Gibt an, ob das Zeichen an der angegebenen Position in einer angegebenen Zeichenfolge als Dezimalzahl kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen an der Position <paramref name="index" /> in <paramref name="s" /> eine Dezimalzahl ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt, ob eine <xref:System.Char> ist ein Basis-10-Ziffern. Dies steht im Gegensatz zu <xref:System.Char.IsNumber%2A>, der bestimmt, ob eine <xref:System.Char> alle numerischen Unicode-Kategorie ist. Zahlen werden die Zeichen wie Brüche, Indizes, hoch-, römische Zahlen, Währung Zähler, eingekreisten Zahlen und Ziffern enthalten.  
  
 Zeichenpositionen in einer Zeichenfolge werden indiziert, beginnend mit 0 (null).  
  
 Gültige Ziffern sind Mitglied der <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> Kategorie.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.IsDigit%2A>.  
  
 [!code-cpp[System.Char.IsDigit#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsDigit/CPP/isdigit.cpp#4)]
 [!code-csharp[System.Char.IsDigit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsDigit/CS/isdigit.cs#4)]
 [!code-vb[System.Char.IsDigit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsDigit/VB/isdigit.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die letzte Position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsNumber(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsHighSurrogate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob das angegebene <see cref="T:System.Char" />-Objekt ein hohes Ersatzzeichen ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsHighSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsHighSurrogate (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHighSurrogate(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsHighSurrogate(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHighSurrogate (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHighSurrogate(char c);" />
      <MemberSignature Language="F#" Value="static member IsHighSurrogate : char -&gt; bool" Usage="System.char.IsHighSurrogate c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das auszuwertende Unicode-Zeichen.</param>
        <summary>Gibt an, ob das angegebene <see cref="T:System.Char" />-Objekt ein hohes Ersatzzeichen ist.</summary>
        <returns>
          <see langword="true" />, wenn der numerische Wert des <paramref name="c" />-Parameters zwischen U+D800 und U+DBFF liegt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zusätzlich zum Darstellen der einzelnen Zeichen, die mit einem 16-Bit-Codepunkt, UTF-16-Codierung ermöglicht die abstrakte Zeichen dargestellt werden mithilfe von zwei 16-Bit-Codepunkten, dies wird auch bezeichnet als ein Ersatzzeichenpaar. Das erste Element in diesem Paar ist das hohe Ersatzzeichen. Der Codepunkt liegen zwischen U + D800 und U + DBFF liegt. Ein einzelnes Ersatzzeichen verfügt über keine eigene Interpretation; Es ist sinnvoll, nur, wenn als Teil eines Ersatzzeichenpaars verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, und <xref:System.Char.IsSurrogatePair%2A> Methoden.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHighSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsHighSurrogate (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHighSurrogate(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsHighSurrogate(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHighSurrogate (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHighSurrogate(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsHighSurrogate : string * int -&gt; bool" Usage="System.char.IsHighSurrogate (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge.</param>
        <param name="index">Die Position des in <c>s</c> auszuwertenden Zeichens.</param>
        <summary>Gibt an, ob das <see cref="T:System.Char" />-Objekt an der angegebenen Position in einer Zeichenfolge ein hohes Ersatzzeichen ist.</summary>
        <returns>
          <see langword="true" />, wenn der numerische Wert des im <paramref name="s" />-Parameter angegebenen Zeichens zwischen U+D800 und U+DBFF liegt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `index` Parameter ist nullbasiert.  
  
 Zusätzlich zum Darstellen der einzelnen Zeichen, die mit einem 16-Bit-Codepunkt, UTF-16-Codierung ermöglicht die abstrakte Zeichen dargestellt werden mithilfe von zwei 16-Bit-Codepunkten, dies wird auch bezeichnet als ein Ersatzzeichenpaar. Das erste Element in diesem Paar ist das hohe Ersatzzeichen. Der Codepunkt liegen zwischen U + D800 und U + DBFF liegt. Ein einzelnes Ersatzzeichen verfügt über keine eigene Interpretation; Es ist sinnvoll, nur, wenn als Teil eines Ersatzzeichenpaars verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, und <xref:System.Char.IsSurrogatePair%2A> Methoden.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist keine Position in <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLetter">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob ein Unicode-Zeichen als Unicode-Buchstabe kategorisiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt, ob eine <xref:System.Char> ist ein Mitglied einer beliebigen Kategorie von Unicode-Buchstabe. Unicode-Buchstaben umfassen Folgendes:  
  
-   Großbuchstaben, z. B. U + 0041 (LATIN CAPITAL LETTER A) bis U + 005A (LATIN CAPITAL LETTER-Z), oder U + 0400 (KYRILLISCHEN Großbuchstaben IE mit Gravis) bis U + 042F (KYRILLISCHER Buchstabe YA). Diese Zeichen sind Mitglied der <xref:System.Globalization.UnicodeCategory.UppercaseLetter?displayProperty=nameWithType> Kategorie.  
  
-   Kleinbuchstaben, z. B. U + 0061 ist (LATEINISCH Buchstabe A) bis U + 007A (LATEINISCH kleine Buchstaben Z), oder U + 03AC (GREEK kleine Buchstaben ALPHA mit TONZEICHEN) bis U + 03CE (GREEK kleine Buchstaben OMEGA mit TONZEICHEN). Diese Zeichen sind Mitglied der <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType> Kategorie.  
  
-   Titel der Groß-/ Kleinschreibung, z. B. U + 01 C-5 (LATIN CAPITAL LETTER D mit kleinen Buchstaben Z mit HÄKCHEN) "oder" U + 1FFC (griechischen Großbuchstaben OMEGA mit PROSGEGRAMMENON). Diese Zeichen sind Mitglied der <xref:System.Globalization.UnicodeCategory.TitlecaseLetter?displayProperty=nameWithType> Kategorie.  
  
-   Modifizierer, z. B. U + 02 b 0 (LETTER SMALL H) und U + 02 c-1 (MODIFIZIERER Buchstaben umgekehrt KEHLKOPFLAUTSILBE beenden), oder U + 1D2C (Buchstaben Großbuchstaben A) bis U + 1D 61 (LETTER SMALL CHI). Diese Zeichen sind Mitglied der <xref:System.Globalization.UnicodeCategory.ModifierLetter?displayProperty=nameWithType> Kategorie.  
  
-   Andere Buchstaben aus, z. B. U + 05 D 0 (HEBRÄISCH Buchstaben ALEF) bis U + 05EA (HEBRÄISCH Buchstabe TAV), U + 0621 (Arabisch Buchstaben HAMZA) bis U + 063A (Arabisch Buchstaben GHAIN), oder U + 4E00 (\<CJK ideografisches Zeichen und >) bis 9 FC-U + 3 (\<CJK ideografisches Zeichen, die letzten (>). Diese Zeichen sind Mitglied der <xref:System.Globalization.UnicodeCategory.OtherLetter?displayProperty=nameWithType> Kategorie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLetter">
      <MemberSignature Language="C#" Value="public static bool IsLetter (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetter(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetter (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetter(char c);" />
      <MemberSignature Language="F#" Value="static member IsLetter : char -&gt; bool" Usage="System.char.IsLetter c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das auszuwertende Unicode-Zeichen.</param>
        <summary>Gibt an, ob das angegebene Unicode-Zeichen als Unicode-Buchstabe kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="c" /> ein Buchstabe ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt, ob eine <xref:System.Char> ist ein Mitglied einer beliebigen Kategorie von Unicode-Buchstabe. Unicode-Buchstaben umfassen Folgendes:  
  
-   Großbuchstaben, z. B. U + 0041 (LATIN CAPITAL LETTER A) bis U + 005A (LATIN CAPITAL LETTER-Z), oder U + 0400 (KYRILLISCHEN Großbuchstaben IE mit Gravis) bis U + 042F (KYRILLISCHER Buchstabe YA). Diese Zeichen sind Mitglied der <xref:System.Globalization.UnicodeCategory.UppercaseLetter?displayProperty=nameWithType> Kategorie.  
  
-   Kleinbuchstaben, z. B. U + 0061 ist (LATEINISCH Buchstabe A) bis U + 007A (LATEINISCH kleine Buchstaben Z), oder U + 03AC (GREEK kleine Buchstaben ALPHA mit TONZEICHEN) bis U + 03CE (GREEK kleine Buchstaben OMEGA mit TONZEICHEN). Diese Zeichen sind Mitglied der <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType> Kategorie.  
  
-   Titel der Groß-/ Kleinschreibung, z. B. U + 01 C-5 (LATIN CAPITAL LETTER D mit kleinen Buchstaben Z mit HÄKCHEN) "oder" U + 1FFC (griechischen Großbuchstaben OMEGA mit PROSGEGRAMMENON). Diese Zeichen sind Mitglied der <xref:System.Globalization.UnicodeCategory.TitlecaseLetter?displayProperty=nameWithType> Kategorie.  
  
-   Modifizierer, z. B. U + 02 b 0 (LETTER SMALL H) und U + 02 c-1 (MODIFIZIERER Buchstaben umgekehrt KEHLKOPFLAUTSILBE beenden), oder U + 1D2C (Buchstaben Großbuchstaben A) bis U + 1D 61 (LETTER SMALL CHI). Diese Zeichen sind Mitglied der <xref:System.Globalization.UnicodeCategory.ModifierLetter?displayProperty=nameWithType> Kategorie.  
  
-   Andere Buchstaben aus, z. B. U + 05 D 0 (HEBRÄISCH Buchstaben ALEF) bis U + 05EA (HEBRÄISCH Buchstabe TAV), U + 0621 (Arabisch Buchstaben HAMZA) bis U + 063A (Arabisch Buchstaben GHAIN), oder U + 4E00 (\<CJK ideografisches Zeichen und >) bis 9 FC-U + 3 (\<CJK ideografisches Zeichen, die letzten (>). Diese Zeichen sind Mitglied der <xref:System.Globalization.UnicodeCategory.OtherLetter?displayProperty=nameWithType> Kategorie.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.IsLetter%2A>.  
  
 [!code-cpp[System.Char.IsLetter#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetter/CPP/isletter.cpp#5)]
 [!code-csharp[System.Char.IsLetter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetter/CS/isletter.cs#5)]
 [!code-vb[System.Char.IsLetter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetter/VB/isletter.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsLetter">
      <MemberSignature Language="C#" Value="public static bool IsLetter (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetter(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetter(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetter (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetter(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsLetter : string * int -&gt; bool" Usage="System.char.IsLetter (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge.</param>
        <param name="index">Die Position des in <c>s</c> auszuwertenden Zeichens.</param>
        <summary>Gibt an, ob das Zeichen an der angegebenen Position in einer angegebenen Zeichenfolge als Unicode-Buchstabe kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen an der Position <paramref name="index" /> in <paramref name="s" /> ein Buchstabe ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zeichenpositionen in einer Zeichenfolge werden indiziert, beginnend mit 0 (null).  
  
 Diese Methode bestimmt, ob das Zeichen an einer angegebenen Indexposition in einer Zeichenfolge ein Mitglied einer beliebigen Kategorie von Unicode-Buchstabe. Unicode-Buchstaben umfassen Folgendes:  
  
-   Großbuchstaben, z. B. U + 0041 (LATIN CAPITAL LETTER A) bis U + 005A (LATIN CAPITAL LETTER-Z), oder U + 0400 (KYRILLISCHEN Großbuchstaben IE mit Gravis) bis U + 042F (KYRILLISCHER Buchstabe YA). Diese Zeichen sind Mitglied der <xref:System.Globalization.UnicodeCategory.UppercaseLetter?displayProperty=nameWithType> Kategorie.  
  
-   Kleinbuchstaben, z. B. U + 0061 ist (LATEINISCH Buchstabe A) bis U + 007A (LATEINISCH kleine Buchstaben Z), oder U + 03AC (GREEK kleine Buchstaben ALPHA mit TONZEICHEN) bis U + 03CE (GREEK kleine Buchstaben OMEGA mit TONZEICHEN). Diese Zeichen sind Mitglied der <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType> Kategorie.  
  
-   Titel der Groß-/ Kleinschreibung, z. B. U + 01 C-5 (LATIN CAPITAL LETTER D mit kleinen Buchstaben Z mit HÄKCHEN) "oder" U + 1FFC (griechischen Großbuchstaben OMEGA mit PROSGEGRAMMENON). Diese Zeichen sind Mitglied der <xref:System.Globalization.UnicodeCategory.TitlecaseLetter?displayProperty=nameWithType> Kategorie.  
  
-   Modifizierer, z. B. U + 02 b 0 (LETTER SMALL H) und U + 02 c-1 (MODIFIZIERER Buchstaben umgekehrt KEHLKOPFLAUTSILBE beenden), oder U + 1D2C (Buchstaben Großbuchstaben A) bis U + 1D 61 (LETTER SMALL CHI). Diese Zeichen sind Mitglied der <xref:System.Globalization.UnicodeCategory.ModifierLetter?displayProperty=nameWithType> Kategorie.  
  
-   Andere Buchstaben aus, z. B. U + 05 D 0 (HEBRÄISCH Buchstaben ALEF) bis U + 05EA (HEBRÄISCH Buchstabe TAV), U + 0621 (Arabisch Buchstaben HAMZA) bis U + 063A (Arabisch Buchstaben GHAIN), oder U + 4E00 (\<CJK ideografisches Zeichen und >) bis 9 FC-U + 3 (\<CJK ideografisches Zeichen, die letzten (>). Diese Zeichen sind Mitglied der <xref:System.Globalization.UnicodeCategory.OtherLetter?displayProperty=nameWithType> Kategorie.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.IsLetter%2A>.  
  
 [!code-cpp[System.Char.IsLetter#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetter/CPP/isletter.cpp#5)]
 [!code-csharp[System.Char.IsLetter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetter/CS/isletter.cs#5)]
 [!code-vb[System.Char.IsLetter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetter/VB/isletter.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die letzte Position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLetterOrDigit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob ein Unicode-Zeichen als Buchstabe oder Dezimalzahl kategorisiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Buchstaben gültig und die Dezimalstellen sind Mitglieder der folgenden Kategorien in <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`, `LowercaseLetter`, `TitlecaseLetter`, `ModifierLetter`, `OtherLetter`, oder `DecimalDigitNumber`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLetterOrDigit">
      <MemberSignature Language="C#" Value="public static bool IsLetterOrDigit (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetterOrDigit(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetterOrDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetterOrDigit (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetterOrDigit(char c);" />
      <MemberSignature Language="F#" Value="static member IsLetterOrDigit : char -&gt; bool" Usage="System.char.IsLetterOrDigit c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das auszuwertende Unicode-Zeichen.</param>
        <summary>Gibt an, ob das angegebene Unicode-Zeichen als Buchstabe oder als Dezimalzahl kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="c" /> ein Buchstabe oder eine Dezimalzahl ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Buchstaben gültig und die Dezimalstellen sind Mitglieder der folgenden Kategorien in <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`, `LowercaseLetter`, `TitlecaseLetter`, `ModifierLetter`, `OtherLetter`, oder `DecimalDigitNumber`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.IsLetterOrDigit%2A>.  
  
 [!code-cpp[System.Char.IsLetterOrDigit#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CPP/isletterordigit.cpp#6)]
 [!code-csharp[System.Char.IsLetterOrDigit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CS/isletterordigit.cs#6)]
 [!code-vb[System.Char.IsLetterOrDigit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/VB/isletterordigit.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsLetterOrDigit">
      <MemberSignature Language="C#" Value="public static bool IsLetterOrDigit (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetterOrDigit(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetterOrDigit(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetterOrDigit (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetterOrDigit(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsLetterOrDigit : string * int -&gt; bool" Usage="System.char.IsLetterOrDigit (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge.</param>
        <param name="index">Die Position des in <c>s</c> auszuwertenden Zeichens.</param>
        <summary>Gibt an, ob das Zeichen an der angegebenen Position in einer angegebenen Zeichenfolge als Buchstabe oder Dezimalzahl kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen an der Position <paramref name="index" /> in <paramref name="s" /> ein Buchstabe oder eine Dezimalzahl ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zeichenpositionen in einer Zeichenfolge werden indiziert, beginnend mit 0 (null).  
  
 Buchstaben gültig und die Dezimalstellen sind Mitglieder der folgenden Kategorien in <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`, `LowercaseLetter`, `TitlecaseLetter`, `ModifierLetter`, `OtherLetter`, oder `DecimalDigitNumber`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.IsLetterOrDigit%2A>.  
  
 [!code-cpp[System.Char.IsLetterOrDigit#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CPP/isletterordigit.cpp#6)]
 [!code-csharp[System.Char.IsLetterOrDigit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CS/isletterordigit.cs#6)]
 [!code-vb[System.Char.IsLetterOrDigit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/VB/isletterordigit.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die letzte Position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob ein Unicode-Zeichen als Kleinbuchstabe kategorisiert wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLower">
      <MemberSignature Language="C#" Value="public static bool IsLower (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLower(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLower(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLower (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLower(char c);" />
      <MemberSignature Language="F#" Value="static member IsLower : char -&gt; bool" Usage="System.char.IsLower c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das auszuwertende Unicode-Zeichen.</param>
        <summary>Gibt an, ob das angegebene Unicode-Zeichen als Kleinbuchstabe kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="c" /> ein Kleinbuchstabe ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gültige Kleinbuchstaben gehören zur Kategorie <xref:System.Globalization.UnicodeCategory>: `LowercaseLetter`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.IsLower%2A>.  
  
 [!code-cpp[System.Char.IsLower#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLower/CPP/islower.cpp#7)]
 [!code-csharp[System.Char.IsLower#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLower/CS/islower.cs#7)]
 [!code-vb[System.Char.IsLower#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLower/VB/islower.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsUpper(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsLower">
      <MemberSignature Language="C#" Value="public static bool IsLower (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLower(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLower(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLower (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLower(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsLower : string * int -&gt; bool" Usage="System.char.IsLower (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge.</param>
        <param name="index">Die Position des in <c>s</c> auszuwertenden Zeichens.</param>
        <summary>Gibt an, ob das Zeichen an der angegebenen Position in einer angegebenen Zeichenfolge als Kleinbuchstabe kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen an der Position <paramref name="index" /> in <paramref name="s" /> ein Kleinbuchstabe ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zeichenpositionen in einer Zeichenfolge werden indiziert, beginnend mit 0 (null).  
  
 Gültige Kleinbuchstaben gehören zur Kategorie <xref:System.Globalization.UnicodeCategory>: `LowercaseLetter`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.IsLower%2A>.  
  
 [!code-cpp[System.Char.IsLower#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLower/CPP/islower.cpp#7)]
 [!code-csharp[System.Char.IsLower#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLower/CS/islower.cs#7)]
 [!code-vb[System.Char.IsLower#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLower/VB/islower.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die letzte Position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Char.IsUpper(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLowSurrogate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob das angegebene <see cref="T:System.Char" />-Objekt ein niedriges Ersatzzeichen ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLowSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsLowSurrogate (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLowSurrogate(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLowSurrogate(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLowSurrogate (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLowSurrogate(char c);" />
      <MemberSignature Language="F#" Value="static member IsLowSurrogate : char -&gt; bool" Usage="System.char.IsLowSurrogate c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das auszuwertende Zeichen.</param>
        <summary>Gibt an, ob das angegebene <see cref="T:System.Char" />-Objekt ein niedriges Ersatzzeichen ist.</summary>
        <returns>
          <see langword="true" />, wenn der numerische Wert des <paramref name="c" />-Parameters zwischen U+DC00 und U+DFFF liegt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zusätzlich zum Darstellen der einzelnen Zeichen, die mit einem 16-Bit-Codepunkt, UTF-16-Codierung ermöglicht die abstrakte Zeichen dargestellt werden mithilfe von zwei 16-Bit-Codepunkten, dies wird auch bezeichnet als ein Ersatzzeichenpaar. In diesem Paar das zweite Element ist das niedrige Ersatzzeichen. Der Codepunkt liegen zwischen U + DC00 und U + DFFF. Ein einzelnes Ersatzzeichen verfügt über keine eigene Interpretation; Es ist sinnvoll, nur, wenn als Teil eines Ersatzzeichenpaars verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, und <xref:System.Char.IsSurrogatePair%2A> Methoden.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLowSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsLowSurrogate (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLowSurrogate(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLowSurrogate(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLowSurrogate (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLowSurrogate(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsLowSurrogate : string * int -&gt; bool" Usage="System.char.IsLowSurrogate (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge.</param>
        <param name="index">Die Position des in <c>s</c> auszuwertenden Zeichens.</param>
        <summary>Gibt an, ob das <see cref="T:System.Char" />-Objekt an der angegebenen Position in einer Zeichenfolge ein niedriges Ersatzzeichen ist.</summary>
        <returns>
          <see langword="true" />, wenn der numerische Wert des im <paramref name="s" />-Parameter angegebenen Zeichens zwischen U+DC00 und U+DFFF liegt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `index` Parameter ist nullbasiert.  
  
 Zusätzlich zum Darstellen der einzelnen Zeichen, die mit einem 16-Bit-Codepunkt, UTF-16-Codierung ermöglicht die abstrakte Zeichen dargestellt werden mithilfe von zwei 16-Bit-Codepunkten, dies wird auch bezeichnet als ein Ersatzzeichenpaar. In diesem Paar das zweite Element ist das niedrige Ersatzzeichen. Der Codepunkt liegen zwischen U + DC00 und U + DFFF. Ein einzelnes Ersatzzeichen verfügt über keine eigene Interpretation; Es ist sinnvoll, nur, wenn als Teil eines Ersatzzeichenpaars verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, und <xref:System.Char.IsSurrogatePair%2A> Methoden.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist keine Position in <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNumber">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob ein Unicode-Zeichen als Zahl kategorisiert wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNumber">
      <MemberSignature Language="C#" Value="public static bool IsNumber (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNumber(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsNumber(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNumber (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNumber(char c);" />
      <MemberSignature Language="F#" Value="static member IsNumber : char -&gt; bool" Usage="System.char.IsNumber c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das auszuwertende Unicode-Zeichen.</param>
        <summary>Gibt an, ob das angegebene Unicode-Zeichen als Zahl kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="c" /> eine Zahl ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt, ob eine <xref:System.Char> alle numerischen Unicode-Kategorie ist. Neben dem einschließen von Ziffern, enthalten Zahlen, Zeichen, Brüche, tiefgestellte Zeichen, hoch-, römische Zahlen, Währung Zähler und eingekreisten Zahlen. Diese Methode steht im Gegensatz zu den <xref:System.Char.IsDigit%2A> Methode, die bestimmt, ob eine <xref:System.Char> ist ein Basis-10-Ziffern.  
  
> [!IMPORTANT]
>  Die <xref:System.Char.IsNumber%28System.Char%29> Methode ist nicht vorgesehen, um festzustellen, ob eine Zeichenfolge von numerischen Zeichen besteht aus (z. B. durch Aufrufen der Methode für jedes Zeichen in einer Zeichenfolge). Um zu bestimmen, ob eine Zeichenfolge aus numerischen Zeichen besteht, rufen Sie eine der Überladungen der der `TryParse` Methode (z. B. <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> oder <xref:System.Double.TryParse%2A?displayProperty=nameWithType> eines Ganzzahlen oder Gleitkommazahlen-Typs.  
  
 Gültige Zahlen sind Mitglieder der <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, <xref:System.Globalization.UnicodeCategory.LetterNumber?displayProperty=nameWithType>, oder <xref:System.Globalization.UnicodeCategory.OtherNumber?displayProperty=nameWithType> Kategorie.  
  
 Die <xref:System.Char.IsNumber%28System.Char%29> Methode setzt voraus, dass `c` ein einzelnes linguistische Zeichen entspricht, und überprüft, ob das Zeichen eine Zahl darstellt. Allerdings werden einige Zahlen im Unicode-Standard dargestellt, durch zwei <xref:System.Char> Objekte, die ein Ersatzzeichenpaar bilden. Zum Beispiel besteht das the Aegean Zahlensystem Codepunkte U + 10107 bis U + 10133. Im folgenden Beispiel wird die <xref:System.Char.ConvertFromUtf32%2A> Methode, um eine Zeichenfolge zu instanziieren, AEGEAN Nummer eins darstellt. Wie die Ausgabe des Beispiels zeigt die <xref:System.Char.IsNumber%28System.Char%29> Methodenrückgabe `false` , wenn sie entweder ein hohes Ersatzzeichen oder ein niedriges Ersatzzeichen dieses Zeichens übergeben wird.  
  
 [!code-csharp[System.Char.IsNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber1.cs#1)]
 [!code-vb[System.Char.IsNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber1.vb#1)]  
  
   
  
## Examples  
 Das folgende Beispiel zeigt <xref:System.Char.IsNumber%2A>.  
  
 [!code-cpp[System.Char.IsNumber#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsNumber/CPP/isnumber.cpp#8)]
 [!code-csharp[System.Char.IsNumber#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber.cs#8)]
 [!code-vb[System.Char.IsNumber#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsDigit(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsNumber">
      <MemberSignature Language="C#" Value="public static bool IsNumber (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNumber(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsNumber(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNumber (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNumber(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsNumber : string * int -&gt; bool" Usage="System.char.IsNumber (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge.</param>
        <param name="index">Die Position des in <c>s</c> auszuwertenden Zeichens.</param>
        <summary>Gibt an, ob das Zeichen an der angegebenen Position in einer angegebenen Zeichenfolge als Zahl kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen an der Position <paramref name="index" /> in <paramref name="s" /> eine Zahl ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt, ob eine <xref:System.Char> alle numerischen Unicode-Kategorie ist. Neben dem einschließen von Ziffern, enthalten Zahlen, Zeichen, Brüche, tiefgestellte Zeichen, hoch-, römische Zahlen, Währung Zähler und eingekreisten Zahlen. Diese Methode steht im Gegensatz zu den <xref:System.Char.IsDigit%2A> Methode, die bestimmt, ob eine <xref:System.Char> ist ein Basis-10-Ziffern.  
  
 Zeichenpositionen in einer Zeichenfolge werden indiziert, beginnend mit 0 (null).  
  
> [!IMPORTANT]
>  Die <xref:System.Char.IsNumber%28System.String%2CSystem.Int32%29> Methode ist nicht vorgesehen, um festzustellen, ob eine Zeichenfolge von numerischen Zeichen besteht aus (z. B. durch Aufrufen der Methode für jedes Zeichen in einer Zeichenfolge). Um zu bestimmen, ob eine Zeichenfolge aus numerischen Zeichen besteht, rufen Sie eine der Überladungen der der `TryParse` Methode (z. B. <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> oder <xref:System.Double.TryParse%2A?displayProperty=nameWithType> eines Ganzzahlen oder Gleitkommazahlen-Typs.  
  
 Gültige Zahlen sind Mitglieder der <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, <xref:System.Globalization.UnicodeCategory.LetterNumber?displayProperty=nameWithType>, oder <xref:System.Globalization.UnicodeCategory.OtherNumber?displayProperty=nameWithType> Kategorie.  
  
 Wenn die <xref:System.Char> Objekt an der Position `index` ist das erste Zeichen eines gültigen Ersatzzeichenpaars, das <xref:System.Char.IsNumber%28System.String%2CSystem.Int32%29> Methode bestimmt, ob das Ersatzzeichenpaar eine Ziffer bildet. Zum Beispiel besteht das the Aegean Zahlensystem Codepunkte U + 10107 bis U + 10133. Im folgenden Beispiel wird die <xref:System.Char.ConvertFromUtf32%2A> Methode, um eine Zeichenfolge zu instanziieren, AEGEAN Nummer eins darstellt. Wie die Ausgabe des Beispiels zeigt die <xref:System.Char.IsNumber%28System.String%2CSystem.Int32%29> Methodenrückgabe `true` , wenn sie das hohe Ersatzzeichen des AEGEAN Nummer eins übergeben wird. Wenn er das niedrige Ersatzzeichen übergeben wird, es berücksichtigt nur die Kategorie der das niedrige Ersatzzeichen und gibt `false`.  
  
 [!code-csharp[System.Char.IsNumber#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber1.cs#2)]
 [!code-vb[System.Char.IsNumber#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber1.vb#2)]  
  
   
  
## Examples  
 Das folgende Beispiel zeigt <xref:System.Char.IsNumber%2A>.  
  
 [!code-cpp[System.Char.IsNumber#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsNumber/CPP/isnumber.cpp#8)]
 [!code-csharp[System.Char.IsNumber#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber.cs#8)]
 [!code-vb[System.Char.IsNumber#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die letzte Position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Char.IsDigit(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPunctuation">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob ein Unicode-Zeichen als Satzzeichen kategorisiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gültige Satzzeichen sind Mitglieder der folgenden Kategorien in <xref:System.Globalization.UnicodeCategory>: `ConnectorPunctuation`, `DashPunctuation`, `OpenPunctuation`, `ClosePunctuation`, `InititalQuotePunctuation`, `FinalQuotePunctuation`, oder `OtherPunctuation`. Sie enthalten Zeichen, mit der Unicode-Codepunkten in der folgenden Tabelle aufgeführt.  
  
|||||  
|-|-|-|-|  
|U + 0021, U + 0023|U + 060C "und" U + 060D|U + 1800, U + 180A|Der 3014 U +, U + 301F|  
|U + 0025, U + 002A|U+061B|U + 1944 und U + 1945|U + 3030|  
|U + 002C bis U + 002F|U + 061E und U + 061F|U + 19DE und U + 19DF|U + 303D|  
|U + 003A und U + 003B|U + 066A 066 U + d|U + 1A1E und U + 1A1F|U + 30A0|  
|U + 003F und U + 0040|U + 06D 4|U + 1B5A, U + 1B60|U + 30FB|  
|U + 005B 005 U + d|U + 0700 070 U + d|U + U + 2027 2010|U + A874, U + A877|  
|U + 005F|U + 07F7, U + 07F9|U + 2030, U + 2043|U + FD3E und U + FD3F|  
|U+007B|U + 0964 und U + 0965|U + 2045, U + 2051|U + FE10, U + FE19|  
|007 U + D|U+0970|U + 2053, U + 205E|U + FE30, U + FE52|  
|U+00A1|U+0DF4|207 U + D und U + 207E|U + FE54, U + FE61|  
|U + 00AB|U + 0E4F, U + 0E5B|208 U + D und U + 208E|U+FE63|  
|U + 00AD|U + 0F04, U + 0F12|U + 2329 und U + 232A|U+FE68|  
|U+00B7|U + 0F3A, U + 0F3D|U + 2768, U + 2775|U + FE6A und U + FE6B|  
|U + 00BB|U+0F85|U + 27 c 5 bis U + 27 c-6|U + FF01, U + FF03|  
|U + 00BF|U + 0FD0 und U + 0FD1|U + 27E6 bis U + 27EB|U + FF05, U + FF0A|  
|U+037E|U + 104A, U + 104F|U + 2983, U + 2998|U + FF0C, U + FF0F|  
|U + 0387|U + 10FB|U + 29D 8, um U + 29DB|U + FF1A und U + FF1B|  
|U + 055A, U + 055F|U + 1361, U + 1368|U + 29FC und U + 29FD|U + FF1F und U + FF20|  
|U + 0589 und U + 058A|U + 166D und U + 166E|U + 2CF9, U + 2CFC|U + FF3B, U + FF3D|  
|U + 05BE|169 U + b "und" U + 169C|U + 2CFE und U + 2CFF|U + FF3F|  
|05C-U + 0|U + 16EB bis U + 16ED|U + 2E00, U + 2E17|U+FF5B|  
|U+05C3|U + 1735 und U + 1736|U + 2E1C und U + 2E1D|U + FF5D|  
|U+05C6|U + 17D 4 bis U + 17D 6|U + 3001, U + 3003|U + FF5F, U + FF65|  
|U + 05F3 und U + 05F4|U + 17D 8, um U + 17DA|U + 3008, U + 3011||  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPunctuation">
      <MemberSignature Language="C#" Value="public static bool IsPunctuation (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPunctuation(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsPunctuation(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPunctuation (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPunctuation(char c);" />
      <MemberSignature Language="F#" Value="static member IsPunctuation : char -&gt; bool" Usage="System.char.IsPunctuation c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das auszuwertende Unicode-Zeichen.</param>
        <summary>Gibt an, ob das angegebene Unicode-Zeichen als Satzzeichen kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="c" /> ein Satzzeichen ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gültige Satzzeichen sind Mitglieder der folgenden Kategorien in <xref:System.Globalization.UnicodeCategory>: `ConnectorPunctuation`, `DashPunctuation`, `OpenPunctuation`, `ClosePunctuation`, `InititalQuotePunctuation`, `FinalQuotePunctuation`, oder `OtherPunctuation`. Sie enthalten Zeichen, mit der Unicode-Codepunkten in der folgenden Tabelle aufgeführt.  
  
|||||  
|-|-|-|-|  
|U + 0021, U + 0023|U + 060C "und" U + 060D|U + 1800, U + 180A|Der 3014 U +, U + 301F|  
|U + 0025, U + 002A|U+061B|U + 1944 und U + 1945|U + 3030|  
|U + 002C bis U + 002F|U + 061E und U + 061F|U + 19DE und U + 19DF|U + 303D|  
|U + 003A und U + 003B|U + 066A 066 U + d|U + 1A1E und U + 1A1F|U + 30A0|  
|U + 003F und U + 0040|U + 06D 4|U + 1B5A, U + 1B60|U + 30FB|  
|U + 005B 005 U + d|U + 0700 070 U + d|U + U + 2027 2010|U + A874, U + A877|  
|U + 005F|U + 07F7, U + 07F9|U + 2030, U + 2043|U + FD3E und U + FD3F|  
|U+007B|U + 0964 und U + 0965|U + 2045, U + 2051|U + FE10, U + FE19|  
|007 U + D|U+0970|U + 2053, U + 205E|U + FE30, U + FE52|  
|U+00A1|U+0DF4|207 U + D und U + 207E|U + FE54, U + FE61|  
|U + 00AB|U + 0E4F, U + 0E5B|208 U + D und U + 208E|U+FE63|  
|U + 00AD|U + 0F04, U + 0F12|U + 2329 und U + 232A|U+FE68|  
|U+00B7|U + 0F3A, U + 0F3D|U + 2768, U + 2775|U + FE6A und U + FE6B|  
|U + 00BB|U+0F85|U + 27 c 5 bis U + 27 c-6|U + FF01, U + FF03|  
|U + 00BF|U + 0FD0 und U + 0FD1|U + 27E6 bis U + 27EB|U + FF05, U + FF0A|  
|U+037E|U + 104A, U + 104F|U + 2983, U + 2998|U + FF0C, U + FF0F|  
|U + 0387|U + 10FB|U + 29D 8, um U + 29DB|U + FF1A und U + FF1B|  
|U + 055A, U + 055F|U + 1361, U + 1368|U + 29FC und U + 29FD|U + FF1F und U + FF20|  
|U + 0589 und U + 058A|U + 166D und U + 166E|U + 2CF9, U + 2CFC|U + FF3B, U + FF3D|  
|U + 05BE|169 U + b "und" U + 169C|U + 2CFE und U + 2CFF|U + FF3F|  
|05C-U + 0|U + 16EB bis U + 16ED|U + 2E00, U + 2E17|U+FF5B|  
|U+05C3|U + 1735 und U + 1736|U + 2E1C und U + 2E1D|U + FF5D|  
|U+05C6|U + 17D 4 bis U + 17D 6|U + 3001, U + 3003|U + FF5F, U + FF65|  
|U + 05F3 und U + 05F4|U + 17D 8, um U + 17DA|U + 3008, U + 3011||  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.IsPunctuation%2A>.  
  
 [!code-cpp[System.Char.IsPunctuation#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CPP/ispunctuation.cpp#9)]
 [!code-csharp[System.Char.IsPunctuation#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CS/ispunctuation.cs#9)]
 [!code-vb[System.Char.IsPunctuation#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsPunctuation/VB/ispunctuation.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPunctuation">
      <MemberSignature Language="C#" Value="public static bool IsPunctuation (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPunctuation(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsPunctuation(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPunctuation (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPunctuation(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsPunctuation : string * int -&gt; bool" Usage="System.char.IsPunctuation (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge.</param>
        <param name="index">Die Position des in <c>s</c> auszuwertenden Zeichens.</param>
        <summary>Gibt an, ob das Zeichen an der angegebenen Position in einer angegebenen Zeichenfolge als Satzzeichen kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen an der Position <paramref name="index" /> in <paramref name="s" /> ein Satzzeichen ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zeichenpositionen in einer Zeichenfolge werden indiziert, beginnend mit 0 (null).  
  
 Gültige Satzzeichen sind Mitglieder der folgenden Kategorien in <xref:System.Globalization.UnicodeCategory>: `ConnectorPunctuation`, `DashPunctuation`, `OpenPunctuation`, `ClosePunctuation`, `InititalQuotePunctuation`, `FinalQuotePunctuation`, oder `OtherPunctuation`. Sie enthalten Zeichen, mit der Unicode-Codepunkten in der folgenden Tabelle aufgeführt.  
  
|||||  
|-|-|-|-|  
|U + 0021, U + 0023|U + 060C "und" U + 060D|U + 1800, U + 180A|Der 3014 U +, U + 301F|  
|U + 0025, U + 002A|U+061B|U + 1944 und U + 1945|U + 3030|  
|U + 002C bis U + 002F|U + 061E und U + 061F|U + 19DE und U + 19DF|U + 303D|  
|U + 003A und U + 003B|U + 066A 066 U + d|U + 1A1E und U + 1A1F|U + 30A0|  
|U + 003F und U + 0040|U + 06D 4|U + 1B5A, U + 1B60|U + 30FB|  
|U + 005B 005 U + d|U + 0700 070 U + d|U + U + 2027 2010|U + A874, U + A877|  
|U + 005F|U + 07F7, U + 07F9|U + 2030, U + 2043|U + FD3E und U + FD3F|  
|U+007B|U + 0964 und U + 0965|U + 2045, U + 2051|U + FE10, U + FE19|  
|007 U + D|U+0970|U + 2053, U + 205E|U + FE30, U + FE52|  
|U+00A1|U+0DF4|207 U + D und U + 207E|U + FE54, U + FE61|  
|U + 00AB|U + 0E4F, U + 0E5B|208 U + D und U + 208E|U+FE63|  
|U + 00AD|U + 0F04, U + 0F12|U + 2329 und U + 232A|U+FE68|  
|U+00B7|U + 0F3A, U + 0F3D|U + 2768, U + 2775|U + FE6A und U + FE6B|  
|U + 00BB|U+0F85|U + 27 c 5 bis U + 27 c-6|U + FF01, U + FF03|  
|U + 00BF|U + 0FD0 und U + 0FD1|U + 27E6 bis U + 27EB|U + FF05, U + FF0A|  
|U+037E|U + 104A, U + 104F|U + 2983, U + 2998|U + FF0C, U + FF0F|  
|U + 0387|U + 10FB|U + 29D 8, um U + 29DB|U + FF1A und U + FF1B|  
|U + 055A, U + 055F|U + 1361, U + 1368|U + 29FC und U + 29FD|U + FF1F und U + FF20|  
|U + 0589 und U + 058A|U + 166D und U + 166E|U + 2CF9, U + 2CFC|U + FF3B, U + FF3D|  
|U + 05BE|169 U + b "und" U + 169C|U + 2CFE und U + 2CFF|U + FF3F|  
|05C-U + 0|U + 16EB bis U + 16ED|U + 2E00, U + 2E17|U+FF5B|  
|U+05C3|U + 1735 und U + 1736|U + 2E1C und U + 2E1D|U + FF5D|  
|U+05C6|U + 17D 4 bis U + 17D 6|U + 3001, U + 3003|U + FF5F, U + FF65|  
|U + 05F3 und U + 05F4|U + 17D 8, um U + 17DA|U + 3008, U + 3011||  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.IsPunctuation%2A>.  
  
 [!code-cpp[System.Char.IsPunctuation#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CPP/ispunctuation.cpp#9)]
 [!code-csharp[System.Char.IsPunctuation#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CS/ispunctuation.cs#9)]
 [!code-vb[System.Char.IsPunctuation#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsPunctuation/VB/ispunctuation.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die letzte Position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSeparator">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob ein Unicode-Zeichen als Trennzeichen kategorisiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Unicode-standard erkennt drei Unterkategorien von Trennzeichen:  
  
-   Leerzeichen Trennzeichen (die <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> Kategorie), die Zeichen wie z. B. \u0020 enthält.  
  
-   Zeilentrennzeichen (die <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> Kategorie), darunter \u2028.  
  
-   Absatztrennzeichen (die <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> Kategorie), darunter \u2029.  
  
> [!NOTE]
>  Der Unicode-Standard klassifiziert die Zeichen \u000A (LF), \u000C (FF) und \u000D (CR) als Steuerzeichen (Mitglied der <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> Kategorie) und nicht als Trennzeichen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSeparator">
      <MemberSignature Language="C#" Value="public static bool IsSeparator (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSeparator(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSeparator(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSeparator (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSeparator(char c);" />
      <MemberSignature Language="F#" Value="static member IsSeparator : char -&gt; bool" Usage="System.char.IsSeparator c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das auszuwertende Unicode-Zeichen.</param>
        <summary>Gibt an, ob ein angegebenes Unicode-Zeichen als Trennzeichen kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="c" /> ein Trennzeichen ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Unicode-standard erkennt drei Unterkategorien von Trennzeichen:  
  
-   Leerzeichen Trennzeichen (die <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> Kategorie), die Zeichen wie z. B. \u0020 enthält.  
  
-   Zeilentrennzeichen (die <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> Kategorie), darunter \u2028.  
  
-   Absatztrennzeichen (die <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> Kategorie), darunter \u2029.  
  
> [!NOTE]
>  Der Unicode-Standard klassifiziert die Zeichen \u000A (LF), \u000C (FF) und \u000D (CR) als Steuerzeichen (Mitglied der <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> Kategorie) und nicht als Trennzeichen.  
  
   
  
## Examples  
 Das folgende Beispiel enthält die <xref:System.Char> Objekte, die als Trennzeichen klassifiziert werden.  
  
 [!code-cpp[System.Char.IsSeparator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSeparator/CPP/isseparator1.cpp#1)]
 [!code-csharp[System.Char.IsSeparator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSeparator/CS/isseparator1.cs#1)]
 [!code-vb[System.Char.IsSeparator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSeparator/VB/isseparator1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.UnicodeCategory" />
      </Docs>
    </Member>
    <Member MemberName="IsSeparator">
      <MemberSignature Language="C#" Value="public static bool IsSeparator (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSeparator(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSeparator(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSeparator (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSeparator(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsSeparator : string * int -&gt; bool" Usage="System.char.IsSeparator (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge.</param>
        <param name="index">Die Position des in <c>s</c> auszuwertenden Zeichens.</param>
        <summary>Gibt an, ob das Zeichen an der angegebenen Position in einer angegebenen Zeichenfolge als Trennzeichen kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen an der Position <paramref name="index" /> in <paramref name="s" /> ein Trennzeichen ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zeichenpositionen in einer Zeichenfolge werden indiziert, beginnend mit 0 (null).  
  
 Die Unicode-standard erkennt drei Unterkategorien von Trennzeichen:  
  
-   Leerzeichen Trennzeichen (die <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> Kategorie), die Zeichen wie z. B. \u0020 enthält.  
  
-   Zeilentrennzeichen (die <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> Kategorie), darunter \u2028.  
  
-   Absatztrennzeichen (die <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> Kategorie), darunter \u2029.  
  
> [!NOTE]
>  Der Unicode-Standard klassifiziert die Zeichen \u000A (LF), \u000C (FF) und \u000D (CR) als Steuerzeichen (Mitglied der <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> Kategorie) und nicht als Trennzeichen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt <xref:System.Char.IsSeparator%2A>.  
  
 [!code-cpp[System.Char.IsSeparator#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSeparator/CPP/isseparator.cpp#10)]
 [!code-csharp[System.Char.IsSeparator#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSeparator/CS/isseparator.cs#10)]
 [!code-vb[System.Char.IsSeparator#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSeparator/VB/isseparator.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die letzte Position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSurrogate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob ein Zeichen über einen Ersatzzeichencodeeinheit verfügt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsSurrogate (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogate(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogate(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogate (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogate(char c);" />
      <MemberSignature Language="F#" Value="static member IsSurrogate : char -&gt; bool" Usage="System.char.IsSurrogate c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das auszuwertende Unicode-Zeichen.</param>
        <summary>Gibt an, ob das angegebene Zeichen über einen Ersatzzeichencodeeinheit verfügt.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="c" /> entweder ein hohes Ersatzzeichen oder ein niedriges Ersatzzeichen ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Ersatz ist eine <xref:System.Char> Objekt mit einer UTF-16-Codeeinheit im Bereich zwischen U + D800 und U + DFFF. Jedes Zeichen mit der Codeeinheit in diesem Bereich gehört zu den <xref:System.Globalization.UnicodeCategory.Surrogate?displayProperty=nameWithType> Kategorie. Die einzelne Ersatzzeichen-Codeeinheit verfügt über keine eigene Interpretation, hat jedoch Bedeutung nur als Teil eines Ersatzzeichenpaars. Weitere Informationen zu Ersatzzeichenpaaren finden Sie unter den Unicode-Standard auf die [Unicode-Homepage](http://go.microsoft.com/fwlink/?linkid=37123).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Char.IsSurrogate%2A> Methode.  
  
 [!code-cpp[System.Char.IsSurrogate#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CPP/issurrogate.cpp#11)]
 [!code-csharp[System.Char.IsSurrogate#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CS/issurrogate.cs#11)]
 [!code-vb[System.Char.IsSurrogate#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSurrogate/VB/issurrogate.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Char.IsHighSurrogate" />
        <altmember cref="Overload:System.Char.IsLowSurrogate" />
        <altmember cref="Overload:System.Char.IsSurrogatePair" />
      </Docs>
    </Member>
    <Member MemberName="IsSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsSurrogate (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogate(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogate(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogate (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogate(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsSurrogate : string * int -&gt; bool" Usage="System.char.IsSurrogate (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge.</param>
        <param name="index">Die Position des in <c>s</c> auszuwertenden Zeichens.</param>
        <summary>Gibt an, ob das Zeichen an der angegebenen Position in einer angegebenen Zeichenfolge über einen Ersatzzeichen-Codeeinheit verfügt.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen an Position <paramref name="index" /> in <paramref name="s" /> entweder ein hohes Ersatzzeichen oder ein niedriges Ersatzzeichen ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zeichenpositionen in einer Zeichenfolge werden indiziert, beginnend mit 0 (null).  
  
 Ein Ersatz ist eine <xref:System.Char> Objekt mit einer UTF-16-Codeeinheit im Bereich zwischen U + D800 und U + DFFF. Jedes Zeichen mit der Codeeinheit in diesem Bereich gehört zu den <xref:System.Globalization.UnicodeCategory.Surrogate?displayProperty=nameWithType> Kategorie. Die einzelne Ersatzzeichen-Codeeinheit verfügt über keine eigene Interpretation, hat jedoch Bedeutung nur als Teil eines Ersatzzeichenpaars. Weitere Informationen zu Ersatzzeichenpaaren finden Sie unter den Unicode-Standard auf die [Unicode-Homepage](http://go.microsoft.com/fwlink/?linkid=37123).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.IsSurrogate%2A>.  
  
 [!code-cpp[System.Char.IsSurrogate#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CPP/issurrogate.cpp#11)]
 [!code-csharp[System.Char.IsSurrogate#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CS/issurrogate.cs#11)]
 [!code-vb[System.Char.IsSurrogate#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSurrogate/VB/issurrogate.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die letzte Position in <paramref name="s" />.</exception>
        <altmember cref="Overload:System.Char.IsHighSurrogate" />
        <altmember cref="Overload:System.Char.IsLowSurrogate" />
        <altmember cref="Overload:System.Char.IsSurrogatePair" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSurrogatePair">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob zwei angegebene <see cref="T:System.Char" />-Objekte ein Ersatzzeichenpaar bilden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSurrogatePair">
      <MemberSignature Language="C#" Value="public static bool IsSurrogatePair (char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogatePair(char highSurrogate, char lowSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogatePair(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogatePair (highSurrogate As Char, lowSurrogate As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="F#" Value="static member IsSurrogatePair : char * char -&gt; bool" Usage="System.char.IsSurrogatePair (highSurrogate, lowSurrogate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" />
        <Parameter Name="lowSurrogate" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="highSurrogate">Das Zeichen, das als das hohe Ersatzzeichen eines Ersatzzeichenpaars ausgewertet werden soll.</param>
        <param name="lowSurrogate">Das Zeichen, das als das niedrige Ersatzzeichen eines Ersatzzeichenpaars ausgewertet werden soll.</param>
        <summary>Gibt an, ob die beiden angegebenen <see cref="T:System.Char" />-Objekte ein Ersatzzeichenpaar bilden.</summary>
        <returns>
          <see langword="true" />, wenn der numerische Wert des <paramref name="highSurrogate" />-Parameters zwischen U+D800 und U+DBFF und der numerische Wert des <paramref name="lowSurrogate" />-Parameters zwischen U+DC00 und U+DFFF liegt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalerweise wird ein einzelnes Zeichen durch eine einzelne 16-Bit-Unicode-Codeeinheit dargestellt. UTF-16-Codierung unterstützt auch das Surrogate-Paare, mit die ein einzelnes abstraktes Zeichen von zwei 16-Bit-Codeeinheiten dargestellt werden können. Die erste Codeeinheit, deren Wert zwischen U + D800 und U + DBFF liegen kann, ist das hohe Ersatzzeichen. Die zweite-Codeeinheit, deren Wert zwischen U + DC00 und U + DFFF liegen kann, ist das niedrige Ersatzzeichen. Einzelne Ersatzzeichen-Codepunkte haben keine eigene Interpretation. Weitere Informationen über Ersatzzeichen und Unicode-Standard, finden Sie unter den [Unicode-Homepage](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, und <xref:System.Char.IsSurrogatePair%2A> Methoden.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.IsHighSurrogate(System.Char)" />
        <altmember cref="M:System.Char.IsLowSurrogate(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsSurrogatePair">
      <MemberSignature Language="C#" Value="public static bool IsSurrogatePair (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogatePair(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogatePair(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogatePair (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogatePair(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsSurrogatePair : string * int -&gt; bool" Usage="System.char.IsSurrogatePair (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge.</param>
        <param name="index">Die Anfangsposition des innerhalb von <c>s</c> auszuwertenden Zeichenpaars.</param>
        <summary>Gibt an, ob zwei aufeinander folgende <see cref="T:System.Char" />-Objekte an einer angegebenen Position in einer Zeichenfolge ein Ersatzzeichenpaar bilden.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="s" />-Parameter an der Position <paramref name="index" /> und <paramref name="index" /> + 1 aufeinander folgende Zeichen enthält, der numerische Wert des Zeichens an der Position <paramref name="index" /> zwischen U+D800 und U+DBFF liegt und der numerische Wert des Zeichens an der Position <paramref name="index" />+1 zwischen U+DC00 und U+DFFF liegt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalerweise wird ein einzelnes Zeichen durch eine einzelne 16-Bit-Unicode-Codeeinheit dargestellt. UTF-16-Codierung unterstützt auch das Surrogate-Paare, mit die ein einzelnes abstraktes Zeichen von zwei 16-Bit-Codeeinheiten dargestellt werden können. Die erste Codeeinheit, deren Wert zwischen U + D800 und U + DBFF liegen kann, ist das hohe Ersatzzeichen. Die zweite-Codeeinheit, deren Wert zwischen U + DC00 und U + DFFF liegen kann, ist das niedrige Ersatzzeichen. Einzelne Ersatzzeichen-Codepunkte haben keine eigene Interpretation. Weitere Informationen über Ersatzzeichen und Unicode-Standard, finden Sie unter den [Unicode-Homepage](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, und <xref:System.Char.IsSurrogatePair%2A> Methoden.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist keine Position in <paramref name="s" />.</exception>
        <altmember cref="M:System.Char.IsHighSurrogate(System.Char)" />
        <altmember cref="M:System.Char.IsLowSurrogate(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSymbol">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob ein Unicode-Zeichen als Symbolzeichen kategorisiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gültige Zeichen sind Mitglieder einer der folgenden Kategorien in <xref:System.Globalization.UnicodeCategory>: `MathSymbol`, `CurrencySymbol`, `ModifierSymbol`, und `OtherSymbol`.  
  
 Symbole in der Unicode-Standard gibt einen lose definierten Satz von Zeichen, die Folgendes umfassen:  
  
-   Währungssymbole.  
  
-   Buchstabenähnliche Symbole, darunter eine Reihe von mathematische alphanumerische Symbole als auch Symbole, z. B. ℅, № und™.  
  
-   Formulare, z. B. hoch- und tiefgestellter Zeichen-Nummer.  
  
-   Mathematische Operatoren und Pfeile.  
  
-   Geometrische Symbole.  
  
-   Technischer Symbole.  
  
-   Braille-Muster.  
  
-   "Dingbats".  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSymbol">
      <MemberSignature Language="C#" Value="public static bool IsSymbol (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSymbol(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSymbol(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSymbol (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSymbol(char c);" />
      <MemberSignature Language="F#" Value="static member IsSymbol : char -&gt; bool" Usage="System.char.IsSymbol c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das auszuwertende Unicode-Zeichen.</param>
        <summary>Gibt an, ob ein angegebenes Unicode-Zeichen als Symbolzeichen kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="c" /> ein Symbolzeichen ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gültige Zeichen sind Mitglieder einer der folgenden Kategorien in <xref:System.Globalization.UnicodeCategory>: `MathSymbol`, `CurrencySymbol`, `ModifierSymbol`, und `OtherSymbol`.  
  
 Symbole in der Unicode-Standard gibt einen lose definierten Satz von Zeichen, die Folgendes umfassen:  
  
-   Währungssymbole.  
  
-   Buchstabenähnliche Symbole, darunter eine Reihe von mathematische alphanumerische Symbole als auch Symbole, z. B. ℅, № und™.  
  
-   Formulare, z. B. hoch- und tiefgestellter Zeichen-Nummer.  
  
-   Mathematische Operatoren und Pfeile.  
  
-   Geometrische Symbole.  
  
-   Technischer Symbole.  
  
-   Braille-Muster.  
  
-   "Dingbats".  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.IsSymbol%2A>.  
  
 [!code-cpp[System.Char.IsSymbol#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSymbol/CPP/issymbol.cpp#12)]
 [!code-csharp[System.Char.IsSymbol#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSymbol/CS/issymbol.cs#12)]
 [!code-vb[System.Char.IsSymbol#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSymbol/VB/issymbol.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsSymbol">
      <MemberSignature Language="C#" Value="public static bool IsSymbol (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSymbol(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSymbol(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSymbol (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSymbol(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsSymbol : string * int -&gt; bool" Usage="System.char.IsSymbol (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge.</param>
        <param name="index">Die Position des in <c>s</c> auszuwertenden Zeichens.</param>
        <summary>Gibt an, ob das Zeichen an der angegebenen Position in einer angegebenen Zeichenfolge als Symbolzeichen kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen an der Position <paramref name="index" /> in <paramref name="s" /> ein Symbolzeichen ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zeichenpositionen in einer Zeichenfolge werden indiziert, beginnend mit 0 (null).  
  
 Gültige Zeichen sind Mitglieder einer der folgenden Kategorien in <xref:System.Globalization.UnicodeCategory?displayProperty=nameWithType>: `MathSymbol`, `CurrencySymbol`, `ModifierSymbol`, und `OtherSymbol`.  
  
 Symbole in der Unicode-Standard gibt einen lose definierten Satz von Zeichen, die Folgendes umfassen:  
  
-   Währungssymbole.  
  
-   Buchstabenähnliche Symbole, darunter eine Reihe von mathematische alphanumerische Symbole als auch Symbole, z. B. ℅, № und™.  
  
-   Formulare, z. B. hoch- und tiefgestellter Zeichen-Nummer.  
  
-   Mathematische Operatoren und Pfeile.  
  
-   Geometrische Symbole.  
  
-   Technischer Symbole.  
  
-   Braille-Muster.  
  
-   "Dingbats".  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.IsSymbol%2A>.  
  
 [!code-cpp[System.Char.IsSymbol#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSymbol/CPP/issymbol.cpp#12)]
 [!code-csharp[System.Char.IsSymbol#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSymbol/CS/issymbol.cs#12)]
 [!code-vb[System.Char.IsSymbol#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSymbol/VB/issymbol.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die letzte Position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob ein Unicode-Zeichen als Großbuchstabe kategorisiert wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsUpper">
      <MemberSignature Language="C#" Value="public static bool IsUpper (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUpper(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsUpper(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUpper (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUpper(char c);" />
      <MemberSignature Language="F#" Value="static member IsUpper : char -&gt; bool" Usage="System.char.IsUpper c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das auszuwertende Unicode-Zeichen.</param>
        <summary>Gibt an, ob ein angegebenes Unicode-Zeichen als Großbuchstabe kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="c" /> ein Großbuchstabe ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gültige Großbuchstaben gehören zur Kategorie <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsLower(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsUpper">
      <MemberSignature Language="C#" Value="public static bool IsUpper (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUpper(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsUpper(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUpper (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUpper(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsUpper : string * int -&gt; bool" Usage="System.char.IsUpper (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge.</param>
        <param name="index">Die Position des in <c>s</c> auszuwertenden Zeichens.</param>
        <summary>Gibt an, ob das Zeichen an der angegebenen Position in einer angegebenen Zeichenfolge als Großbuchstabe kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen an der Position <paramref name="index" /> in <paramref name="s" /> ein Großbuchstabe ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zeichenpositionen in einer Zeichenfolge werden indiziert, beginnend mit 0 (null).  
  
 Gültige Großbuchstaben gehören zur Kategorie <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die letzte Position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsWhiteSpace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob ein Unicode-Zeichen als Leerzeichen kategorisiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Leerzeichen sind die folgenden Unicode-Zeichen enthalten:  
  
-   Mitglied der <xref:System.Globalization.UnicodeCategory.SpaceSeparator> Kategorie enthält die Zeichen, Leerzeichen (U + 0020) fest, markieren Sie "ogam" Leerzeichen (U + 1680), EN QUAD (U + 2000), EM-QUAD (U + 2001), EN Leerzeichen (U + 2002), EM Leerzeichen (U + 2003), drei pro m-Speicherplatz (U + 2004), vier pro m-Speicherplatz (U + 2005), sechs pro m- Leerzeichen (U + 2006), Abbildung Leerzeichen (U + 2007), SATZZEICHEN, Leerzeichen (U + 2008), SCHLANKE Leerzeichen (U + 2009), HAARE Leerzeichen (U + 200A), SCHMALEN geschütztes Leerzeichen (U + 202F), Mittel, MATHEMATISCHE Leerzeichen (U + 205F) und IDEOGRAFISCH vorgegebene Leerzeichen (U + 3000).  
  
-   Mitglieder der <xref:System.Globalization.UnicodeCategory.LineSeparator> Kategorie, die nur aus der Zeile Trennzeichen besteht (U + 2028).  
  
-   Mitglieder der <xref:System.Globalization.UnicodeCategory.ParagraphSeparator> Kategorie, die nur aus dem ABSATZTRENNZEICHEN besteht (U + 2029).  
  
-   Die Zeichen Zeichentabelle (U + 0009), ZEILENVORSCHUBZEICHEN (U + 000A), Zeile TABELLIERUNG (U + 000 b), Seitenvorschub (U + 000C), Wagenrücklauf (U + 000D), Zeile als Nächstes (U + 0085), und ein geschütztes Leerzeichen (U + 00A0).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsWhiteSpace(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWhiteSpace (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWhiteSpace(char c);" />
      <MemberSignature Language="F#" Value="static member IsWhiteSpace : char -&gt; bool" Usage="System.char.IsWhiteSpace c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das auszuwertende Unicode-Zeichen.</param>
        <summary>Gibt an, ob das angegebene Unicode-Zeichen als Leerzeichen kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="c" /> ein Leerzeichen ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Leerzeichen sind die folgenden Unicode-Zeichen enthalten:  
  
-   Mitglied der <xref:System.Globalization.UnicodeCategory.SpaceSeparator> Kategorie, die die Zeichen ein Leerzeichen enthält (U + 0020), geschütztes Leerzeichen (U + 00A0), markieren Sie "ogam" Leerzeichen (U + 1680), EN QUAD (U + 2000), EM-QUAD (U + 2001), EN Leerzeichen (U + 2002), EM Leerzeichen (U + 2003), drei pro m-Speicherplatz (U + 2004), vier pro m-Speicherplatz ( U+ 2005), 6 pro m-Leerzeichen (U + 2006), Abbildung Leerzeichen (U + 2007), SATZZEICHEN, Leerzeichen (U + 2008), SCHLANKE Leerzeichen (U + 2009), HAARE Leerzeichen (U + 200A), SCHMALEN geschütztes Leerzeichen (U + 202F), Mittel, MATHEMATISCHE Leerzeichen (U + 205F) und IDEOGRAFISCH vorgegebene Leerzeichen (U + 3000).  
  
-   Mitglieder der <xref:System.Globalization.UnicodeCategory.LineSeparator> Kategorie, die nur aus der Zeile Trennzeichen besteht (U + 2028).  
  
-   Mitglieder der <xref:System.Globalization.UnicodeCategory.ParagraphSeparator> Kategorie, die nur aus dem ABSATZTRENNZEICHEN besteht (U + 2029).  
  
-   Die Zeichen Zeichentabelle (U + 0009), Zeile FEED (U + 000A), Zeile TABELLIERUNG (U + 000 b), Seitenvorschub (U + 000C), Wagenrücklauf (U + 000D), und neben Zeile (U + 0085).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Char.IsWhiteSpace%28System.Char%29> Methode.  
  
 [!code-cpp[System.Char.IsWhiteSpace#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CPP/iswhitespace.cpp#14)]
 [!code-csharp[System.Char.IsWhiteSpace#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CS/iswhitespace.cs#14)]
 [!code-vb[System.Char.IsWhiteSpace#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/VB/iswhitespace.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Globalization.UnicodeCategory" />
      </Docs>
    </Member>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsWhiteSpace(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWhiteSpace (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWhiteSpace(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsWhiteSpace : string * int -&gt; bool" Usage="System.char.IsWhiteSpace (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge.</param>
        <param name="index">Die Position des in <c>s</c> auszuwertenden Zeichens.</param>
        <summary>Gibt an, ob das Zeichen an der angegebenen Position in einer angegebenen Zeichenfolge als Leerzeichen kategorisiert wird.</summary>
        <returns>
          <see langword="true" />, wenn das Zeichen an der Position <paramref name="index" /> in <paramref name="s" /> Leerraum ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zeichenpositionen in einer Zeichenfolge werden indiziert, beginnend mit 0 (null).  
  
 Leerzeichen sind die folgenden Unicode-Zeichen enthalten:  
  
-   Mitglied der <xref:System.Globalization.UnicodeCategory.SpaceSeparator> Kategorie, die die Zeichen ein Leerzeichen enthält (U + 0020), geschütztes Leerzeichen (U + 00A0), markieren Sie "ogam" Leerzeichen (U + 1680), EN QUAD (U + 2000), EM-QUAD (U + 2001), EN Leerzeichen (U + 2002), EM Leerzeichen (U + 2003), drei pro m-Speicherplatz (U + 2004), vier pro m-Speicherplatz ( U+ 2005), 6 pro m-Leerzeichen (U + 2006), Abbildung Leerzeichen (U + 2007), SATZZEICHEN, Leerzeichen (U + 2008), SCHLANKE Leerzeichen (U + 2009), HAARE Leerzeichen (U + 200A), SCHMALEN geschütztes Leerzeichen (U + 202F), Mittel, MATHEMATISCHE Leerzeichen (U + 205F) und IDEOGRAFISCH vorgegebene Leerzeichen (U + 3000).  
  
-   Mitglieder der <xref:System.Globalization.UnicodeCategory.LineSeparator> Kategorie, die nur aus der Zeile Trennzeichen besteht (U + 2028).  
  
-   Mitglieder der <xref:System.Globalization.UnicodeCategory.ParagraphSeparator> Kategorie, die nur aus dem ABSATZTRENNZEICHEN besteht (U + 2029).  
  
-   Die Zeichen Zeichentabelle (U + 0009), Zeile FEED (U + 000A), Zeile TABELLIERUNG (U + 000 b), Seitenvorschub (U + 000C), Wagenrücklauf (U + 000D), und neben Zeile (U + 0085).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.IsWhiteSpace%2A>.  
  
 [!code-cpp[System.Char.IsWhiteSpace#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CPP/iswhitespace.cpp#14)]
 [!code-csharp[System.Char.IsWhiteSpace#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CS/iswhitespace.cs#14)]
 [!code-vb[System.Char.IsWhiteSpace#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/VB/iswhitespace.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer als die letzte Position in <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Globalization.UnicodeCategory" />
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const char MaxValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal char MaxValue" />
      <MemberSignature Language="DocId" Value="F:System.Char.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Char " />
      <MemberSignature Language="C++ CLI" Value="public: char MaxValue;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : char" Usage="System.char.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den größtmöglichen Wert von <see cref="T:System.Char" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist hexadezimal 0xFFFF.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Char.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const char MinValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal char MinValue" />
      <MemberSignature Language="DocId" Value="F:System.Char.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Char " />
      <MemberSignature Language="C++ CLI" Value="public: char MinValue;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : char" Usage="System.char.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den kleinstmöglichen Wert von <see cref="T:System.Char" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist hexadezimal 0 x 00.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Char.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static char Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; char" Usage="System.char.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die ein einzelnes Zeichen enthält, oder <see langword="null" />.</param>
        <summary>Konvertiert den Wert der angegebenen Zeichenfolge in das entsprechende Unicode-Zeichen.</summary>
        <returns>Ein Unicode-Zeichen, das dem einzigen Zeichen in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.Parse%2A>.  
  
 [!code-cpp[System.Char.Parse#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.Parse/CPP/parse.cpp#15)]
 [!code-csharp[System.Char.Parse#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.Parse/CS/parse.cs#15)]
 [!code-vb[System.Char.Parse#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.Parse/VB/parse.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Die Länge von <paramref name="s" /> ist nicht 1.</exception>
        <altmember cref="M:System.Char.ToString" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>**Hinweis** Diese Konvertierung wird nicht unterstützt. Bei einem entsprechenden Versuch wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Diese Konvertierung wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Diese Konvertierung wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.Char" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Char>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToByte%28System.Char%29?displayProperty=nameWithType> Methode stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Der Wert des aktuellen <see cref="T:System.Char" />-Objekts bleibt unverändert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Char>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>**Hinweis** Diese Konvertierung wird nicht unterstützt. Bei einem entsprechenden Versuch wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Diese Konvertierung wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>**Hinweis** Diese Konvertierung wird nicht unterstützt. Bei einem entsprechenden Versuch wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Diese Konvertierung wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>**Hinweis** Diese Konvertierung wird nicht unterstützt. Bei einem entsprechenden Versuch wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Diese Konvertierung wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.Char" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Char>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt16%28System.Char%29?displayProperty=nameWithType> Methode stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.Char" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Char>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt32%28System.Char%29?displayProperty=nameWithType> Methode stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.Char" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Char>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt64%28System.Char%29?displayProperty=nameWithType> Methode stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.Char" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Char>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToSByte%28System.Char%29?displayProperty=nameWithType> Methode stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>**Hinweis** Diese Konvertierung wird nicht unterstützt. Bei einem entsprechenden Versuch wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Diese Konvertierung wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Ein <see cref="T:System.Type" />-Objekt.</param>
        <param name="provider">Ein <see cref="T:System.IFormatProvider" />-Objekt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Ein Objekt des angegebenen Typs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Char>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ChangeType%28System.Object%2CSystem.Type%2CSystem.IFormatProvider%29> Methode stattdessen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Der Wert des aktuellen <see cref="T:System.Char" />-Objekts kann nicht in den durch den <paramref name="type" />-Parameter angegebenen Typ konvertiert werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein <see cref="T:System.IFormatProvider" />-Objekt. (Geben Sie <see langword="null" /> an, da der <c>provider</c>-Parameter ignoriert wird.)</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.Char" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Char>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt16%28System.Char%29?displayProperty=nameWithType> Methode stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein <see cref="T:System.IFormatProvider" />-Objekt. (Geben Sie <see langword="null" /> an, da der <c>provider</c>-Parameter ignoriert wird.)</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.Char" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Char>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt32%28System.Char%29?displayProperty=nameWithType> Methode stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein <see cref="T:System.IFormatProvider" />-Objekt. (Geben Sie <see langword="null" /> an, da der <c>provider</c>-Parameter ignoriert wird.)</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.Char" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Char>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt64%28System.Char%29?displayProperty=nameWithType> Methode stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den Wert eines Unicode-Zeichens in den entsprechenden Kleinbuchstaben.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static char ToLower (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToLower(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToLower(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLower (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToLower(char c);" />
      <MemberSignature Language="F#" Value="static member ToLower : char -&gt; char" Usage="System.char.ToLower c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das zu konvertierende Unicode-Zeichen.</param>
        <summary>Konvertiert den Wert eines Unicode-Zeichens in den entsprechenden Kleinbuchstaben.</summary>
        <returns>Die Entsprechung von <paramref name="c" /> in Kleinbuchstaben oder der unveränderte Wert von <paramref name="c" />, wenn <paramref name="c" /> bereits aus Kleinbuchstaben besteht oder kein alphabetischer Wert ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Groß-/ Kleinschreibregeln werden aus der aktuellen Kultur abgerufen.  
  
 Verwendung <xref:System.String.ToLower%2A?displayProperty=nameWithType> zum Konvertieren einer Zeichenfolge in Kleinbuchstaben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt <xref:System.Char.ToLower%2A>.  
  
 [!code-cpp[System.Char.ToLower#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToLower/CPP/tolower.cpp#16)]
 [!code-csharp[System.Char.ToLower#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToLower/CS/tolower.cs#16)]
 [!code-vb[System.Char.ToLower#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToLower/VB/tolower.vb#16)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Siehe [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), es wird empfohlen, dass Sie vermeiden, Aufrufmethoden-Groß-/Kleinschreibung und Zeichenfolgen, die Standardwerte zu ersetzen. Stattdessen sollten Sie Methoden aufrufen, die für Parameter explizit angegeben werden müssen. Um ein Zeichen, das mit die Groß-/ Kleinschreibungskonventionen der aktuellen Kultur in Kleinbuchstaben zu konvertieren, rufen die <see cref="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" /> methodenüberladung mit einem Wert von <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> für seine <paramref name="culture" /> Parameter.</para>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static char ToLower (char c, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToLower(char c, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLower (c As Char, culture As CultureInfo) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToLower(char c, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToLower : char * System.Globalization.CultureInfo -&gt; char" Usage="System.char.ToLower (c, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="c">Das zu konvertierende Unicode-Zeichen.</param>
        <param name="culture">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</param>
        <summary>Konvertiert den Wert eines angegebenen Unicode-Zeichens unter Verwendung der angegebenen kulturabhängigen Formatierungsinformationen in den entsprechenden Kleinbuchstaben.</summary>
        <returns>Die gemäß <paramref name="c" /> veränderte Entsprechung von <paramref name="culture" /> in Kleinbuchstaben oder der unveränderte Wert von <paramref name="c" />, wenn <paramref name="c" /> bereits aus Kleinbuchstaben besteht oder kein alphabetischer Wert ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.String.ToLower%2A?displayProperty=nameWithType> zum Konvertieren einer Zeichenfolge in Kleinbuchstaben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.ToLower%2A>.  
  
 [!code-cpp[System.Char.ToLower#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToLower/CPP/tolower.cpp#16)]
 [!code-csharp[System.Char.ToLower#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToLower/CS/tolower.cs#16)]
 [!code-vb[System.Char.ToLower#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToLower/VB/tolower.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> ist <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.CurrentCulture" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public static char ToLowerInvariant (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToLowerInvariant(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToLowerInvariant(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLowerInvariant (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToLowerInvariant(char c);" />
      <MemberSignature Language="F#" Value="static member ToLowerInvariant : char -&gt; char" Usage="System.char.ToLowerInvariant c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das zu konvertierende Unicode-Zeichen.</param>
        <summary>Konvertiert den Wert eines Unicode-Zeichens in dessen Entsprechung in Kleinbuchstaben unter Verwendung der Regeln der invarianten Kultur für Groß- und Kleinschreibung.</summary>
        <returns>Die Entsprechung des <paramref name="c" />-Parameters in Kleinbuchstaben oder der unveränderte Wert von <paramref name="c" />, wenn <paramref name="c" /> bereits aus Kleinbuchstaben besteht oder kein alphabetischer Wert ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Ihre Anwendung nicht betroffen von der aktuellen Kultur ist und hängt von die Groß-/Kleinschreibung eines Zeichens in einer vorhersagbaren Weise ändern, verwenden Sie die <xref:System.Char.ToLowerInvariant%2A> Methode. Die <xref:System.Char.ToLowerInvariant%2A> Methode entspricht dem `ToLower(Char, CultureInfo.InvariantCulture)`.  
  
 Verwendung <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> zum Konvertieren einer Zeichenfolge in Kleinbuchstaben.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="char.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.ToString%2A>.  
  
 [!code-cpp[System.Char.ToString#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToString/CPP/tostring.cpp#17)]
 [!code-csharp[System.Char.ToString#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToString/CS/tostring.cs#17)]
 [!code-vb[System.Char.ToString#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToString/VB/tostring.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToString(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToString (c As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ToString(char c);" />
      <MemberSignature Language="F#" Value="static member ToString : char -&gt; string" Usage="System.char.ToString c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das zu konvertierende Unicode-Zeichen.</param>
        <summary>Konvertiert das angegebene Unicode-Zeichen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Wertes von <paramref name="c" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Char.ToString%2A>.  
  
 [!code-cpp[System.Char.ToString#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToString/CPP/tostring.cpp#17)]
 [!code-csharp[System.Char.ToString#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToString/CS/tostring.cs#17)]
 [!code-vb[System.Char.ToString#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToString/VB/tostring.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="char.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(Reserviert) Ein Objekt, das kulturabhängige Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den Wert dieser Instanz unter Verwendung der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgenentsprechung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `provider` Parameter wird ignoriert; er wird nicht berücksichtigt, bei diesem Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, eine Überladung der <xref:System.Char.ToString%2A>.  
  
 [!code-cpp[System.Char.ToString#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToString/CPP/tostring.cpp#17)]
 [!code-csharp[System.Char.ToString#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToString/CS/tostring.cs#17)]
 [!code-vb[System.Char.ToString#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToString/VB/tostring.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den Wert eines Unicode-Zeichens in den entsprechenden Großbuchstaben.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static char ToUpper (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToUpper(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToUpper(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpper (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToUpper(char c);" />
      <MemberSignature Language="F#" Value="static member ToUpper : char -&gt; char" Usage="System.char.ToUpper c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das zu konvertierende Unicode-Zeichen.</param>
        <summary>Konvertiert den Wert eines Unicode-Zeichens in den entsprechenden Großbuchstaben.</summary>
        <returns>Die Entsprechung von <paramref name="c" /> in Großbuchstaben oder der unveränderte Wert von <paramref name="c" />, wenn <paramref name="c" /> bereits aus Großbuchstaben besteht, keine Entsprechung in Großbuchstaben hat oder kein alphabetischer Wert ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Groß-/ Kleinschreibregeln werden aus der aktuellen Kultur abgerufen.  
  
 Verwendung <xref:System.String.ToUpper%2A?displayProperty=nameWithType> zum Konvertieren einer Zeichenfolge in Großbuchstaben.  
  
   
  
## Examples  
 Im folgende Beispiel konvertiert jedes Zeichen in ein Array, in dessen Entsprechung in Großbuchstaben.  
  
 [!code-csharp[System.Char.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.toupper/cs/toupper1.cs#1)]
 [!code-vb[System.Char.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.toupper/vb/toupper1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Siehe [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), es wird empfohlen, dass Sie vermeiden, Aufrufmethoden-Groß-/Kleinschreibung und Zeichenfolgen, die Standardwerte zu ersetzen. Stattdessen sollten Sie Methoden aufrufen, die für Parameter explizit angegeben werden müssen. Um ein Zeichen in Großbuchstaben unter Verwendung der Groß-/ Kleinschreibungskonventionen der aktuellen Kultur zu konvertieren, rufen die <see cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" /> methodenüberladung mit einem Wert von <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> für seine <paramref name="culture" /> Parameter.</para>
        </block>
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static char ToUpper (char c, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToUpper(char c, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpper (c As Char, culture As CultureInfo) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToUpper(char c, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToUpper : char * System.Globalization.CultureInfo -&gt; char" Usage="System.char.ToUpper (c, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="c">Das zu konvertierende Unicode-Zeichen.</param>
        <param name="culture">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</param>
        <summary>Konvertiert den Wert eines angegebenen Unicode-Zeichens unter Verwendung der angegebenen kulturabhängigen Formatierungsinformationen in den entsprechenden Großbuchstaben.</summary>
        <returns>Die gemäß <paramref name="c" /> veränderte Entsprechung von <paramref name="culture" /> in Großbuchstaben oder der unveränderte Wert von <paramref name="c" />, wenn <paramref name="c" /> bereits aus Großbuchstaben besteht, keine Entsprechung in Großbuchstaben besitzt oder kein alphabetischer Wert ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.String.ToUpper%2A?displayProperty=nameWithType> zum Konvertieren einer Zeichenfolge in Großbuchstaben.  
  
   
  
## Examples  
 Im folgende Beispiel konvertiert jedes Zeichen in ein Array, in dessen Entsprechung in Großbuchstaben für die Kultur En-US, die invariante Kultur und die Kultur tr-TR. In diesem Beispiel ist die Entsprechung, die von jedem Kleinbuchstaben in Großbuchstaben für alle Kulturen, mit Ausnahme von einem Fall identisch. Das Funktoid Kleinbuchstaben "i" Zeichen "I" (U + 0069) konvertiert (U + 0049) in die invariante Kulturen "und" En-US, aber zu i"" (U + 0130) in der Kultur tr-TR.  
  
 [!code-csharp[System.Char.ToUpper#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.toupper/cs/toupper5.cs#2)]
 [!code-vb[System.Char.ToUpper#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.toupper/vb/toupper5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> ist <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.CurrentCulture" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public static char ToUpperInvariant (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToUpperInvariant(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToUpperInvariant(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpperInvariant (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToUpperInvariant(char c);" />
      <MemberSignature Language="F#" Value="static member ToUpperInvariant : char -&gt; char" Usage="System.char.ToUpperInvariant c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Das zu konvertierende Unicode-Zeichen.</param>
        <summary>Konvertiert den Wert eines Unicode-Zeichens in dessen Entsprechung in Großbuchstaben unter Verwendung der Regeln der invarianten Kultur für Groß- und Kleinschreibung.</summary>
        <returns>Die Entsprechung des <paramref name="c" />-Parameters in Großbuchstaben oder der unveränderte Wert von <paramref name="c" />, wenn <paramref name="c" /> bereits aus Großbuchstaben besteht oder kein alphabetischer Wert ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Ihre Anwendung nicht betroffen von der aktuellen Kultur ist und hängt von die Groß-/Kleinschreibung eines Zeichens in einer vorhersagbaren Weise ändern, verwenden Sie die <xref:System.Char.ToUpperInvariant%2A> Methode.  Die <xref:System.Char.ToUpperInvariant%2A> Methode entspricht dem `ToUpper(Char, CultureInfo.InvariantCulture)`.  
  
 Verwendung <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> zum Konvertieren einer Zeichenfolge in Großbuchstaben.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out char result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] char&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.TryParse(System.String,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] char % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.char.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Char" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die ein einzelnes Zeichen enthält, oder <see langword="null" />.</param>
        <param name="result">Enthält nach Beenden der Methode ein Unicode-Zeichen, das bei erfolgreicher Konvertierung dem einzigen Zeichen in <c>s</c> entspricht oder einen nicht definierten Wert, wenn die Konvertierung nicht durchgeführt werden konnte. Die Konvertierung schlägt fehl, wenn der <c>s</c>-Parameter <see langword="null" /> ist oder wenn die Länge von <c>s</c> nicht 1 ist. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Konvertiert den Wert der angegebenen Zeichenfolge in das entsprechende Unicode-Zeichen. Ein Rückgabecode gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="s" />-Parameter erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Char.TryParse%2A> Methode entspricht der <xref:System.Char.Parse%2A> -Methode, mit Ausnahme der <xref:System.Char.TryParse%2A> Methode löst keine Ausnahme aus, wenn die Konvertierung schlägt fehl.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, Überladungen der <xref:System.Char.TryParse%2A> -Methode für verschiedene Basistypen, und die <xref:System.DateTime.TryParseExact%2A> -Methode für die <xref:System.DateTime> Basistyp.  
  
 [!code-cpp[T.TryParse#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.TryParse/CPP/tp.cpp#1)]
 [!code-csharp[T.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.TryParse/CS/tp.cs#1)]
 [!code-vb[T.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.TryParse/VB/tp.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="M:System.Char.ToString" />
      </Docs>
    </Member>
  </Members>
</Type>