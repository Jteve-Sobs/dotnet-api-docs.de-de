<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8ecd4990e6329e1e02719c5524cf7a320f92c6b2" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53230545" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" />
  <TypeSignature Language="F#" Value="type AppDomainSetup = class&#xA;    interface IAppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Assembly-Bindungsinformationen dar, die einer Instanz von <see cref="T:System.AppDomain" /> hinzugefügt werden können.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ändern der Eigenschaften einer <xref:System.AppDomainSetup> Instanz hat keine Auswirkungen auf alle vorhandenen <xref:System.AppDomain>. Nur die Erstellung eines neuen beeinflussen <xref:System.AppDomain>, wenn die <xref:System.AppDomain.CreateDomain%2A> Methode wird aufgerufen, mit der <xref:System.AppDomainSetup> Instanz als Parameter.  
  
 Diese Klasse implementiert die <xref:System.IAppDomainSetup> -Schnittstelle.  
  
> [!CAUTION]
>  Der Standardwert für die <xref:System.AppDomainSetup.DisallowCodeDownload%2A> Eigenschaft ist "false". Diese Einstellung ist für Dienste nicht sicher. Legen Sie diese Eigenschaft auf "true", um Dienste zu vermeiden von teilweise vertrauenswürdigen Code herunterladen,  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482">Vorgehensweise: Konfigurieren einer Anwendungsdomäne</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.AppDomainSetup" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.AppDomainSetup" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : ActivationContext -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationContext" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">Der für eine Anwendungsdomäne zu verwendende Aktivierungskontext.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.AppDomainSetup" />-Klasse mit dem angegebenen Aktivierungskontext für die Verwendung der manifestbasierten Aktivierung einer Anwendungsdomäne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ActivationContext> für angegebene Objekt `activationContext` dient zum Generieren einer <xref:System.Runtime.Hosting.ActivationArguments> -Objekt, das zum Aktivieren einer neuen Anwendungsdomäne erforderlichen Informationen enthält. Dies <xref:System.Runtime.Hosting.ActivationArguments> Objekt kann zugegriffen werden, indem die <xref:System.AppDomainSetup.ActivationArguments%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="activationContext" /> ist <see langword="null" />.</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : System.Runtime.Hosting.ActivationArguments -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationArguments" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" />
      </Parameters>
      <Docs>
        <param name="activationArguments">Ein Objekt, das die für die manifestbasierte Aktivierung einer neuen Anwendungsdomäne erforderlichen Informationen angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.AppDomainSetup" />-Klasse mit den für die Verwendung der manifestbasierten Aktivierung einer Anwendungsdomäne erforderlichen Aktivierungsargumenten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Objekt, das für die angegebene `activationArguments` kann zugegriffen werden, indem die <xref:System.AppDomainSetup.ActivationArguments%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="activationArguments" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ActivationArguments : System.Runtime.Hosting.ActivationArguments with get, set" Usage="System.AppDomainSetup.ActivationArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Daten über die Aktivierung einer Anwendungsdomäne ab oder legt diese fest.</summary>
        <value>Ein Objekt, das Daten über die Aktivierung einer Anwendungsdomäne enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird keine Ausnahme ausgelöst, wenn diese Eigenschaft, um festgelegt wird `null`.  
  
 Die Informationen der <xref:System.Runtime.Hosting.ActivationArguments> Objekt unterstützt die manifestbasierte Aktivierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Eigenschaft ist auf ein <see cref="T:System.Runtime.Hosting.ActivationArguments" />-Objekt festgelegt, dessen Anwendungsidentität nicht der Anwendungsidentität des von der <see cref="P:System.AppDomainSetup.ApplicationTrust" />-Eigenschaft zurückgegebenen <see cref="T:System.Security.Policy.ApplicationTrust" />-Objekts entspricht. Es wird keine Ausnahme ausgelöst, wenn die <see cref="P:System.AppDomainSetup.ApplicationTrust" />-Eigenschaft <see langword="null" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializer : AppDomainInitializer with get, set" Usage="System.AppDomainSetup.AppDomainInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.AppDomainInitializer" />-Delegaten ab oder legt diesen fest, der eine Rückrufmethode darstellt, die beim Initialisieren der Anwendungsdomäne aufgerufen wird.</summary>
        <value>Ein Delegat, der eine Rückrufmethode darstellt, die aufgerufen wird, wenn die Anwendungsdomäne initialisiert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um Informationen an die Rückrufmethode übergeben werden, weisen Sie ein Array von Zeichenfolgen, die die <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> Eigenschaft. Jedes Mal das Array an die Rückrufmethode übergeben eine <xref:System.AppDomain> initialisiert wird.  
  
 Die Rückrufmethode wird im Kontext der neu erstellte Anwendungsdomäne ausgeführt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine untergeordnete Anwendungsdomäne, die mit dem Namen `ChildDomain`mithilfe einer <xref:System.AppDomainSetup> -Objekt und Beweis, aus der Standardanwendungsdomäne. Die <xref:System.AppDomainSetup.AppDomainInitializer%2A> Eigenschaft festgelegt ist, an die Rückrufmethode `AppDomainInit`, die aufgerufen wird, wenn die untergeordnete Domäne initialisiert wird. Die Argumente für die Callback-Methode befinden sich in einem Array von Zeichenfolgen, die zugewiesen wird die <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> Eigenschaft. Wenn die untergeordnete Domäne erstellt wird, gibt die Callback-Methode einfach die Zeichenfolgen an.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializerArguments : string[] with get, set" Usage="System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Argumente zurück, die an die durch den <see cref="T:System.AppDomainInitializer" />-Delegaten dargestellte Rückrufmethode übergeben wurden, oder legt diese fest. Die Rückrufmethode wird beim Initialisieren der Anwendungsdomäne aufgerufen.</summary>
        <value>Ein Array von Zeichenfolgen, das an die durch den <see cref="T:System.AppDomainInitializer" />-Delegaten dargestellte Rückrufmethode übergeben wird, wenn die Rückrufmethode bei der <see cref="T:System.AppDomain" />-Initialisierung aufgerufen wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.AppDomainSetup.AppDomainInitializer%2A> Eigenschaft an eine Rückrufmethode, die aufgerufen wird, während der <xref:System.AppDomain> Initialisierung. Wenn die <xref:System.AppDomainSetup.AppDomainInitializer%2A> Eigenschaft nicht festgelegt ist, die dieser Eigenschaft zugewiesene Array wird nicht verwendet.  
  
 Die Rückrufmethode wird im Kontext der neu erstellte Anwendungsdomäne ausgeführt.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine untergeordnete Anwendungsdomäne, die mit dem Namen `ChildDomain`mithilfe einer <xref:System.AppDomainSetup> -Objekt und Beweis, aus der Standardanwendungsdomäne. Die <xref:System.AppDomainSetup.AppDomainInitializer%2A> Eigenschaft festgelegt ist, an die Rückrufmethode `AppDomainInit`, die aufgerufen wird, wenn die untergeordnete Domäne initialisiert wird. Die Argumente für die Callback-Methode befinden sich in einem Array von Zeichenfolgen, die zugewiesen wird die <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> Eigenschaft. Wenn die untergeordnete Domäne erstellt wird, gibt die Callback-Methode einfach die Zeichenfolgen an.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerAssembly : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Anzeigenamen der Assembly ab, die den Typ des Anwendungsdomänen-Managers für mit diesem <see cref="T:System.AppDomainSetup" />-Objekt erstellte Anwendungsdomänen bereitstellt, oder legt diesen fest.</summary>
        <value>Der Anzeigename der Assembly, die den <see cref="T:System.Type" /> des Anwendungsdomänen-Managers bereitstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um den Typ des Anwendungsdomänen-Managers anzugeben, legen Sie diese Eigenschaft und die <xref:System.AppDomainSetup.AppDomainManagerType%2A> Eigenschaft. Wenn eine dieser Eigenschaften nicht festgelegt ist, wird das andere ignoriert.  
  
 Wenn kein Typ angegeben ist, wird die Anwendungsdomänen-Manager des gleichen Typs wie die übergeordnete Anwendung erstellt (d. h. die Anwendungsdomäne aus dem die <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> Methode wird aufgerufen,).  
  
 Wenn die Anwendungsdomäne geladen wird, <xref:System.TypeLoadException> wird ausgelöst, wenn die Assembly nicht vorhanden ist oder wenn die Assembly nicht mit den vom angegebenen Typ enthält die <xref:System.AppDomainSetup.AppDomainManagerType%2A> Eigenschaft. <xref:System.IO.FileLoadException> wird ausgelöst, wenn die Assembly gefunden wird, aber die Versionsinformationen stimmt nicht überein.  
  
 Verwenden Sie zum Festlegen der Anwendungsdomänen-Manager für die Standardanwendungsdomäne die [ \<AppDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) und [ \<AppDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) Elemente in der [ \<Runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) Abschnitt der Konfigurationsdatei der Anwendung, oder verwenden die Umgebungsvariablen, die in beschriebenen <xref:System.AppDomainManager>.  
  
 Dieses Feature erfordert die Anwendung volle Vertrauenswürdigkeit. (Z. B. hat eine Anwendung ausgeführt wird, auf dem Desktop volle Vertrauenswürdigkeit.) Wenn die Anwendung nicht mit voller Vertrauenswürdigkeit, verfügt eine <xref:System.TypeLoadException> ausgelöst.  
  
 Das Format des Anzeigenamens der Assembly, angegeben durch die <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerType : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vollständigen Namen des Typs ab, der den Anwendungsdomänen-Manager für mit diesem <see cref="T:System.AppDomainSetup" />-Objekt erstellte Anwendungsdomänen bereitstellt, oder legt diesen fest.</summary>
        <value>Der vollständige Name des Typs, einschließlich des Namespaces.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um den Typ des Anwendungsdomänen-Managers anzugeben, legen Sie diese Eigenschaft und die <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> Eigenschaft. Wenn eine dieser Eigenschaften nicht festgelegt ist, wird das andere ignoriert.  
  
 Wenn kein Typ angegeben ist, wird die Anwendungsdomänen-Manager des gleichen Typs wie die übergeordnete Anwendung erstellt (d. h. die Anwendungsdomäne aus dem die <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> Methode wird aufgerufen,).  
  
 Wenn die Anwendungsdomäne geladen wird, <xref:System.TypeLoadException> wird ausgelöst, wenn die Assembly, wird angegeben die <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> Eigenschaft enthält nicht den Typ, der von dieser Eigenschaft angegeben.  
  
 Verwenden Sie zum Festlegen der Anwendungsdomänen-Manager für die Standardanwendungsdomäne die [ \<AppDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) und [ \<AppDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) Elemente in der [ \<Runtime >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) Abschnitt der Konfigurationsdatei der Anwendung, oder verwenden die Umgebungsvariablen, die in beschriebenen <xref:System.AppDomainManager>.  
  
 Dieses Feature erfordert die Anwendung volle Vertrauenswürdigkeit. (Z. B. hat eine Anwendung ausgeführt wird, auf dem Desktop volle Vertrauenswürdigkeit.) Wenn die Anwendung nicht mit voller Vertrauenswürdigkeit, verfügt eine <xref:System.TypeLoadException> ausgelöst.  
  
 Das Format des vollständigen Namens eines Typs, angegeben durch die <xref:System.Type.FullName%2A?displayProperty=nameWithType> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string with get, set" Usage="System.AppDomainSetup.ApplicationBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Verzeichnisses ab, das die Anwendung enthält, oder legt diesen fest.</summary>
        <value>Der Name des Basisverzeichnisses der Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Basisverzeichnis der Anwendung ist, beginnt der Assembly-Manager Suchen nach Assemblys.  
  
 Die <xref:System.AppDomainSetup.ApplicationBase%2A> Eigenschaft kann beeinflussen, welche Berechtigungen für eine Anwendungsdomäne gewährt wurden. Beispielsweise empfängt eine Anwendungsdomäne, die normalerweise aus dem lokalen Computer stammen volle Vertrauenswürdigkeit, die basierend auf den Speicherort des Ursprungs. Jedoch wenn die <xref:System.AppDomainSetup.ApplicationBase%2A> -Eigenschaft dieses <xref:System.AppDomain> festgelegt ist, auf den vollständigen Namen eines Verzeichnisses Intranet die <xref:System.AppDomainSetup.ApplicationBase%2A> Einstellung schränkt die Berechtigungen für die Anwendungsdomäne ein LocalIntranet gewährt, obwohl die Anwendungsdomäne Tatsächlich können aus dem lokalen Computer.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.AppDomainSetup.ApplicationBase%2A> Eigenschaft zum Festlegen der Position, an dem das Assemblyladeprogramm beginnt Suchen nach Assemblys in eine neue Anwendungsdomäne geladen.  
  
> [!NOTE]
>  Sie müssen sicherstellen, dass der angegebene Ordner vorhanden ist.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.AppDomainSetup.ApplicationName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der Anwendung ab oder legt diesen fest.</summary>
        <value>Der Name der Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel veranschaulicht die legen Sie die <xref:System.AppDomainSetup.ApplicationName%2A> Eigenschaft, wenn Sie eine neue Anwendungsdomäne erstellen.  
  
 Im Beispiel wird eine neue Anwendungsdomäne erstellt, und ruft dann die <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType> Methode, um die Beispielassembly in der neuen Anwendungsdomäne laden, und erstellen Sie eine Instanz von der `Worker` Klasse. Die `Worker` -Klasse erbt <xref:System.MarshalByRefObject>, sodass im Beispiel wird die Verwendung des Proxys, die vom kann <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> zum Aufrufen der `TestLoad` Methode.  
  
 Die `TestLoad` Methode lädt eine Assembly, die Sie angeben. Sie müssen einen gültigen, vollqualifizierten Assemblynamen angeben, oder kommentieren Sie die <xref:System.Reflection.Assembly.Load%28System.String%29> Methode. Die `TestLoad` Methode listet die Assemblys, die in der neuen Anwendungsdomäne geladen werden, dass die angegebene Assembly und die Beispielassembly geladen werden.  
  
 Im Beispiel wird die <xref:System.LoaderOptimizationAttribute> Attribut, um das Assemblyladeprogramm anzuweisen, wie die Anwendung Code über Anwendungsdomänen hinweg freigibt.  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust with get, set" Usage="System.AppDomainSetup.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, das Sicherheits- und Vertrauenswürdigkeitsinformationen enthält, oder legt dieses fest.</summary>
        <value>Ein Objekt, das Sicherheits- und Vertrauenswürdigkeitsinformationen enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist `null` bei der <xref:System.AppDomainSetup> erstellt wird. Nachdem geändert, kann es auf einen null-Verweis nicht zurückgesetzt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Eigenschaft ist auf ein <see cref="T:System.Security.Policy.ApplicationTrust" />-Objekt festgelegt, dessen Anwendungsidentität nicht der Anwendungsidentität des von der <see cref="P:System.AppDomainSetup.ActivationArguments" />-Eigenschaft zurückgegebenen <see cref="T:System.Runtime.Hosting.ActivationArguments" />-Objekts entspricht. Es wird keine Ausnahme ausgelöst, wenn die <see cref="P:System.AppDomainSetup.ActivationArguments" />-Eigenschaft <see langword="null" /> ist.</exception>
        <exception cref="T:System.ArgumentNullException">Die Eigenschaft ist auf <see langword="null" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePath : string with get, set" Usage="System.AppDomainSetup.CachePath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen eines anwendungsspezifischen Bereichs ab, in dem Dateien gespiegelt werden, oder legt diesen fest.</summary>
        <value>Der vollqualifizierte Name des Verzeichnispfads und der Datei, in der Dateien gespiegelt werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Reihenfolge, damit diese Eigenschaft wirksam wird, die <xref:System.AppDomainSetup.ApplicationName%2A> Eigenschaft muss ebenfalls festgelegt werden. Wenn die <xref:System.AppDomainSetup.ApplicationName%2A> Eigenschaft nicht festgelegt ist, die <xref:System.AppDomainSetup.CachePath%2A> Eigenschaft wird ignoriert, und des Speicherortes der Schattenkopie-Cache wird standardmäßig auf den Cache heruntergeladen.  
  
 Weitere Informationen zum Erstellen von Schattenkopien, finden Sie unter [Schattenkopien von Assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Erstellen von Schattenkopien von Assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationFile : string with get, set" Usage="System.AppDomainSetup.ConfigurationFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen einer Konfigurationsdatei für eine Anwendungsdomäne ab oder legt diesen fest.</summary>
        <value>Der Name der Konfigurationsdatei.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Konfigurationsdatei wird beschrieben, die Suchregeln und Konfigurationsdaten für die Anwendungsdomäne. Der Host, der die Anwendungsdomäne erstellt ist verantwortlich für diese Daten bereitstellen, da die sinnvolle Werte von Fall zu Fall variieren.  
  
 Beispielsweise ist die Konfigurationsdaten für ASP.NET-Anwendungen für jede Anwendung, Website und -Computer gespeichert, während die Konfigurationsdaten für eine ausführbare Datei für jede Anwendung, Benutzer und Computer gespeichert ist. Nur der Host weiß die Einzelheiten der Konfigurationsdaten für eine bestimmte Situation.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">Schema für Laufzeiteinstellungen</related>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowApplicationBaseProbing : bool with get, set" Usage="System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Anwendungsbasispfad und der private Binärpfad beim Suchen nach zu ladenden Assemblys durchsucht wird.</summary>
        <value><see langword="true" />, wenn die Suche nicht zulässig ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> Eigenschaft `true`, den Wert des der <xref:System.AppDomainSetup.ApplicationBase%2A> Eigenschaft wird ignoriert. D. h. keine Assemblys gesucht in den Verzeichnissen, die gemäß der <xref:System.AppDomainSetup.ApplicationBase%2A> Eigenschaft. Darüber hinaus werden die Werte von der <xref:System.AppDomainSetup.PrivateBinPath%2A> Eigenschaft und die <xref:System.AppDomainSetup.PrivateBinPathProbe%2A> Eigenschaft ignoriert werden. Keine Assemblys sind auf die zugegriffen wurde in den Verzeichnissen, die gemäß der <xref:System.AppDomainSetup.PrivateBinPath%2A> Eigenschaft.  
  
 Die <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> Eigenschaft bietet eine zusätzliche Sicherheitsebene des Steuerelements über den Ladevorgang. In der normalen Reihenfolge geladen, wird die Anwendungsbasis vor sind die <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> Ereignis wird ausgelöst. Allerdings müssen einige Anwendungen beim Laden von Assemblys aus einer OLE-Verbunddatei innerhalb eines Dokuments oder von einem spezifischen bekannten Ort, die im globalen Assemblycache weder in den Verzeichnissen, die gemäß der <xref:System.AppDomainSetup.ApplicationBase%2A> und <xref:System.AppDomainSetup.PrivateBinPath%2A> Eigenschaften. Solche Anwendungen können die <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> Eigenschaft um Standardtest verursachte Verzögerung zu vermeiden, und klicken Sie zum Vermeiden des Ladens von Kopien der Assembly erforderlich, die in der Prüfpfade gefunden werden kann.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowBindingRedirects : bool with get, set" Usage="System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Assembly-Bindungsumleitung in einer Anwendungsdomäne zulässig ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Umleitung von Assemblys nicht zulässig ist, <see langword="false" />, wenn sie zulässig ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomainSetup.DisallowBindingRedirects%2A> Eigenschaft von Services und Server-Anwendungen, in dem kein bindungsumleitung einer Assembly Teil des Szenarios für die Anwendung verwendet werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowCodeDownload : bool with get, set" Usage="System.AppDomainSetup.DisallowCodeDownload" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Assembly-Downloads über HTTP für eine Anwendungsdomäne zulässig sind, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der HTTP-Download von Assemblys nicht zulässig ist, <see langword="false" />, wenn er zulässig ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomainSetup.DisallowCodeDownload%2A> Eigenschaft über Dienste und serveranwendungen, in dem kein Herunterladen Code über ein Intranet oder Internet Teil des Szenarios für die Anwendung verwendet werden soll.  
  
> [!CAUTION]
>  Der Standardwert für die <xref:System.AppDomainSetup.DisallowCodeDownload%2A> Eigenschaft `false`. Diese Einstellung ist für Dienste nicht sicher. Legen Sie diese Eigenschaft auf, um Dienste zu vermeiden von teilweise vertrauenswürdigen Code herunterladen, `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowPublisherPolicy : bool with get, set" Usage="System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der [&lt;publisherPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md)-Abschnitt der Konfigurationsdatei auf eine Anwendungsdomäne angewendet wird, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn der <see langword="&lt;publisherPolicy&gt;" />-Abschnitt der Konfigurationsdatei für eine Anwendungsdomäne ignoriert wird, <see langword="false" />, wenn die deklarierte Herausgeberrichtlinie übernommen wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A> Eigenschaft gilt speziell für eine Webanwendung, die lokal geladen wird. Verwenden Sie diese Eigenschaft, um zu verhindern, dass einen böswilligen Versuch eine unsafe-Webanwendung im abgesicherten Modus ausgeführt.  
  
 Weitere Informationen zum Umgehen der Herausgeberrichtlinie, finden Sie unter den [Umleiten von Assemblyversionen](~/docs/framework/configure-apps/redirect-assembly-versions.md) Thema. Weitere Informationen zum sicheren Modus finden Sie im Abschnitt "Untersuchen der Konfigurationsdateien" die [How the Runtime Locates Assemblies](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md) Thema.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DynamicBase : string with get, set" Usage="System.AppDomainSetup.DynamicBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Basisverzeichnis ab oder legt dieses fest, in dem sich das Verzeichnis für dynamisch generierte Dateien befindet.</summary>
        <value>Das Verzeichnis, in dem sich das <see cref="P:System.AppDomain.DynamicDirectory" /> befindet.  

 <block subset="none" type="note"><para>  
 Der Rückgabewert dieser Eigenschaft ist anders als der Wert, der zugewiesen wurde.
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 Verwenden Sie diese Eigenschaft, um das Basisverzeichnis festgelegt, wo wird das dynamische Verzeichnis für die neue Anwendungsdomäne gespeichert werden. Wenn Code in die neue Anwendungsdomäne geladen wird, eine Assembly, Assembly-Auflösung sucht zuerst in der Prüfpfade. Wenn sie die Assembly nicht gefunden wird, sucht Sie im dynamischen Verzeichnis, der zurückgegeben wird, durch die <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> Eigenschaft. Dynamische Assemblys, die geladen und von der neuen Anwendungsdomäne ausgeführt werden, können es platziert werden.  
  
 Wenn Sie einen Pfad zum Zuweisen der <xref:System.AppDomainSetup.DynamicBase%2A> -Eigenschaft, ein zusätzliches Unterverzeichnis hinzugefügt wird; der Namen des diesem Unterverzeichnis wird der Hashcode des Werts zugewiesen die <xref:System.AppDomainSetup.ApplicationName%2A> Eigenschaft. Daher unterscheidet sich das Basisverzeichnis auf nachfolgend von dieser Eigenschaft zurückgegebene immer von der zugewiesene Wert.  
  
> [!IMPORTANT]
>  Diese Eigenschaft einen Wert zuweisen, wird kein Verzeichnisse erstellt. Die Verzeichnisse müssen erstellt oder überprüft der Code, der sie verwendet werden.  
  
 Das dynamische Verzeichnis ist ein Unterverzeichnis von <xref:System.AppDomainSetup.DynamicBase%2A>. Der einfache Name ist der Rückgabewert von der <xref:System.AppDomainSetup.ApplicationName%2A> -Eigenschaft, sodass dessen Format *Originalpfad*\\*Hashcode*\\*Anwendungsname*.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.AppDomainSetup.DynamicBase%2A> Eigenschaft, um den Pfad eine Anwendungsdomäne festgelegt sondiert beim Laden von dynamischen Assemblys.  
  
 Das Beispiel erstellt eine <xref:System.AppDomainSetup> -Objekt und legt seine <xref:System.AppDomainSetup.ApplicationName%2A> Eigenschaft "Example" und die zugehörige <xref:System.AppDomainSetup.DynamicBase%2A> Eigenschaft auf "C:\DynamicAssemblyDir". Das Beispiel zeigt, klicken Sie dann die <xref:System.AppDomainSetup.DynamicBase%2A> -Eigenschaft, um anzugeben, dass es sich bei der Hashcode, der den Namen der Anwendung als Unterverzeichnis des Pfades angefügt wurde, der ursprünglich zugeordnet wurde.  
  
> [!NOTE]
>  Das Basisverzeichnis in diesem Beispiel soll werden außerhalb des Suchpfads für die exemplarische Anwendung befindet. Achten Sie darauf, dass Sie das Beispiel in einem anderen Speicherort zu kompilieren. Löschen Sie das Basisverzeichnis und allen seinen Unterverzeichnisse jedes Mal, wenn Sie das Beispiel ausführen.  
  
 Das Beispiel erstellt eine neue Anwendungsdomäne mit der <xref:System.AppDomainSetup> Objekt. Das Beispiel erstellt das dynamische Verzeichnis klicken Sie dann, wenn es nicht bereits vorhanden ist. Obwohl das Beispiel der Anwendungsdomäne verwendet <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> Eigenschaft, um den Namen der dynamischen Verzeichnis abzurufen. Es konnte das Verzeichnis ganz einfach im Voraus erstellen, durch die Verkettung des ursprünglichen Pfads, der den Hashcode für den Anwendungsnamen, und die Name der Anwendung.  
  
 Das Beispiel enthält eine `GenerateDynamicAssembly` -Methode, die eine Assembly Namens gibt `DynamicHelloWorld.dll` und speichert sie in der neuen Anwendungsdomäne dynamische-Verzeichnis. Die dynamische Assembly enthält einen Typ, `HelloWorld`, die eine statische Methode hat (`Shared` Methode in Visual Basic) mit dem Namen `HelloFromAD`. Das Aufrufen dieser Methode zeigt den Namen der Anwendungsdomäne.  
  
 Die `Example` Klasse leitet sich von <xref:System.MarshalByRefObject>, damit das Beispiel eine Instanz der Klasse in der neuen Anwendungsdomäne und rufen erstellen kann der `Test` Methode. Die `Test` Methode lädt die dynamische Assembly anhand des Anzeigenamens und ruft die statische `HelloFromAD` Methode.  
  
 Sie können anzeigen, dass das dynamische Verzeichnis nach der Prüfpfade durchsucht wird, durch das Schreiben von Code für eine Assembly mit dem Namen `DynamicHelloWorld.dll` und im gleichen Verzeichnis wie in diesem Beispiel kompilieren. Die Assembly muss eine Klasse namens verfügen `HelloWorld` mit einer statischen Methode, die mit dem Namen `HelloFromAD`. Diese Methode muss nicht die gleiche Funktionalität wie das im Beispiel; Sie können einfach eine Zeichenfolge in der Konsole anzeigen. Die Assembly benötigen auch eine <xref:System.Reflection.AssemblyVersionAttribute> -Attribut, das die Version auf 1.0.0.0 festlegt. Wenn Sie das Beispiel ausführen, befindet die Assembly, die Sie im aktuellen Verzeichnis kompiliert, bevor das dynamische Verzeichnis durchsucht wird.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Diese Eigenschaft kann nicht festgelegt werden, da der Anwendungsname in der Anwendungsdomäne <see langword="null" /> lautet.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberSignature Language="F#" Value="member this.GetConfigurationBytes : unit -&gt; byte[]" Usage="appDomainSetup.GetConfigurationBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die XML-Konfigurationsinformationen zurück, die von der <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />-Methode festgelegt werden. Hierdurch werden die XML-Konfigurationsinformationen der Anwendung überschrieben.</summary>
        <returns>Ein Array mit den XML-Konfigurationsinformationen, die von der <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />-Methode festgelegt wurden, oder <see langword="null" />, wenn die <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />-Methode nicht aufgerufen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Methode bietet eine Möglichkeit, die die Konfigurationsinformationen in einer Anwendung außer Kraft setzen, die eine neue Anwendungsdomäne erstellt. Die Konfigurationsinformationen für die Datei in `value` überschreibt die Konfigurationsinformationen für die Datei für die Anwendung. Wenn die Example.exe-Anwendung eine neue Anwendungsdomäne erstellt, können sie z. B. die Konfigurationsinformationen, die ursprünglich abgerufene Beispiel.exe.config Datei überschreiben.  
  
> [!IMPORTANT]
>  Einige Consumer der Informationen zur Konfigurationsdatei verwenden Sie die von gespeicherte Informationen nicht die <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Methode. Die Laufzeit erzwingt dies nicht. Verwenden, um sicherzustellen, dass alle Informationen der Datei, in einer neuen Anwendungsdomäne überschrieben wird die <xref:System.AppDomainSetup.ConfigurationFile%2A> Eigenschaft, um eine Konfigurationsdatei anzugeben. Die <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Methode beeinflusst die Assemblybindung.  
  
 Die XML-Code in `value` ist identisch mit den XML-Code in einer normalen Konfiguration-Datei mit dem Unterschied, dass sie als gespeichert wird eine <xref:System.Byte> Array.  
  
 Um die der Konfigurationsbytes für eine Anwendungsdomäne zuzugreifen, verwenden die <xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType> -Eigenschaft zum Abrufen der <xref:System.AppDomainSetup> Objekt, für die Anwendungsdomäne der <xref:System.AppDomainSetup.GetConfigurationBytes%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LicenseFile : string with get, set" Usage="System.AppDomainSetup.LicenseFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position der dieser Domäne zugeordneten Lizenzdatei ab oder legt diese fest.</summary>
        <value>Der Name und Speicherort der Lizenzdatei.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberSignature Language="F#" Value="member this.LoaderOptimization : LoaderOptimization with get, set" Usage="System.AppDomainSetup.LoaderOptimization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Optimierungsrichtlinie zum Laden ausführbarer Dateien an.</summary>
        <value>Eine Enumerationskonstante, die mit dem <see cref="T:System.LoaderOptimizationAttribute" /> verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine dynamische Assembly erstellt und speichert es in den Datenträger und verwendet dann die <xref:System.AppDomainSetup.LoaderOptimization%2A> die Optimierungsrichtlinie zum Laden der Assembly in eine Anwendungsdomäne festzulegende Eigenschaft.  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PartialTrustVisibleAssemblies : string[] with get, set" Usage="System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Liste von mit dem <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />-Flag markierten Assemblys ab, die für teilweise vertrauenswürdigen Code, der in einer Sandbox-Anwendungsdomäne ausgeführt wird, sichtbar gemacht werden, oder legt diese fest.</summary>
        <value>Ein Array partieller Assemblynamen, wobei jeder partielle Name aus dem einfachen Assemblynamen und dem öffentlichen Schlüssel besteht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ab der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Security.AllowPartiallyTrustedCallersAttribute> -Attribut (APTCA) stehen zur Verfügung, bedingte Festlegen der <xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A> Eigenschaft <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>. Eine APTCA-Assembly, die mit markierten <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault> kann nicht von teilweise vertrauenswürdigem Code verwendet werden, es sei denn, dadurch die hostanwendung.  
  
 Der Host des eine Sandbox-Anwendungsdomäne kann es sich um Code in der Anwendungsdomäne für die Verwendung von Assemblys mit bedingten APTCA-Attribute durch Erstellen eines Arrays, das den einfachen Namen und den öffentlichen Schlüssel der einzelnen Assembly enthält, und dieser Eigenschaft das Array zuweisen. Ein Element des Arrays kann beispielsweise wie folgt aussehen: "MyAssembly, öffentlicher Schlüssel = 0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad 0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9 ".  
  
> [!IMPORTANT]
>  Wenn Sie eine Unterklasse von verwenden <xref:System.AppDomainManager>, und die Assembly, die sie definiert, hängt von Assemblys, die mit dem bedingten APTCA-Attribut markiert sind, Sie müssen die Assemblys einschließen, in der Liste, die Sie zum Übergeben der <xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A> Eigenschaft der <xref:System.AppDomainSetup>Sie verwenden, um die Anwendungsdomänen zu erstellen. Andernfalls werden die Assemblys, die mit dem bedingten APTCA-Attribut markiert sind deaktiviert.  
  
> [!NOTE]
>  Wenn Sie eine Anwendung debuggen, die in einer Sandkastenanwendungsdomäne ausgeführt wird einige <xref:System.Security.SecurityException> Nachrichten können irreführend sein. Beispielsweise kann eine Nachricht angeben, dass der vollständig vertrauenswürdigen Assemblys Berechtigungen nur begrenzten hat, wenn die tatsächliche Ursache des Problems ist, dass eine sicherheitsforderung, die den Berechtigungssatz der Sandbox-Anwendungsdomäne überschreitet, die an der Begrenzung des weitergegeben wurde die Sandbox-Anwendungsdomäne und Fehler.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPath : string with get, set" Usage="System.AppDomainSetup.PrivateBinPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Liste der Verzeichnisse unterhalb des Anwendungsbasisverzeichnisses ab, in denen nach privaten Assemblys gesucht wird, oder legt diese fest.</summary>
        <value>Eine durch Semikolons getrennte Liste von Verzeichnisnamen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Private Assemblys werden in der gleichen Verzeichnisstruktur wie die Anwendung bereitgestellt. Wenn die Verzeichnisse für angegeben <xref:System.AppDomainSetup.PrivateBinPath%2A> sind nicht unter <xref:System.AppDomainSetup.ApplicationBase%2A>, werden sie ignoriert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPathProbe : string with get, set" Usage="System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Zeichenfolgenwert ab, der <see cref="P:System.AppDomainSetup.ApplicationBase" /> in den Suchpfad für die Anwendung aufnimmt oder ausschließt und nur <see cref="P:System.AppDomainSetup.PrivateBinPath" /> durchsucht.</summary>
        <value>Ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic) zur Einbeziehung des Anwendungsbasispfads bei der Suche nach Assemblys; jeder Zeichenfolgenwert ungleich NULL zum Ausschließen des Pfads. Der Standardwert ist <see langword="null" />sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft auf einen beliebigen Zeichenfolgenwert ungleich Null, einschließlich <xref:System.String.Empty?displayProperty=nameWithType> (""), um den Pfad des Anwendungsverzeichnisses – d. h. ausschließen <xref:System.AppDomainSetup.ApplicationBase%2A> : Klicken Sie in den Suchpfad für die Anwendung und Suche nach Assemblys nur in <xref:System.AppDomainSetup.PrivateBinPath%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SandboxInterop : bool with get, set" Usage="System.AppDomainSetup.SandboxInterop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Schnittstellenzwischenspeicherung für Interop-Aufrufe in der Anwendungsdomäne deaktiviert ist, sodass <c>QueryInterface</c> für jeden Aufruf ausgeführt wird, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn die Schnittstellenzwischenspeicherung für Interop-Aufrufe in Anwendungsdomänen deaktiviert ist, die mit dem aktuellen <see cref="T:System.AppDomainSetup" />-Objekt erstellt wurden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deaktivieren die schnittstellenzwischenspeicherung hat einen erheblichen Einfluss auf die Leistung von Interop-aufrufen.  
  
 Dieser Member wird eingeführt, der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberSignature Language="F#" Value="member this.SetCompatibilitySwitches : seq&lt;string&gt; -&gt; unit" Usage="appDomainSetup.SetCompatibilitySwitches switches" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="switches">Ein aufzählbarer Satz von Zeichenfolgenwerten, die Kompatibilitätsschalter angeben, oder <see langword="null" />, um die vorhandenen Kompatibilitätsschalter zu löschen.</param>
        <summary>Legt die angegebenen Schalter fest und macht die Anwendungsdomäne für die angegebenen Probleme mit früheren Versionen von .NET Framework kompatibel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hauptversionen von .NET Framework führen gelegentlich Änderungen aus der vorherigen Version. Z. B. die [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] führt eine kleine Anzahl von Änderungen aus der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]. Verwenden der <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A> Methode, um anzugeben, dass eine oder mehrere dieser Änderungen muss ein Rollback für die Anwendungsdomäne, um das Verhalten mit der früheren Version von .NET Framework kompatibel zu machen.  
  
 Bei jedem Aufruf dieser Methode ersetzt die vorhandenen Switcheinstellungen. Um die Einstellungen zu löschen, geben Sie `null` für die `switches` Parameter.  
  
 Der Satz von Zeichenfolgenwerten, die Sie, für die angeben `switches` ein einfache Zeichenfolgen-Array, kann sein, da Arrays implementiert die <xref:System.Collections.IEnumerable> Schnittstelle.  
  
 Die folgende Tabelle enthält Beispiele für Kompatibilitätsschalter, die festgelegt werden können, um das Verhalten früherer Versionen von .NET Framework wiederherzustellen.  
  
|Schalter|Bedeutung|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Codezugriffssicherheit (CAS) für die [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] in dieser Anwendungsdomäne aktiviert ist. Finden Sie unter [ &lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Standardwerte für die zum Sortieren von Zeichenfolgen die [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] in dieser Anwendungsdomäne aktiviert sind. Erfolgreiches Wiederherstellen sortieren erfordert auch die sort00001000.dll-dynamic Link Library auf dem lokalen System verfügbar sein. Finden Sie unter [ &lt;CompatSortNLSVersion&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Standardwerte für die zum Sortieren von Zeichenfolgen die [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] und Unicode 5.0 in dieser Anwendungsdomäne aktiviert sind. Erfolgreiches Wiederherstellen sortieren erfordert auch die sort00060101.dll dynamic Link Library, auf dem lokalen System verfügbar sein.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> Formatieren von Verhalten für die [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] in dieser Anwendungsdomäne aktiviert ist. Finden Sie unter [ &lt;TimeSpan_LegacyFormatMode&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) und im Abschnitt "Wiederherstellen von Legacy TimeSpan Formatting" die <xref:System.TimeSpan> Thema.|  
|"UseRandomizedStringHashAlgorithm"|Die Common Language Runtime berechnet Hashcodes für Zeichenfolgen auf einer pro Anwendungsdomäne, anstatt einen einzelnen Hashalgorithmus, der einen konsistenten Hashcode über Anwendungsdomänen hinweg erzeugt. Finden Sie unter [ &lt;UseRandomizedStringHashAlgorithm&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/07132b9c-4a72-4710-99d7-e702405e02d4">&lt;NetFx40_LegacySecurityPolicy&gt; Element</related>
        <related type="Article" href="https://msdn.microsoft.com/library/782cc82e-83f7-404a-80b7-6d3061a8b6e3">&lt;CompatSortNLSVersion&gt; Element</related>
        <related type="Article" href="https://msdn.microsoft.com/library/865e7207-d050-4442-b574-57ea29d5e2d6">&lt;TimeSpan_LegacyFormatMode&gt; Element</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; Element</related>
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetConfigurationBytes : byte[] -&gt; unit" Usage="appDomainSetup.SetConfigurationBytes value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Ein Array, das die XML-Konfigurationsinformationen enthält, die für die Anwendungsdomäne verwendet werden sollen.</param>
        <summary>Stellt XML-Konfigurationsinformationen für die Anwendungsdomäne bereit und ersetzt die XML-Konfigurationsinformationen der Anwendung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Methode bietet eine Möglichkeit, eine Anwendung die Konfigurationsinformationen zu ersetzen, die eine neue Anwendungsdomäne erstellt. Die Konfigurationsinformationen für die Datei in `value` ersetzt die Konfigurationsinformationen für die Datei für die Anwendung. Wenn die Example.exe-Anwendung eine neue Anwendungsdomäne erstellt, können sie z. B. die Konfigurationsinformationen, die ursprünglich aus der Konfigurationsdatei Beispiel.exe.config abgerufene ersetzen.  
  
> [!IMPORTANT]
>  Einige Consumer der Informationen zur Konfigurationsdatei verwenden Sie die von gespeicherte Informationen nicht die <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Methode. Die Laufzeit erzwingt dies nicht. Um sicherzustellen, dass alle Informationen der Datei in eine neue Anwendungsdomäne ersetzt wird, verwenden die <xref:System.AppDomainSetup.ConfigurationFile%2A> Eigenschaft, um eine Konfigurationsdatei anzugeben. Die <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Methode beeinflusst die Assemblybindung.  
  
 Die XML-Code in `value` ist identisch mit den XML-Code in einer normalen Konfiguration-Datei mit dem Unterschied, dass sie als gespeichert wird eine <xref:System.Byte> Array.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">Schema für Laufzeiteinstellungen</related>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="F#" Value="member this.SetNativeFunction : string * int * nativeint -&gt; unit" Usage="appDomainSetup.SetNativeFunction (functionName, functionVersion, functionPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="functionVersion" Type="System.Int32" />
        <Parameter Name="functionPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="functionName">Der Name der zu überschreibenden Funktion zum Zeichenfolgenvergleich.</param>
        <param name="functionVersion">Die Funktionsversion. Der Wert von [!INCLUDE[net_v45](~/includes/net-v45-md.md)] muss 1 oder größer sein.</param>
        <param name="functionPointer">Ein Zeiger auf die Funktion, die <paramref name="functionName" /> überschreibt.</param>
        <summary>Stellt die Common Language Runtime mit einer anderen Implementierung einer Zeichenfolgenvergleichsfunktion bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgenden Zeichenfolgenvergleich und-Sortierung Methoden können überschrieben werden, indem die <xref:System.AppDomainSetup.SetNativeFunction%2A> Methode:  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 Weitere Informationen zu diesen Funktionen finden Sie unter [National Language Support-Funktionen](https://go.microsoft.com/fwlink/?LinkId=228134).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="functionName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="functionVersion" /> ist ungleich 1 oder größer.  
  
- oder -  
 <paramref name="functionPointer" /> ist <see cref="F:System.IntPtr.Zero" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyDirectories : string with get, set" Usage="System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Namen der Verzeichnisse mit zu spiegelnden Assemblys ab oder legt diese fest.</summary>
        <value>Eine durch Semikolons getrennte Liste von Verzeichnisnamen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Erstellen von Schattenkopien aktiviert ist, werden die Standardeinstellung Schattenkopie, die alle Assemblys, die bei der Suche gefunden. in den Verzeichnissen, also gemäß den <xref:System.AppDomainSetup.PrivateBinPath%2A> und <xref:System.AppDomainSetup.ApplicationBase%2A> Eigenschaften. Die <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> Eigenschaft beschränkt die Schattenkopie, auf die Assemblys in den Verzeichnissen, die anhand des <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>.  
  
 Wenn Sie eine Zeichenfolge, die keine Zuweisen der <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> -Eigenschaft, oder wenn Sie diese Eigenschaft, um festlegen `null`, alle Assemblys in den Verzeichnissen, die gemäß der <xref:System.AppDomainSetup.ApplicationBase%2A> und <xref:System.AppDomainSetup.PrivateBinPath%2A> Eigenschaften gespiegelt werden.  
  
> [!IMPORTANT]
>  Verzeichnispfade dürfen keine Semikolons enthalten, da das Semikolon das Trennzeichen ist. Es gibt kein Escapezeichen für Semikolons.  
  
 Beim Erstellen von Schattenkopien aktiviert ist, werden die Assemblydateien an einen anderen Speicherort kopiert, bevor Sie die Assemblys geladen werden. Die ursprüngliche Assemblydatei ist nicht gesperrt, damit er aktualisiert werden kann. Weitere Informationen zum Erstellen von Schattenkopien, finden Sie unter [Schattenkopien von Assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Erstellen von Schattenkopien von Assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : string with get, set" Usage="System.AppDomainSetup.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Zeichenfolge ab, die angibt, ob das Spiegeln ein- oder ausgeschaltet ist.</summary>
        <value>Der Zeichenfolgenwert "true" für aktiviertes Erstellen von Schattenkopien oder "false" für deaktiviertes Erstellen von Schattenkopien.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zum Erstellen von Schattenkopien, finden Sie unter [Schattenkopien von Assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Erstellen von Schattenkopien von Assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string with get, set" Usage="System.AppDomainSetup.TargetFrameworkName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Zeichenfolge ab oder legt diese fest, die die Zielversion und das Profil von .NET Framework für die Anwendungsdomäne festlegt, in einem Format, das vom <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" />-Konstruktor analysiert werden kann.</summary>
        <value>Die Zielversion und das Profil des .NET Framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft, der derzeit ausgeführten Version von .NET Framework mitzuteilen, dass es sich bei die Anwendungsdomäne verwendet wird, laden und Ausführen von Assemblys, die für die Zielversion und das Profil kompiliert wurden. Verfügt die derzeit ausgeführte Version von .NET Framework optionale Verhaltensweisen, die die Kompatibilität des Codes auswirken, die mit der Zielversion kompiliert wurde, können sie aktivieren oder deaktivieren diese Verhalten entsprechend, um die Kompatibilität zu verbessern. Dies kann nützlich sein, wenn eine Anwendung-add-ins mit mehreren Versionen von .NET Framework kompiliert werden, indem Sie sie in separaten Anwendungsdomänen ausführen unterstützt.  
  
 Für Clientanwendungen, die den Wert des der <xref:System.AppDomainSetup.TargetFrameworkName%2A> Eigenschaft abgeleitet wird, aus der <xref:System.Runtime.Versioning.TargetFrameworkAttribute> Attribut. In [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] und höher, das Hinzufügen dieses Attributs auf die Assembly, die automatisch auf Grundlage der Einstellung des Projekts **Zielframework** Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>