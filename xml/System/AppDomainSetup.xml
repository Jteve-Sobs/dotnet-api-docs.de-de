<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata><Meta Name="ms.openlocfilehash" Value="95813b5498c66484241f15c5263618d4215d8cd0" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86602708" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomainSetup" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit AppDomainSetup extends System.Object" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="F#" Value="type AppDomainSetup = class" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type AppDomainSetup = class&#xA;    interface IAppDomainSetup" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" FrameworkAlternate="xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Runtime.Extensions" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Assembly-Bindungsinformationen dar, die einer Instanz von <see cref="T:System.AppDomain" /> hinzugefügt werden können.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ändern der Eigenschaften einer <xref:System.AppDomainSetup> Instanz wirkt sich nicht auf vorhandene aus <xref:System.AppDomain> . Sie kann sich nur auf die Erstellung eines neuen auswirken <xref:System.AppDomain> , wenn die- <xref:System.AppDomain.CreateDomain%2A> Methode mit der- <xref:System.AppDomainSetup> Instanz als Parameter aufgerufen wird.  
  
 Diese Klasse implementiert die <xref:System.IAppDomainSetup>-Schnittstelle.  
  
> [!CAUTION]
>  Der Standardwert für die- <xref:System.AppDomainSetup.DisallowCodeDownload%2A> Eigenschaft ist false. Diese Einstellung ist für Dienste unsicher. Legen Sie diese Eigenschaft auf true fest, um zu verhindern, dass Dienste teilweise vertrauenswürdigen Code herunterladen.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="/dotnet/framework/app-domains/how-to-configure-an-application-domain">Vorgehensweise: Konfigurieren einer Anwendungsdomäne</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.AppDomainSetup" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.AppDomainSetup" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (activationContext As ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : ActivationContext -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationContext" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="activationContext">Der für eine Anwendungsdomäne zu verwendende Aktivierungskontext.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.AppDomainSetup" />-Klasse mit dem angegebenen Aktivierungskontext für die Verwendung der manifestbasierten Aktivierung einer Anwendungsdomäne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.ActivationContext> für angegebene-Objekt `activationContext` wird verwendet, um ein Objekt zu generieren, das <xref:System.Runtime.Hosting.ActivationArguments> Informationen enthält, die zum Aktivieren einer neuen Anwendungsdomäne erforderlich sind. <xref:System.Runtime.Hosting.ActivationArguments>Auf dieses Objekt kann mithilfe der-Eigenschaft zugegriffen werden <xref:System.AppDomainSetup.ActivationArguments%2A> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="activationContext" /> ist <see langword="null" />.</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (activationArguments As ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : System.Runtime.Hosting.ActivationArguments -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationArguments" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="activationArguments">Ein Objekt, das die für die manifestbasierte Aktivierung einer neuen Anwendungsdomäne erforderlichen Informationen angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.AppDomainSetup" />-Klasse mit den für die Verwendung der manifestbasierten Aktivierung einer Anwendungsdomäne erforderlichen Aktivierungsargumenten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Auf das für angegebene-Objekt `activationArguments` kann mithilfe der- <xref:System.AppDomainSetup.ActivationArguments%2A> Eigenschaft zugegriffen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="activationArguments" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ActivationArguments : System.Runtime.Hosting.ActivationArguments with get, set" Usage="System.AppDomainSetup.ActivationArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Daten über die Aktivierung einer Anwendungsdomäne ab oder legt diese fest.</summary>
        <value>Ein Objekt, das Daten über die Aktivierung einer Anwendungsdomäne enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft auf festgelegt ist, wird keine Ausnahme ausgelöst `null` .  
  
 Die vom-Objekt bereitgestellten Informationen <xref:System.Runtime.Hosting.ActivationArguments> unterstützen die Manifest-basierte Aktivierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Eigenschaft ist auf ein <see cref="T:System.Runtime.Hosting.ActivationArguments" />-Objekt festgelegt, dessen Anwendungsidentität nicht der Anwendungsidentität des von der <see cref="P:System.AppDomainSetup.ApplicationTrust" />-Eigenschaft zurückgegebenen <see cref="T:System.Security.Policy.ApplicationTrust" />-Objekts entspricht. Es wird keine Ausnahme ausgelöst, wenn die <see cref="P:System.AppDomainSetup.ApplicationTrust" />-Eigenschaft <see langword="null" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializer : AppDomainInitializer with get, set" Usage="System.AppDomainSetup.AppDomainInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.AppDomainInitializer" />-Delegaten ab oder legt diesen fest, der eine Rückrufmethode darstellt, die beim Initialisieren der Anwendungsdomäne aufgerufen wird.</summary>
        <value>Ein Delegat, der eine Rückrufmethode darstellt, die aufgerufen wird, wenn die Anwendungsdomäne initialisiert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um Informationen an die Rückruf Methode zu übergeben, weisen Sie der-Eigenschaft ein Zeichen folgen Array zu <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> . Das Array wird bei jeder Initialisierung von an die Rückruf Methode übermittelt <xref:System.AppDomain> .  
  
 Die Rückruf Methode wird im Kontext der neu erstellten Anwendungsdomäne ausgeführt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine untergeordnete Anwendungsdomäne mit dem Namen erstellt `ChildDomain` , wobei ein <xref:System.AppDomainSetup> -Objekt und ein Beweis aus der Standard Anwendungsdomäne verwendet werden. Die- <xref:System.AppDomainSetup.AppDomainInitializer%2A> Eigenschaft wird auf die Rückruf Methode festgelegt `AppDomainInit` , die aufgerufen wird, wenn die untergeordnete Domäne initialisiert wird. Die Argumente für die Rückruf Methode werden in ein Array von Zeichen folgen eingefügt, das der-Eigenschaft zugewiesen wird <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> . Wenn die untergeordnete Domäne erstellt wird, druckt die Rückruf Methode einfach die Zeichen folgen.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializerArguments : string[] with get, set" Usage="System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Argumente zurück, die an die durch den <see cref="T:System.AppDomainInitializer" />-Delegaten dargestellte Rückrufmethode übergeben wurden, oder legt diese fest. Die Rückrufmethode wird beim Initialisieren der Anwendungsdomäne aufgerufen.</summary>
        <value>Ein Array von Zeichenfolgen, das an die durch den <see cref="T:System.AppDomainInitializer" />-Delegaten dargestellte Rückrufmethode übergeben wird, wenn die Rückrufmethode bei der <see cref="T:System.AppDomain" />-Initialisierung aufgerufen wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die- <xref:System.AppDomainSetup.AppDomainInitializer%2A> Eigenschaft, um eine Rückruf Methode anzugeben, die während der <xref:System.AppDomain> Initialisierung aufgerufen wird. Wenn die- <xref:System.AppDomainSetup.AppDomainInitializer%2A> Eigenschaft nicht festgelegt ist, wird das Array, das dieser Eigenschaft zugewiesen ist, nicht verwendet.  
  
 Die Rückruf Methode wird im Kontext der neu erstellten Anwendungsdomäne ausgeführt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine untergeordnete Anwendungsdomäne mit dem Namen erstellt `ChildDomain` , wobei ein <xref:System.AppDomainSetup> -Objekt und ein Beweis aus der Standard Anwendungsdomäne verwendet werden. Die- <xref:System.AppDomainSetup.AppDomainInitializer%2A> Eigenschaft wird auf die Rückruf Methode festgelegt `AppDomainInit` , die aufgerufen wird, wenn die untergeordnete Domäne initialisiert wird. Die Argumente für die Rückruf Methode werden in ein Array von Zeichen folgen eingefügt, das der-Eigenschaft zugewiesen wird <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> . Wenn die untergeordnete Domäne erstellt wird, druckt die Rückruf Methode einfach die Zeichen folgen.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerAssembly : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Anzeigenamen der Assembly ab, die den Typ des Anwendungsdomänen-Managers für mit diesem <see cref="T:System.AppDomainSetup" />-Objekt erstellte Anwendungsdomänen bereitstellt, oder legt diesen fest.</summary>
        <value>Der Anzeigename der Assembly, die den <see cref="T:System.Type" /> des Anwendungsdomänen-Managers bereitstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um den Typ des Anwendungs Domänen-Managers anzugeben, legen Sie diese Eigenschaft und die- <xref:System.AppDomainSetup.AppDomainManagerType%2A> Eigenschaft fest. Wenn eine dieser Eigenschaften nicht festgelegt ist, wird die andere ignoriert.  
  
 Wenn kein Typ angegeben ist, wird der Anwendungs Domänen-Manager vom gleichen Typ wie die übergeordnete Anwendungsdomäne (d. h. die Anwendungsdomäne, aus der die <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> Methode aufgerufen wird) erstellt.  
  
 Wenn die Anwendungsdomäne geladen wird, <xref:System.TypeLoadException> wird ausgelöst, wenn die Assembly nicht vorhanden ist, oder, wenn die Assembly nicht den von der-Eigenschaft angegebenen Typ enthält <xref:System.AppDomainSetup.AppDomainManagerType%2A> . <xref:System.IO.FileLoadException> wird ausgelöst, wenn die Assembly gefunden wurde, die Versionsinformationen aber nicht.  
  
 Um den Anwendungs Domänen-Manager für die Standard Anwendungsdomäne festzulegen, verwenden Sie das [\<appDomainManagerAssembly>](/dotnet/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element) -Element und das- [\<appDomainManagerType>](/dotnet/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element) Element im- [\<runtime>](/dotnet/framework/configure-apps/file-schema/runtime/runtime-element) Abschnitt der Anwendungs Konfigurationsdatei, oder verwenden Sie die in beschriebenen Umgebungsvariablen <xref:System.AppDomainManager> .  
  
 Diese Funktion erfordert die volle Vertrauenswürdigkeit der Anwendung. (Eine Anwendung, die auf dem Desktop ausgeführt wird, hat beispielsweise volle Vertrauenswürdigkeit.) Wenn die Anwendung nicht über volle Vertrauenswürdigkeit verfügt, <xref:System.TypeLoadException> wird eine ausgelöst.  
  
 Das Format des Assemblyanzeigenamen wird von der- <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> Eigenschaft angegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerType : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vollständigen Namen des Typs ab, der den Anwendungsdomänen-Manager für mit diesem <see cref="T:System.AppDomainSetup" />-Objekt erstellte Anwendungsdomänen bereitstellt, oder legt diesen fest.</summary>
        <value>Der vollständige Name des Typs, einschließlich des Namespaces.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um den Typ des Anwendungs Domänen-Managers anzugeben, legen Sie diese Eigenschaft und die- <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> Eigenschaft fest. Wenn eine dieser Eigenschaften nicht festgelegt ist, wird die andere ignoriert.  
  
 Wenn kein Typ angegeben ist, wird der Anwendungs Domänen-Manager vom gleichen Typ wie die übergeordnete Anwendungsdomäne (d. h. die Anwendungsdomäne, aus der die <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> Methode aufgerufen wird) erstellt.  
  
 Wenn die Anwendungsdomäne geladen wird, <xref:System.TypeLoadException> wird ausgelöst, wenn die von der- <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> Eigenschaft angegebene Assembly nicht den von dieser Eigenschaft angegebenen Typ enthält.  
  
 Um den Anwendungs Domänen-Manager für die Standard Anwendungsdomäne festzulegen, verwenden Sie das [\<appDomainManagerAssembly>](/dotnet/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element) -Element und das- [\<appDomainManagerType>](/dotnet/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element) Element im- [\<runtime>](/dotnet/framework/configure-apps/file-schema/runtime/runtime-element) Abschnitt der Anwendungs Konfigurationsdatei, oder verwenden Sie die in beschriebenen Umgebungsvariablen <xref:System.AppDomainManager> .  
  
 Diese Funktion erfordert die volle Vertrauenswürdigkeit der Anwendung. (Eine Anwendung, die auf dem Desktop ausgeführt wird, hat beispielsweise volle Vertrauenswürdigkeit.) Wenn die Anwendung nicht über volle Vertrauenswürdigkeit verfügt, <xref:System.TypeLoadException> wird eine ausgelöst.  
  
 Das Format des vollständigen Namens eines Typs wird von der- <xref:System.Type.FullName%2A?displayProperty=nameWithType> Eigenschaft angegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationBase As String" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); };" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string" Usage="System.AppDomainSetup.ApplicationBase" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string with get, set" Usage="System.AppDomainSetup.ApplicationBase" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Verzeichnisses ab, das die Anwendung enthält, oder legt diesen fest.</summary>
        <value>Der Name des Basisverzeichnisses der Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Anwendungs Basisverzeichnis ist der Ort, an dem der assemblymanager die Suche nach Assemblys startet  
  
 Die- <xref:System.AppDomainSetup.ApplicationBase%2A> Eigenschaft kann Einfluss darauf haben, welche Berechtigungen einer Anwendungsdomäne gewährt werden. Beispielsweise erhält eine Anwendungsdomäne, die auf dem lokalen computerbasiert, normalerweise die volle Vertrauenswürdigkeit basierend auf dem Ursprungs Standort. Wenn jedoch die- <xref:System.AppDomainSetup.ApplicationBase%2A> Eigenschaft von <xref:System.AppDomain> auf den vollständigen Namen eines Intranetverzeichnisses festgelegt ist <xref:System.AppDomainSetup.ApplicationBase%2A> , schränkt die Einstellung die der Anwendungsdomäne gewährten Berechtigungen auf eine LocalIntranet-Gewährung ein, auch wenn die Anwendungsdomäne tatsächlich vom lokalen Computer stammt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die-Eigenschaft verwendet wird <xref:System.AppDomainSetup.ApplicationBase%2A> , um den Speicherort festzulegen, an dem das assemblylade Modul beginnt, wenn Assemblys in eine neue Anwendungsdomäne geladen  
  
> [!NOTE]
>  Sie müssen sicherstellen, dass der angegebene Ordner vorhanden ist.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.AppDomainSetup.ApplicationName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der Anwendung ab oder legt diesen fest.</summary>
        <value>Der Namen der Anwendung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die-Eigenschaft festgelegt wird, <xref:System.AppDomainSetup.ApplicationName%2A> Wenn Sie eine neue Anwendungsdomäne erstellen.  
  
 Im Beispiel wird eine neue Anwendungsdomäne erstellt. Anschließend wird die-Methode aufgerufen, <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType> um die Beispielassembly in die neue Anwendungsdomäne zu laden und eine Instanz der-Klasse zu erstellen `Worker` . Die `Worker` Klasse erbt <xref:System.MarshalByRefObject> , sodass im Beispiel der von zurückgegebene Proxy verwendet werden kann, <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> um die Methode aufzurufen `TestLoad` .  
  
 Die- `TestLoad` Methode lädt eine Assembly, die Sie angeben. Geben Sie entweder einen gültigen voll qualifizierten Assemblynamen an, oder kommentieren Sie die <xref:System.Reflection.Assembly.Load%28System.String%29> Methode aus. Die- `TestLoad` Methode listet die Assemblys auf, die in die neue Anwendungsdomäne geladen werden, und zeigt an, dass die angegebene Assembly und die Beispielassembly geladen sind.  
  
 Im Beispiel wird das- <xref:System.LoaderOptimizationAttribute> Attribut verwendet, um dem assemblylader mitzuteilen, wie die Anwendung Code über Anwendungs Domänen hinweg freigeben wird.  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust with get, set" Usage="System.AppDomainSetup.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, das Sicherheits- und Vertrauenswürdigkeitsinformationen enthält, oder legt dieses fest.</summary>
        <value>Ein Objekt, das Sicherheits- und Vertrauenswürdigkeitsinformationen enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist, `null` Wenn das <xref:System.AppDomainSetup> erstellt wird. Die Änderung kann nicht auf einen NULL-Verweis zurückgesetzt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Eigenschaft ist auf ein <see cref="T:System.Security.Policy.ApplicationTrust" />-Objekt festgelegt, dessen Anwendungsidentität nicht der Anwendungsidentität des von der <see cref="P:System.AppDomainSetup.ActivationArguments" />-Eigenschaft zurückgegebenen <see cref="T:System.Runtime.Hosting.ActivationArguments" />-Objekts entspricht. Es wird keine Ausnahme ausgelöst, wenn die <see cref="P:System.AppDomainSetup.ActivationArguments" />-Eigenschaft <see langword="null" /> ist.</exception>
        <exception cref="T:System.ArgumentNullException">Die Eigenschaft ist auf <see langword="null" /> festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePath : string with get, set" Usage="System.AppDomainSetup.CachePath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen eines anwendungsspezifischen Bereichs ab, in dem Dateien gespiegelt werden, oder legt diesen fest.</summary>
        <value>Der vollqualifizierte Name des Verzeichnispfads und der Datei, in der Dateien gespiegelt werden.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Damit diese Eigenschaft wirksam wird, muss die- <xref:System.AppDomainSetup.ApplicationName%2A> Eigenschaft ebenfalls festgelegt werden. Wenn die- <xref:System.AppDomainSetup.ApplicationName%2A> Eigenschaft nicht festgelegt ist, <xref:System.AppDomainSetup.CachePath%2A> wird die-Eigenschaft ignoriert, und der Cache Speicherort für Schatten Kopien wird standardmäßig auf den Download Cache festgelegt  
  
 Weitere Informationen zum Kopieren von Schatten Kopien finden Sie unter [schattenkopieassemblys](/dotnet/framework/app-domains/shadow-copy-assemblies).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="/dotnet/framework/app-domains/shadow-copy-assemblies">Erstellen von Schattenkopien von Assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationFile : string with get, set" Usage="System.AppDomainSetup.ConfigurationFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen einer Konfigurationsdatei für eine Anwendungsdomäne ab oder legt diesen fest.</summary>
        <value>Der Name der Konfigurationsdatei.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Konfigurationsdatei werden die Such Regeln und Konfigurationsdaten für die Anwendungsdomäne beschrieben. Der Host, von dem die Anwendungsdomäne erstellt wird, ist für die Bereitstellung dieser Daten verantwortlich, da die aussagekräftigen Werte von der Situation abhängig sind.  
  
 Beispielsweise werden die Konfigurationsdaten für ASP.NET-Anwendungen für jede Anwendung, jede Site und jeden Computer gespeichert, während die Konfigurationsdaten für eine ausführbare Datei für jede Anwendung, jeden Benutzer und jeden Computer gespeichert werden. Nur der Host kennt die Besonderheiten der Konfigurationsdaten für einen bestimmten Umstand.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/">Schema für Laufzeiteinstellungen</related>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowApplicationBaseProbing : bool with get, set" Usage="System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Anwendungsbasispfad und der private Binärpfad beim Suchen nach zu ladenden Assemblys durchsucht wird.</summary>
        <value><see langword="true" /> , wenn die Suche nicht zulässig ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die- <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> Eigenschaft ist `true` , wird der Wert der- <xref:System.AppDomainSetup.ApplicationBase%2A> Eigenschaft ignoriert. Das heißt, dass in den Verzeichnissen, die durch die-Eigenschaft angegeben werden, keine Assemblys gesucht werden <xref:System.AppDomainSetup.ApplicationBase%2A> . Außerdem werden die Werte der <xref:System.AppDomainSetup.PrivateBinPath%2A> -Eigenschaft und der- <xref:System.AppDomainSetup.PrivateBinPathProbe%2A> Eigenschaft ignoriert. In den Verzeichnissen, die durch die-Eigenschaft angegeben werden, werden keine Assemblys gesucht <xref:System.AppDomainSetup.PrivateBinPath%2A> .  
  
 Die- <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> Eigenschaft stellt eine zusätzliche Steuerungsebene für den Ladevorgang bereit. In der normalen Assembly wird geladen, bevor das- <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> Ereignis ausgelöst wird. Allerdings müssen einige Anwendungen ggf. Assemblys aus einer OLE-Verbund Datei innerhalb eines Dokuments oder eines eindeutigen bekannten Speicher Orts, der weder im globalen Assemblycache noch in den von der-Eigenschaft und der-Eigenschaft angegebenen Verzeichnissen ist, laden <xref:System.AppDomainSetup.ApplicationBase%2A> <xref:System.AppDomainSetup.PrivateBinPath%2A> . Solche Anwendungen können die- <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> Eigenschaft verwenden, um die Verzögerung zu vermeiden, die durch die normale Überprüfung verursacht wird, und um zu vermeiden, dass Kopien der erforderlichen Assembly geladen werden, die sich möglicherweise in den normalen Überprüfungs Pfaden befinden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowBindingRedirects : bool with get, set" Usage="System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Assembly-Bindungsumleitung in einer Anwendungsdomäne zulässig ist, oder legt diesen fest.</summary>
        <value><see langword="true" /> , wenn die Umleitung von Assemblys nicht zulässig ist, <see langword="false" /> , wenn sie zulässig ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.AppDomainSetup.DisallowBindingRedirects%2A> Eigenschaft ist für die Verwendung durch-Dienste und Server Anwendungen konzipiert, bei denen die Umleitung der Assemblybindung nicht Teil des Anwendungs Szenarios ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowCodeDownload : bool with get, set" Usage="System.AppDomainSetup.DisallowCodeDownload" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Assembly-Downloads über HTTP für eine Anwendungsdomäne zulässig sind, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der HTTP-Download von Assemblys nicht zulässig ist, <see langword="false" />, wenn er zulässig ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.AppDomainSetup.DisallowCodeDownload%2A> Eigenschaft ist für die Verwendung durch Dienste und Server Anwendungen konzipiert, in denen das Herunterladen von Code aus einem Intranet oder dem Internet nicht Teil des Anwendungs Szenarios ist.  
  
> [!CAUTION]
>  Der Standardwert für die- <xref:System.AppDomainSetup.DisallowCodeDownload%2A> Eigenschaft ist `false` . Diese Einstellung ist für Dienste unsicher. Legen Sie diese Eigenschaft auf fest, um zu verhindern, dass Dienste teilweise vertrauenswürdigen Code herunterladen `true` .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowPublisherPolicy : bool with get, set" Usage="System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der [ &lt; publisherPolicy &gt; ](/dotnet/framework/configure-apps/file-schema/runtime/publisherpolicy-element) -Abschnitt der Konfigurationsdatei auf eine Anwendungsdomäne angewendet wird, oder legt ihn fest.</summary>
        <value><see langword="true" />, wenn der <see langword="&lt;publisherPolicy&gt;" />-Abschnitt der Konfigurationsdatei für eine Anwendungsdomäne ignoriert wird, <see langword="false" />, wenn die deklarierte Herausgeberrichtlinie übernommen wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A> Eigenschaft gilt speziell für eine Webanwendung, die lokal geladen wird. Verwenden Sie diese Eigenschaft, um zu verhindern, dass böswillige Webanwendungen im abgesicherten Modus ausgeführt werden.  
  
 Weitere Informationen zum Umgehen der Herausgeber Richtlinie finden Sie im Thema [umleiten](/dotnet/framework/configure-apps/redirect-assembly-versions) von Assemblyversionen. Weitere Informationen zum abgesicherten Modus finden Sie im Abschnitt "untersuchen der Konfigurationsdateien" im Thema [How the Runtime Locates](/dotnet/framework/deployment/how-the-runtime-locates-assemblies) Assemblys.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DynamicBase : string with get, set" Usage="System.AppDomainSetup.DynamicBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[set: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Basisverzeichnis ab oder legt dieses fest, in dem sich das Verzeichnis für dynamisch generierte Dateien befindet.</summary>
        <value>Das Verzeichnis, in dem sich das <see cref="P:System.AppDomain.DynamicDirectory" /> befindet.  

 <block subset="none" type="note"><para>  
 Der Rückgabewert dieser Eigenschaft ist anders als der Wert, der zugewiesen wurde.
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 Verwenden Sie diese Eigenschaft, um das Basisverzeichnis festzulegen, in dem sich das dynamische Verzeichnis für die neue Anwendungsdomäne befindet. Wenn Code in der neuen Anwendungsdomäne eine Assembly lädt, wird die Assemblyauflösung zuerst in den normalen Prüf Pfaden durchsucht. Wenn die Assembly nicht gefunden wird, wird Sie im dynamischen Verzeichnis durchsucht, das von der-Eigenschaft zurückgegeben wird <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> . Dynamische Assemblys, die von der neuen Anwendungsdomäne geladen und ausgeführt werden, können dort platziert werden.  
  
 Wenn Sie der Eigenschaft einen Pfad zuweisen <xref:System.AppDomainSetup.DynamicBase%2A> , wird ein zusätzliches Unterverzeichnis hinzugefügt. der Name dieses Unterverzeichnisses ist der Hashcode des Werts, der der Eigenschaft zugewiesen ist <xref:System.AppDomainSetup.ApplicationName%2A> . Daher unterscheidet sich das Basisverzeichnis, das von dieser Eigenschaft zurückgegeben wird, immer von dem zugewiesenen Wert.  
  
> [!IMPORTANT]
>  Wenn Sie dieser Eigenschaft einen Wert zuweisen, werden keine Verzeichnisse erstellt. Die Verzeichnisse müssen von dem Code erstellt oder überprüft werden, der Sie verwendet.  
  
 Das dynamische Verzeichnis ist ein Unterverzeichnis von <xref:System.AppDomainSetup.DynamicBase%2A> . Der einfache Name ist der Wert, der von der-Eigenschaft zurückgegeben wird <xref:System.AppDomainSetup.ApplicationName%2A> , sodass sein Format *ursprünglicher Pfad* \\ *Hash Code* \\ *Anwendungsname*ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die-Eigenschaft verwendet wird <xref:System.AppDomainSetup.DynamicBase%2A> , um den Pfad festzulegen, den eine Anwendungsdomäne beim Laden dynamischer Assemblys testet  
  
 Im Beispiel wird ein <xref:System.AppDomainSetup> -Objekt erstellt und seine <xref:System.AppDomainSetup.ApplicationName%2A> -Eigenschaft auf "example" und seine- <xref:System.AppDomainSetup.DynamicBase%2A> Eigenschaft auf "c:\dynamicassemblydir" festgelegt. Im Beispiel wird dann die- <xref:System.AppDomainSetup.DynamicBase%2A> Eigenschaft angezeigt, um anzuzeigen, dass der Hashcode des Anwendungs namens als Unterverzeichnis des ursprünglich zugewiesenen Pfades angefügt wurde.  
  
> [!NOTE]
>  Das Basisverzeichnis in diesem Beispiel soll außerhalb des Suchpfads für die Beispielanwendung liegen. Stellen Sie sicher, dass das Beispiel an einem anderen Speicherort kompiliert wird. Löschen Sie jedes Mal, wenn Sie das Beispiel ausführen, das Basisverzeichnis und alle Unterverzeichnisse.  
  
 Im Beispiel wird eine neue Anwendungsdomäne mit dem- <xref:System.AppDomainSetup> Objekt erstellt. Im Beispiel wird dann das dynamische Verzeichnis erstellt, wenn es nicht bereits vorhanden ist. Obwohl das Beispiel die-Eigenschaft der Anwendungsdomäne verwendet <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> , um den Namen des dynamischen Verzeichnisses zu erhalten, könnte es so einfach sein, das Verzeichnis vorab zu erstellen, indem der ursprüngliche Pfad, der Hashcode des Anwendungs namens und der Anwendungsname verkettet werden.  
  
 Das Beispiel enthält eine `GenerateDynamicAssembly` -Methode, die eine Assembly `DynamicHelloWorld.dll` mit dem Namen ausgibt und im dynamischen Verzeichnis der neuen Anwendungsdomäne speichert. Die dynamische Assembly enthält einen Typ, `HelloWorld` , der über eine statische Methode ( `Shared` Methode in Visual Basic) mit dem Namen verfügt `HelloFromAD` . Wenn Sie diese Methode aufrufen, wird der Name der Anwendungsdomäne angezeigt.  
  
 Die- `Example` Klasse wird von abgeleitet <xref:System.MarshalByRefObject> , sodass im Beispiel eine Instanz der-Klasse in der neuen Anwendungsdomäne erstellt und die zugehörige-Methode aufgerufen werden kann `Test` . Die `Test` -Methode lädt die dynamische Assembly nach Ihrem anzeigen Amen und ruft die statische- `HelloFromAD` Methode auf.  
  
 Sie können anzeigen, dass das dynamische Verzeichnis nach den normalen Überprüfungs Pfaden durchsucht wird, indem Sie Code für eine Assembly mit dem Namen schreiben `DynamicHelloWorld.dll` und diese im gleichen Verzeichnis wie in diesem Beispiel kompilieren. Die Assembly muss über eine Klasse `HelloWorld` mit dem Namen mit einer statischen Methode namens verfügen `HelloFromAD` . Diese Methode muss nicht die gleiche Funktionalität wie die im Beispiel haben. Es kann einfach eine Zeichenfolge in der Konsole angezeigt werden. Die Assembly muss auch über ein <xref:System.Reflection.AssemblyVersionAttribute> Attribut verfügen, das die Version auf 1.0.0.0 festlegt. Wenn Sie das Beispiel ausführen, wird die Assembly, die Sie im aktuellen Verzeichnis kompiliert haben, vor dem Durchsuchen des dynamischen Verzeichnisses gefunden.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Diese Eigenschaft kann nicht festgelegt werden, da der Anwendungsname in der Anwendungsdomäne <see langword="null" /> lautet.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberSignature Language="F#" Value="member this.GetConfigurationBytes : unit -&gt; byte[]" Usage="appDomainSetup.GetConfigurationBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die XML-Konfigurationsinformationen zurück, die von der <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />-Methode festgelegt werden. Hierdurch werden die XML-Konfigurationsinformationen der Anwendung überschrieben.</summary>
        <returns>Ein Array mit den XML-Konfigurationsinformationen, die von der <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />-Methode festgelegt wurden, oder <see langword="null" />, wenn die <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />-Methode nicht aufgerufen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Methode bietet eine Möglichkeit, die Konfigurationsinformationen einer Anwendung zu überschreiben, die eine neue Anwendungsdomäne erstellt. Die Konfigurationsdatei Informationen in `value` überschreiben die Konfigurationsdatei Informationen für die Anwendung. Wenn die Example.exe Anwendung z. b. eine neue Anwendungsdomäne erstellt, kann Sie die Konfigurationsinformationen überschreiben, die ursprünglich aus Example.exe.config Datei abgerufen wurden.  
  
> [!IMPORTANT]
>  Einige Consumer von Konfigurationsdatei Informationen verwenden nicht die von der-Methode gespeicherten Informationen <xref:System.AppDomainSetup.SetConfigurationBytes%2A> . Die Laufzeit erzwingt dies nicht. Um sicherzustellen, dass alle Konfigurationsdatei Informationen in einer neuen Anwendungsdomäne überschrieben werden, verwenden Sie die- <xref:System.AppDomainSetup.ConfigurationFile%2A> Eigenschaft, um eine Konfigurationsdatei anzugeben. Die Methode wirkt sich auf die Assemblybindung aus <xref:System.AppDomainSetup.SetConfigurationBytes%2A> .  
  
 Der XML-Code in ist mit dem XML-Code `value` in einer normalen Konfigurationsdatei identisch, mit dem Unterschied, dass er als-Array gespeichert wird <xref:System.Byte> .  
  
 Um auf die Konfigurations Bytes für eine Anwendungsdomäne zuzugreifen, verwenden Sie die- <xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType> Eigenschaft, um das- <xref:System.AppDomainSetup> Objekt für die Anwendungsdomäne zu erhalten, und verwenden Sie dann die- <xref:System.AppDomainSetup.GetConfigurationBytes%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LicenseFile : string with get, set" Usage="System.AppDomainSetup.LicenseFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position der dieser Domäne zugeordneten Lizenzdatei ab oder legt diese fest.</summary>
        <value>Der Name und Speicherort der Lizenzdatei.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberSignature Language="F#" Value="member this.LoaderOptimization : LoaderOptimization with get, set" Usage="System.AppDomainSetup.LoaderOptimization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Optimierungsrichtlinie zum Laden ausführbarer Dateien an.</summary>
        <value>Eine Enumerationskonstante, die mit dem <see cref="T:System.LoaderOptimizationAttribute" /> verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine dynamische Assembly erstellt und auf dem Datenträger gespeichert. Anschließend wird die-Eigenschaft verwendet, <xref:System.AppDomainSetup.LoaderOptimization%2A> um die Optimierungs Richtlinie festzulegen, mit der die Assembly in eine Anwendungsdomäne geladen wird.  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PartialTrustVisibleAssemblies : string[] with get, set" Usage="System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Liste von mit dem <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />-Flag markierten Assemblys ab, die für teilweise vertrauenswürdigen Code, der in einer Sandbox-Anwendungsdomäne ausgeführt wird, sichtbar gemacht werden, oder legt diese fest.</summary>
        <value>Ein Array partieller Assemblynamen, wobei jeder partielle Name aus dem einfachen Assemblynamen und dem öffentlichen Schlüssel besteht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ab [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] kann das- <xref:System.Security.AllowPartiallyTrustedCallersAttribute> Attribut (APTCA) durch Festlegen der-Eigenschaft auf bedingt erstellt werden <xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A> <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault> . Eine mit markierte APTCA-Assembly <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault> kann nicht von teilweise vertrauenswürdigem Code verwendet werden, es sei denn, Sie wird von der Host Anwendung zugelassen.  
  
 Der Host einer Sandbox-Anwendungsdomäne ermöglicht dem Code in der Anwendungsdomäne die Verwendung von Assemblys mit bedingten APTCA-Attributen durch Erstellen eines Arrays, das den einfachen Namen und den öffentlichen Schlüssel der einzelnen Assemblys enthält, und das Zuweisen des Arrays zu dieser Eigenschaft. Ein Element des-Arrays könnte z. b. wie folgt aussehen: "MyAssembly, PublicKey = 0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad0be9b56dae4f6b83332b92a2a3 b8ea2804c40efbc0b6b9".  
  
> [!IMPORTANT]
>  Wenn Sie eine Unterklasse von verwenden und die Assembly, die Sie definiert, von Assemblys abhängig ist, die <xref:System.AppDomainManager> mit dem bedingten APTCA-Attribut markiert sind, müssen Sie diese Assemblys in der Liste einschließen, die Sie an die-Eigenschaft des-Objekts übergeben, das <xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A> <xref:System.AppDomainSetup> Sie zum Erstellen von Anwendungs Domänen verwenden. Andernfalls werden die Assemblys, die mit dem bedingten APTCA-Attribut markiert sind, deaktiviert.  
  
> [!NOTE]
>  Beim Debuggen einer Anwendung, die in einer Sandbox-Anwendungsdomäne ausgeführt wird, <xref:System.Security.SecurityException> können einige Nachrichten irreführend sein. Beispielsweise kann eine Nachricht angeben, dass eine ihrer vollständig vertrauenswürdigen Assemblys nur eingeschränkte Berechtigungen aufweist, wenn die tatsächliche Ursache des Problems darin besteht, dass eine Sicherheitsanforderung, die den Berechtigungs Satz der Sandbox-Anwendungsdomäne überschreitet, an die Grenze der Sandbox-Anwendungsdomäne weitergegeben wurde und fehlgeschlagen ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPath : string with get, set" Usage="System.AppDomainSetup.PrivateBinPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Liste der Verzeichnisse unterhalb des Anwendungsbasisverzeichnisses ab, in denen nach privaten Assemblys gesucht wird, oder legt diese fest.</summary>
        <value>Eine durch Semikolons getrennte Liste von Verzeichnisnamen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Private Assemblys werden in derselben Verzeichnisstruktur wie die Anwendung bereitgestellt. Wenn die Verzeichnisse, die für angegeben <xref:System.AppDomainSetup.PrivateBinPath%2A> sind, nicht unterliegen <xref:System.AppDomainSetup.ApplicationBase%2A> , werden Sie ignoriert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPathProbe : string with get, set" Usage="System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Zeichenfolgenwert ab, der <see cref="P:System.AppDomainSetup.ApplicationBase" /> in den Suchpfad für die Anwendung aufnimmt oder ausschließt und nur <see cref="P:System.AppDomainSetup.PrivateBinPath" /> durchsucht.</summary>
        <value>Ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic) zur Einbeziehung des Anwendungsbasispfads bei der Suche nach Assemblys; jeder Zeichenfolgenwert ungleich NULL zum Ausschließen des Pfads. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft auf einen Zeichen folgen Wert zurück, der nicht NULL ist, einschließlich <xref:System.String.Empty?displayProperty=nameWithType> (""), um den Pfad des Anwendungs Verzeichnisses auszuschließen, d <xref:System.AppDomainSetup.ApplicationBase%2A> . h. von dem Suchpfad für die Anwendung, und um nur in nach Assemblys zu suchen <xref:System.AppDomainSetup.PrivateBinPath%2A> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SandboxInterop : bool with get, set" Usage="System.AppDomainSetup.SandboxInterop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Schnittstellenzwischenspeicherung für Interop-Aufrufe in der Anwendungsdomäne deaktiviert ist, sodass <c>QueryInterface</c> für jeden Aufruf ausgeführt wird, oder legt diesen Wert fest.</summary>
        <value><see langword="true" /> , wenn die Schnittstellenzwischenspeicherung für Interop-Aufrufe in Anwendungsdomänen deaktiviert ist, die mit dem aktuellen <see cref="T:System.AppDomainSetup" /> -Objekt erstellt wurden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Deaktivieren der Schnittstellen Zwischenspeicherung hat erhebliche Auswirkungen auf die Leistung von Interop-aufrufen.  
  
 Dieser Member wird in der eingeführt [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberSignature Language="F#" Value="member this.SetCompatibilitySwitches : seq&lt;string&gt; -&gt; unit" Usage="appDomainSetup.SetCompatibilitySwitches switches" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="switches">Ein aufzählbarer Satz von Zeichenfolgenwerten, die Kompatibilitätsschalter angeben, oder <see langword="null" />, um die vorhandenen Kompatibilitätsschalter zu löschen.</param>
        <summary>Legt die angegebenen Schalter fest und macht die Anwendungsdomäne für die angegebenen Probleme mit früheren Versionen von .NET Framework kompatibel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In den Hauptversionen der .NET Framework werden manchmal grundlegende Änderungen der früheren Version eingeführt. Beispielsweise führt die [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] eine kleine Anzahl von wichtigen Änderungen aus der ein [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] . Verwenden Sie die- <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A> Methode, um anzugeben, dass für eine oder mehrere dieser wichtigen Änderungen ein Rollback für die Anwendungsdomäne ausgeführt werden soll, damit das Verhalten mit der vorherigen Version des .NET Framework kompatibel ist.  
  
 Jedes Mal, wenn Sie diese Methode aufgerufen haben, werden die vorhandenen Switcheinstellungen ersetzt. Geben Sie für den-Parameter an, um die Einstellungen zu löschen `null` `switches` .  
  
 Der Satz von Zeichen folgen Werten, die Sie für bereitstellen `switches` , kann ein einfaches Zeichen folgen Array sein, da Arrays die- <xref:System.Collections.IEnumerable> Schnittstelle implementieren.  
  
 Die folgende Tabelle enthält Beispiele für Kompatibilitäts Switches, die festgelegt werden können, um das Verhalten früherer Versionen des .NET Framework wiederherzustellen.  
  
|Schalter|Bedeutung|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Die Code Zugriffssicherheit (Code Access Security, CAS) für die [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] ist in dieser Anwendungsdomäne aktiviert. Siehe [ &lt; NetFx40_LegacySecurityPolicy &gt; Element](/dotnet/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element).|  
|"NetFx40_Legacy20SortingBehavior"|Die Standardwerte für die Zeichen folgen Sortierung für [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] sind in dieser Anwendungsdomäne aktiviert. Um das Legacy-Sortier Verhalten erfolgreich wiederherzustellen, muss auch die sort00001000.dll Dynamic Link Library auf dem lokalen System verfügbar sein. Siehe [ &lt; compatsortnlsversion- &gt; Element](/dotnet/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element).|  
|"NetFx40_Legacy40SortingBehavior"|Die Standardwerte für die Zeichen folgen Sortierung für [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] und Unicode 5,0 sind in dieser Anwendungsdomäne aktiviert. Um das Legacy-Sortier Verhalten erfolgreich wiederherzustellen, muss auch die sort00060101.dll Dynamic Link Library auf dem lokalen System verfügbar sein.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> Das Formatierungs Verhalten für [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] ist in dieser Anwendungsdomäne aktiviert. Weitere Informationen finden Sie unter [ &lt; TimeSpan_LegacyFormatMode- &gt; Element](/dotnet/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element) und im Abschnitt "Wiederherstellen der veralteten TimeSpan-Formatierung" des <xref:System.TimeSpan> Themas.|  
|UseRandomizedStringHashAlgorithm|Die Laufzeit berechnet Hashcodes für Zeichen folgen pro Anwendungsdomäne, anstatt einen einzigen Hash Algorithmus zu verwenden, der einen konsistenten Hashcode über Anwendungs Domänen hinweg erzeugt. Siehe [ &lt; userandomizedstringhashalgorithm- &gt; Element](/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element">&lt;NetFx40_LegacySecurityPolicy- &gt; Element</related>
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element">&lt;Compatsortnlsversion- &gt; Element</related>
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element">&lt;TimeSpan_LegacyFormatMode- &gt; Element</related>
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element">&lt;Userandomizedstringhashalgorithm- &gt; Element</related>
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetConfigurationBytes : byte[] -&gt; unit" Usage="appDomainSetup.SetConfigurationBytes value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Ein Array, das die XML-Konfigurationsinformationen enthält, die für die Anwendungsdomäne verwendet werden sollen.</param>
        <summary>Stellt XML-Konfigurationsinformationen für die Anwendungsdomäne bereit und ersetzt die XML-Konfigurationsinformationen der Anwendung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.AppDomainSetup.SetConfigurationBytes%2A> Methode bietet eine Möglichkeit, die Konfigurationsinformationen einer Anwendung zu ersetzen, die eine neue Anwendungsdomäne erstellt. Die Konfigurationsdatei Informationen in `value` ersetzen die Konfigurationsdatei Informationen für die Anwendung. Wenn die Example.exe Anwendung z. b. eine neue Anwendungsdomäne erstellt, kann Sie die Konfigurationsinformationen ersetzen, die ursprünglich aus der Example.exe.config-Datei abgerufen wurden.  
  
> [!IMPORTANT]
>  Einige Consumer von Konfigurationsdatei Informationen verwenden nicht die von der-Methode gespeicherten Informationen <xref:System.AppDomainSetup.SetConfigurationBytes%2A> . Die Laufzeit erzwingt dies nicht. Um sicherzustellen, dass alle Konfigurationsdatei Informationen in einer neuen Anwendungsdomäne ersetzt werden, verwenden Sie die- <xref:System.AppDomainSetup.ConfigurationFile%2A> Eigenschaft, um eine Konfigurationsdatei anzugeben. Die Methode wirkt sich auf die Assemblybindung aus <xref:System.AppDomainSetup.SetConfigurationBytes%2A> .  
  
 Der XML-Code in ist mit dem XML-Code `value` in einer normalen Konfigurationsdatei identisch, mit dem Unterschied, dass er als-Array gespeichert wird <xref:System.Byte> .  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/">Schema für Laufzeiteinstellungen</related>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="F#" Value="member this.SetNativeFunction : string * int * nativeint -&gt; unit" Usage="appDomainSetup.SetNativeFunction (functionName, functionVersion, functionPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="functionVersion" Type="System.Int32" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="functionPointer" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="functionName">Der Name der zu überschreibenden Funktion zum Zeichenfolgenvergleich.</param>
        <param name="functionVersion">Die Funktionsversion. Der Wert von [!INCLUDE[net_v45](~/includes/net-v45-md.md)] muss 1 oder größer sein.</param>
        <param name="functionPointer">Ein Zeiger auf die Funktion, die <paramref name="functionName" /> überschreibt.</param>
        <summary>Stellt die Common Language Runtime mit einer anderen Implementierung einer Zeichenfolgenvergleichsfunktion bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgenden Zeichen folgen Vergleichs-und Sortiermethoden können von der-Methode überschrieben werden <xref:System.AppDomainSetup.SetNativeFunction%2A> :  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 Weitere Informationen zu diesen Funktionen finden Sie [unter Unterstützung für nationale Sprachunterstützung](https://go.microsoft.com/fwlink/?LinkId=228134).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="functionName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="functionVersion" /> ist ungleich 1 oder größer.  
  
- oder - 
 <paramref name="functionPointer" /> ist <see cref="F:System.IntPtr.Zero" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyDirectories : string with get, set" Usage="System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Namen der Verzeichnisse mit zu spiegelnden Assemblys ab oder legt diese fest.</summary>
        <value>Eine durch Semikolons getrennte Liste von Verzeichnisnamen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Kopieren von Schatten aktiviert ist, wird standardmäßig eine Schatten Kopie aller Assemblys durchsucht, die durchsucht wurden. Das heißt, in den Verzeichnissen, die von den <xref:System.AppDomainSetup.PrivateBinPath%2A> Eigenschaften und angegeben werden <xref:System.AppDomainSetup.ApplicationBase%2A> . Die- <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> Eigenschaft schränkt die Schatten Kopie auf die Assemblys in den Verzeichnissen ein, die von angegeben werden <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> .  
  
 Wenn Sie der-Eigenschaft keine Zeichenfolge zuweisen <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> oder wenn Sie diese Eigenschaft auf festlegen `null` , werden alle Assemblys in den Verzeichnissen, die durch die-Eigenschaft und die-Eigenschaft angegeben sind, als <xref:System.AppDomainSetup.ApplicationBase%2A> <xref:System.AppDomainSetup.PrivateBinPath%2A> Schatten kopiert.  
  
> [!IMPORTANT]
>  Verzeichnispfade dürfen keine Semikolons enthalten, da das Semikolon das Trennzeichen ist. Es gibt kein Escapezeichen für Semikolons.  
  
 Wenn Schatten Kopien wirksam sind, werden Assemblydateien an einen anderen Speicherort kopiert, bevor die Assemblys geladen werden. Die ursprüngliche Assemblydatei ist nicht gesperrt, sodass Sie aktualisiert werden kann. Weitere Informationen zum Kopieren von Schatten Kopien finden Sie unter [schattenkopieassemblys](/dotnet/framework/app-domains/shadow-copy-assemblies).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="/dotnet/framework/app-domains/shadow-copy-assemblies">Erstellen von Schattenkopien von Assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : string with get, set" Usage="System.AppDomainSetup.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Zeichenfolge ab, die angibt, ob das Spiegeln ein- oder ausgeschaltet ist.</summary>
        <value>Der Zeichenfolgenwert "true" für aktiviertes Erstellen von Schattenkopien oder "false" für deaktiviertes Erstellen von Schattenkopien.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zum Kopieren von Schatten Kopien finden Sie unter [schattenkopieassemblys](/dotnet/framework/app-domains/shadow-copy-assemblies).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="/dotnet/framework/app-domains/shadow-copy-assemblies">Erstellen von Schattenkopien von Assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetFrameworkName As String" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); };" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string" Usage="System.AppDomainSetup.TargetFrameworkName" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string with get, set" Usage="System.AppDomainSetup.TargetFrameworkName" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Zeichenfolge ab oder legt diese fest, die die Zielversion und das Profil von .NET Framework für die Anwendungsdomäne festlegt, in einem Format, das vom <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" />-Konstruktor analysiert werden kann.</summary>
        <value>Die Zielversion und das Profil des .NET Framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft fest, um die derzeit laufende Version des .NET Framework zu informieren, dass die Anwendungsdomäne zum Laden und Ausführen von Assemblys verwendet wird, die für die Zielversion und das Profil kompiliert wurden. Wenn die aktuell laufende Version der .NET Framework optionale Verhalten aufweist, die sich auf die Kompatibilität von Code auswirken, der mit der Zielversion kompiliert wurde, können Sie diese Verhalten entsprechend aktivieren oder deaktivieren, um die Kompatibilität zu verbessern. Dies kann hilfreich sein, wenn eine Anwendung Add-Ins unterstützt, die mit mehreren Versionen der .NET Framework kompiliert wurden, indem Sie in separaten Anwendungs Domänen ausgeführt werden.  
  
 Bei Client Anwendungen wird der Wert der- <xref:System.AppDomainSetup.TargetFrameworkName%2A> Eigenschaft aus dem-Attribut abgeleitet <xref:System.Runtime.Versioning.TargetFrameworkAttribute> . In [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] und höher wird dieses Attribut automatisch basierend auf der Einstellung der **Ziel Framework** -Eigenschaft des Projekts der Assembly hinzugefügt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
