<Type Name="Decimal" FullName="System.Decimal">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="21d399bb6ab16180910e704f47a0a42624bfa5f7" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34255413" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Decimal : IComparable, IComparable&lt;decimal&gt;, IConvertible, IEquatable&lt;decimal&gt;, IFormattable, System.Runtime.Serialization.IDeserializationCallback" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Decimal extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Decimal&gt;, class System.IConvertible, class System.IEquatable`1&lt;valuetype System.Decimal&gt;, class System.IFormattable, class System.Runtime.Serialization.IDeserializationCallback" />
  <TypeSignature Language="DocId" Value="T:System.Decimal" />
  <TypeSignature Language="VB.NET" Value="Public Structure Decimal&#xA;Implements IComparable, IComparable(Of Decimal), IConvertible, IDeserializationCallback, IEquatable(Of Decimal), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Decimal : IComparable, IComparable&lt;System::Decimal&gt;, IConvertible, IEquatable&lt;System::Decimal&gt;, IFormattable, System::Runtime::Serialization::IDeserializationCallback" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Decimal&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Decimal&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Dezimalzahl dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal> Werttyp stellt Dezimalzahlen im Bereich von 79,228,162,514,264,337,593,543,950,335 bis-79,228,162,514,264,337,593,543,950,335 dar. Der Standardwert von einer `Decimal` ist 0. Die <xref:System.Decimal> Werttyp eignet sich für finanzielle Berechnungen, die eine große Anzahl von signifikanten ganzheitlichen Zahlen sowie Nachkommastellen Ziffern und keine Rundungsfehler erfordern. Die <xref:System.Decimal> Typ nicht beseitigt die Notwendigkeit für die Rundung. Stattdessen wird es durch runden Fehler minimiert. Der folgende Code erzeugt z. B. ein Ergebnis von 0.9999999999999999999999999999 anstatt 1.  
  
 [!code-cpp[System.Decimal.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Class/cpp/decimal1.cpp#1)]
 [!code-csharp[System.Decimal.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Class/cs/DecimalDivision_46630_1.cs#1)]
 [!code-vb[System.Decimal.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Class/vb/DecimalDivision_46630_1.vb#1)]  
  
 Wenn das Ergebnis der Multiplikation und Division übergeben wird, um die <xref:System.Math.Round%2A> -Methode, das Ergebnis leidet kein Verlust der Genauigkeit, wie im folgenden Code gezeigt.  
  
 [!code-cpp[System.Decimal.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Class/cpp/decimal2.cpp#2)]
 [!code-csharp[System.Decimal.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Class/cs/DecimalDivision_46630_1.cs#2)]
 [!code-vb[System.Decimal.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Class/vb/DecimalDivision_46630_1.vb#2)]  
  
 Eine Dezimalzahl ist, ein Gleitkommawert, der ein Zeichen besteht, einen numerischen Wert, in dem jede Ziffer im Wert von 0 bis 9 reicht, und ein Skalierungsfaktor, der die Position eines Gleitkommatyps Dezimalstellen angibt, die die ganzheitlichen Zahlen sowie Nachkommastellen Teile des trennt die der numerische Wert.  
  
 Die binäre Darstellung von einem <xref:System.Decimal> Wert besteht aus einem 1-Bit-Zeichen, einer 96-Bit-Ganzzahl und ein Skalierungsfaktor, der zum Dividieren der 96-Bit-Ganzzahl und angeben, welcher Teil ein Dezimalbruch ist. Der Skalierungsfaktor ist implizit die Zahl 10 potenziert mit einem Exponenten zwischen 0 und 28. Aus diesem Grund die binäre Darstellung von einer <xref:System.Decimal> Wert des Formulars ((-2<sup>96</sup> auf 2<sup>96</sup>) / 10<sup>(0 bis 28)</sup>), wobei-(2<sup>96</sup>-1) ist gleich <xref:System.Decimal.MinValue>, und 2<sup>96</sup>-1 ist gleich <xref:System.Decimal.MaxValue>. Weitere Informationen zu der binären Darstellung des <xref:System.Decimal> Werte und ein Beispiel finden Sie unter der <xref:System.Decimal.%23ctor%28System.Int32%5B%5D%29> Konstruktor und die <xref:System.Decimal.GetBits%2A> Methode.  
  
 Der Skalierungsfaktor auch beibehalten, nachfolgende Nullen in, einer <xref:System.Decimal> Anzahl. Nachfolgende Nullen wirken sich nicht auf den Wert des einem <xref:System.Decimal> Anzahl der in arithmetischen oder Vergleichsoperationen. Allerdings nachfolgende Nullen möglicherweise eingeblendet werden, indem die <xref:System.Decimal.ToString%2A> Methode, wenn eine Zeichenfolge für die Kultur spezifische Format angewendet wird.  
  
## <a name="conversion-considerations"></a>Konvertierung Überlegungen  
 Dieser Typ bietet Methoden, die konvertiert <xref:System.Decimal> -Werte in und aus <xref:System.SByte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.Byte>, <xref:System.UInt16>, <xref:System.UInt32>, und <xref:System.UInt64> Werte. Konvertierungen von diesen ganzzahligen Typen zu <xref:System.Decimal> sind erweiternde Konvertierungen, die nie Informationen verloren gehen oder Ausnahmen auslösen.  
  
 Konvertierungen von <xref:System.Decimal> auf eines der ganzzahligen Typen werden einschränkende Konvertierungen, die gerundet wird, die <xref:System.Decimal> Wert auf die nächste ganze Zahl in Richtung 0 (null). In einigen Sprachen, wie z. B. c#, unterstützt auch die Konvertierung von <xref:System.Decimal> Werte <xref:System.Char> Werte. Wenn das Ergebnis dieser Konvertierungen in den Zieltyp dargestellt werden, kann ein <xref:System.OverflowException> Ausnahme wird ausgelöst.  
  
 Die <xref:System.Decimal> Typ bietet auch Methoden, die konvertiert <xref:System.Decimal> -Werte in und aus <xref:System.Single> und <xref:System.Double> Werte. Konvertierungen von <xref:System.Decimal> auf <xref:System.Single> oder <xref:System.Double> einschränkende Konvertierungen, die Genauigkeit jedoch keine Informationen über das Ausmaß des konvertierten Werts verloren gehen können. Die Konvertierung löst keine Ausnahme aus.  
  
 Konvertierungen von <xref:System.Single> oder <xref:System.Double> auf <xref:System.Decimal> Auslösen einer <xref:System.OverflowException> -Ausnahme aus, wenn das Ergebnis der Konvertierung als dargestellt werden kann eine <xref:System.Decimal>.  
  
## <a name="performing-operations-on-decimal-values"></a>Ausführen von Vorgängen für Dezimalwerte  
 Die <xref:System.Decimal> Typ unterstützt die standardmäßige mathematische Operationen wie Addition, Subtraktion, Division, Multiplikation und unäre Negation. Sie können auch direkt mit der binären Darstellung des arbeiten ein <xref:System.Decimal> -Wert durch Aufrufen der <xref:System.Decimal.GetBits%2A> Methode.  
  
 Um zwei <xref:System.Decimal> Werte, können Sie die standardmäßigen numerischen Vergleichsoperatoren, oder Sie können rufen Sie die <xref:System.Decimal.CompareTo%2A> oder <xref:System.Decimal.Equals%2A> Methode.  
  
 Sie können auch aufrufen, die Mitglieder der <xref:System.Math> -Klasse, eine Breite Palette von numerischen Vorgänge, z. B. Abrufen der Absolute Wert einer Zahl, die den maximalen oder minimalen Wert von zwei zu bestimmen <xref:System.Decimal> Werte, die die Vorzeichen einer Zahl abrufen und Rundung eine Zahl.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Decimal>.  
  
 [!code-cpp[Decimal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Decimal Example/CPP/source.cpp#1)]
 [!code-csharp[Decimal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Decimal Example/CS/source.cs#1)]
 [!code-vb[Decimal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Decimal Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle Member dieses Typs sind threadsicher. Elemente, die angezeigt werden, so ändern Sie den Zustand der Instanz zurückgeben tatsächlich eine neue Instanz mit dem neuen Wert initialisiert. Als müssen mit einem beliebigen anderen Typ Lesen und Schreiben in eine freigegebene Variable, die eine Instanz dieses Typs enthält durch ein Schloss auf Threadsicherheit geschützt werden.</threadsafe>
    <altmember cref="T:System.SByte" />
    <altmember cref="T:System.Int16" />
    <altmember cref="T:System.Int32" />
    <altmember cref="T:System.Int64" />
    <altmember cref="T:System.Byte" />
    <altmember cref="T:System.UInt16" />
    <altmember cref="T:System.UInt32" />
    <altmember cref="T:System.UInt64" />
    <altmember cref="T:System.Single" />
    <altmember cref="T:System.Double" />
    <altmember cref="T:System.Char" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz von <see cref="T:System.Decimal" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Decimal(double value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Der als <see cref="T:System.Decimal" /> darzustellende Wert.</param>
        <summary>Initialisiert eine neue Instanz von <see cref="T:System.Decimal" /> mit dem Wert der angegebenen Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor rundet `value` auf 15 signifikante Ziffern, die den nächsten. Dies geschieht auch, wenn die Zahl über mehr als 15 Ziffern verfügt und die weniger signifikante Ziffern 0 (null sind).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt mehrere `Decimal` Zahlen mithilfe der Überladung des Konstruktors, der initialisiert einen `Decimal` Struktur mit einem <xref:System.Double> Wert.  
  
 [!code-cpp[System.Decimal.Ctor.Reals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Reals/CPP/ctordo.cpp#2)]
 [!code-csharp[System.Decimal.Ctor.Reals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Reals/CS/ctordo.cs#2)]
 [!code-vb[System.Decimal.Ctor.Reals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Reals/VB/ctordo.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist größer als <see cref="F:System.Decimal.MaxValue" /> oder kleiner als <see cref="F:System.Decimal.MinValue" />.  Oder:  <paramref name="value" /> ist <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> oder <see cref="F:System.Double.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Decimal(int value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der als <see cref="T:System.Decimal" /> darzustellende Wert.</param>
        <summary>Initialisiert eine neue Instanz von <see cref="T:System.Decimal" /> mit dem Wert einer angegebenen 32-Bit-Ganzzahl mit Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel erstellt mehrere `Decimal` Zahlen mithilfe der Überladung des Konstruktors, der initialisiert einen `Decimal` Struktur mit einem <xref:System.Int32> Wert.  
  
 [!code-cpp[System.Decimal.Ctor.Ints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CPP/ctori.cpp#1)]
 [!code-csharp[System.Decimal.Ctor.Ints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CS/ctori.cs#1)]
 [!code-vb[System.Decimal.Ctor.Ints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/VB/ctori.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (int[] bits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32[] bits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bits As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Decimal(cli::array &lt;int&gt; ^ bits);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bits" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="bits">Eine Array von 32-Bit-Ganzzahlen mit Vorzeichen, das eine Darstellung eines Decimal-Werts enthält.</param>
        <summary>Initialisiert eine neue Instanz von <see cref="T:System.Decimal" /> mit einem binär dargestellten Decimal-Wert in einem angegebenen Array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die binäre Darstellung von einem <xref:System.Decimal> Anzahl besteht aus einem 1-Bit-Zeichen, einer 96-Bit-Ganzzahl und ein Skalierungsfaktor verwendet, um die ganze Zahl aufteilen und angeben, welcher Teil ein Dezimalbruch ist. Der Skalierungsfaktor ist implizit die Zahl 10 potenziert mit einem Exponenten zwischen 0 und 28.  
  
 `bits` ist ein Array von 32-Bit-Ganzzahlen mit Vorzeichen, das aus vier Elementen besteht.  
  
 `bits` [0], `bits` [1], und `bits` [2] enthalten die geringe, mittlere und hohe 32 Bits der 96-Bit-Ganzzahl.  
  
 `bits` [3] enthält den Skalierungsfaktor und das Vorzeichen und besteht aus folgenden Teilen:  
  
 Bits 0 bis 15, das niederwertige Wort, werden nicht verwendet und müssen 0 (null) sein.  
  
 Bits 16 bis 23 darf einen Exponenten zwischen 0 und 28, womit die Leistungsfähigkeit von 10, um die ganze Zahl zu unterteilen.  
  
 Bits 24 bis 30 werden nicht verwendet und müssen 0 (null) sein.  
  
 Bit enthält 31 die Vorzeichen. 0 Bedeutung Positive und Negative 1 bedeutet.  
  
 Ein numerischer Wert möglicherweise mehrere mögliche binäre Darstellungen; Alle sind gleichermaßen gültig und numerisch entspricht. Beachten Sie, dass die bitdarstellung zwischen 0 (null) negativen und positiven unterscheidet. Diese Werte werden als wird in alle Vorgänge gleich behandelt.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt mehrere `Decimal` Zahlen mithilfe der Überladung des Konstruktors, der initialisiert einen `Decimal` Struktur mit einem Array von vier <xref:System.Int32> Werte.  
  
 [!code-cpp[System.Decimal.Ctor.Arrays#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Arrays/CPP/ctoriarr.cpp#1)]
 [!code-csharp[System.Decimal.Ctor.Arrays#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Arrays/CS/ctoriarr.cs#1)]
 [!code-vb[System.Decimal.Ctor.Arrays#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Arrays/VB/ctoriarr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bits" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="bits" /> ist nicht 4.  Oder:  Die Darstellung des Dezimalwerts in <paramref name="bits" /> ist ungültig.</exception>
        <altmember cref="M:System.Decimal.GetBits(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Decimal(long value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Der als <see cref="T:System.Decimal" /> darzustellende Wert.</param>
        <summary>Initialisiert eine neue Instanz von <see cref="T:System.Decimal" /> mit dem Wert einer angegebenen 64-Bit-Ganzzahl mit Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel erstellt mehrere `Decimal` Zahlen mithilfe der Überladung des Konstruktors, der initialisiert einen `Decimal` Struktur mit einem <xref:System.Int64> Wert.  
  
 [!code-cpp[System.Decimal.Ctor.Ints#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CPP/ctorl.cpp#3)]
 [!code-csharp[System.Decimal.Ctor.Ints#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CS/ctorl.cs#3)]
 [!code-vb[System.Decimal.Ctor.Ints#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/VB/ctorl.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Decimal(float value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Der als <see cref="T:System.Decimal" /> darzustellende Wert.</param>
        <summary>Initialisiert eine neue Instanz von <see cref="T:System.Decimal" /> mit dem Wert der angegebenen Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor rundet `value` auf 7 signifikante Stellen den nächsten. Dies geschieht auch, wenn die Zahl mehr als 7 Dezimalstellen hat und weniger signifikanten Stellen 0 (null sind).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt mehrere `Decimal` Zahlen mithilfe der Überladung des Konstruktors, der initialisiert einen `Decimal` Struktur mit einem <xref:System.Single> Wert.  
  
 [!code-cpp[System.Decimal.Ctor.Reals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Reals/CPP/ctors.cpp#1)]
 [!code-csharp[System.Decimal.Ctor.Reals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Reals/CS/ctors.cs#1)]
 [!code-vb[System.Decimal.Ctor.Reals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Reals/VB/ctors.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist größer als <see cref="F:System.Decimal.MaxValue" /> oder kleiner als <see cref="F:System.Decimal.MinValue" />.  Oder:  <paramref name="value" /> ist <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Decimal(System::UInt32 value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Der als <see cref="T:System.Decimal" /> darzustellende Wert.</param>
        <summary>Initialisiert eine neue Instanz von <see cref="T:System.Decimal" /> mit dem Wert einer angegebenen 32-Bit-Ganzzahl ohne Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel erstellt mehrere `Decimal` Zahlen mithilfe der Überladung des Konstruktors, der initialisiert einen `Decimal` Struktur mit einem <xref:System.UInt32> Wert.  
  
 [!code-cpp[System.Decimal.Ctor.Ints#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CPP/ctorui.cpp#2)]
 [!code-csharp[System.Decimal.Ctor.Ints#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CS/ctorui.cs#2)]
 [!code-vb[System.Decimal.Ctor.Ints#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/VB/ctorui.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Decimal(System::UInt64 value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Der als <see cref="T:System.Decimal" /> darzustellende Wert.</param>
        <summary>Initialisiert eine neue Instanz von <see cref="T:System.Decimal" /> mit dem Wert einer angegebenen 64-Bit-Ganzzahl ohne Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel erstellt mehrere `Decimal` Zahlen mithilfe der Überladung des Konstruktors, der initialisiert einen `Decimal` Struktur mit einem <xref:System.UInt64> Wert.  
  
 [!code-cpp[System.Decimal.Ctor.Ints#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CPP/ctorul.cpp#4)]
 [!code-csharp[System.Decimal.Ctor.Ints#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CS/ctorul.cs#4)]
 [!code-vb[System.Decimal.Ctor.Ints#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/VB/ctorul.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (int lo, int mid, int hi, bool isNegative, byte scale);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 lo, int32 mid, int32 hi, bool isNegative, unsigned int8 scale) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (lo As Integer, mid As Integer, hi As Integer, isNegative As Boolean, scale As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Decimal(int lo, int mid, int hi, bool isNegative, System::Byte scale);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="lo" Type="System.Int32" />
        <Parameter Name="mid" Type="System.Int32" />
        <Parameter Name="hi" Type="System.Int32" />
        <Parameter Name="isNegative" Type="System.Boolean" />
        <Parameter Name="scale" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="lo">Die unteren 32 Bit einer 96-Bit-Ganzzahl.</param>
        <param name="mid">Die mittleren 32 Bit einer 96-Bit-Ganzzahl.</param>
        <param name="hi">Die oberen 32 Bit einer 96-Bit-Ganzzahl.</param>
        <param name="isNegative">
          <see langword="true" />, um eine negative Zahl anzugeben; <see langword="false" />, um eine positive Zahl anzugeben.</param>
        <param name="scale">Eine Zehnerpotenz mit einem Exponenten zwischen 0 (null) und 28.</param>
        <summary>Initialisiert einen neue Instanz von <see cref="T:System.Decimal" /> mit Parametern, die die Bestandteile der Instanz angeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die binäre Darstellung von einem <xref:System.Decimal> Anzahl besteht aus einem 1-Bit-Zeichen, einer 96-Bit-Ganzzahl und ein Skalierungsfaktor verwendet, um die ganze Zahl aufteilen und angeben, welcher Teil ein Dezimalbruch ist. Der Skalierungsfaktor ist implizit die Zahl 10 potenziert mit einem Exponenten zwischen 0 und 28.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt mehrere `Decimal` Zahlen mithilfe der Überladung des Konstruktors, der initialisiert einen `Decimal` Struktur mit drei <xref:System.Int32> Wert Wörter, eine <xref:System.Boolean> anmelden, und ein <xref:System.Byte> Skalierungsfaktor.  
  
 [!code-cpp[System.Decimal.Ctor.Arrays#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Arrays/CPP/ctoriiibby.cpp#2)]
 [!code-csharp[System.Decimal.Ctor.Arrays#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Arrays/CS/ctoriiibby.cs#2)]
 [!code-vb[System.Decimal.Ctor.Arrays#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Arrays/VB/ctoriiibby.vb#2)]  
  
 Im folgenden Beispiel wird die <xref:System.Decimal.GetBits%2A> Methode, um die Komponenten eines Arrays abzurufen. Es verwendet dann dieses Array im Aufruf der <xref:System.Decimal.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Byte%29> Konstruktor zum Instanziieren einer neuen <xref:System.Decimal> Wert.  
  
 [!code-csharp[System.Decimal.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.ctor/cs/ctor2a.cs#1)]
 [!code-vb[System.Decimal.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.ctor/vb/ctor2a.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="scale" /> ist größer als 28.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static decimal Add (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Add(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Add(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Add(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Der erste zu addierende Wert.</param>
        <param name="d2">Der zweite zu addierende Wert.</param>
        <summary>Addiert zwei angegebene <see cref="T:System.Decimal" />-Werte.</summary>
        <returns>Die Summe von <paramref name="d1" /> und <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das folgende Codebeispiel veranschaulicht die Verwendung von `Add` :  
  
 [!code-cpp[Decimal Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Decimal Example/CPP/source.cpp#5)]
 [!code-csharp[Decimal Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Decimal Example/CS/source.cs#5)]
 [!code-vb[Decimal Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Decimal Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Die Summe von <paramref name="d1" /> und <paramref name="d2" /> ist kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Subtract(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Multiply(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Divide(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static decimal Ceiling (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Ceiling(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Ceiling(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Ceiling(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Eine Dezimalzahl.</param>
        <summary>Gibt den kleinsten ganzzahligen Wert zurück, der größer oder gleich der angegebenen Dezimalzahl ist.</summary>
        <returns>Der kleinste ganzzahlige Wert, der größer oder gleich dem <paramref name="d" />-Parameter ist. Beachten Sie, dass diese Methode einen <see cref="T:System.Decimal" /> anstelle eines ganzzahligen Typs zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten dieser Methode folgt Standard IEEE-754, Abschnitt 4. Diese Art von Rundung wird manchmal bezeichnet runden in Richtung plus unendlich. Das heißt, wenn `d` positiv ist, wird das Vorhandensein von jeder Nachkommawert Ursachen `d` auf die nächsthöhere ganze Zahl gerundet werden. Wenn `d` ist negativ, Rundung bewirkt, dass alle Nachkommawert von `d` verworfen werden. Die Ausführung von dieser Methode unterscheidet sich von der <xref:System.Decimal.Floor%2A> -Methode, die runden in Richtung minus unendlich unterstützt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Decimal.Ceiling%2A> Methode und Unterschiede aufgezeigt, mit der <xref:System.Decimal.Floor%2A> Methode.  
  
 [!code-csharp[System.Decimal.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ceiling/cs/ceiling1.cs#1)]
 [!code-vb[System.Decimal.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Decimal.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (d1 As Decimal, d2 As Decimal) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Der erste zu vergleichende Wert.</param>
        <param name="d2">Der zweite zu vergleichende Wert.</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.Decimal" />-Werte.</summary>
        <returns>Eine Zahl mit Vorzeichen, die die relativen Werte von <paramref name="d1" /> und <paramref name="d2" /> angibt.  
  
 <list type="table"><listheader><term> Rückgabewert  </term><description> Bedeutung  </description></listheader><item><term> Kleiner als 0 (null)  </term><description><paramref name="d1" /> ist kleiner als <paramref name="d2" />.  </description></item><item><term> 0 (null)  </term><description><paramref name="d1" /> und <paramref name="d2" /> sind gleich.  </description></item><item><term> Größer als 0 (null)  </term><description><paramref name="d1" /> ist größer als <paramref name="d2" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel werden mehrere <xref:System.Decimal> Werte. Beachten Sie, die die erste Vergleich gibt an, dass die beiden Werte gleich trotz der nachzufolgen Subtraktion sind die `value2` Variable. Grund hierfür ist die <xref:System.Decimal> Typ %expectedhash einer Genauigkeit von 29 Stellen ein Unterschied zwischen diesen beiden Werten nur mit 30 Dezimalstellen erkannt werden kann.  
  
 [!code-csharp[System.Decimal.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Decimal.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.CompareTo(System.Object)" />
        <altmember cref="M:System.Decimal.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt oder <see cref="T:System.Decimal" /> und gibt eine Angabe über das Verhältnis der entsprechenden Werte zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.CompareTo(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Decimal) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Das Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen <see cref="T:System.Decimal" />-Objekt und gibt einen Vergleich der entsprechenden Werte zurück.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verhältnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term> Rückgabewert  </term><description> Bedeutung  </description></listheader><item><term> Kleiner als 0 (null)  </term><description> Diese Instanz ist kleiner als <paramref name="value" />.  </description></item><item><term> 0 (null)  </term><description> Diese Instanz ist gleich <paramref name="value" />.  </description></item><item><term> Größer als 0 (null)  </term><description> Diese Instanz ist größer als <paramref name="value" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> Schnittstelle und führt etwas bessere Leistung als die <xref:System.Decimal.CompareTo%2A?displayProperty=nameWithType> Methode, da sie keinen konvertieren die `value` Parameter für ein Objekt.  
  
 Abhängig von der Programmiersprache, ist es eventuell möglich, Code eine <xref:System.Decimal.CompareTo%2A> Methode, in dem der Parametertyp weniger Bits aufweist (schmaler ist) als der Instanztyp. Dies ist möglich, da einige Programmiersprachen eine implizite erweiternde Konvertierung durchführt, die den Parameter als einen Typ mit wie vielen Bits wie die Instanz darstellt.  
  
 Nehmen wir beispielsweise an, die der Typ ist <xref:System.Int32> und der Parametertyp ist <xref:System.Byte>. Microsoft C#-Compiler generiert eine Anleitung zur Darstellung des Parameters als ein <xref:System.Int32> -Objekt, und generiert dann eine <xref:System.Int32.CompareTo%2A?displayProperty=nameWithType> Methode, um die Werte von Vergleichen die <xref:System.Int32> Instanz und die <xref:System.Int32> Parameter Darstellung.  
  
 Ihre Programmiersprache Dokumentation, um festzustellen, ob der Compiler implizite erweiternde Konvertierungen für numerische Typen ausführt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, generische und nicht generische Versionen der <xref:System.Decimal.CompareTo%2A> Methode für verschiedene Wert- und Referenztypen.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das Objekt, das mit dieser Instanz verglichen werden soll, oder <see langword="null" />.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt und gibt einen Vergleich der entsprechenden Werte zurück.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verhältnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term> Rückgabewert  </term><description> Bedeutung  </description></listheader><item><term> Kleiner als 0 (null)  </term><description> Diese Instanz ist kleiner als <paramref name="value" />.  </description></item><item><term> 0 (null)  </term><description> Diese Instanz ist gleich <paramref name="value" />.  </description></item><item><term> Größer als 0 (null)  </term><description> Diese Instanz ist größer als <paramref name="value" />.  Oder:  <paramref name="value" /> ist <see langword="null" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede Instanz von <xref:System.Decimal>, unabhängig vom Wert wird als größer betrachtet `null`.  
  
 Parameter `value` muss `null` oder einer Instanz von <xref:System.Decimal>ist, andernfalls wird eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird vergleicht verschiedene `Decimal` und andere Objekte als Verweis `Decimal` mithilfe der `CompareTo` Methode.  
  
 [!code-cpp[System.Decimal.Compare_Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/CPP/cto_eq_obj.cpp#1)]
 [!code-csharp[System.Decimal.Compare_Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/CS/cto_eq_obj.cs#1)]
 [!code-vb[System.Decimal.Compare_Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/VB/cto_eq_obj.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> ist keine <see cref="T:System.Decimal" />.</exception>
        <altmember cref="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static decimal Divide (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Divide(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Divide(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Divide(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Der Dividend.</param>
        <param name="d2">Der Divisor.</param>
        <summary>Dividiert zwei angegebene <see cref="T:System.Decimal" />-Werte.</summary>
        <returns>Das Ergebnis der Division von <paramref name="d1" /> durch <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Decimal.Divide%2A> Methode, um einen Bereich von Werten durch 22.1 dividieren.  
  
 [!code-csharp[System.Decimal.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Decimal.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="d2" /> ist 0 (null).</exception>
        <exception cref="T:System.OverflowException">Der Rückgabewert (d. h. der Quotient) ist kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Add(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Subtract(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Multiply(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei Instanzen der <see cref="T:System.Decimal" />-Struktur denselben Wert darstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Equals(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Ein mit dieser Instanz zu vergleichendes Objekt.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz und ein angegebenes <see cref="T:System.Decimal" />-Objekt den gleichen Wert darstellen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="value" /> gleich dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die <xref:System.IEquatable%601?displayProperty=nameWithType> Schnittstelle, und führt etwas bessere Leistung als <xref:System.Decimal.Equals%2A> , da sie keinen konvertieren die `value` Parameter für ein Objekt.  
  
 Wenn `value` weniger Bits aufweist (schmaler ist) als den Instanztyp aus, führen einige Programmiersprachen eine implizite erweiternde Konvertierung, die den Wert des Parameters in einen Wert mit mehr Bits transformiert.  
  
 Nehmen wir beispielsweise an, die der Typ ist <xref:System.Int32> und der Parametertyp ist <xref:System.Byte>. Microsoft C#-Compiler generiert Anweisungen, um die Darstellung des Werts des Parameters als ein <xref:System.Int32> -Objekt, und generiert dann eine <xref:System.Int32.CompareTo%2A?displayProperty=nameWithType> Methode zum Vergleichen der <xref:System.Int32> Instanz und die Parameter-Darstellung.  
  
 Ihre Programmiersprache Dokumentation, um festzustellen, ob der Compiler implizite erweiternde Konvertierungen für numerische Typen ausführt.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Compilerfehler überladungsauflösung gelten möglicherweise für einen sichtbaren Unterschied im Verhalten der beiden Konto <see cref="M:System.Decimal.Equals(System.Object)" /> Überladungen der Methode. Wenn eine implizite Konvertierung zwischen den <paramref name="obj" /> Argument und eine <see cref="T:System.Decimal" /> definiert ist und das Argument als nicht typisiert ist ein <see cref="T:System.Object" />, Compilern möglicherweise führen Sie eine implizite Konvertierung und rufen die <see cref="M:System.Decimal.Equals(System.Decimal)" /> Methode. Rufen sie Sie andernfalls die <see cref="M:System.Decimal.Equals(System.Object)" /> Methode, die immer zurückgibt <see langword="false" /> wenn seine <paramref name="obj" /> Argument ist ein <see cref="T:System.Decimal" /> Wert. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen zwei methodenüberladungen. Im Fall von alle primitiven ganzzahligen Typen ist, u. a. signiert und Typen ohne Vorzeichen, gibt der erste Vergleich <see langword="true" /> , da der Compiler automatisch eine erweiternde Konvertierung und ruft führt die <see cref="M:System.Decimal.Equals(System.Decimal)" /> -Methode, während die zweite Vergleich gibt <see langword="false" /> , da der Compiler Ruft die <see cref="M:System.Decimal.Equals(System.Object)" /> Methode.  [! code-csharp[System.Decimal.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.equals/cs/equalsoverl.cs#2)] [! code-vb[System.Decimal.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Decimal.Equals(System.Object)" />
        <altmember cref="Overload:System.Decimal.CompareTo" />
        <altmember cref="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz und ein angegebenes <see cref="T:System.Object" /> denselben Typ und Wert darstellen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="value" /> ein <see cref="T:System.Decimal" /> und gleich dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird vergleicht verschiedene `Decimal` und andere Objekte als Verweis `Decimal` mithilfe der `Equals` Methode.  
  
 [!code-cpp[System.Decimal.Compare_Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/CPP/cto_eq_obj.cpp#1)]
 [!code-csharp[System.Decimal.Compare_Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/CS/cto_eq_obj.cs#1)]
 [!code-vb[System.Decimal.Compare_Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/VB/cto_eq_obj.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Compilerfehler überladungsauflösung gelten möglicherweise für einen sichtbaren Unterschied im Verhalten der beiden Konto <see cref="M:System.Decimal.Equals(System.Object)" /> Überladungen der Methode. Wenn eine implizite Konvertierung zwischen den <paramref name="obj" /> Argument und eine <see cref="T:System.Decimal" /> definiert ist und das Argument als nicht typisiert ist ein <see cref="T:System.Object" />, Compilern möglicherweise führen Sie eine implizite Konvertierung und rufen die <see cref="M:System.Decimal.Equals(System.Decimal)" /> Methode. Rufen sie Sie andernfalls die <see cref="M:System.Decimal.Equals(System.Object)" /> Methode, die immer zurückgibt <see langword="false" /> wenn seine <paramref name="obj" /> Argument ist ein <see cref="T:System.Decimal" /> Wert. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen zwei methodenüberladungen. Im Fall von alle primitiven ganzzahligen Typen ist, u. a. signiert und Typen ohne Vorzeichen, gibt der erste Vergleich <see langword="true" /> , da der Compiler automatisch eine erweiternde Konvertierung und ruft führt die <see cref="M:System.Decimal.Equals(System.Decimal)" /> -Methode, während die zweite Vergleich gibt <see langword="false" /> , da der Compiler Ruft die <see cref="M:System.Decimal.Equals(System.Object)" /> Methode.  [! code-csharp[System.Decimal.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.equals/cs/equalsoverl.cs#2)] [! code-vb[System.Decimal.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Equals(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (d1 As Decimal, d2 As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Der erste zu vergleichende Wert.</param>
        <param name="d2">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei angegebene Instanzen von <see cref="T:System.Decimal" /> denselben Wert darstellen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="d1" /> und <paramref name="d2" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird vergleicht verschiedene `Decimal` Werte auf einen Verweis `Decimal` mithilfe der statischen `Equals` Methode.  
  
 [!code-cpp[System.Decimal.Compare_Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/CPP/comp_equal.cpp#2)]
 [!code-csharp[System.Decimal.Compare_Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/CS/comp_equal.cs#2)]
 [!code-vb[System.Decimal.Compare_Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/VB/comp_equal.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static decimal Floor (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Floor(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Floor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Floor(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Der zu rundende Wert.</param>
        <summary>Rundet eine angegebene <see cref="T:System.Decimal" />-Zahl auf die nächste Ganzzahl in Richtung minus unendlich.</summary>
        <returns>Wenn <paramref name="d" /> einen Teil mit Bruchzahlen enthält, die nächste ganze <see cref="T:System.Decimal" />-Zahl in Richtung minus unendlich, die kleiner als <paramref name="d" /> ist.  Oder:  Wenn <paramref name="d" /> keinen Bruchteil hat, wird <paramref name="d" /> unverändert zurückgegeben. Beachten Sie, dass die Methode einen Ganzzahlwert vom Typ <see cref="T:System.Decimal" /> zurückgibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten dieser Methode folgt Standard IEEE-754, Abschnitt 4. Diese Art von Rundung wird manchmal bezeichnet runden in Richtung minus unendlich. Das heißt, wenn `d` positiv ist, alle Nachkommawert wird abgeschnitten. Wenn `d` ist negativ ist, das Vorhandensein von jeder Nachkommawert bewirkt, dass es auf die nächste ganze Zahl gerundet. Die Ausführung von dieser Methode unterscheidet sich von der <xref:System.Decimal.Ceiling%2A> -Methode, die Rundung in Richtung plus unendlich unterstützt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Decimal.Floor%2A> Methode und Unterschiede aufgezeigt, mit der <xref:System.Decimal.Ceiling%2A> Methode.  
  
 [!code-csharp[System.Decimal.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ceiling/cs/ceiling1.cs#1)]
 [!code-vb[System.Decimal.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32)" />
        <altmember cref="M:System.Decimal.Truncate(System.Decimal)" />
        <altmember cref="M:System.Decimal.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="FromOACurrency">
      <MemberSignature Language="C#" Value="public static decimal FromOACurrency (long cy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal FromOACurrency(int64 cy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.FromOACurrency(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromOACurrency (cy As Long) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal FromOACurrency(long cy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cy" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="cy">Ein Currency-Wert für OLE Automation.</param>
        <summary>Konvertiert die angegebene 64-Bit-Ganzzahl mit Vorzeichen, die einen Currency-Wert für OLE-Automatisierung enthält, in den entsprechenden <see cref="T:System.Decimal" />-Wert.</summary>
        <returns>Ein <see cref="T:System.Decimal" />-Wert, der die Entsprechung von <paramref name="cy" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird mit der `FromOACurrency` -Methode zum Konvertieren <xref:System.Int64> Felder, die OLE-Automatisierung Currency-Werte in die entsprechende enthalten `Decimal` Zahlen.  
  
 [!code-cpp[System.Decimal.OACurrency#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.OACurrency/CPP/fromoacurrency.cpp#2)]
 [!code-csharp[System.Decimal.OACurrency#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.OACurrency/CS/fromoacurrency.cs#2)]
 [!code-vb[System.Decimal.OACurrency#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.OACurrency/VB/fromoacurrency.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.ToOACurrency(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="GetBits">
      <MemberSignature Language="C#" Value="public static int[] GetBits (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32[] GetBits(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.GetBits(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBits (d As Decimal) As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;int&gt; ^ GetBits(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Der zu konvertierende Wert.</param>
        <summary>Konvertiert den Wert einer angegebenen Instanz von <see cref="T:System.Decimal" /> in die entsprechende binäre Darstellung.</summary>
        <returns>Ein Array von 32-Bit-Ganzzahlen mit Vorzeichen mit vier Elementen, die die binäre Darstellung von <paramref name="d" /> enthalten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die binäre Darstellung von einem <xref:System.Decimal> Anzahl besteht aus einem 1-Bit-Zeichen, einer 96-Bit-Ganzzahl und ein Skalierungsfaktor verwendet, um die ganze Zahl aufteilen und angeben, welcher Teil ein Dezimalbruch ist. Der Skalierungsfaktor ist implizit die Zahl 10 potenziert mit einem Exponenten zwischen 0 und 28.  
  
 Der Rückgabewert ist ein Array von 32-Bit-Ganzzahlen mit Vorzeichen mit vier Elementen.  
  
 Das erste, zweite und dritte Element im zurückgegebenen Array enthalten die geringe, mittlere und hohe 32 Bits der 96-Bit-Ganzzahl.  
  
 Das vierte Element des zurückgegebenen Arrays enthält den Skalierungsfaktor und melden. Es besteht aus den folgenden Teilen:  
  
 Bits 0 bis 15, das niederwertige Wort, werden nicht verwendet und müssen 0 (null) sein.  
  
 Bits 16 bis 23 darf einen Exponenten zwischen 0 und 28, womit die Leistungsfähigkeit von 10, um die ganze Zahl zu unterteilen.  
  
 Bits 24 bis 30 werden nicht verwendet und müssen 0 (null) sein.  
  
 Bit 31 enthält das Vorzeichen: 0 bedeutet positive und 1 minus.  
  
 Beachten Sie, dass die bitdarstellung zwischen 0 (null) negativen und positiven unterscheidet. Diese Werte werden als wird in alle Vorgänge gleich behandelt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `GetBits` Methode, um mehrere konvertieren `Decimal` Werte in ihre entsprechenden binären Darstellungen. Es zeigt dann die Dezimalwerte und den hexadezimalen Wert der Elemente in das zurückgegebene Array die <xref:System.Decimal.GetBits%2A> Methode.  
  
 [!code-cpp[System.Decimal.Get_Bits_Hash_Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Get_Bits_Hash_Type/CPP/getbits.cpp#2)]
 [!code-csharp[System.Decimal.Get_Bits_Hash_Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Get_Bits_Hash_Type/CS/getbits.cs#2)]
 [!code-vb[System.Decimal.Get_Bits_Hash_Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Get_Bits_Hash_Type/VB/getbits.vb#2)]  
  
 Im folgenden Beispiel wird die <xref:System.Decimal.GetBits%2A> Methode, um die Komponenten eines Arrays abzurufen. Es verwendet dann dieses Array im Aufruf der <xref:System.Decimal.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Byte%29> Konstruktor zum Instanziieren einer neuen <xref:System.Decimal> Wert.  
  
 [!code-csharp[System.Decimal.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.ctor/cs/ctor2a.cs#1)]
 [!code-vb[System.Decimal.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.ctor/vb/ctor2a.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Decimal.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den <see cref="T:System.TypeCode" /> für den Werttyp <see cref="T:System.Decimal" /> zurück.</summary>
        <returns>Die Enumerationskonstante <see cref="F:System.TypeCode.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird mit der `GetTypeCode` -Methode zur Rückgabe des Typencode für `Decimal` Werttyp.  
  
 [!code-cpp[System.Decimal.Get_Bits_Hash_Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Get_Bits_Hash_Type/CPP/gettypecode.cpp#3)]
 [!code-csharp[System.Decimal.Get_Bits_Hash_Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Get_Bits_Hash_Type/CS/gettypecode.cs#3)]
 [!code-vb[System.Decimal.Get_Bits_Hash_Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Get_Bits_Hash_Type/VB/gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public static readonly decimal MaxValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Decimal MaxValue" />
      <MemberSignature Language="DocId" Value="F:System.Decimal.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxValue As Decimal " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Decimal MaxValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den größtmöglichen Wert von <see cref="T:System.Decimal" /> dar. Dieses Feld ist konstant und schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist positiven Wert 79,228,162,514,264,337,593,543,950,335.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von `MaxValue` :  
  
 [!code-cpp[Decimal Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Decimal Example/CPP/source.cpp#2)]
 [!code-csharp[Decimal Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Decimal Example/CS/source.cs#2)]
 [!code-vb[Decimal Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Decimal Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Decimal.Zero" />
        <altmember cref="F:System.Decimal.One" />
        <altmember cref="F:System.Decimal.MinusOne" />
        <altmember cref="F:System.Decimal.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static readonly decimal MinusOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Decimal MinusOne" />
      <MemberSignature Language="DocId" Value="F:System.Decimal.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinusOne As Decimal " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Decimal MinusOne;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt die Zahl -1 dar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der `MinusOne` Feld.  
  
 [!code-cpp[System.Decimal.Fields#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Fields/CPP/fields.cpp#1)]
 [!code-csharp[System.Decimal.Fields#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Fields/CS/fields.cs#1)]
 [!code-vb[System.Decimal.Fields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Fields/VB/fields.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Decimal.Zero" />
        <altmember cref="F:System.Decimal.One" />
        <altmember cref="F:System.Decimal.MaxValue" />
        <altmember cref="F:System.Decimal.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public static readonly decimal MinValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Decimal MinValue" />
      <MemberSignature Language="DocId" Value="F:System.Decimal.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinValue As Decimal " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Decimal MinValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den kleinstmöglichen Wert von <see cref="T:System.Decimal" /> dar. Dieses Feld ist konstant und schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist negativen Wert 79,228,162,514,264,337,593,543,950,335.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der `MinValue` Feld.  
  
 [!code-cpp[System.Decimal.Fields#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Fields/CPP/fields.cpp#1)]
 [!code-csharp[System.Decimal.Fields#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Fields/CS/fields.cs#1)]
 [!code-vb[System.Decimal.Fields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Fields/VB/fields.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Decimal.Zero" />
        <altmember cref="F:System.Decimal.One" />
        <altmember cref="F:System.Decimal.MinusOne" />
        <altmember cref="F:System.Decimal.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static decimal Multiply (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Multiply(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Multiply(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Multiply(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Der Multiplikand.</param>
        <param name="d2">Der Multiplikator.</param>
        <summary>Multipliziert zwei angegebene <see cref="T:System.Decimal" />-Werte.</summary>
        <returns>Das Ergebnis der Multiplikation von <paramref name="d1" /> und <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel erstellt mehrere Paare von `Decimal` Werte und berechnet die Produkte zu der `Multiply` Methode.  
  
 [!code-cpp[System.Decimal.Mul_Div_Rem#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Mul_Div_Rem/CPP/mul_div_rem.cpp#1)]
 [!code-csharp[System.Decimal.Mul_Div_Rem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Mul_Div_Rem/CS/mul_div_rem.cs#1)]
 [!code-vb[System.Decimal.Mul_Div_Rem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Mul_Div_Rem/VB/mul_div_rem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Rückgabewert ist kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Add(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Subtract(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Divide(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static decimal Negate (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Negate(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Negate(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Negate(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Der zu negierende Wert.</param>
        <summary>Gibt das Ergebnis der Multiplikation des angegebenen <see cref="T:System.Decimal" />-Werts mit -1 zurück.</summary>
        <returns>Eine Dezimalzahl mit dem Wert <paramref name="d" />, jedoch mit dem entgegen gesetzten Zeichen.  Oder:  Null, wenn <paramref name="d" /> null ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird mit der `Negate` Methode so ändern Sie die Vorzeichen von mehreren `Decimal` Werte.  
  
 [!code-cpp[System.Decimal.Flr_Neg_Rnd_Trnc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Flr_Neg_Rnd_Trnc/CPP/floor_neg_trunc.cpp#1)]
 [!code-csharp[System.Decimal.Flr_Neg_Rnd_Trnc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Flr_Neg_Rnd_Trnc/CS/floor_neg_trunc.cs#1)]
 [!code-vb[System.Decimal.Flr_Neg_Rnd_Trnc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Flr_Neg_Rnd_Trnc/VB/floor_neg_trunc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly decimal One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Decimal One" />
      <MemberSignature Language="DocId" Value="F:System.Decimal.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Decimal " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Decimal One;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt die Zahl 1 dar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der `One` Feld.  
  
 [!code-cpp[System.Decimal.Fields#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Fields/CPP/fields.cpp#1)]
 [!code-csharp[System.Decimal.Fields#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Fields/CS/fields.cs#1)]
 [!code-vb[System.Decimal.Fields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Fields/VB/fields.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Decimal.Zero" />
        <altmember cref="F:System.Decimal.MinusOne" />
        <altmember cref="F:System.Decimal.MaxValue" />
        <altmember cref="F:System.Decimal.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static decimal operator + (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Addition(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Addition(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal operator +(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Der erste zu addierende Wert.</param>
        <param name="d2">Der zweite zu addierende Wert.</param>
        <summary>Addiert zwei angegebene <see cref="T:System.Decimal" />-Werte.</summary>
        <returns>Das Ergebnis der Addition von <paramref name="d1" /> und <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal.op_Addition%2A> Methode definiert, die Operation der Addition-Operator für <xref:System.Decimal> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Decimal.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/addition1.cs#3)]
 [!code-vb[System.Decimal.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/addition1.vb#3)]  
  
 Wenn die Sprache, die Sie verwenden benutzerdefinierte Operatoren nicht unterstützt, rufen Sie die <xref:System.Decimal.Add%2A> Methode stattdessen.  
  
 Die entsprechende Methode für diesen Operator ist. <xref:System.Decimal.Add%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Rückgabewert ist kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Add(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static decimal operator -- (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Decrement(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Decrement(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal operator --(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Der zu dekrementierende Wert.</param>
        <summary>Verringert den <see cref="T:System.Decimal" />-Operanden um 1.</summary>
        <returns>Der um 1 dekrementierte Wert von <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal.op_Decrement%2A> Methode definiert, den Vorgang des Dekrementoperators für <xref:System.Decimal> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Decimal.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/decrement1.cs#4)]  
  
 Einige Sprachen (z. B. Visual Basic), die keine Inkrement-Operators können Aufrufen der <xref:System.Decimal.op_Decrement%2A> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Decimal.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/decrement1.vb#5)]  
  
 Wenn Ihre Sprache benutzerdefinierte Operatoren nicht unterstützt, rufen Sie die <xref:System.Decimal.Subtract%2A> Methode stattdessen wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Decimal.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/decrement2.cs#6)]
 [!code-vb[System.Decimal.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/decrement2.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Rückgabewert ist kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Subtract(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static decimal operator / (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Division(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Division(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal operator /(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Der Dividend.</param>
        <param name="d2">Der Divisor.</param>
        <summary>Dividiert zwei angegebene <see cref="T:System.Decimal" />-Werte.</summary>
        <returns>Das Ergebnis der Division von <paramref name="d1" /> durch <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal.op_Division%2A> Methode definiert, den Vorgang neben dem Divisionsoperator für <xref:System.Decimal> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Decimal.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/division1.cs#7)]
 [!code-vb[System.Decimal.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/division1.vb#7)]  
  
 Wenn die Sprache, die Sie verwenden benutzerdefinierte Operatoren nicht unterstützt, rufen Sie die <xref:System.Decimal.Divide%2A> Methode stattdessen.  
  
 Die entsprechende Methode für diesen Operator ist. <xref:System.Decimal.Divide%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="d2" /> ist 0 (null).</exception>
        <exception cref="T:System.OverflowException">Der Rückgabewert ist kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Divide(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Equality(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Decimal, d2 As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Der erste zu vergleichende Wert.</param>
        <param name="d2">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei <see cref="T:System.Decimal" /> Werte gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="d1" /> und <paramref name="d2" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal.op_Equality%2A> Methode definiert, den Vorgang des Gleichheitsoperators für <xref:System.Decimal> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Decimal.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/equality1.cs#1)]
 [!code-vb[System.Decimal.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/equality1.vb#1)]  
  
 Wenn die Sprache, die Sie verwenden benutzerdefinierte Operatoren nicht unterstützt, rufen Sie die <xref:System.Decimal.Equals%2A> Methode stattdessen.  
  
 Die entsprechende Methode für diesen Operator ist. <xref:System.Decimal.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Equals(System.Object)" />
        <altmember cref="M:System.Decimal.op_Inequality(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiert eine explizite Konvertierung zwischen einem <see cref="T:System.Decimal" />-Objekt und einem anderen Typ.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der zu konvertierende Wert.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Decimal" /> in eine 8-Bit Ganzzahl ohne Vorzeichen.</summary>
        <returns>Eine 8-Bit-Ganzzahl ohne Vorzeichen, die das konvertierte <see cref="T:System.Decimal" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Operator unterstützt die explizite Konvertierung einer <xref:System.Decimal> zu einem <xref:System.Byte>. Die Syntax für solche expliziten Konvertierungen können sprachabhängig, und einzelne Sprachcompiler verschiedene Implementierungen bieten unterschiedliche Ergebnisse zurückgeben. Das Beispiel veranschaulicht die verschiedenen Rückgabewerte aus, wenn Sie explizit zu konvertieren einer <xref:System.Decimal> -Wert in einen <xref:System.Byte> Wert mithilfe von c#, C++ und Visual Basic. Um die Konvertierung auszuführen, die unabhängig von der Sprache ist, rufen Sie die <xref:System.Decimal.ToByte%28System.Decimal%29?displayProperty=nameWithType> oder <xref:System.Convert.ToByte%28System.Decimal%29?displayProperty=nameWithType> Methode.
 

## Examples 
 Das folgende Beispiel konvertiert <xref:System.Decimal> -Zahlen <xref:System.Byte> Werte mit den expliziten <xref:System.Decimal> auf <xref:System.Byte> Konvertierungsoperator.

 [!code-cpp[System.Decimal.ConvTo#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctos_byte.cpp#4)] 
 [!code-csharp[System.Decimal.ConvTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctos_byte.cs#4)] 
 [!code-vb[System.Decimal.ConvTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctos_byte.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist kleiner als <see cref="F:System.Byte.MinValue" /> oder größer als <see cref="F:System.Byte.MaxValue" />.</exception>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator char (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname char op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Char" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator char(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der zu konvertierende Wert.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Decimal" /> in ein Unicodezeichen.</summary>
        <returns>Ein Unicode-Zeichen, das das konvertierte <see cref="T:System.Decimal" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Operator unterstützt die explizite Konvertierung einer <xref:System.Decimal> zu einem <xref:System.Char>. Die Syntax für solche expliziten Konvertierungen sprachabhängig, und einzelne Sprachcompiler können verschiedene Implementierungen bieten unterschiedliche Ergebnisse zurückgeben oder unterstützen Sie die Konvertierung nicht zu. Angenommen, die Visual Basic- und C++-Compiler unterstützen keine explizites <xref:System.Decimal> auf eine <xref:System.Char> Konvertierung.
 

## Examples 
 Das folgende Beispiel konvertiert <xref:System.Decimal> -Zahlen <xref:System.Char> -Werte (Unicode-Zeichen) mit den expliziten <xref:System.Decimal> auf <xref:System.Char> Konvertierungsoperator.

 [!code-csharp[System.Decimal.ConvTo#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctochar.cs#6)]
 [!code-vb[System.Decimal.ConvTo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctochar.vb#6)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist kleiner als <see cref="F:System.Char.MinValue" /> oder größer als <see cref="F:System.Char.MaxValue" />.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der zu konvertierende Wert.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Decimal" /> in eine Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die das konvertierte <see cref="T:System.Decimal" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang kann zu einem Genauigkeitsverlust führen, da eine Gleitkommazahl mit doppelter Genauigkeit weniger signifikante Ziffern als hat eine <xref:System.Decimal>.
 
 Dieser Operator unterstützt die explizite Konvertierung einer <xref:System.Decimal> zu einem <xref:System.Double>. Die Syntax für solche expliziten Konvertierungen können sprachabhängig, und einzelne Sprachcompiler verschiedene Implementierungen bieten unterschiedliche Ergebnisse zurückgeben. Das Beispiel veranschaulicht die verschiedenen Rückgabewerte aus, wenn Sie explizit zu konvertieren einer <xref:System.Decimal> -Wert in einen <xref:System.Double> Wert mithilfe von c#, C++ und Visual Basic. Um die Konvertierung auszuführen, die unabhängig von der Sprache ist, rufen Sie die <xref:System.Decimal.ToDouble%28System.Decimal%29?displayProperty=nameWithType> oder <xref:System.Convert.ToDouble%28System.Decimal%29?displayProperty=nameWithType> Methode.
 

## Examples
 Das folgende Beispiel konvertiert <xref:System.Decimal> -Zahlen <xref:System.Double> Werte mit den expliziten <xref:System.Decimal> auf <xref:System.Double> Konvertierungsoperator.

 [!code-cpp[System.Decimal.ConvTo#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctosgl_dbl.cpp#5)] 
 [!code-csharp[System.Decimal.ConvTo#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctosgl_dbl.cs#5)]
 [!code-vb[System.Decimal.ConvTo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctosgl_dbl.vb#5)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der zu konvertierende Wert.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Decimal" /> in eine 16-Bit Ganzzahl mit Vorzeichen.</summary>
        <returns>Eine 16-Bit-Ganzzahl mit Vorzeichen, die das konvertierte <see cref="T:System.Decimal" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

 Dieser Operator unterstützt die explizite Konvertierung einer <xref:System.Decimal> auf eine <xref:System.Int16>. Die Syntax für solche expliziten Konvertierungen können sprachabhängig, und einzelne Sprachcompiler verschiedene Implementierungen bieten unterschiedliche Ergebnisse zurückgeben. Das Beispiel veranschaulicht die verschiedenen Rückgabewerte aus, wenn Sie explizit zu konvertieren einer <xref:System.Decimal> -Wert an ein <xref:System.Int16> Wert mithilfe von c#, Visual Basic und C++. Um die Konvertierung auszuführen, die unabhängig von der Sprache ist, rufen Sie die <xref:System.Decimal.ToInt16%28System.Decimal%29?displayProperty=nameWithType> oder <xref:System.Convert.ToInt16%28System.Decimal%29?displayProperty=nameWithType> Methode.
 

## Examples
 Das folgende Beispiel konvertiert <xref:System.Decimal> -Zahlen <xref:System.Int16> Werte mit den expliziten <xref:System.Decimal> auf <xref:System.Int16> Konvertierungsoperator.

 [!code-cpp[System.Decimal.ConvTo#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctou_int16.cpp#3)] 
 [!code-csharp[System.Decimal.ConvTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctou_int16.cs#3)] 
 [!code-vb[System.Decimal.ConvTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctou_int16.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist kleiner als <see cref="F:System.Int16.MinValue" /> oder größer als <see cref="F:System.Int16.MaxValue" />.</exception>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der zu konvertierende Wert.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Decimal" /> in eine 32-Bit Ganzzahl mit Vorzeichen.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die das konvertierte <see cref="T:System.Decimal" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Operator unterstützt die explizite Konvertierung einer <xref:System.Decimal> auf eine <xref:System.Int32>. Die Syntax für solche expliziten Konvertierungen können sprachabhängig, und einzelne Sprachcompiler verschiedene Implementierungen bieten unterschiedliche Ergebnisse zurückgeben. Das Beispiel veranschaulicht die verschiedenen Rückgabewerte aus, wenn Sie explizit zu konvertieren einer <xref:System.Decimal> -Wert an ein <xref:System.Int32> Wert mithilfe von c#, C++ und Visual Basic. Um die Konvertierung auszuführen, die unabhängig von der Sprache ist, rufen Sie die <xref:System.Decimal.ToInt32%28System.Decimal%29?displayProperty=nameWithType> oder <xref:System.Convert.ToInt32%28System.Decimal%29?displayProperty=nameWithType> Methode.
 

## Examples
 Das folgende Beispiel konvertiert <xref:System.Decimal> -Zahlen <xref:System.Int32> Werte mit den expliziten <xref:System.Decimal> auf <xref:System.Int32> Konvertierungsoperator.

 [!code-cpp[System.Decimal.ConvTo#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctou_int32.cpp#2)] 
 [!code-csharp[System.Decimal.ConvTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctou_int32.cs#2)] 
 [!code-vb[System.Decimal.ConvTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctou_int32.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist kleiner als <see cref="F:System.Int32.MinValue" /> oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der zu konvertierende Wert.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Decimal" /> in eine 64-Bit Ganzzahl mit Vorzeichen.</summary>
        <returns>Eine 64-Bit-Ganzzahl mit Vorzeichen, die das konvertierte <see cref="T:System.Decimal" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Operator unterstützt die explizite Konvertierung einer <xref:System.Decimal> auf eine <xref:System.Int64>. Die Syntax für solche expliziten Konvertierungen können sprachabhängig, und einzelne Sprachcompiler verschiedene Implementierungen bieten unterschiedliche Ergebnisse zurückgeben. Das Beispiel veranschaulicht die verschiedenen Rückgabewerte aus, wenn Sie explizit zu konvertieren einer <xref:System.Decimal> -Wert an ein <xref:System.Int64> Wert mithilfe von c# und Visual Basic. Um die Konvertierung auszuführen, die unabhängig von der Sprache ist, rufen Sie die <xref:System.Decimal.ToInt64%28System.Decimal%29?displayProperty=nameWithType> oder <xref:System.Convert.ToInt64%28System.Decimal%29?displayProperty=nameWithType> Methode.
 
## Examples
 Das folgende Beispiel konvertiert <xref:System.Decimal> -Zahlen <xref:System.Int64> Werte mit den expliziten <xref:System.Decimal> auf <xref:System.Int64> Konvertierungsoperator.

 [!code-cpp[System.Decimal.ConvTo#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctou_int64.cpp#1)] 
 [!code-csharp[System.Decimal.ConvTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctou_int64.cs#1)] 
 [!code-vb[System.Decimal.ConvTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctou_int64.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist kleiner als <see cref="F:System.Int64.MinValue" /> oder größer als <see cref="F:System.Int64.MaxValue" />.</exception>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der zu konvertierende Wert.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Decimal" /> in eine 8-Bit Ganzzahl mit Vorzeichen.  Diese API ist nicht CLS-kompatibel.</summary>
        <returns>Eine 8-Bit-Ganzzahl mit Vorzeichen, die das konvertierte <see cref="T:System.Decimal" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Operator unterstützt die explizite Konvertierung einer <xref:System.Decimal> zu einem <xref:System.SByte>. Die Syntax für solche expliziten Konvertierungen können sprachabhängig, und einzelne Sprachcompiler verschiedene Implementierungen bieten unterschiedliche Ergebnisse zurückgeben. Das Beispiel veranschaulicht die verschiedenen Rückgabewerte aus, wenn Sie explizit zu konvertieren einer <xref:System.Decimal> -Wert in einen <xref:System.Byte> und ein <xref:System.SByte> Wert mithilfe von c# und Visual Basic. Um die Konvertierung auszuführen, die unabhängig von der Sprache ist, rufen Sie die <xref:System.Decimal.ToSByte%28System.Decimal%29?displayProperty=nameWithType> Methode oder die <xref:System.Convert.ToSByte%28System.Decimal%29?displayProperty=nameWithType> Methode.   


## Examples 
 Das folgende Beispiel konvertiert <xref:System.Decimal> -Zahlen <xref:System.SByte> Werte mit den expliziten <xref:System.Decimal> auf <xref:System.SByte> Konvertierungsoperator.

 [!code-cpp[System.Decimal.Operators.Explicit#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.decimal.operators.explicit/cpp/tosbyte.cpp#1)] 
 [!code-csharp[System.Decimal.Operators.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators.explicit/cs/tosbyte.cs#1)]
 [!code-vb[System.Decimal.Operators.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators.explicit/vb/tosbyte.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist kleiner als <see cref="F:System.SByte.MinValue" /> oder größer als <see cref="F:System.SByte.MaxValue" />.</exception>
        <altCompliant cref="M:System.Decimal.ToInt16(System.Decimal)" />
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der zu konvertierende Wert.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Decimal" /> in eine Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die das konvertierte <see cref="T:System.Decimal" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang kann zu einem Genauigkeitsverlust führen, da eine Gleitkommazahl mit einfacher Genauigkeit weniger signifikante Ziffern als hat eine <xref:System.Decimal>.

 Dieser Operator unterstützt die explizite Konvertierung einer <xref:System.Decimal> zu einem <xref:System.Single>. Die Syntax für solche expliziten Konvertierungen können sprachabhängig, und einzelne Sprachcompiler verschiedene Implementierungen bieten unterschiedliche Ergebnisse zurückgeben. Das Beispiel veranschaulicht die verschiedenen Rückgabewerte aus, wenn Sie explizit zu konvertieren einer <xref:System.Decimal> -Wert in einen <xref:System.Single> Wert mithilfe von c# und Visual Basic. Um die Konvertierung auszuführen, die unabhängig von der Sprache ist, rufen Sie die <xref:System.Decimal.ToSingle%28System.Decimal%29?displayProperty=nameWithType> oder <xref:System.Convert.ToSingle%28System.Decimal%29?displayProperty=nameWithType> Methode.
 

## Examples
 Das folgende Beispiel konvertiert <xref:System.Decimal> -Zahlen <xref:System.Single> Werte mit den expliziten <xref:System.Decimal> auf <xref:System.Single> Konvertierungsoperator.

 [!code-cpp[System.Decimal.Operators.Explicit#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.decimal.operators.explicit/cpp/tosingle1.cpp#2)] 
 [!code-csharp[System.Decimal.Operators.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators.explicit/cs/tosingle1.cs#2)]
 [!code-vb[System.Decimal.Operators.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators.explicit/vb/tosingle1.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der zu konvertierende Wert.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Decimal" /> in eine 16-Bit Ganzzahl ohne Vorzeichen.  Diese API ist nicht CLS-kompatibel.</summary>
        <returns>Eine 16-Bit-Ganzzahl ohne Vorzeichen, die das konvertierte <see cref="T:System.Decimal" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Operator unterstützt die explizite Konvertierung einer <xref:System.Decimal> zu einem <xref:System.UInt16>. Die Syntax für solche expliziten Konvertierungen können sprachabhängig, und einzelne Sprachcompiler verschiedene Implementierungen bieten unterschiedliche Ergebnisse zurückgeben. Das Beispiel veranschaulicht die verschiedenen Rückgabewerte aus, wenn Sie explizit zu konvertieren einer <xref:System.Decimal> -Wert in einen <xref:System.UInt16> Wert mithilfe von c# und Visual Basic. Um die Konvertierung auszuführen, die unabhängig von der Sprache ist, rufen Sie die <xref:System.Decimal.ToUInt16%28System.Decimal%29?displayProperty=nameWithType> oder <xref:System.Convert.ToUInt16%28System.Decimal%29?displayProperty=nameWithType> Methode.
 

## Examples
 Das folgende Beispiel konvertiert <xref:System.Decimal> -Zahlen <xref:System.UInt16> Werte mit den expliziten <xref:System.Decimal> auf <xref:System.UInt16> Konvertierungsoperator.

 [!code-cpp[System.Decimal.ConvTo#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctou_int16.cpp#3)] 
 [!code-csharp[System.Decimal.ConvTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctou_int16.cs#3)]
 [!code-vb[System.Decimal.ConvTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctou_int16.vb#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist kleiner als <see cref="F:System.UInt16.MinValue" /> oder größer als <see cref="F:System.UInt16.MaxValue" />.</exception>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der zu konvertierende Wert.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Decimal" /> in eine 32-Bit Ganzzahl ohne Vorzeichen.  Diese API ist nicht CLS-kompatibel.</summary>
        <returns>Eine 32-Bit-Ganzzahl ohne Vorzeichen, die das konvertierte <see cref="T:System.Decimal" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Operator unterstützt die explizite Konvertierung einer <xref:System.Decimal> zu einem <xref:System.UInt32>. Die Syntax für solche expliziten Konvertierungen können sprachabhängig, und einzelne Sprachcompiler verschiedene Implementierungen bieten unterschiedliche Ergebnisse zurückgeben. Das Beispiel veranschaulicht die verschiedenen Rückgabewerte aus, wenn Sie explizit zu konvertieren einer <xref:System.Decimal> -Wert in einen <xref:System.UInt32> Wert mithilfe von c# und Visual Basic. Um die Konvertierung auszuführen, die unabhängig von der Sprache ist, rufen Sie die <xref:System.Decimal.ToUInt32%28System.Decimal%29?displayProperty=nameWithType> oder <xref:System.Convert.ToUInt32%28System.Decimal%29?displayProperty=nameWithType> Methode.


## Examples
 Das folgende Beispiel konvertiert <xref:System.Decimal> -Zahlen <xref:System.UInt32> Werte mit den expliziten <xref:System.Decimal> auf <xref:System.UInt32> Konvertierungsoperator.

 [!code-cpp[System.Decimal.ConvTo#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctou_int32.cpp#2)] 
 [!code-csharp[System.Decimal.ConvTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctou_int32.cs#2)]
 [!code-vb[System.Decimal.ConvTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctou_int32.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist kleiner als <see cref="F:System.UInt32.MinValue" /> oder größer als <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altCompliant cref="M:System.Decimal.ToInt64(System.Decimal)" />
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der zu konvertierende Wert.</param>
        <summary>Definiert eine explizite Konvertierung einer <see cref="T:System.Decimal" /> in eine 64-Bit Ganzzahl ohne Vorzeichen.  Diese API ist nicht CLS-kompatibel.</summary>
        <returns>Eine 64-Bit-Ganzzahl ohne Vorzeichen, die das konvertierte <see cref="T:System.Decimal" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Operator unterstützt die explizite Konvertierung einer <xref:System.Decimal> zu einem <xref:System.UInt64>. Die Syntax für solche expliziten Konvertierungen können sprachabhängig, und einzelne Sprachcompiler verschiedene Implementierungen bieten unterschiedliche Ergebnisse zurückgeben. Das Beispiel veranschaulicht die verschiedenen Rückgabewerte aus, wenn Sie explizit zu konvertieren einer <xref:System.Decimal> -Wert in einen <xref:System.UInt64> Wert mithilfe von c# und Visual Basic. Um die Konvertierung auszuführen, die unabhängig von der Sprache ist, rufen Sie die <xref:System.Decimal.ToUInt64%28System.Decimal%29?displayProperty=nameWithType> oder <xref:System.Convert.ToUInt64%28System.Decimal%29?displayProperty=nameWithType> Methode.


## Examples 
 Das folgende Beispiel konvertiert <xref:System.Decimal> -Zahlen <xref:System.UInt64> Werte mit den expliziten <xref:System.Decimal> auf <xref:System.UInt64> Konvertierungsoperator.

 [!code-cpp[System.Decimal.ConvTo#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctou_int64.cpp#1)] 
 [!code-csharp[System.Decimal.ConvTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctou_int64.cs#1)]
 [!code-vb[System.Decimal.ConvTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctou_int64.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist negativ oder größer als <see cref="F:System.UInt64.MaxValue" />.</exception>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Double)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Definiert eine explizite Konvertierung einer Gleitkommazahl mit doppelter Genauigkeit in eine <see cref="T:System.Decimal" />.</summary>
        <returns>Die konvertierte Gleitkommazahl mit doppelter Genauigkeit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  

 Das folgende Beispiel konvertiert <xref:System.Double> Werte <xref:System.Decimal> Zahlen mithilfe der <xref:System.Double> auf <xref:System.Decimal> Konvertierungsoperator. Diese Konvertierung erfordert den Op_Explicit-Operator in Visual Basic.

 [!code-cpp[System.Decimal.ConvFrom.Others#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/CPP/cfromdouble.cpp#2)]
 [!code-csharp[System.Decimal.ConvFrom.Others#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/CS/cfromdouble.cs#2)]
 [!code-vb[System.Decimal.ConvFrom.Others#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/VB/cfromdouble.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist größer als <see cref="F:System.Decimal.MaxValue" /> oder kleiner als <see cref="F:System.Decimal.MinValue" />.  Oder:  <paramref name="value" /> ist <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> oder <see cref="F:System.Double.NegativeInfinity" />.</exception>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Single)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Definiert eine explizite Konvertierung einer Gleitkommazahl mit einfacher Genauigkeit in eine <see cref="T:System.Decimal" />.</summary>
        <returns>Die konvertierte Gleitkommazahl mit einfacher Genauigkeit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel konvertiert <xref:System.Single> Werte <xref:System.Decimal> Zahlen mithilfe der <xref:System.Single> auf <xref:System.Decimal> Konvertierungsoperator. Diese Konvertierung erfordert den Op_Explicit-Operator in Visual Basic.

 [!code-cpp[System.Decimal.ConvFrom.Others#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/CPP/cfromsingle.cpp#3)]
 [!code-csharp[System.Decimal.ConvFrom.Others#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/CS/cfromsingle.cs#3)]
 [!code-vb[System.Decimal.ConvFrom.Others#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/VB/cfromsingle.vb#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist größer als <see cref="F:System.Decimal.MaxValue" /> oder kleiner als <see cref="F:System.Decimal.MinValue" />.  Oder:  <paramref name="value" /> ist <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" />.</exception>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_GreaterThan(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (d1 As Decimal, d2 As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Der erste zu vergleichende Wert.</param>
        <param name="d2">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebenes <see cref="T:System.Decimal" /> größer als eine anderes angegebenes <see cref="T:System.Decimal" /> ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="d1" /> größer als <paramref name="d2" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal.op_GreaterThan%2A> Methode definiert, den Vorgang des größer-als-Operator für <xref:System.Decimal> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Decimal.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/greaterthan1.cs#8)]
 [!code-vb[System.Decimal.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/greaterthan1.vb#8)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Decimal.Compare%2A> Methode stattdessen. Sie können auch in der Lage sind, rufen Sie die <xref:System.Decimal.op_GreaterThan%2A> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Decimal.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/greaterthan2.vb#9)]  
  
 Die entsprechende Methode für diesen Operator ist. <xref:System.Decimal.Compare%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_GreaterThanOrEqual(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (d1 As Decimal, d2 As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Der erste zu vergleichende Wert.</param>
        <param name="d2">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebenes <see cref="T:System.Decimal" /> größer oder gleich einem anderen angegebenen <see cref="T:System.Decimal" /> ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="d1" /> größer oder gleich <paramref name="d2" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal.op_GreaterThanOrEqual%2A> Methode definiert, den Vorgang, der den Operator "größer als oder gleich" für <xref:System.Decimal> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Decimal.Operators#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/greaterthanorequal1.cs#10)]
 [!code-vb[System.Decimal.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/greaterthanorequal1.vb#10)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Decimal.Compare%2A> Methode stattdessen. Sie können auch in der Lage sind, rufen Sie die <xref:System.Decimal.op_GreaterThanOrEqual%2A> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Decimal.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/greaterthanorequal2.vb#11)]  
  
 Die entsprechende Methode für diesen Operator ist. <xref:System.Decimal.Compare%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiert eine implizite Konvertierung des Werts eines Typs zu einem <see cref="T:System.Decimal" />-Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladungen der der <xref:System.Decimal.op_Implicit%2A> Methode definieren die Typen aus dem konvertiert der Compiler kann automatisch eine <xref:System.Decimal> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder einen Aufruf für eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie keine <xref:System.OverflowException> Ausnahme.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.Byte)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Decimal(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende 8-Bit-Ganzzahl ohne Vorzeichen.</param>
        <summary>Definiert eine implizite Konvertierung einer 8-Bit-Ganzzahl ohne Vorzeichen in einen <see cref="T:System.Decimal" />-Wert.</summary>
        <returns>Die konvertierte 8-Bit-Ganzzahl ohne Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladungen der der <xref:System.Decimal.op_Implicit%2A> Methode definieren die Typen aus dem konvertiert der Compiler kann automatisch eine <xref:System.Decimal> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder einen Aufruf für eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie keine <xref:System.OverflowException> Ausnahme.  


## Examples
 Das folgende Beispiel konvertiert <xref:System.Byte> Werte <xref:System.Decimal> Zahlen.

 [!code-cpp[System.Decimal.ConvFrom.UInts#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CPP/cfrombyte.cpp#4)]
 [!code-csharp[System.Decimal.ConvFrom.UInts#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CS/cfrombyte.cs#4)]
 [!code-vb[System.Decimal.ConvFrom.UInts#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/VB/cfrombyte.vb#4)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.Char)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Char) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Decimal(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Das zu konvertierende Unicode-Zeichen.</param>
        <summary>Definiert eine implizite Konvertierung eines Unicodezeichens in einen <see cref="T:System.Decimal" />-Wert.</summary>
        <returns>Das konvertierte Unicode-Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladungen der der <xref:System.Decimal.op_Implicit%2A> Methode definieren die Typen aus dem konvertiert der Compiler kann automatisch eine <xref:System.Decimal> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder einen Aufruf für eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie keine <xref:System.OverflowException> Ausnahme.  


## Examples
 Das folgende Beispiel konvertiert <xref:System.Char> Werte (Unicode-Zeichen) <xref:System.Decimal> Zahlen. Diese Konvertierung erfordert Op_Implicit-Operator in Visual Basic, jedoch nicht in c# und C++. 

 [!code-cpp[System.Decimal.ConvFrom.Others#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/CPP/cfromchar.cpp#1)]
 [!code-csharp[System.Decimal.ConvFrom.Others#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/CS/cfromchar.cs#1)]
 [!code-vb[System.Decimal.ConvFrom.Others#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/VB/cfromchar.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.Int16)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Decimal(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende 16-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Definiert eine implizite Konvertierung einer 16-Bit-Ganzzahl mit Vorzeichen in einen <see cref="T:System.Decimal" />-Wert.</summary>
        <returns>Die konvertierte 16-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladungen der der <xref:System.Decimal.op_Implicit%2A> Methode definieren die Typen aus dem konvertiert der Compiler kann automatisch eine <xref:System.Decimal> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder einen Aufruf für eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie keine <xref:System.OverflowException> Ausnahme.  


## Examples
 Das folgende Beispiel konvertiert <xref:System.Int16> Werte <xref:System.Decimal> Zahlen. Diese Konvertierung erfordert Op_Implicit-Operator in Visual Basic, jedoch nicht in c# und C++. 

 [!code-cpp[System.Decimal.ConvFrom.SInts#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CPP/cfromint16.cpp#3)]
 [!code-csharp[System.Decimal.ConvFrom.SInts#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CS/cfromint16.cs#3)]
 [!code-vb[System.Decimal.ConvFrom.SInts#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/VB/cfromint16.vb#3)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.Int32)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Decimal(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Definiert eine implizite Konvertierung einer 32-Bit-Ganzzahl mit Vorzeichen in einen <see cref="T:System.Decimal" />-Wert.</summary>
        <returns>Die konvertierte 32-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladungen der der <xref:System.Decimal.op_Implicit%2A> Methode definieren die Typen aus dem konvertiert der Compiler kann automatisch eine <xref:System.Decimal> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder einen Aufruf für eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie keine <xref:System.OverflowException> Ausnahme.  


## Examples
 Das folgende Beispiel konvertiert <xref:System.Int32> Werte <xref:System.Decimal> Zahlen. 

 [!code-cpp[System.Decimal.ConvFrom.SInts#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CPP/cfromint32.cpp#2)]
 [!code-csharp[System.Decimal.ConvFrom.SInts#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CS/cfromint32.cs#2)]
 [!code-vb[System.Decimal.ConvFrom.SInts#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/VB/cfromint32.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.Int64)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Decimal(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende 64-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Definiert eine implizite Konvertierung einer 64-Bit-Ganzzahl mit Vorzeichen in einen <see cref="T:System.Decimal" />-Wert.</summary>
        <returns>Die konvertierte 64-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladungen der der <xref:System.Decimal.op_Implicit%2A> Methode definieren die Typen aus dem konvertiert der Compiler kann automatisch eine <xref:System.Decimal> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder einen Aufruf für eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie keine <xref:System.OverflowException> Ausnahme.  


## Examples
 Das folgende Beispiel konvertiert <xref:System.Int64> Werte <xref:System.Decimal> Zahlen. 

 [!code-cpp[System.Decimal.ConvFrom.SInts#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CPP/cfromint64.cpp#1)]
 [!code-csharp[System.Decimal.ConvFrom.SInts#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CS/cfromint64.cs#1)]
 [!code-vb[System.Decimal.ConvFrom.SInts#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/VB/cfromint64.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.SByte)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Decimal(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende 8-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Definiert eine implizite Konvertierung einer 8-Bit-Ganzzahl mit Vorzeichen in einen <see cref="T:System.Decimal" />-Wert.  Diese API ist nicht CLS-kompatibel.</summary>
        <returns>Die konvertierte 8-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladungen der der <xref:System.Decimal.op_Implicit%2A> Methode definieren die Typen aus dem konvertiert der Compiler kann automatisch eine <xref:System.Decimal> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder einen Aufruf für eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie keine <xref:System.OverflowException> Ausnahme.  


## Examples
 Das folgende Beispiel konvertiert <xref:System.SByte> Werte <xref:System.Decimal> Zahlen. 

 [!code-cpp[System.Decimal.ConvFrom.SInts#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CPP/cfromsbyte.cpp#4)]
 [!code-csharp[System.Decimal.ConvFrom.SInts#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CS/cfromsbyte.cs#4)]
 [!code-vb[System.Decimal.ConvFrom.SInts#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/VB/cfromsbyte.vb#4)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.UInt16)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Decimal(System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende 16-Bit-Ganzzahl ohne Vorzeichen.</param>
        <summary>Definiert eine implizite Konvertierung einer 16-Bit-Ganzzahl ohne Vorzeichen in einen <see cref="T:System.Decimal" />-Wert.  Diese API ist nicht CLS-kompatibel.</summary>
        <returns>Die konvertierte 16-Bit-Ganzzahl ohne Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladungen der der <xref:System.Decimal.op_Implicit%2A> Methode definieren die Typen aus dem konvertiert der Compiler kann automatisch eine <xref:System.Decimal> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder einen Aufruf für eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie keine <xref:System.OverflowException> Ausnahme.  


## Examples
 Das folgende Beispiel konvertiert <xref:System.UInt16> Werte <xref:System.Decimal> Zahlen. 

 [!code-cpp[System.Decimal.ConvFrom.UInts#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CPP/cfromuint16.cpp#3)]
 [!code-csharp[System.Decimal.ConvFrom.UInts#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CS/cfromuint16.cs#3)]
 [!code-vb[System.Decimal.ConvFrom.UInts#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/VB/cfromuint16.vb#3)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.UInt32)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Decimal(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende 32-Bit-Ganzzahl ohne Vorzeichen.</param>
        <summary>Definiert eine implizite Konvertierung einer 32-Bit-Ganzzahl ohne Vorzeichen in einen <see cref="T:System.Decimal" />-Wert.  Diese API ist nicht CLS-kompatibel.</summary>
        <returns>Die konvertierte 32-Bit-Ganzzahl ohne Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladungen der der <xref:System.Decimal.op_Implicit%2A> Methode definieren die Typen aus dem konvertiert der Compiler kann automatisch eine <xref:System.Decimal> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder einen Aufruf für eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie keine <xref:System.OverflowException> Ausnahme.  


## Examples
 Das folgende Beispiel konvertiert <xref:System.UInt32> Werte <xref:System.Decimal> Zahlen.

 [!code-cpp[System.Decimal.ConvFrom.UInts#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CPP/cfromuint32.cpp#2)] 
 [!code-csharp[System.Decimal.ConvFrom.UInts#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CS/cfromuint32.cs#2)] 
 [!code-vb[System.Decimal.ConvFrom.UInts#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/VB/cfromuint32.vb#2)]   

 ]]></format>
        </remarks>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.UInt64)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Decimal(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende 64-Bit-Ganzzahl ohne Vorzeichen.</param>
        <summary>Definiert eine implizite Konvertierung einer 64-Bit-Ganzzahl ohne Vorzeichen in einen <see cref="T:System.Decimal" />-Wert.  Diese API ist nicht CLS-kompatibel.</summary>
        <returns>Die konvertierte 64-Bit-Ganzzahl ohne Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladungen der der <xref:System.Decimal.op_Implicit%2A> Methode definieren die Typen aus dem konvertiert der Compiler kann automatisch eine <xref:System.Decimal> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder einen Aufruf für eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie keine <xref:System.OverflowException> Ausnahme.  


## Examples
 Das folgende Beispiel konvertiert <xref:System.UInt64> Werte <xref:System.Decimal> Zahlen mithilfe der <xref:System.UInt64> auf <xref:System.Decimal> Konvertierungsoperator. 

 [!code-cpp[System.Decimal.ConvFrom.UInts#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CPP/cfromuint64.cpp#1)] 
 [!code-csharp[System.Decimal.ConvFrom.UInts#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CS/cfromuint64.cs#1)] 
 [!code-vb[System.Decimal.ConvFrom.UInts#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/VB/cfromuint64.vb#1)]   

 ]]></format>
        </remarks>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static decimal operator ++ (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Increment(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Increment(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal operator ++(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Der zu inkrementierende Wert.</param>
        <summary>Erhöht den <see cref="T:System.Decimal" />-Operanden um 1.</summary>
        <returns>Der um 1 inkrementierte Wert von <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal.op_Increment%2A> Methode definiert, den Vorgang des Inkrementoperators für <xref:System.Decimal> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Decimal.Operators#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/increment1.cs#12)]  
  
 Einige Sprachen (z. B. Visual Basic), die keine Inkrement-Operators können Aufrufen der <xref:System.Decimal.op_Increment%2A> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Decimal.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/increment1.vb#13)]  
  
 Wenn Ihre Sprache benutzerdefinierte Operatoren nicht unterstützt, rufen Sie die <xref:System.Decimal.Add%2A> Methode stattdessen wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Decimal.Operators#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/increment2.cs#14)]
 [!code-vb[System.Decimal.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/increment2.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Rückgabewert ist kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Add(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Inequality(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Decimal, d2 As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Der erste zu vergleichende Wert.</param>
        <param name="d2">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei <see cref="T:System.Decimal" />-Objekte über unterschiedliche Werte verfügen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="d1" /> und <paramref name="d2" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal.op_Inequality%2A> -Methode definiert die Operation des Ungleichheitsoperators für <xref:System.Decimal> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Decimal.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/inequality1.cs#2)]
 [!code-vb[System.Decimal.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/inequality1.vb#2)]  
  
 Wenn die Sprache, die Sie verwenden benutzerdefinierte Operatoren nicht unterstützt, können Sie auf Ungleichheit testen, indem Sie eine der folgenden Methoden:  
  
-   Aufrufen der <xref:System.Decimal.Compare%2A> Methode, die die Beziehung zwischen zwei angibt <xref:System.Decimal> Werte.  
  
-   Aufrufen der <xref:System.Decimal.Equals%2A> -Methode und ihren Wert umkehren.  
  
 Die entsprechende Methode für diesen Operator ist. <xref:System.Decimal.Compare%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Equals(System.Object)" />
        <altmember cref="M:System.Decimal.op_Equality(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_LessThan(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (d1 As Decimal, d2 As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Der erste zu vergleichende Wert.</param>
        <param name="d2">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebenes <see cref="T:System.Decimal" /> kleiner als ein anderes angegebenes <see cref="T:System.Decimal" /> ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="d1" /> kleiner als <paramref name="d2" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal.op_LessThan%2A> Methode definiert, den Vorgang des kleiner-als-Operator für <xref:System.Decimal> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Decimal.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/lessthan1.cs#15)]
 [!code-vb[System.Decimal.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/lessthan1.vb#15)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Decimal.Compare%2A> Methode stattdessen. Sie können auch in der Lage sind, rufen Sie die <xref:System.Decimal.op_LessThan%2A> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Decimal.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/lessthan2.vb#16)]  
  
 Die entsprechende Methode für diesen Operator ist. <xref:System.Decimal.Compare%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_LessThanOrEqual(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (d1 As Decimal, d2 As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Der erste zu vergleichende Wert.</param>
        <param name="d2">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebenes <see cref="T:System.Decimal" /> kleiner oder gleich einem anderen angegebenen <see cref="T:System.Decimal" /> ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="d1" /> kleiner oder gleich <paramref name="d2" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal.op_LessThanOrEqual%2A> Methode definiert, den Vorgang, der kleiner als oder gleich-Operator für <xref:System.Decimal> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Decimal.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/lessthanorequal1.cs#17)]
 [!code-vb[System.Decimal.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/lessthanorequal1.vb#17)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Decimal.Compare%2A> Methode stattdessen. Sie können auch in der Lage sind, rufen Sie die <xref:System.Decimal.op_LessThanOrEqual%2A> -Methode direkt, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Decimal.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/lessthanorequal2.vb#18)]  
  
 Die entsprechende Methode für diesen Operator ist. <xref:System.Decimal.Compare%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static decimal operator % (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Modulus(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Modulus(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal operator %(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Der Dividend.</param>
        <param name="d2">Der Divisor.</param>
        <summary>Gibt den Rest aus der Division zweier angegebener <see cref="T:System.Decimal" />-Werte zurück.</summary>
        <returns>Der Rest der Division von <paramref name="d1" /> durch <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal.op_Modulus%2A> Operator definiert die Rest-Vorgang, der den Rest aus der Division zweier angegebener zurückgibt <xref:System.Decimal> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Decimal.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/modulus1.cs#19)]
 [!code-vb[System.Decimal.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/modulus1.vb#19)]  
  
 Die Vorzeichen des Werts durch die Rest-Vorgang zurückgegeben wurden, hängt von der Dividend geteilt werden das Vorzeichen ab. Wenn Dividend positiv ist, gibt der Rest-Vorgang ein positives Ergebnis zurück. Wenn sie negativ ist, gibt der Rest-Vorgang ein negatives Ergebnis zurück.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Decimal.Remainder%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>. Wenn die Sprache, die Sie verwenden benutzerdefinierte Operatoren nicht unterstützt, rufen Sie die <xref:System.Decimal.Remainder%2A> Methode stattdessen.  
         ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="d2" /> ist <see langword="zero" />.</exception>
        <exception cref="T:System.OverflowException">Der Rückgabewert ist kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Remainder(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static decimal operator * (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Multiply(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Multiply(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal operator *(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Der erste zu multiplizierende Wert.</param>
        <param name="d2">Der zweite zu multiplizierende Wert.</param>
        <summary>Multipliziert zwei angegebene <see cref="T:System.Decimal" />-Werte.</summary>
        <returns>Das Ergebnis der Multiplikation von <paramref name="d1" /> mit <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal.op_Multiply%2A> Methode definiert, den Vorgang, der den Multiplikationsoperator für <xref:System.Decimal> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Decimal.Operators#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/multiply1.cs#20)]
 [!code-vb[System.Decimal.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/multiply1.vb#20)]  
  
 Wenn die Sprache, die Sie verwenden benutzerdefinierte Operatoren nicht unterstützt, rufen Sie die <xref:System.Decimal.Multiply%2A> Methode stattdessen.  
  
 Die entsprechende Methode für diesen Operator ist. <xref:System.Decimal.Multiply%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Rückgabewert ist kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Multiply(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static decimal operator - (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Subtraction(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Subtraction(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal operator -(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Der Minuend.</param>
        <param name="d2">Der Subtrahend.</param>
        <summary>Subtrahiert zwei angegebene <see cref="T:System.Decimal" />-Werte.</summary>
        <returns>Das Ergebnis der Subtraktion von <paramref name="d2" /> von <paramref name="d1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal.op_Subtraction%2A> Methode definiert, den Vorgang des Subtraktionsoperators für <xref:System.Decimal> Werte. Dadurch werden dem folgenden Code:  
  
 [!code-csharp[System.Decimal.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/subtraction1.cs#21)]
 [!code-vb[System.Decimal.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/subtraction1.vb#21)]  
  
 Wenn die Sprache, die Sie verwenden benutzerdefinierte Operatoren nicht unterstützt, rufen Sie die <xref:System.Decimal.Subtract%2A> Methode stattdessen.  
  
 Die entsprechende Methode für diesen Operator ist. <xref:System.Decimal.Subtract%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Rückgabewert ist kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Subtract(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static decimal operator - (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_UnaryNegation(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_UnaryNegation(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal operator -(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Der zu negierende Wert.</param>
        <summary>Negiert den Wert des angegebenen <see cref="T:System.Decimal" />-Operanden.</summary>
        <returns>Das Ergebnis von <paramref name="d" />, multipliziert mit -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal.op_UnaryPlus%2A> -Methode definiert die Ausführung der unäre Negationsoperator (oder die Additive Inverse-Operator) für <xref:System.Decimal> Werte. Der Vorgang erzeugt einen Wert, der sich in 0 (null) ergibt, wenn die ursprüngliche Nummer hinzugefügt wird. Sprachen, die keine benutzerdefinierte Operatoren unterstützen können Aufrufen der <xref:System.Decimal.Negate%2A> Methode stattdessen.  
  
 Die entsprechende Methode für diesen Operator ist. <xref:System.Decimal.Negate%28System.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Negate(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static decimal operator + (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_UnaryPlus(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_UnaryPlus(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal operator +(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Der Operand, der zurückgegeben werden soll.</param>
        <summary>Gibt den Wert des <see cref="T:System.Decimal" />-Operanden zurück (das Vorzeichen des Operanden bleibt unverändert).</summary>
        <returns>Der Wert <paramref name="d" /> des Operanden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal.op_UnaryPlus%2A> Methode definiert, die Ausführung von der positive unäre Operator für <xref:System.Decimal> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wandelt die angegebene Zeichenfolgendarstellung einer Zahl in ihre <see cref="T:System.Decimal" />-Entsprechung um.</summary>
        <altmember cref="Overload:System.Decimal.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static decimal Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Parse(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolgendarstellung der zu konvertierenden Zahl.</param>
        <summary>Wandelt die angegebene Zeichenfolgendarstellung einer Zahl in ihre <see cref="T:System.Decimal" />-Entsprechung um.</summary>
        <returns>Die Entsprechung der in <paramref name="s" /> enthaltenen Zahl.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parameter `s` enthält eine Reihe von der Form:  
  
 [ws] [anmelden] [Ziffern] Ziffern [.fractional-Ziffern] [ws]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum.|  
|*sign*|Einem optionalen Vorzeichen.|  
|*Ziffern*|Eine Folge von Ziffern zwischen 0 und 9.|  
|*,*|Eine kulturspezifische Tausende Trennzeichen.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen.|  
|*fractional-digits*|Eine Folge von Ziffern zwischen 0 und 9.|  
  
 Parameter `s` wird die <xref:System.Globalization.NumberStyles.Number?displayProperty=nameWithType> Stil. Dies bedeutet, dass Leerraum und Tausenden Trennzeichen zulässig sind jedoch Währungssymbole nicht. Um die Elemente explizit definieren (z. B. Währungssymbole, Tausende Trennzeichen und Leerzeichen) in vorhanden sein können `s`, verwenden Sie entweder die <xref:System.Decimal.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> oder <xref:System.Decimal.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 Parameter `s` analysiert unter Verwendung der Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> für die aktuelle Systemkultur initialisiert wurde. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Um eine Zeichenfolge, die unter Verwendung der Formatierungsinformationen einer anderen Kultur zu analysieren, verwenden die <xref:System.Decimal.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> oder <xref:System.Decimal.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 Bei Bedarf den Wert des `s` wird auf den nächsten gerundet.  
  
 Ein <xref:System.Decimal> hat die Genauigkeit von 29 Stellen. Wenn `s` eine Zahl ein, die mehr als 29 Stellen jedoch einen Teil mit Bruchzahlen und wird innerhalb des Bereichs von <xref:System.Decimal.MaxValue> und <xref:System.Decimal.MinValue>, die Zahl gerundet wird, nicht auf 29 Ziffern, die in den nächsten gekürzt.  
  
 Wenn während eines Analysevorgangs eine Trennzeichen, in gefunden wird der `s` -Parameter, und die geltenden Währung oder Anzahl von Dezimalstellen und Gruppentrennzeichen sind identisch, der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe als Trennzeichen. Weitere Informationen über Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Decimal.Parse%28System.String%29> Methode zum Analysieren von zeichenfolgendarstellungen <xref:System.Decimal> Werte.  
  
 [!code-csharp[System.Decimal.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Parse/CS/parse.cs#1)]
 [!code-vb[System.Decimal.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Parse/VB/parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> weist nicht das richtige Format auf.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" /> ist.</exception>
        <altmember cref="Overload:System.Decimal.TryParse" />
        <altmember cref="M:System.Decimal.ToString" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static decimal Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolgendarstellung der zu konvertierenden Zahl.</param>
        <param name="style">Eine bitweise Kombination von <see cref="T:System.Globalization.NumberStyles" />-Werten, die die Stilelemente angeben, die in <c>s</c> vorhanden sein können. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Number" />.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil in die <see cref="T:System.Decimal" />-Entsprechung.</summary>
        <returns>Die <see cref="T:System.Decimal" />-Zahl, die der in <paramref name="s" /> enthaltenen Zahl entspricht, wie durch <paramref name="style" /> angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `style` Parameter definiert, die die Stilelemente (z. B. Tausende Trennzeichen, Leerzeichen und Währungssymbole), sind zulässig, der `s` Parameter, damit der Analysevorgang erfolgreich ausgeführt werden kann. Es muss eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration. Die folgenden <xref:System.Globalization.NumberStyles> Elemente werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Abhängig vom Wert der `style`die `s` -Parameter enthält möglicherweise die folgenden Elemente:  
  
 [ws] [$] [anmelden] [Ziffern] Ziffern [.fractional-Ziffern] [-e [Anmeldung] Ziffern] [ws]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum. Leerzeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag.|  
|*$*|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der aktuellen Kultur. Das Währungssymbol der aktuellen Kultur stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag.|  
|*sign*|Einem optionalen Vorzeichen. Die Zeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `s` zum Angeben eines negativen Werts Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Flag.|  
|*Ziffern*|Eine Folge von Ziffern zwischen 0 und 9.|  
|*,*|Eine kulturspezifische Tausende Trennzeichen. Tausendertrennzeichen der aktuellen Kultur Trennzeichen erscheinen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flag.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen. In der aktuellen Kultur Dezimaltrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|*fractional-digits*|Eine Folge von Ziffern zwischen 0 und 9. Dezimalstellen erscheinen `s` nur, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|*e*|Die "e" oder "E"-Zeichen, das gibt an, dass der Wert in Exponentialschreibweise dargestellt wird. Die `s` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag.|  
  
 Eine Zeichenfolge mit nur-Ziffern (entspricht der <xref:System.Globalization.NumberStyles.None> Stil) immer erfolgreich analysiert. Die verbleibenden <xref:System.Globalization.NumberStyles> Member steuern Elemente, die nicht unbedingt in der Eingabezeichenfolge vorhanden sein. In der folgenden Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Mitglieder Auswirkungen auf die Elemente, die möglicherweise vorhandene in `s`.  
  
|NumberStyles-Wert|Elemente in s neben Ziffern zulässig|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Die *Ziffern* nur Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Sprachelement *.* und *Dezimalstellen* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Die `s` Parameter können auch Exponentialschreibweise. Dieses Flag unterstützt Werte im Formular *Ziffern*E*Ziffern*; zusätzliche Flags sind erforderlich, um Zeichenfolgen mit Elementen, z. B. positive oder negative Vorzeichen und Dezimaltrennzeichen erfolgreich analysiert.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *Anmeldung* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *Anmeldung* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *Anmeldung* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Die *,* Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Die * $ * Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Die `s` Parameter keine hexadezimale Zahl oder einer Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `s`, *Anmeldung* am Anfang des `s`, und die *.* Symbol. Die `s` Parameter können auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`, `sign`, *,*, und *.* Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Formatvorlagen außer `s` eine hexadezimale Zahl nicht darstellen kann.|  
  
 Die `s` Parameter analysiert wird, unter Verwendung der Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> Objekt initialisiert wurde, für die aktuelle Systemkultur. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>.  
  
 Ein <xref:System.Decimal> hat die Genauigkeit von 29 Stellen. Wenn `s` eine Zahl ein, die mehr als 29 Stellen jedoch einen Teil mit Bruchzahlen und wird innerhalb des Bereichs von <xref:System.Decimal.MaxValue> und <xref:System.Decimal.MinValue>, die Zahl gerundet wird, nicht auf 29 Ziffern, die in den nächsten gekürzt.  
  
 Wenn eine Trennzeichen in kommt die `s` Parameter bei einem Analysevorgang `styles` enthält die <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Werte, und die geltenden Währung oder Anzahl von Dezimalstellen und Gruppentrennzeichen identisch sind, der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen und Gruppentrennzeichen ist. Weitere Informationen über Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.Decimal.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> Methode analysiert die zeichenfolgendarstellungen <xref:System.Decimal> Werte mithilfe der Kultur En-US.  
  
 [!code-csharp[System.Decimal.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Parse/CS/parse.cs#2)]
 [!code-vb[System.Decimal.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Parse/VB/parse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  Oder:  <paramref name="style" /> ist der Wert <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> weist nicht das richtige Format auf.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" /> ist.</exception>
        <altmember cref="Overload:System.Decimal.TryParse" />
        <altmember cref="M:System.Decimal.ToString" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static decimal Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolgendarstellung der zu konvertierenden Zahl.</param>
        <param name="provider">Ein <see cref="T:System.IFormatProvider" />, der kulturabhängige Analyseinformationen über <c>s</c> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl unter Verwendung der angegebenen kulturspezifischen Formatierungsinformationen in die <see cref="T:System.Decimal" />-Entsprechung.</summary>
        <returns>Die <see cref="T:System.Decimal" />-Zahl, die der in <paramref name="s" /> enthaltenen Zahl entspricht, wie durch <paramref name="provider" /> angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung der der <xref:System.Decimal.Parse%28System.String%2CSystem.IFormatProvider%29> Methode wird häufig verwendet, um Text zu konvertieren, die in einer Vielzahl von Möglichkeiten, formatiert werden, kann ein <xref:System.Decimal> Wert. Beispielsweise kann verwendet werden, konvertieren Sie den Text in einem Textfeld HTML in einen numerischen Wert von einem Benutzer eingegeben.  
  
 Die `s` Parameter enthält eine Reihe von der Form:  
  
 [ws] [anmelden] [Ziffern] Ziffern [.fractional-Ziffern] [ws]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum.|  
|*sign*|Einem optionalen Vorzeichen.|  
|*Ziffern*|Eine Folge von Ziffern zwischen 0 und 9.|  
|*,*|Eine kulturspezifische Tausende Trennzeichen.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen.|  
|*fractional-digits*|Eine Folge von Ziffern zwischen 0 und 9.|  
  
 Die `s` Parameter wird interpretiert, mit der <xref:System.Globalization.NumberStyles.Number?displayProperty=nameWithType> Stil. Dies bedeutet, dass Leerraum und Tausenden Trennzeichen zulässig sind jedoch Währungssymbole nicht. Um die Elemente explizit definieren (z. B. Währungssymbole, Tausendertrennzeichen Trennzeichen und Leerzeichen) in vorhanden sein können `s`, verwenden die <xref:System.Decimal.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung, z. B. eine <xref:System.Globalization.NumberFormatInfo> oder <xref:System.Globalization.CultureInfo> Objekt. Die `provider` Parameter liefert kulturspezifische Informationen, die bei der Analyse verwendet. Wenn `provider` gleich `null` ist, wird die aktuelle Threadkultur verwendet.  
  
 Ein <xref:System.Decimal> Objekt hat die Genauigkeit von 29 Stellen. Wenn `s` eine Zahl ein, die mehr als 29 Stellen jedoch einen Teil mit Bruchzahlen und wird innerhalb des Bereichs von <xref:System.Decimal.MaxValue> und <xref:System.Decimal.MinValue>, die Zahl gerundet wird, nicht auf 29 Ziffern, die in den nächsten gekürzt.  
  
 Wenn eine Trennzeichen in kommt die `s` Parameter, während ein Analysevorgang und der geltenden Währung oder die Anzahl von Dezimalstellen und Gruppentrennzeichen stimmen überein, der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe als Trennzeichen. Weitere Informationen über Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel wird die Schaltfläche mit der click-Ereignishandler, der ein Web Form. Er verwendet das zurückgegebene Array die <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> Eigenschaft um Gebietsschema des Benutzers zu bestimmen. Klicken Sie dann instanziiert einen <xref:System.Globalization.CultureInfo> -Objekt, das diesem Gebietsschema entspricht. Die <xref:System.Globalization.NumberFormatInfo> -Objekt, das zu gehört <xref:System.Globalization.CultureInfo> Objekt wird dann zum Übergeben der <xref:System.Decimal.Parse%28System.String%2CSystem.IFormatProvider%29> Methode, um den Benutzer Konvertieren der Eingabe für eine <xref:System.Decimal> Wert.  
  
 [!code-csharp[ParseMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#3)]
 [!code-vb[ParseMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> hat nicht das richtige Format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" /> ist.</exception>
        <altmember cref="Overload:System.Decimal.TryParse" />
        <altmember cref="M:System.Decimal.ToString" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static decimal Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Number, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Number, Optional provider As IFormatProvider = null) As Decimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static decimal Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolgendarstellung der zu konvertierenden Zahl.</param>
        <param name="style">Eine bitweise Kombination von <see cref="T:System.Globalization.NumberStyles" />-Werten, die die Stilelemente angeben, die in <c>s</c> vorhanden sein können. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Number" />.</param>
        <param name="provider">Ein <see cref="T:System.IFormatProvider" />-Objekt, das kulturspezifische Informationen zum Format von <c>s</c> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl unter Verwendung des angegebenen Stils und kulturspezifischer Formatierungsinformationen in die <see cref="T:System.Decimal" />-Entsprechung.</summary>
        <returns>Die <see cref="T:System.Decimal" />-Zahl, die gemäß den Angaben in <paramref name="s" /> und <paramref name="style" /> der in <paramref name="provider" /> enthaltenen Zahl entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `style` Parameter definiert das zulässige Format von der `s` Parameter, damit der Analysevorgang erfolgreich ausgeführt werden kann. Es muss eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration. Die folgenden <xref:System.Globalization.NumberStyles> Elemente werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Abhängig vom Wert der `style`die `s` -Parameter enthält möglicherweise die folgenden Elemente:  
  
 [ws] [$] [anmelden] [Ziffern] Ziffern [.fractional-Ziffern] [-e [Anmeldung] Ziffern] [ws]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*$*|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, indem die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> Eigenschaften der <xref:System.Globalization.NumberFormatInfo> zurückgegebenes Objekt die <xref:System.IFormatProvider.GetFormat%2A> Methode der `provider` Parameter. Das Währungssymbol stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag.|  
|*ws*|Optionaler Leerraum. Leerzeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag.|  
|*sign*|Einem optionalen Vorzeichen. Die Zeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> Flag kann angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `s` zum Angeben eines negativen Werts Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Flag.|  
|*Ziffern*|Eine Folge von Ziffern zwischen 0 und 9.|  
|*,*|Eine kulturspezifische Tausende Trennzeichen. Das Tausendertrennzeichen Trennzeichen der Kultur definiert wird, indem Sie `provider` erscheinen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flag.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen. Der Kultur definiert wird, indem Sie das Dezimaltrennzeichen `provider` erscheinen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|*fractional-digits*|Eine Folge von Ziffern zwischen 0 und 9. Dezimalstellen erscheinen `s` nur, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|*e*|Die "e" oder "E"-Zeichen, das gibt an, dass der Wert in Exponentialschreibweise dargestellt wird. Die `s` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag.|  
  
 Eine Zeichenfolge mit nur-Ziffern (entspricht der <xref:System.Globalization.NumberStyles.None> Stil) immer erfolgreich analysiert. Die verbleibenden <xref:System.Globalization.NumberStyles> Member steuern Elemente, die nicht unbedingt in der Eingabezeichenfolge vorhanden sein. In der folgenden Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Mitglieder Auswirkungen auf die Elemente, die möglicherweise vorhandene in `s`.  
  
|NumberStyles-Wert|Elemente in s neben Ziffern zulässig|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Die *Ziffern* nur Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Sprachelement *.* und *Dezimalstellen* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Die `s` Parameter können auch Exponentialschreibweise.  Dieses Flag unterstützt Werte im Formular *Ziffern*E*Ziffern*; zusätzliche Flags sind erforderlich, um Zeichenfolgen mit Elementen, z. B. positive oder negative Vorzeichen und Dezimaltrennzeichen erfolgreich analysiert.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *Anmeldung* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *Anmeldung* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *Anmeldung* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Die *,* Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Die * $ * Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Die `s` Parameter keine hexadezimale Zahl oder einer Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `s`, *Anmeldung* am Anfang des `s`, und die *.* Symbol. Die `s` Parameter können auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`, `sign`, *,*, und *.* Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Formatvorlagen außer `s` eine hexadezimale Zahl nicht darstellen kann.|  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung, z. B. eine <xref:System.Globalization.NumberFormatInfo> oder <xref:System.Globalization.CultureInfo> Objekt. Die `provider` Parameter liefert kulturspezifische Informationen, die bei der Analyse verwendet. Wenn `provider` gleich `null` ist, wird die aktuelle Threadkultur verwendet.  
  
 Ein <xref:System.Decimal> Objekt hat die Genauigkeit von 29 Stellen. Wenn `s` eine Zahl ein, die mehr als 29 Stellen jedoch einen Teil mit Bruchzahlen und wird innerhalb des Bereichs von <xref:System.Decimal.MaxValue> und <xref:System.Decimal.MinValue>, die Zahl gerundet wird, nicht auf 29 Ziffern, die in den nächsten gekürzt.  
  
 Wenn eine Trennzeichen in kommt die `s` Parameter, während ein Analysevorgang und der geltenden Währung oder die Anzahl von Dezimalstellen und Gruppentrennzeichen stimmen überein, der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe als Trennzeichen. Weitere Informationen über Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Vielzahl von `style` und `provider` Parameter analysiert die zeichenfolgendarstellungen <xref:System.Decimal> Werte.  
  
 [!code-csharp[System.Decimal.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Parse/CS/parse.cs#3)]
 [!code-vb[System.Decimal.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Parse/VB/parse.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> weist nicht das richtige Format auf.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" /> ist.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  Oder:  <paramref name="style" /> ist der Wert <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="Overload:System.Decimal.TryParse" />
        <altmember cref="M:System.Decimal.ToString" />
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static decimal Remainder (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Remainder(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Remainder(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Remainder(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Der Dividend.</param>
        <param name="d2">Der Divisor.</param>
        <summary>Berechnet den Rest der Division zweier <see cref="T:System.Decimal" />-Werte.</summary>
        <returns>Der Rest aus der Division von <paramref name="d1" /> durch <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Decimal.Remainder%2A> Methode, um den Rest in einer Folge von Divisionsoperationen zu berechnen.  
  
 [!code-csharp[System.Decimal.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.remainder/cs/remainder.cs#1)]
 [!code-vb[System.Decimal.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.remainder/vb/remainder.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="d2" /> ist 0 (null).</exception>
        <exception cref="T:System.OverflowException">Der Rückgabewert ist kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Round">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rundet einen Wert auf die nächste Ganzzahl oder auf die angegebene Anzahl von Dezimalstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Round(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Eine zu rundende Dezimalzahl.</param>
        <summary>Rundet einen Dezimalwert auf die nächste Ganzzahl.</summary>
        <returns>Die Ganzzahl, die dem <paramref name="d" />-Parameter am nächsten ist. Wenn <paramref name="d" /> genau in der Mitte zwischen zwei Ganzzahlen liegt (von denen eine gerade und die andere ungerade ist), wird die gerade Zahl zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten dieser Methode folgt Standard IEEE-754, Abschnitt 4. Diese Art von Rundung bezeichnet *runden Hälfte sogar* oder *Banker rounding*. Es so werden Rundungsfehler reduziert, die sich aus runden Mitte liegenden Werten in nur eine Richtung ergeben. Entspricht dem Aufrufen der <xref:System.Decimal.Round%28System.Decimal%2CSystem.MidpointRounding%29> Methode mit einem `mode` Argument <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird einen Bereich von <xref:System.Decimal> Werte zwischen 100 und 102 auf die nächste Ganzzahl. Da die Methode unverzerrte Rundung verwendet, beachten Sie, dass 100.5 auf 100 und 101.5 rundet 102 rundet aus.  
  
 [!code-csharp[System.Decimal.Round#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.Round/cs/Round1.cs#1)]
 [!code-vb[System.Decimal.Round#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.Round/vb/Round1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Das Ergebnis liegt außerhalb des Bereichs eines <see cref="T:System.Decimal" />-Werts.</exception>
        <altmember cref="M:System.Math.Round(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Round(System.Decimal,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, decimals As Integer) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, int decimals);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="d">Eine zu rundende Dezimalzahl.</param>
        <param name="decimals">Ein Wert zwischen 0 (null) und 28, der die Anzahl der Dezimalstellen angibt, auf die gerundet werden soll.</param>
        <summary>Rundet einen <see cref="T:System.Decimal" />-Wert auf die angegebene Anzahl von Dezimalstellen.</summary>
        <returns>Die Dezimalzahl, die dem auf <paramref name="d" /> Dezimalstellen gerundeten Wert von <paramref name="decimals" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht dem Aufrufen der <xref:System.Decimal.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29> Methode mit einem `mode` Argument <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>. Wenn `d` ist genau in der Mitte zwischen zwei Werten gerundet, ist das Ergebnis der gerundete Wert, der eine gerade Zahl in die am weitesten rechts Dezimalstelle aufweist. Der Wert 2,345 wird z. B. bei einer Rundung auf zwei Dezimalziffern zu 2,34, und der Wert 2,355 wird zu 2,36. Dieser Prozess wird als bezeichnet *sogar Rundung*, oder *Banker rounding*. Es so werden Rundungsfehler reduziert, die sich aus runden Mitte liegenden Werten in nur eine Richtung ergeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird mehrere `Decimal` Werte für eine angegebene Anzahl von Dezimalstellen, die mithilfe der `Round` Methode.  
  
 [!code-csharp[System.Decimal.Round#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.Round/cs/Round12.cs#12)]
 [!code-vb[System.Decimal.Round#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.Round/vb/Round12.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="decimals" /> ist kein Wert zwischen 0 (null) und 28.</exception>
        <altmember cref="M:System.Decimal.Floor(System.Decimal)" />
        <altmember cref="M:System.Decimal.Truncate(System.Decimal)" />
        <altmember cref="M:System.Math.Round(System.Decimal,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Round(System.Decimal,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, mode As MidpointRounding) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d">Eine zu rundende Dezimalzahl.</param>
        <param name="mode">Ein Wert, der angibt, wie <c>d</c> gerundet wird, wenn es genau zwischen zwei Zahlen liegt.</param>
        <summary>Rundet einen Dezimalwert auf die nächste Ganzzahl. Ein Parameter gibt an, wie der Wert gerundet wird, wenn er genau zwischen zwei Zahlen liegt.</summary>
        <returns>Die Ganzzahl, die dem <paramref name="d" />-Parameter am nächsten ist. Wenn <paramref name="d" /> genau in der Mitte zwischen zwei Zahlen liegt (von denen eine gerade und die andere ungerade ist), bestimmt der <paramref name="mode" />-Parameter, welche der beiden Zahlen zurückgegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Mitte liegenden Werten ist der Wert nach der am wenigsten signifikante Ziffer in das Ergebnis genau halbem Weg zwischen zwei Zahlen. 7.5 ist z. B. einen Wert für den Mittelpunkt, wird jedoch auf eine ganze Zahl gerundet. Für Werte für Mittelpunkt und der nächste Wert kann nicht leicht identifiziert werden ohne eine Rundung gilt, ist die `mode` Argument. Die <xref:System.Decimal.Round%2A> Methode unterstützt zwei Rundung Konventionen für die Behandlung Mittelpunkt-Werte.  
  
 Aufgerundet.  
 Mittelpunkt Werte werden auf die nächste Zahl von NULL Weg gerundet. Beispielsweise Rundet 3.5, 4, 4.5 runden auf 5,-3.5 in-4, gerundet und-4.5 Rundet-5. Diese Form der Rundung wird dargestellt, indem die <xref:System.MidpointRounding.AwayFromZero?displayProperty=nameWithType> Enumerationsmember.  
  
 Aufgerundet ist die am häufigsten bekannten Form der Rundung.  
  
 Dies gilt auch für Rundung oder unverzerrte Rundung  
 Mittelpunkt Werte werden auf die nächste gerade Zahl gerundet. Z. B. 3.5 und 4.5 runden, 4 und-3.5 und-4.5 zu-4 gerundet. Diese Form der Rundung wird dargestellt, indem die <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType> Enumerationsmember.  
  
 Auf den nächsten Wert gerundet wird der Standardform des Rundung in finanzielle und statistische Vorgängen verwendet. Es entspricht dem Standard IEEE 754, Abschnitt 4. Bei Verwendung in mehreren Rundungsoperationen verringert sich die Rundungsfehler, die vom Mittelpunkt der Werte in einer Richtung runden verursacht wird. In einigen Fällen kann diese Rundungsfehler erheblich sein.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Rückgabewerte der <xref:System.Math.Round%28System.Decimal%29> -Methode, die <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> Methode mit eine `mode` Argument des <xref:System.MidpointRounding.ToEven>, und die <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> Methode mit einer `mode` Argument des <xref:System.MidpointRounding.AwayFromZero>.  
  
 [!code-csharp[System.Math.Round.Overload#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint1.cs#5)]
 [!code-vb[System.Math.Round.Overload#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> ist kein <see cref="T:System.MidpointRounding" />-Wert.</exception>
        <exception cref="T:System.OverflowException">Das Ergebnis liegt außerhalb des Bereichs eines <see cref="T:System.Decimal" />-Objekts.</exception>
        <altmember cref="M:System.Math.Round(System.Decimal,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, decimals As Integer, mode As MidpointRounding) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, int decimals, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d">Eine zu rundende Dezimalzahl.</param>
        <param name="decimals">Die Anzahl der signifikanten Dezimalstellen (Genauigkeit) im Rückgabewert.</param>
        <param name="mode">Ein Wert, der angibt, wie <c>d</c> gerundet wird, wenn es genau zwischen zwei Zahlen liegt.</param>
        <summary>Rundet einen Dezimalwert auf eine angegebene Genauigkeit. Ein Parameter gibt an, wie der Wert gerundet wird, wenn er genau zwischen zwei Zahlen liegt.</summary>
        <returns>Die Zahl, die dem <paramref name="d" />-Parameter am nächsten ist, der die gleiche Genauigkeit wie der <paramref name="decimals" />-Parameter aufweist. Wenn <paramref name="d" /> genau in der Mitte zwischen zwei Zahlen liegt (von denen eine gerade und die andere ungerade ist), bestimmt der <paramref name="mode" />-Parameter, welche der beiden Zahlen zurückgegeben wird. Wenn die Genauigkeit von <paramref name="d" /> kleiner als <paramref name="decimals" /> ist, wird <paramref name="d" /> unverändert zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `decimals` Parameter gibt die Anzahl der signifikanten Dezimalstellen im Rückgabewert und reicht von 0 bis 28. Wenn `decimals` NULL ist, wird eine ganze Zahl zurückgegeben.  
  
 In der Mitte liegenden Werten ist der Wert nach der am wenigsten signifikante Ziffer in das Ergebnis genau halbem Weg zwischen zwei Zahlen. Beispielsweise ist 3.47500 Mitte liegenden Werten wird jedoch werden auf zwei Dezimalstellen gerundet und 7.500 ist Mitte liegenden Werten aus, wenn es auf eine ganze Zahl gerundet. In diesen Fällen der nächste Wert kann nicht leicht identifiziert werden ohne eine Rundung gilt, ist die `mode` Argument. Die <xref:System.Decimal.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29> Methode unterstützt zwei Rundung Konventionen für die Behandlung Mittelpunkt-Werte.  
  
 Aufgerundet.  
 Mittelpunkt Werte werden auf die nächste Zahl von NULL Weg gerundet. 3,75 abgerundet, 3.8, 3,85 runden, 3.9,-3.75 in-3.8, gerundet und-3.85 auf-3.9 gerundet. Diese Form der Rundung wird dargestellt, indem die <xref:System.MidpointRounding.AwayFromZero?displayProperty=nameWithType> Enumerationsmember.  
  
 Aufgerundet ist die am häufigsten bekannten Form der Rundung.  
  
 Dies gilt auch für Rundung oder unverzerrte Rundung  
 Mittelpunkt Werte werden auf die nächste gerade Zahl gerundet. Beispielsweise 3,75 und 3,85 gerundet wird, um 3.8 und-3.75 und-3.85 gerundet wird, um-3.8. Diese Form der Rundung wird dargestellt, indem die <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType> Enumerationsmember.  
  
 Auf den nächsten Wert gerundet wird der Standardform des Rundung in finanzielle und statistische Vorgängen verwendet. Es entspricht dem Standard IEEE 754, Abschnitt 4. Bei Verwendung in mehreren Rundungsoperationen verringert sich die Rundungsfehler, die vom Mittelpunkt der Werte in einer Richtung runden verursacht wird. In einigen Fällen kann diese Rundungsfehler erheblich sein.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29> Methode mit dem <xref:System.MidpointRounding> Enumeration.  
  
 [!code-cpp[math.midpointrounding#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.midpointrounding/cpp/mpr.cpp#1)]
 [!code-csharp[math.midpointrounding#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.midpointrounding/CS/mpr.cs#1)]
 [!code-vb[math.midpointrounding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.midpointrounding/VB/mpr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="decimals" /> ist kleiner als 0 (null) oder größer als 28.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> ist kein <see cref="T:System.MidpointRounding" />-Wert.</exception>
        <exception cref="T:System.OverflowException">Das Ergebnis liegt außerhalb des Bereichs eines <see cref="T:System.Decimal" />-Objekts.</exception>
        <altmember cref="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static decimal Subtract (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Subtract(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Subtract(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (d1 As Decimal, d2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Subtract(System::Decimal d1, System::Decimal d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">Der Minuend.</param>
        <param name="d2">Der Subtrahend.</param>
        <summary>Subtrahiert einen angegebenen <see cref="T:System.Decimal" />-Wert von einem anderen.</summary>
        <returns>Das Ergebnis der Subtraktion von <paramref name="d2" /> von <paramref name="d1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von `Subtract`.  
  
 [!code-cpp[Decimal Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Decimal Example/CPP/source.cpp#4)]
 [!code-csharp[Decimal Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Decimal Example/CS/source.cs#4)]
 [!code-vb[Decimal Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Decimal Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Rückgabewert ist kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
        <altmember cref="M:System.Decimal.Add(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Multiply(System.Decimal,System.Decimal)" />
        <altmember cref="M:System.Decimal.Divide(System.Decimal,System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" />, wenn der Wert der aktuellen Instanz nicht 0 (null) ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Decimal>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToBoolean%28System.Decimal%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Byte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Decimal>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist, rufen Sie entweder die <xref:System.Decimal.ToByte%2A?displayProperty=nameWithType> Methode oder die <xref:System.Convert.ToByte%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der resultierende Ganzzahlwert ist kleiner als <see cref="F:System.Byte.MinValue" /> oder größer als <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Diese Konvertierung wird nicht unterstützt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Keine Diese Konvertierung wird nicht unterstützt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Diese Konvertierung wird nicht unterstützt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Keine Diese Konvertierung wird nicht unterstützt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Der unveränderte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Decimal>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Double" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Decimal>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist, rufen Sie entweder die <xref:System.Decimal.ToDouble%2A?displayProperty=nameWithType> Methode oder die <xref:System.Convert.ToDouble%2A?displayProperty=nameWithType> Methode.  
  
 Da eine <xref:System.Double> hat weniger signifikante Ziffern als ein <xref:System.Decimal>, diesen Vorgang möglicherweise Rundungsfehler erzeugen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Decimal>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist, rufen Sie entweder die <xref:System.Decimal.ToInt16%2A?displayProperty=nameWithType> Methode oder die <xref:System.Convert.ToInt16%2A?displayProperty=nameWithType> Methode.  
  
 Die <xref:System.Decimal> Wert wird in Richtung 0 (null), auf die nächste Ganzzahl gerundet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der resultierende Ganzzahlwert ist kleiner als <see cref="F:System.Int16.MinValue" /> oder größer als <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Der Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Decimal>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist, rufen Sie entweder die <xref:System.Decimal.ToInt32%2A?displayProperty=nameWithType> Methode oder die <xref:System.Convert.ToInt32%2A?displayProperty=nameWithType> Methode.  
  
 Die <xref:System.Decimal> Wert wird in Richtung 0 (null), auf die nächste Ganzzahl gerundet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der resultierende Ganzzahlwert ist kleiner als <see cref="F:System.Int32.MinValue" /> oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Decimal>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist, rufen Sie entweder die <xref:System.Decimal.ToInt64%2A?displayProperty=nameWithType> Methode oder die <xref:System.Convert.ToInt64%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der resultierende Ganzzahlwert ist kleiner als <see cref="F:System.Int64.MinValue" /> oder größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.SByte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Decimal>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist, rufen Sie entweder die <xref:System.Decimal.ToSByte%2A?displayProperty=nameWithType> Methode oder die <xref:System.Convert.ToSByte%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der resultierende Ganzzahlwert ist kleiner als <see cref="F:System.SByte.MinValue" /> oder größer als <see cref="F:System.SByte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Single" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Decimal>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist, rufen Sie entweder die <xref:System.Decimal.ToSingle%2A?displayProperty=nameWithType> Methode oder die <xref:System.Convert.ToSingle%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, in den der Wert dieser <see cref="T:System.Decimal" />-Instanz konvertiert werden soll.</param>
        <param name="provider">Eine <see cref="T:System.IFormatProvider" />-Implementierung, die kulturspezifische Informationen zum Format des zurückgegebenen Werts bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Der in ein <paramref name="type" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Decimal>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der `static` (`Shared` in Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> Methode stattdessen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Die angeforderte Typkonvertierung wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Decimal>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist, rufen Sie entweder die <xref:System.Decimal.ToUInt16%2A?displayProperty=nameWithType> Methode oder die <xref:System.Convert.ToUInt16%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der resultierende Ganzzahlwert ist kleiner als <see cref="F:System.UInt16.MinValue" /> oder größer als <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Decimal>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist, rufen Sie entweder die <xref:System.Decimal.ToUInt32%2A?displayProperty=nameWithType> Methode oder die <xref:System.Convert.ToUInt32%2A?displayProperty=nameWithType> Methode.  
  
 Die <xref:System.Decimal> Wert wird in Richtung 0 (null), auf die nächste Ganzzahl gerundet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der resultierende Ganzzahlwert ist kleiner als <see cref="F:System.UInt32.MinValue" /> oder größer als <see cref="F:System.UInt32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Decimal>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist, rufen Sie entweder die <xref:System.Decimal.ToUInt64%2A?displayProperty=nameWithType> Methode oder die <xref:System.Convert.ToUInt64%2A?displayProperty=nameWithType> Methode.  
  
 Die <xref:System.Decimal> Wert wird in Richtung 0 (null), auf die nächste Ganzzahl gerundet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der resultierende Ganzzahlwert ist kleiner als <see cref="F:System.UInt64.MinValue" /> oder größer als <see cref="F:System.UInt64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.IDeserializationCallback.OnDeserialization">
      <MemberSignature Language="C#" Value="void IDeserializationCallback.OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDeserialization (sender As Object) Implements IDeserializationCallback.OnDeserialization" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System::Object ^ sender) = System::Runtime::Serialization::IDeserializationCallback::OnDeserialization;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">Das Objekt, das den Rückruf initiiert hat. Die Funktionen für diesen Parameter sind derzeit nicht implementiert.</param>
        <summary>Wird ausgeführt, wenn die Deserialisierung eines Objekts abgeschlossen ist.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Das <see cref="T:System.Decimal" />-Objekt enthält ungültige oder beschädigte Daten.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToByte(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToByte (value As Decimal) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ToByte(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende Dezimalzahl.</param>
        <summary>Konvertiert den Wert des angegebenen <see cref="T:System.Decimal" /> in die entsprechende 8-Bit-Ganzzahl ohne Vorzeichen.</summary>
        <returns>Eine 8-Bit-Ganzzahl ohne Vorzeichen, die <paramref name="value" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parameter `value` auf den nächsten ganzzahligen Wert in Richtung 0 gerundet wird und dass das Ergebnis zurückgegeben wird.  
  
 Sie können auch konvertieren eine <xref:System.Decimal> Wert auf eine 8-Bit-Ganzzahl ohne Vorzeichen mithilfe der <xref:System.Decimal.op_Explicit%2A> Zuweisungsoperator. Da der Operator eine einschränkende Konvertierung ausführt, müssen Sie einen Typumwandlungsoperator in C#- oder eine Konvertierungsfunktion in Visual Basic verwenden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Decimal.ToByte%2A> Methode, um zu Dezimalzahlen konvertieren <xref:System.Byte> Werte.  
  
 [!code-csharp[System.Decimal.ToByte#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.tobyte/cs/tobyte_1.cs#1)]
 [!code-vb[System.Decimal.ToByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.tobyte/vb/tobyte_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist kleiner als <see cref="F:System.Byte.MinValue" /> oder größer als <see cref="F:System.Byte.MaxValue" />.</exception>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToDouble(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToDouble (d As Decimal) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double ToDouble(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Die zu konvertierende Dezimalzahl.</param>
        <summary>Konvertiert den Wert des angegebenen <see cref="T:System.Decimal" /> in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die <paramref name="d" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang kann Rundungsfehler erzeugen, da eine Gleitkommazahl mit doppelter Genauigkeit weniger signifikante Ziffern als hat eine <xref:System.Decimal>.  
  
 Können außerdem konvertiert eine <xref:System.Decimal> auf eine <xref:System.Double> Wert mithilfe der <xref:System.Decimal.op_Explicit%2A> Zuweisungsoperator. Da die Konvertierung einem Genauigkeitsverlust führen kann, müssen Sie einen Typumwandlungsoperator in C#- oder eine Konvertierungsfunktion in Visual Basic verwenden.  
  
   
  
## Examples  
 Der folgende code konvertiert `Decimal` -Zahlen <xref:System.Double> Werte mit `ToDouble` Methode.  
  
 [!code-cpp[System.Decimal.ToXXX#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.ToXXX/CPP/tosgl_dbl.cpp#5)]
 [!code-csharp[System.Decimal.ToXXX#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.ToXXX/CS/tosgl_dbl.cs#5)]
 [!code-vb[System.Decimal.ToXXX#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.ToXXX/VB/tosgl_dbl.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToInt16(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToInt16 (value As Decimal) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ToInt16(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende Dezimalzahl.</param>
        <summary>Konvertiert den Wert des angegebenen <see cref="T:System.Decimal" /> in die entsprechende 16-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Eine 16-Bit-Ganzzahl mit Vorzeichen, die <paramref name="value" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch Konvertieren einer <xref:System.Decimal> Wert in eine 16-Bit-Ganzzahl mit der <xref:System.Decimal.op_Explicit%2A> Zuweisungsoperator. Da der Operator eine einschränkende Konvertierung ausführt, müssen Sie einen Typumwandlungsoperator in C#- oder eine Konvertierungsfunktion in Visual Basic verwenden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Decimal.ToInt16%2A> Methode, um zu Dezimalzahlen konvertieren <xref:System.Int16> Werte.  
  
 [!code-csharp[System.Decimal.ToInt16#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.toint16/cs/toint16_1.cs#1)]
 [!code-vb[System.Decimal.ToInt16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.toint16/vb/toint16_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist kleiner als <see cref="F:System.Int16.MinValue" /> oder größer als <see cref="F:System.Int16.MaxValue" />.</exception>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToInt32(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToInt32 (d As Decimal) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ToInt32(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Die zu konvertierende Dezimalzahl.</param>
        <summary>Konvertiert den Wert des angegebenen <see cref="T:System.Decimal" /> in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die dem Wert von <paramref name="d" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert ist der ganzzahlige Teil des decimal-Werts; Dezimalstellen werden abgeschnitten.  
  
 Sie können auch Konvertieren einer <xref:System.Decimal> Wert in eine 32-Bit-Ganzzahl mit der <xref:System.Decimal.op_Explicit%2A> Zuweisungsoperator. Da der Operator eine einschränkende Konvertierung ausführt, müssen Sie einen Typumwandlungsoperator in C#- oder eine Konvertierungsfunktion in Visual Basic verwenden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Decimal.ToInt32%2A> Methode, um zu Dezimalzahlen konvertieren <xref:System.Int32> Werte.  
  
 [!code-csharp[System.Decimal.ToInt32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.toint32/cs/toint32_1.cs#1)]
 [!code-vb[System.Decimal.ToInt32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.toint32/vb/toint32_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="d" /> ist kleiner als <see cref="F:System.Int32.MinValue" /> oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToInt64(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToInt64 (d As Decimal) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ToInt64(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Die zu konvertierende Dezimalzahl.</param>
        <summary>Konvertiert den Wert des angegebenen <see cref="T:System.Decimal" /> in die entsprechende 64-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Eine 64-Bit-Ganzzahl mit Vorzeichen, die dem Wert von <paramref name="d" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert ist der ganzzahlige Teil des decimal-Werts; Dezimalstellen werden abgeschnitten.  
  
 Sie können auch Konvertieren einer <xref:System.Decimal> Wert in eine 64-Bit-Ganzzahl mit der <xref:System.Decimal.op_Explicit%2A> Zuweisungsoperator. Da der Operator eine einschränkende Konvertierung ausführt, müssen Sie einen Typumwandlungsoperator in C#- oder eine Konvertierungsfunktion in Visual Basic verwenden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Decimal.ToInt64%2A> Methode, um zu Dezimalzahlen konvertieren <xref:System.Int64> Werte.  
  
 [!code-csharp[System.Decimal.ToInt64#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.toint64/cs/toint64_1.cs#1)]
 [!code-vb[System.Decimal.ToInt64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.toint64/vb/toint64_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="d" /> ist kleiner als <see cref="F:System.Int64.MinValue" /> oder größer als <see cref="F:System.Int64.MaxValue" />.</exception>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="ToOACurrency">
      <MemberSignature Language="C#" Value="public static long ToOACurrency (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToOACurrency(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToOACurrency(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToOACurrency (value As Decimal) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ToOACurrency(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende Dezimalzahl.</param>
        <summary>Konvertiert den angegebenen <see cref="T:System.Decimal" />-Wert in den entsprechenden Currency-Wert für OLE-Automatisierung, der in einer 64-Bit-Ganzzahl mit Vorzeichen enthalten ist.</summary>
        <returns>Eine 64-Bit-Ganzzahl mit Vorzeichen, die den entsprechenden Wert von <paramref name="value" /> für die OLE-Automatisierung enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird mit der `ToOACurrency` -Methode zum Konvertieren `Decimal` Zahlen auf die entsprechende OLE-Automatisierung Currency-Werte, die in enthaltenen <xref:System.Int64> Felder.  
  
 [!code-cpp[System.Decimal.OACurrency#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.OACurrency/CPP/tooacurrency.cpp#1)]
 [!code-csharp[System.Decimal.OACurrency#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.OACurrency/CS/tooacurrency.cs#1)]
 [!code-vb[System.Decimal.OACurrency#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.OACurrency/VB/tooacurrency.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.FromOACurrency(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToSByte(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToSByte (value As Decimal) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte ToSByte(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende Dezimalzahl.</param>
        <summary>Konvertiert den Wert des angegebenen <see cref="T:System.Decimal" /> in die entsprechende 8-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Eine 8-Bit-Ganzzahl mit Vorzeichen, die <paramref name="value" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch konvertieren eine <xref:System.Decimal> Wert einer 8-Bit-Ganzzahl mit Vorzeichen unter Verwendung der <xref:System.Decimal.op_Explicit%2A> Zuweisungsoperator. Da der Operator eine einschränkende Konvertierung ausführt, müssen Sie einen Typumwandlungsoperator in C#- oder eine Konvertierungsfunktion in Visual Basic verwenden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Decimal.ToSByte%2A> Methode, um zu Dezimalzahlen konvertieren <xref:System.SByte> Werte.  
  
 [!code-csharp[System.Decimal.ToSByte#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.tosbyte/cs/tosbyte1.cs#1)]
 [!code-vb[System.Decimal.ToSByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.tosbyte/vb/tosbyte1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Decimal.ToInt16(System.Decimal)" />
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist kleiner als <see cref="F:System.SByte.MinValue" /> oder größer als <see cref="F:System.SByte.MaxValue" />.</exception>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToSingle(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToSingle (d As Decimal) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ToSingle(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Die zu konvertierende Dezimalzahl.</param>
        <summary>Konvertiert den Wert des angegebenen <see cref="T:System.Decimal" /> in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem Wert von <paramref name="d" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang kann Rundungsfehler erzeugen, da eine Gleitkommazahl mit einfacher Genauigkeit weniger signifikante Ziffern als hat eine <xref:System.Decimal>.  
  
 Können außerdem konvertiert eine <xref:System.Decimal> auf eine <xref:System.Single> Wert mithilfe der <xref:System.Decimal.op_Explicit%2A> Zuweisungsoperator. Da die Konvertierung einem Genauigkeitsverlust führen kann, müssen Sie einen Typumwandlungsoperator in C#- oder eine Konvertierungsfunktion in Visual Basic verwenden.  
  
   
  
## Examples  
 Der folgende code konvertiert `Decimal` -Zahlen <xref:System.Single> Werte mithilfe der `ToSingle` Methode.  
  
 [!code-cpp[System.Decimal.ToXXX#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.ToXXX/CPP/tosgl_dbl.cpp#5)]
 [!code-csharp[System.Decimal.ToXXX#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.ToXXX/CS/tosgl_dbl.cs#5)]
 [!code-vb[System.Decimal.ToXXX#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.ToXXX/VB/tosgl_dbl.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den numerischen Wert dieser Instanz in die entsprechende <see cref="T:System.String" />-Darstellung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Eine Zeichenfolge, die den Wert dieser Instanz darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal.ToString> -Methode formatiert einen <xref:System.Decimal> Wert in der Standardeinstellung ("G" oder Allgemeines) Format der aktuellen Kultur. Wenn Sie ein anderes Format oder eine Kultur angeben möchten, verwenden Sie die anderen Überladungen von der <xref:System.Decimal.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Decimal.ToString%28System.IFormatProvider%29>|  
|Einem bestimmten format|Standardkultur (aktueller)|<xref:System.Decimal.ToString%28System.String%29>|  
|Einem bestimmten format|Eine bestimmte Kultur|<xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 .NET Framework bietet eine umfangreiche formatierungsunterstützung, dies wird in den folgenden Themen zur Formatierung ausführlicher beschrieben:  
  
-   Weitere Informationen zu numerischen Formatbezeichnern finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine <xref:System.Decimal> -Wert mithilfe der standardmäßigen <xref:System.Decimal.ToString> Methode. Es zeigt auch die zeichenfolgendarstellungen der <xref:System.Decimal> -Wert, der über eine Reihe von Standardformatbezeichnern Optimierungsfehler.  
  
 [!code-csharp[System.Decimal.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.ToString/CS/ToString2.cs#2)]
 [!code-vb[System.Decimal.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.ToString/VB/ToString2.vb#2)]  
  
 Das folgende Beispiel zeigt die Menge des Money in einem Konto an.  
  
 [!code-cpp[Decimal Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Decimal Example/CPP/source.cpp#5)]
 [!code-csharp[Decimal Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Decimal Example/CS/source.cs#5)]
 [!code-vb[Decimal Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Decimal Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz unter Berücksichtigung der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal.ToString%28System.IFormatProvider%29> -Methode formatiert einen <xref:System.Decimal> Wert in der Standardeinstellung ("G" oder Allgemeines) Format einer angegebenen Kultur. Wenn Sie ein anderes Format oder die aktuelle Kultur angeben möchten, verwenden Sie die anderen Überladungen von der <xref:System.Decimal.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standardkultur (aktueller)|<xref:System.Decimal.ToString>|  
|Einem bestimmten format|Standardkultur (aktueller)|<xref:System.Decimal.ToString%28System.String%29>|  
|Einem bestimmten format|Eine bestimmte Kultur|<xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 .NET Framework bietet eine umfangreiche formatierungsunterstützung, dies wird in den folgenden Themen zur Formatierung ausführlicher beschrieben:  
  
-   Weitere Informationen zu numerischen Formatbezeichnern finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt. In der Regel `provider` ist ein <xref:System.Globalization.NumberFormatInfo> Objekt oder ein <xref:System.Globalization.CultureInfo> Objekt. Die `provider` Parameter liefert kulturspezifische Informationen, die bei der Formatierung verwendete. Wenn `provider` gleich `null` ist, wird die aktuelle Threadkultur verwendet.  
  
 Konvertieren einer <xref:System.Decimal> Wert in die Zeichenfolgendarstellung einer angegebenen Kultur mit einer bestimmten Formatzeichenfolge Aufruf der <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die angegebene Zeichenfolgendarstellung einer <xref:System.Decimal> -Wert mit <xref:System.Globalization.CultureInfo> Objekte, die verschiedene Kulturen darstellen.  
  
 [!code-csharp[System.Decimal.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.ToString/CS/ToString2.cs#3)]
 [!code-vb[System.Decimal.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.ToString/VB/ToString2.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Eine standardmäßige oder benutzerdefinierte numerische Formatierungszeichenfolge.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung unter Berücksichtigung des angegebenen Formats.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Decimal.ToString%28System.String%29> -Methode formatiert einen <xref:System.Decimal> Wert in einem angegebenen Format mit den Konventionen der aktuellen Kultur. Wenn Sie die Standardeinstellung ("G" oder Allgemeines) verwenden möchten formatieren oder eine andere Kultur angegeben, Verwendung der anderen Überladungen der <xref:System.Decimal.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standardkultur (aktueller)|<xref:System.Decimal.ToString>|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Decimal.ToString%28System.IFormatProvider%29>|  
|Einem bestimmten format|Eine bestimmte Kultur|<xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Die <xref:System.Decimal.ToString%2A> Methode verwendet die standardmäßige oder benutzerdefinierte numerische Formatierungszeichenfolge gemäß der `format` Parameter, um den Wert der aktuellen Instanz in seine Zeichenfolgendarstellung zu konvertieren. Die `format` Parameter kann eine beliebige gültige [numerischer Standardformatbezeichner](~/docs/standard/base-types/standard-numeric-format-strings.md) außer D, R, und X sowie eine beliebige Kombination von [benutzerdefinierten Zahlenformatbezeichner](~/docs/standard/base-types/custom-numeric-format-strings.md). Wenn `format` ist `null` oder eine leere Zeichenfolge ist, der Rückgabewert dieser Instanz mit dem allgemeinen numerische Formatbezeichner (G) formatiert ist.  
  
 .NET Framework bietet eine umfangreiche formatierungsunterstützung, dies wird in den folgenden Themen zur Formatierung ausführlicher beschrieben:  
  
-   Weitere Informationen zu numerischen Formatbezeichnern finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Der Rückgabewert wird formatiert, mithilfe der <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur. Rufen Sie zum Anwenden der Formatierungskonventionen der einer angegebenen Kultur der <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine <xref:System.Decimal> -Wert mit den einzelnen unterstützten numerischen Standardformatbezeichnern zusammen mit zwei benutzerdefinierte numerische Formatzeichenfolgen. Konvertieren Sie die numerischen Werte in Zeichenfolgen, wird im Beispiel die Formatierungskonventionen der Kultur En-US verwendet.  
  
 [!code-csharp[System.Decimal.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.ToString/CS/ToString2.cs#4)]
 [!code-vb[System.Decimal.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.ToString/VB/ToString2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.</exception>
        <altmember cref="M:System.Decimal.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Eine numerische Formatierungszeichenfolge.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz unter Verwendung des angegebenen Formats und der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="format" /> und <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29> -Methode formatiert einen <xref:System.Double> Wert in einem angegebenen Format einer angegebenen Kultur. Wenn Sie die Standardeinstellungen Format oder Kultur verwenden möchten, verwenden Sie die andere Überladungen des der <xref:System.Double.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standardkultur (aktueller)|<xref:System.Double.ToString>|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Einem bestimmten format|Standardkultur (aktueller)|<xref:System.Double.ToString%28System.String%29>|  
  
 Die `format` Parameter kann eine beliebige gültige numerische Standardformatbezeichner außer D "," R "," und "X sowie eine beliebige Kombination von benutzerdefinierten Zahlenformatbezeichner sein. Wenn `format` ist `null` oder eine leere Zeichenfolge ist, der Rückgabewert für diese Instanz mit dem allgemeinen numerische Formatbezeichner ("G") formatiert ist.  
  
 .NET Framework bietet eine umfangreiche formatierungsunterstützung, dies wird in den folgenden Themen zur Formatierung ausführlicher beschrieben:  
  
-   Weitere Informationen zu numerischen Formatbezeichnern finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte Zahlenformatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt. In der Regel `provider` ist ein <xref:System.Globalization.NumberFormatInfo> oder <xref:System.Globalization.CultureInfo> Objekt. Die `provider` Parameter liefert kulturspezifische Informationen, die bei der Formatierung verwendete. Wenn `provider` gleich `null` ist, wird die aktuelle Threadkultur verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine <xref:System.Decimal> -Wert mit den einzelnen unterstützten numerischen Standardformatbezeichnern für verschiedene Kulturen.  
  
 [!code-csharp[System.Decimal.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.ToString/CS/ToString2.cs#5)]
 [!code-vb[System.Decimal.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.ToString/VB/ToString2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.</exception>
        <altmember cref="M:System.Decimal.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToUInt16(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUInt16 (value As Decimal) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 ToUInt16(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende Dezimalzahl.</param>
        <summary>Konvertiert den Wert des angegebenen <see cref="T:System.Decimal" /> in die entsprechende 16-Bit-Ganzzahl ohne Vorzeichen.</summary>
        <returns>Eine 16-Bit-Ganzzahl ohne Vorzeichen, die dem Wert von <paramref name="value" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert ist der ganzzahlige Teil des decimal-Werts; Dezimalstellen werden abgeschnitten.  
  
 Sie können auch Konvertieren einer <xref:System.Decimal> Wert einer 16-Bit-Ganzzahl ohne Vorzeichen mit der <xref:System.Decimal.op_Explicit%2A> Zuweisungsoperator. Da der Operator eine einschränkende Konvertierung ausführt, müssen Sie einen Typumwandlungsoperator in C#- oder eine Konvertierungsfunktion in Visual Basic verwenden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Decimal.ToUInt16%2A> Methode, um zu Dezimalzahlen konvertieren <xref:System.UInt16> Werte.  
  
 [!code-csharp[System.Decimal.ToUInt16#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.touint16/cs/touint16_1.cs#1)]
 [!code-vb[System.Decimal.ToUInt16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.touint16/vb/touint16_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Decimal.ToInt32(System.Decimal)" />
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> ist größer als <see cref="F:System.UInt16.MaxValue" /> oder kleiner als <see cref="F:System.UInt16.MinValue" />.</exception>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToUInt32(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUInt32 (d As Decimal) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 ToUInt32(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Die zu konvertierende Dezimalzahl.</param>
        <summary>Konvertiert den Wert des angegebenen <see cref="T:System.Decimal" /> in die entsprechende 32-Bit-Ganzzahl ohne Vorzeichen.</summary>
        <returns>Eine 32-Bit-Ganzzahl ohne Vorzeichen, die dem Wert von <paramref name="d" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert ist der ganzzahlige Teil des decimal-Werts; Dezimalstellen werden abgeschnitten.  
  
 Sie können auch Konvertieren einer <xref:System.Decimal> Wert, der eine 32-Bit-Ganzzahl ohne Vorzeichen mithilfe der <xref:System.Decimal.op_Explicit%2A> Zuweisungsoperator. Da der Operator eine einschränkende Konvertierung ausführt, müssen Sie einen Typumwandlungsoperator in C#- oder eine Konvertierungsfunktion in Visual Basic verwenden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Decimal.ToUInt32%2A> Methode, um zu Dezimalzahlen konvertieren <xref:System.UInt32> Werte.  
  
 [!code-csharp[System.Decimal.ToUInt32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.touint32/cs/touint32_1.cs#1)]
 [!code-vb[System.Decimal.ToUInt32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.touint32/vb/touint32_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Decimal.ToInt64(System.Decimal)" />
        <exception cref="T:System.OverflowException">
          <paramref name="d" /> ist negativ oder größer als <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToUInt64(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUInt64 (d As Decimal) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 ToUInt64(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Die zu konvertierende Dezimalzahl.</param>
        <summary>Konvertiert den Wert des angegebenen <see cref="T:System.Decimal" /> in die entsprechende 64-Bit-Ganzzahl ohne Vorzeichen.</summary>
        <returns>Eine 64-Bit-Ganzzahl ohne Vorzeichen, die dem Wert von <paramref name="d" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert ist der ganzzahlige Teil des decimal-Werts; Dezimalstellen werden abgeschnitten.  
  
 Sie können auch Konvertieren einer <xref:System.Decimal> Wert, der eine 64-Bit-Ganzzahl ohne Vorzeichen mithilfe der <xref:System.Decimal.op_Explicit%2A> Zuweisungsoperator. Da der Operator eine einschränkende Konvertierung ausführt, müssen Sie einen Typumwandlungsoperator in C#- oder eine Konvertierungsfunktion in Visual Basic verwenden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Decimal.ToUInt64%2A> Methode, um zu Dezimalzahlen konvertieren <xref:System.UInt64> Werte.  
  
 [!code-csharp[System.Decimal.ToUInt64#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.touint64/cs/touint64_1.cs#1)]
 [!code-vb[System.Decimal.ToUInt64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.touint64/vb/touint64_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="d" /> ist negativ oder größer als <see cref="F:System.UInt64.MaxValue" />.</exception>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static decimal Truncate (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Truncate(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Truncate(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Truncate(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Die zu verkürzende Dezimalzahl.</param>
        <summary>Gibt den ganzzahligen Teil des angegebenen <see cref="T:System.Decimal" /> zurück; Bruchziffern werden verworfen.</summary>
        <returns>Das auf die nächste ganze Zahl in Richtung 0 gerundete Ergebnis von <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode rundet `d` in Richtung 0 (null), auf die nächste ganze Zahl, entspricht dem verwerfen alle Stellen nach dem Dezimaltrennzeichen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der `Truncate` Methode, um die Dezimalstellen sind von mehreren verwerfen `Decimal` Werte.  
  
 [!code-cpp[System.Decimal.Flr_Neg_Rnd_Trnc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Flr_Neg_Rnd_Trnc/CPP/floor_neg_trunc.cpp#1)]
 [!code-csharp[System.Decimal.Flr_Neg_Rnd_Trnc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Flr_Neg_Rnd_Trnc/CS/floor_neg_trunc.cs#1)]
 [!code-vb[System.Decimal.Flr_Neg_Rnd_Trnc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Flr_Neg_Rnd_Trnc/VB/floor_neg_trunc.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32)" />
        <altmember cref="M:System.Decimal.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wandelt die angegebene Zeichenfolgendarstellung einer Zahl in ihre <see cref="T:System.Decimal" />-Entsprechung um. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <altmember cref="Overload:System.Decimal.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out decimal result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] valuetype System.Decimal&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.TryParse(System.ReadOnlySpan{System.Char},System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] System::Decimal % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Decimal&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out decimal result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] valuetype System.Decimal&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.TryParse(System.String,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] System::Decimal % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Decimal&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolgendarstellung der zu konvertierenden Zahl.</param>
        <param name="result">To be added.</param>
        <summary>Wandelt die angegebene Zeichenfolgendarstellung einer Zahl in ihre <see cref="T:System.Decimal" />-Entsprechung um. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung unterscheidet sich von der <xref:System.Decimal.Parse%28System.String%29?displayProperty=nameWithType> Methode durch einen booleschen Wert, der angibt, ob der Analysevorgang erfolgreich war, anstatt den analysierten numerischen Wert zurückgeben. Es entfällt die Notwendigkeit, mit der Behandlung von Ausnahmen für Testen einer <xref:System.FormatException> , `s` ist ungültig und kann nicht erfolgreich analysiert werden kann.  
  
 Parameter `s` enthält eine Reihe von der Form:  
  
 [ws] [anmelden] [Ziffern] Ziffern [.fractional-Ziffern] [ws]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum.|  
|*sign*|Einem optionalen Vorzeichen.|  
|*Ziffern*|Eine Folge von Ziffern zwischen 0 und 9.|  
|*,*|Eine kulturspezifische Tausende Trennzeichen.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen.|  
|*fractional-digits*|Eine Folge von Ziffern zwischen 0 und 9.|  
  
 Parameter `s` wird die <xref:System.Globalization.NumberStyles.Number?displayProperty=nameWithType> Stil. Dies bedeutet, dass Leerraum und Tausenden Trennzeichen zulässig sind jedoch Währungssymbole nicht. Um die Elemente explizit definieren (z. B. Währungssymbole, Tausendertrennzeichen Trennzeichen und Leerzeichen) in vorhanden sein können `s`, verwenden die <xref:System.Decimal.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Decimal%40%29?displayProperty=nameWithType> methodenüberladung.  
  
 Parameter `s` analysiert unter Verwendung der Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> Objekt initialisiert wurde, für die aktuelle Systemkultur. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Analysieren eine Zeichenfolge unter Verwendung der Formatierungsinformationen einer anderen Kultur angegeben, verwenden Sie die <xref:System.Decimal.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Decimal%40%29?displayProperty=nameWithType> -methodenüberladung.  
  
 Bei Bedarf den Wert des `s` wird auf den nächsten gerundet.  
  
 Ein <xref:System.Decimal> Objekt hat die Genauigkeit von 29 Stellen. Wenn `s` eine Zahl ein, die mehr als 29 Stellen jedoch einen Teil mit Bruchzahlen und wird innerhalb des Bereichs von <xref:System.Decimal.MaxValue> und <xref:System.Decimal.MinValue>, die Zahl gerundet wird, nicht auf 29 Ziffern, die in den nächsten gekürzt.  
  
 Wenn während eines Analysevorgangs eine Trennzeichen, in gefunden wird der `s` -Parameter, und die geltenden Währung oder Anzahl von Dezimalstellen und Gruppentrennzeichen sind identisch, der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe als Trennzeichen. Weitere Informationen über Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Decimal.TryParse%28System.String%2CSystem.Decimal%40%29?displayProperty=nameWithType> Methode, um die zeichenfolgenentsprechungen von numerischen Werten zu konvertieren <xref:System.Decimal> Werte. Es wird davon ausgegangen, dass die aktuelle Kultur "En-US".  
  
 [!code-csharp[System.Decimal.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.TryParse/cs/TryParse.cs#1)]
 [!code-vb[System.Decimal.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.TryParse/vb/TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Decimal.Parse" />
        <altmember cref="M:System.Decimal.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out decimal result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Decimal&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Decimal % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Decimal&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out decimal result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Decimal&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Decimal % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Decimal&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Die Zeichenfolgendarstellung der zu konvertierenden Zahl.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die das zulässige Format von <c>s</c> angibt. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Number" />.</param>
        <param name="provider">Ein Objekt, das kulturabhängige Analyseinformationen über <c>s</c> bereitstellt.</param>
        <param name="result">To be added.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl unter Verwendung des angegebenen Stils und kulturspezifischer Formatierungsinformationen in die <see cref="T:System.Decimal" />-Entsprechung. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung unterscheidet sich von der <xref:System.Decimal.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode durch einen booleschen Wert, der angibt, ob der Analysevorgang erfolgreich war, anstatt den analysierten numerischen Wert zurückgeben. Es entfällt die Notwendigkeit, mit der Behandlung von Ausnahmen für Testen einer <xref:System.FormatException> , `s` ist ungültig und kann nicht erfolgreich analysiert werden kann.  
  
 Die `style` Parameter definiert das zulässige Format von der `s` Parameter, damit der Analysevorgang erfolgreich ausgeführt werden kann. Es muss eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration. Die folgenden <xref:System.Globalization.NumberStyles> Elemente werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 Abhängig vom Wert der Formatvorlage die `s` -Parameter enthält möglicherweise die folgenden Elemente:  
  
 [ws] [$] [anmelden] [Ziffern] Ziffern [.fractional-Ziffern] [-e [Anmeldung] Ziffern] [ws]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum. Leerzeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> Flag. Es stehen am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag.|  
|*$*|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, indem die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> oder <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der <xref:System.Globalization.NumberFormatInfo> zurückgegebenes Objekt die <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> Methode der `provider` Parameter. Das Währungssymbol stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag.|  
|*sign*|Einem optionalen Vorzeichen.|  
|*Ziffern*|Eine Folge von Ziffern zwischen 0 und 9.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen.|  
|*fractional-digits*|Eine Folge von Ziffern zwischen 0 und 9.|  
  
 Die `style` Parameter gibt das zulässige Format von der `s` -Parameter und kann einen oder mehrere <xref:System.Globalization.NumberStyles> -Enumerationskonstanten mithilfe einer bitweisen OR-Operation kombiniert. Wenn `style` ist null, `s` wird die <xref:System.Globalization.NumberStyles.Number?displayProperty=nameWithType> Stil.  
  
 Die `provider` Parameter ist ein <xref:System.IFormatProvider> Implementierung wie z. B. eine <xref:System.Globalization.NumberFormatInfo> oder <xref:System.Globalization.CultureInfo> Objekt. Die `provider` Parameter liefert kulturspezifische Informationen, die bei der Analyse verwendet. Wenn `provider` gleich `null` ist, wird die aktuelle Threadkultur verwendet.  
  
 Ein <xref:System.Decimal> Objekt hat die Genauigkeit von 29 Stellen. Wenn `s` eine Zahl ein, die mehr als 29 Stellen jedoch einen Teil mit Bruchzahlen und wird innerhalb des Bereichs von <xref:System.Decimal.MaxValue> und <xref:System.Decimal.MinValue>, die Zahl gerundet wird, nicht auf 29 Ziffern, die in den nächsten gekürzt.  
  
 Wenn eine Trennzeichen in kommt die `s` Parameter, während ein Analysevorgang und der geltenden Währung oder die Anzahl von Dezimalstellen und Gruppentrennzeichen stimmen überein, der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe als Trennzeichen. Weitere Informationen über Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.Decimal.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Decimal%40%29> Methode, um die Zeichenfolgendarstellung einer Zahl zu analysieren, die einen bestimmten nachrichtenstil und mit den Konventionen einer bestimmten Kultur formatiert wird.  
  
 [!code-csharp[System.Decimal.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.TryParse/cs/TryParse.cs#2)]
 [!code-vb[System.Decimal.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.TryParse/vb/TryParse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  Oder:  <paramref name="style" /> ist der Wert <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="Overload:System.Decimal.Parse" />
        <altmember cref="M:System.Decimal.ToString" />
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly decimal Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Decimal Zero" />
      <MemberSignature Language="DocId" Value="F:System.Decimal.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Decimal " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Decimal Zero;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt die Zahl 0 (null) dar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der `Zero` Feld.  
  
 [!code-cpp[System.Decimal.Fields#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Fields/CPP/fields.cpp#1)]
 [!code-csharp[System.Decimal.Fields#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Fields/CS/fields.cs#1)]
 [!code-vb[System.Decimal.Fields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Fields/VB/fields.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Decimal.One" />
        <altmember cref="F:System.Decimal.MinusOne" />
        <altmember cref="F:System.Decimal.MaxValue" />
        <altmember cref="F:System.Decimal.MinValue" />
      </Docs>
    </Member>
  </Members>
</Type>