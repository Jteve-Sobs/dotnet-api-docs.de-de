<Type Name="Byte" FullName="System.Byte">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9929dd16871d061f896bfb33d7bf5e24c7597fb1" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57958545" /></Metadata><TypeSignature Language="C#" Value="public struct Byte : IComparable, IComparable&lt;byte&gt;, IConvertible, IEquatable&lt;byte&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit unsigned int8 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;unsigned int8&gt;, class System.IConvertible, class System.IEquatable`1&lt;unsigned int8&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Byte" />
  <TypeSignature Language="VB.NET" Value="Public Structure Byte&#xA;Implements IComparable, IComparable(Of Byte), IConvertible, IEquatable(Of Byte), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Byte : IComparable, IComparable&lt;System::Byte&gt;, IConvertible, IEquatable&lt;System::Byte&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type byte = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-3.0">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine ganze 8-Bit-Zahl ohne Vorzeichen dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte> ist ein Typ von unveränderlichen Wert, die Ganzzahlen ohne Vorzeichen darstellt, die zwischen 0 (dargestellt durch die <xref:System.Byte.MinValue?displayProperty=nameWithType> Konstante) bis 255 (dargestellt durch die <xref:System.Byte.MaxValue?displayProperty=nameWithType> Konstanten). .NET Framework enthält auch einen signierten ganzzahligen 8-Bit-Wert-Typ <xref:System.SByte>, steht für Werte, die zwischen-128 und 127 liegen.  
  
## <a name="instantiating-a-byte-value"></a>Instanziieren einen Byte-Wert  
 Instanziieren Sie ein <xref:System.Byte> Wert auf verschiedene Weise:  
  
-   Sie können deklarieren, ein <xref:System.Byte> Variable und weisen sie einen Ganzzahlliterals-Wert, der innerhalb des Bereichs von wird die <xref:System.Byte> -Datentyp. Das folgende Beispiel deklariert zwei <xref:System.Byte> Variablen und weist sie auf diese Weise Werte.  
  
     [!code-csharp[System.Byte.Instantiation#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.byte.instantiation/cs/byteinstantiation1.cs#1)]
     [!code-vb[System.Byte.Instantiation#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.byte.instantiation/vb/byteinstantiate1.vb#1)]  
  
-   Sie können einen numerischen nicht-Byte-Wert in ein Byte zuweisen. Dies ist eine einschränkende Konvertierung, damit es Wenn ein Cast-Operator in C# geschrieben und eine Konvertierungsmethode in Visual Basic erfordert `Option Strict` ist. Wenn der nicht-Byte-Wert ist eine <xref:System.Single>, <xref:System.Double>, oder <xref:System.Decimal> -Wert, der eine nachkommakomponente, den Umgang mit der Teil mit Bruchzahlen enthält, hängt von der Compiler die Konvertierung ausführt. Das folgende Beispiel weist mehrere numerische Werte <xref:System.Byte> Variablen.  
  
     [!code-csharp[System.Byte.Instantiation#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.byte.instantiation/cs/byteinstantiation1.cs#2)]
     [!code-vb[System.Byte.Instantiation#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.byte.instantiation/vb/byteinstantiate1.vb#2)]  
  
-   Sie können eine Methode zum Aufrufen der <xref:System.Convert> Klasse konvertiert einen unterstützten Typ in einen <xref:System.Byte> Wert. Dies ist möglich, da <xref:System.Byte> unterstützt die <xref:System.IConvertible> Schnittstelle. Das folgende Beispiel veranschaulicht die Konvertierung eines Arrays von <xref:System.Int32> Werte <xref:System.Byte> Werte.  
  
     [!code-csharp[System.Convert.ToByte#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tobyte/cs/tobyte1.cs#4)]
     [!code-vb[System.Convert.ToByte#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tobyte/vb/tobyte1.vb#4)]  
  
-   Rufen Sie die <xref:System.Byte.Parse%2A> oder <xref:System.Byte.TryParse%2A> Methode konvertiert die Zeichenfolgendarstellung einer <xref:System.Byte> Wert eine <xref:System.Byte>. Die Zeichenfolge kann entweder dezimale oder hexadezimale-Ziffern enthalten. Das folgende Beispiel veranschaulicht den Analysevorgang mithilfe einer Dezimalzahl und eine hexadezimale Zeichenfolge.  
  
     [!code-csharp[System.Byte.Instantiation#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.byte.instantiation/cs/byteinstantiation1.cs#3)]
     [!code-vb[System.Byte.Instantiation#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.byte.instantiation/vb/byteinstantiate1.vb#3)]  
  
## <a name="performing-operations-on-byte-values"></a>Ausführen von Vorgängen für Bytes-Werte  
 Die <xref:System.Byte> Typ unterstützt die standardmäßige mathematische Operationen wie Addition, Subtraktion, Division, Multiplikation, Subtraktion, Negation und unäre Negation. Die anderen ganzzahligen Typen, wie die <xref:System.Byte> Typ unterstützt auch das bitweise `AND`, `OR`, `XOR`, linke UMSCHALTTASTE und right Shift-Operatoren.  
  
 Sie können die standardmäßigen numerischen Operatoren zum Vergleichen zweier <xref:System.Byte> Werte, oder Sie rufen die <xref:System.Byte.CompareTo%2A> oder <xref:System.Byte.Equals%2A> Methode.  
  
 Sie können auch aufrufen, die Mitglieder der <xref:System.Math> Klasse, um eine Vielzahl von numerischen Operationen, beispielsweise die den absoluten Wert einer Zahl berechnet den Quotienten und den Rest aus der ganzzahligen Division, Bestimmen der maximalen oder minimalen Werts von zwei auszuführen ganze Zahlen, öffnen die Vorzeichen einer Zahl und eine Zahl runden.  
  
## <a name="representing-a-byte-as-a-string"></a>Stellt einen Byte als String  
 Die <xref:System.Byte> Typ bietet vollständige Unterstützung für standardmäßige und benutzerdefinierte numerische Formatzeichenfolgen. (Weitere Informationen finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md), [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md), und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).) Allerdings werden in den meisten Fällen-Bytes-Werte als ein Ziffern auf drei Ziffern bestehenden Werte ohne zusätzliche Formatierung oder als hexadezimale Werte zwei Ziffern dargestellt.  
  
 Formatieren einer <xref:System.Byte> Wert als ganzzahlige Zeichenfolge ohne führende Nullen, können Sie die parameterlose Aufrufen <xref:System.Byte.ToString> Methode. Mit dem Formatbezeichner "D", können Sie auch eine angegebene Anzahl führender Nullen in der Zeichenfolgendarstellung einschließen. Sie können mit dem Formatbezeichner "X", darstellen einer <xref:System.Byte> Wert als hexadezimale Zeichenfolge. Im folgenden Beispiel formatiert, die Elemente in ein Array von <xref:System.Byte> Werte in der folgenden drei Arten.  
  
 [!code-csharp[System.Byte.Formatting#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.byte.formatting/cs/formatting1.cs#1)]
 [!code-vb[System.Byte.Formatting#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.byte.formatting/vb/formatting1.vb#1)]  
  
 Sie können auch Formatieren einer <xref:System.Byte> Wert als binäre, oktale, Dezimal oder hexadezimal-Zeichenfolge durch Aufrufen der <xref:System.Convert.ToString%28System.Byte%2CSystem.Int32%29> -Methode und die Basis als zweiten Parameter der Methode angeben. Im folgenden Beispiel wird diese Methode, um die binäre, oktale, anzuzeigen und eine hexadezimale Darstellung eines Arrays von Bytewerten.  
  
 [!code-csharp[System.Byte.Formatting#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.byte.formatting/cs/formatting1.cs#2)]
 [!code-vb[System.Byte.Formatting#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.byte.formatting/vb/formatting1.vb#2)]  
  
## <a name="working-with-non-decimal-byte-values"></a>Arbeiten mit nicht-Dezimalzahlen-Bytes-Werte  
 Zusätzlich zum Arbeiten mit einzelnen Bytes als Dezimalzahlen, empfiehlt es sich zum Ausführen von bitweiser Operations mit Bytewerten oder Arbeiten mit Byte-Arrays oder die binären oder hexadezimalen Darstellungen von Bytewerten. Z. B. Überladungen der der <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> Methode kann jede der primitiven Datentypen in ein Bytearray konvertieren und die <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> Methode konvertiert ein <xref:System.Numerics.BigInteger> Wert in ein Bytearray.  
  
 <xref:System.Byte> Werte werden durch ihre Größe, ohne eine Vorzeichenbit in 8 Bits dargestellt. Dies ist wichtig zu bedenken, wenn Sie bitweise Operationen <xref:System.Byte> Werte oder bei der Arbeit mit einzelnen Bits. Um einen numerischen, booleschen Wert oder Vergleichsoperation für zwei beliebige Werte von nicht-Dezimalzahlen auszuführen, müssen beide Werte die gleiche Darstellung verwenden.  
  
 Wenn ein Vorgang ausgeführt wird, auf zwei <xref:System.Byte> Werte, die Werte verwenden die gleiche Darstellung, sodass das Ergebnis ist. Dies wird im folgenden Beispiel, das von der niedrigsten Bit maskiert veranschaulicht eine <xref:System.Byte> Wert, um sicherzustellen, dass es selbst ist.  
  
 [!code-csharp[System.Byte.Bitwise#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.byte.bitwise/cs/bitwise1.cs#1)]
 [!code-vb[System.Byte.Bitwise#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.byte.bitwise/vb/bitwise1.vb#1)]  
  
 Andererseits, bei der Arbeit mit nicht signierten und signierten Bits, bitweise Operationen sind etwas kompliziert, die die <xref:System.SByte> Werte verwenden Vorzeichen-Wert-Darstellung für positive Werte und zwei der Ergänzung Darstellung für negative Werte . Um eine sinnvolle bitweise Operation auszuführen, müssen die Werte in zwei äquivalente Darstellung konvertiert werden, und Informationen über das signierte Bit beibehalten werden muss. Im folgende Beispiel wird zum Maskieren Sie Bits 2 und 4, der ein Array von 8-Bit-Werten für mit und ohne Vorzeichen.  
  
 [!code-csharp[System.Byte.Bitwise#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.byte.bitwise/cs/bitwise2.cs#2)]
 [!code-vb[System.Byte.Bitwise#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.byte.bitwise/vb/bitwise2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle Member dieses Typs sind threadsicher. Mitglieder, die angezeigt werden, so ändern Sie den Zustand der Instanz zurück tatsächlich eine neue Instanz initialisiert wird, mit dem neuen Wert an. Wie bei jeder anderen Art werden lesen und Schreiben in eine freigegebene Variable, die eine Instanz dieses Typs enthält durch eine Sperre um Threadsicherheit zu gewährleisten geschützt.</threadsafe>
    <altmember cref="T:System.SByte" />
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.IFormattable" />
    <altmember cref="T:System.IConvertible" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">Beispiel: .NET Framework 4-Hilfsprogramm zur Formatierung</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt oder <see cref="T:System.Byte" /> und gibt eine Angabe über das Verhältnis der entsprechenden Werte zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.CompareTo(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Byte) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Byte value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : byte -&gt; int&#xA;override this.CompareTo : byte -&gt; int" Usage="byte.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Eine zu vergleichende ganze 8-Bit-Zahl ohne Vorzeichen.</param>
        <summary>Vergleicht diese Instanz mit einer angegebenen 8-Bit-Ganzzahl ohne Vorzeichen, und gibt eine Angabe über das Verhältnis der entsprechenden Werte zurück.</summary>
        <returns>Eine Ganzzahl mit Vorzeichen, die die relative Reihenfolge dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> BESCHREIBUNG 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Diese Instanz ist kleiner als <paramref name="value" />.  
  
 </description></item><item><term> Zero 
 </term><description> Diese Instanz ist gleich <paramref name="value" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Diese Instanz ist größer als <paramref name="value" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> -Schnittstelle und führt etwas bessere Leistung als die <xref:System.Byte.CompareTo%28System.Object%29?displayProperty=nameWithType> Methode, da es keine konvertieren die `value` Parameter für ein Objekt.  
  
 Abhängig von der Programmiersprache, ist es eventuell möglich, Code eine <xref:System.Byte.CompareTo%2A> Methode, bei der Parametertyp weniger Bits hat (schmaler ist) als der Instanztyp. Dies ist möglich, da einige Programmiersprachen eine implizite erweiternde Konvertierung durchführen, die den Parameter als einen Typ mit wie vielen Bits als die Instanz darstellt.  
  
 Nehmen wir beispielsweise an, der Instanztyp <xref:System.Int32> und der Parametertyp ist <xref:System.Byte>. Der Microsoft C#-Compiler generiert, Anweisungen, um den Wert des Parameters als darstellen ein <xref:System.Int32>, generiert dann eine <xref:System.Int32.CompareTo%2A?displayProperty=nameWithType> -Methode, die die Werte der vergleicht die <xref:System.Int32> Instanz und die <xref:System.Int32> Darstellung der Parameter.  
  
 Ihre bevorzugte Programmiersprache Dokumentation, um festzustellen, ob der Compiler implizite erweiternde Konvertierungen für numerische Typen ausführt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, generische und nicht generischen Versionen der `CompareTo` Methode für verschiedene Wert- und Verweistypen.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IComparable" />
        <altmember cref="M:System.Byte.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="byte.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Ein Vergleichsobjekt oder <see langword="null" />.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt und gibt eine Angabe über das Verhältnis der entsprechenden Werte zurück.</summary>
        <returns>Eine Ganzzahl mit Vorzeichen, die die relative Reihenfolge dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> BESCHREIBUNG 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Diese Instanz ist kleiner als <paramref name="value" />.  
  
 </description></item><item><term> Zero 
 </term><description> Diese Instanz ist gleich <paramref name="value" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Diese Instanz ist größer als <paramref name="value" />.  
  
- oder - 
 <paramref name="value" /> ist <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` muss `null` oder eine Instanz von <xref:System.Byte>ist, andernfalls wird eine Ausnahme ausgelöst.  
  
 Jede Instanz von <xref:System.Byte>, unabhängig von seinem Wert wird als größer betrachtet `null`.  
  
 Diese Methode wird implementiert, zur Unterstützung der <xref:System.IComparable> Schnittstelle.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Byte.CompareTo%2A> Methode.  
  
 [!code-cpp[System.Byte Examples#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Byte Examples/CPP/systembyte.cpp#3)]
 [!code-csharp[System.Byte Examples#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Byte Examples/CS/systembyte.cs#3)]
 [!code-vb[System.Byte Examples#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte Examples/VB/systembyte.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> ist keine <see cref="T:System.Byte" />.</exception>
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="M:System.Byte.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei Instanzen der <see cref="T:System.Byte" />-Struktur denselben Wert darstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (byte obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(unsigned int8 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Equals(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Byte) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Byte obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : byte -&gt; bool" Usage="byte.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Byte" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Ein mit dieser Instanz zu vergleichendes Objekt.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz und ein angegebenes <see cref="T:System.Byte" />-Objekt den gleichen Wert darstellen.</summary>
        <returns><see langword="true" />, wenn <paramref name="obj" /> gleich dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die <xref:System.IEquatable%601?displayProperty=nameWithType> -Schnittstelle und führt etwas bessere Leistung als <xref:System.Byte.Equals%28System.Object%29> , da es keine konvertieren die `obj` Parameter für ein Objekt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird bestimmt, ob die erste <xref:System.Byte> Wert ist gleich dem zweiten <xref:System.Byte> Wert und gibt an, ob die erste <xref:System.Byte> Wert ist gleich der zweiten die geschachtelten Version <xref:System.Byte> Wert.  
  
 [!code-cpp[system.byte.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.byte.equals/cpp/eq.cpp#1)]
 [!code-csharp[system.byte.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.byte.equals/cs/eq.cs#1)]
 [!code-vb[system.byte.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.byte.equals/vb/eq.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Byte.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="byte.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Objekt, das mit dieser Instanz verglichen werden soll, oder <see langword="null" />.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich einem angegebenen Objekt ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="obj" /> eine Instanz von <see cref="T:System.Byte" /> ist, deren Wert gleich dem Wert dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird bestimmt, ob die erste <xref:System.Byte> Wert ist gleich dem zweiten <xref:System.Byte> Wert und gibt an, ob die erste <xref:System.Byte> Wert ist gleich der zweiten die geschachtelten Version <xref:System.Byte> Wert.  
  
 [!code-cpp[system.byte.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.byte.equals/cpp/eq.cpp#1)]
 [!code-csharp[system.byte.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.byte.equals/cs/eq.cs#1)]
 [!code-vb[system.byte.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.byte.equals/vb/eq.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Byte.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="byte.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
        <returns>Ein Hashcode für die aktuelle <see cref="T:System.Byte" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="byte.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den <see cref="T:System.TypeCode" /> für den Werttyp <see cref="T:System.Byte" /> zurück.</summary>
        <returns>Die Enumerationskonstante <see cref="F:System.TypeCode.Byte" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const byte MaxValue = 255;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal unsigned int8 MaxValue = unsigned int8(255)" />
      <MemberSignature Language="DocId" Value="F:System.Byte.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Byte  = 255" />
      <MemberSignature Language="C++ CLI" Value="public: System::Byte MaxValue = 255;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : byte" Usage="System.byte.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <MemberValue>255</MemberValue>
      <Docs>
        <summary>Stellt den größtmöglichen Wert von <see cref="T:System.Byte" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist 255 (hexadezimal 0xFF).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Byte.MaxValue> Feld Variableneingaben für Werte, die außerhalb des Bereichs möglicher Bytewerte.  
  
 [!code-cpp[System.Byte Examples#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Byte Examples/CPP/systembyte.cpp#1)]
 [!code-csharp[System.Byte Examples#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Byte Examples/CS/systembyte.cs#1)]
 [!code-vb[System.Byte Examples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte Examples/VB/systembyte.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Byte.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const byte MinValue = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal unsigned int8 MinValue = unsigned int8(0)" />
      <MemberSignature Language="DocId" Value="F:System.Byte.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Byte  = 0" />
      <MemberSignature Language="C++ CLI" Value="public: System::Byte MinValue = 0;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : byte" Usage="System.byte.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>Stellt den kleinstmöglichen Wert von <see cref="T:System.Byte" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist 0.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Byte.MinValue> Feld Variableneingaben für Werte, die außerhalb des Bereichs möglicher Bytewerte.  
  
 [!code-cpp[System.Byte Examples#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Byte Examples/CPP/systembyte.cpp#1)]
 [!code-csharp[System.Byte Examples#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Byte Examples/CS/systembyte.cs#1)]
 [!code-vb[System.Byte Examples#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte Examples/VB/systembyte.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Byte.MaxValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wandelt die angegebene Zeichenfolgendarstellung einer Zahl in ihre <see cref="T:System.Byte" />-Entsprechung um.</summary>
        <altmember cref="Overload:System.Byte.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static byte Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; byte" Usage="System.byte.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält. Die Zeichenfolge wird unter Verwendung des <see cref="F:System.Globalization.NumberStyles.Integer" />-Formats interpretiert.</param>
        <summary>Wandelt die angegebene Zeichenfolgendarstellung einer Zahl in ihre <see cref="T:System.Byte" />-Entsprechung um.</summary>
        <returns>Ein Bytewert, der der Zahl in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `s` -Parameter enthält eine Zahl im Format:  
  
 [ws] [Sign] Ziffern [ws]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionalen Leerzeichen.|  
|*sign*|Ein optionalen positiven oder negativen Vorzeichen.|  
|*Ziffern*|Eine Folge von Ziffern von 0 bis 9.|  
  
 Die `s` Parameter wird interpretiert, mit der <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> Stil. Zusätzlich zu den Bytewert Dezimalstellen sind dürfen nur führende und nachfolgende Leerzeichen zusammen mit einem vorangestellten Plus-oder Minuszeichen. (Wenn das Vorzeichen vorhanden ist, ein positiven Vorzeichen sein muss oder die Methode löst eine <xref:System.OverflowException>.) Style-Elemente explizit zu definieren, die in vorhanden sein können `s`, verwenden Sie entweder die <xref:System.Byte.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> oder <xref:System.Byte.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 Die `s` -Parameter wird analysiert, die unter Verwendung der Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das für die aktuelle Systemkultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Um eine Zeichenfolge, die unter Verwendung der Formatierungsinformationen in einer anderen Kultur zu analysieren, verwenden die <xref:System.Byte.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Zeichenfolgenwert in einen Bytewert mit konvertiert die <xref:System.Byte.Parse%28System.String%29?displayProperty=nameWithType> Methode. Der resultierende Bytewert wird dann in der Konsole angezeigt.  
  
 [!code-cpp[System.Byte.Parse#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Byte.Parse/cpp/parse.cpp#1)]
 [!code-csharp[System.Byte.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Byte.Parse/CS/parse.cs#1)]
 [!code-vb[System.Byte.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.Parse/VB/parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> weist nicht das richtige Format auf.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Byte.MinValue" /> oder größer als <see cref="F:System.Byte.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Byte.ToString" />
        <altmember cref="F:System.Byte.MaxValue" />
        <altmember cref="F:System.Byte.MinValue" />
        <altmember cref="T:System.Globalization.NumberStyles" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static byte Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; byte" Usage="System.byte.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält. Die Zeichenfolge wird unter Verwendung des durch <paramref name="style" /> angegebenen Formats interpretiert.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="s" /> vorhanden sein können. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil in die <see cref="T:System.Byte" />-Entsprechung.</summary>
        <returns>Ein Bytewert, der der Zahl in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `style` Parameter definiert die Stilelemente (z.B. Leerzeichen oder das positiven Vorzeichen), die in dürfen die `s` Parameter, damit der Analysevorgang erfolgreich ist. Es muss eine Kombination von Bitflags aus den <xref:System.Globalization.NumberStyles> Enumeration. Abhängig vom Wert `style`, `s` Parameter die folgenden Elemente enthalten:  
  
 [ws] [$] [Sign] Ziffern [.fractional_digits] [Ziffern e [Sign]] [ws]  
  
 Oder, wenn Sie `style` enthält <xref:System.Globalization.NumberStyles.AllowHexSpecifier>:  
  
 [ws] Hexdigits [ws]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionalen Leerzeichen. Leerzeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> Flag oder am Ende des s Wenn Style enthält die <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag.|  
|*$*|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> -Eigenschaft der aktuellen Kultur. In der aktuellen Kultur Währungssymbol angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag.|  
|*sign*|Ein optionalen positiven Vorzeichen. (Die Methode löst eine <xref:System.OverflowException> ist ein negativen Vorzeichen vorhanden in `s`.) Die Zeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> Flag oder am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag.|  
|*Ziffern*|Eine Folge von Ziffern von 0 bis 9.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen. In der aktuellen Kultur Dezimaltrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|*fractional_digits*|Ein oder mehrere Vorkommen der Ziffer 0. Bruchziffern können angezeigt werden, `s` nur, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|*e*|Das e oder E-Zeichen, die angibt, dass der Wert in Exponentialschreibweise dargestellt wird. Die `s` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag.|  
|*hexdigits*|Eine Sequenz von hexadezimalen Ziffern von 0 bis f oder 0 bis F.|  
  
> [!NOTE]
> Alle abschließenden NULL (U + 0000)-Zeichen im `s` werden ignoriert, durch den Analysevorgang, unabhängig vom Wert für die `style` Argument.

 Eine Zeichenfolge mit nur Dezimalstellen (Dies entspricht der <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die meisten der verbleibenden <xref:System.Globalization.NumberStyles> Elemente steuern, Elemente, die möglicherweise sind jedoch nicht erforderlich, in dieser Eingabezeichenfolge vorhanden sein muss. Die folgende Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Mitglieder Auswirkungen auf die Elemente, die ggf. im `s`.  
  
|Nicht zusammengesetzte NumberStyles-Werte|Elemente in s neben Ziffern zulässig|  
|----------------------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>|Nur Dezimalstellen.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>|Das Sprachelement *.* und *Bruchziffern* Elemente. Allerdings *Bruchziffern* muss lediglich eine oder mehrere 0 bestehen oder <xref:System.OverflowException> ausgelöst.|  
|<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>|Die `s` Parameter können Sie auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>|Die *ws* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>|Die *ws* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>|Ein positiven Vorzeichen können angezeigt werden, bevor Sie *Ziffern*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>|Ein positiven Vorzeichen können angezeigt werden, nach dem *Ziffern*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>|Dieses Flag wird zwar unterstützt, die Verwendung von Klammern in `s` führt zu einer <xref:System.OverflowException>.|  
|<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>|Obwohl das Gruppentrennzeichen angezeigt, im werden kann `s`, es kann nur einer oder mehreren 0-Ziffern stehen.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>|Die *$* Element.|  
  
 Wenn die <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> -Flag wird verwendet, `s` muss ein hexadezimaler Wert ohne Präfix. Beispielsweise erfolgreich analysiert, "F3", "0xF3" jedoch nicht. Der nur anderen Flags, die mit ihm kombiniert werden können, sind <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Die <xref:System.Globalization.NumberStyles> Enumeration umfasst einen zusammengesetzter Zahlenstil <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>, die beide Flags Leerzeichen enthält.)  
  
 Die `s` -Parameter wird analysiert, die unter Verwendung der Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das für die aktuelle Systemkultur initialisiert wird. Um den Formatierungsinformationen des anderen Kultur zu verwenden, rufen die <xref:System.Byte.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> überladen.  
  
   
  
## Examples  
 Im folgenden Beispiel analysiert die zeichenfolgendarstellungen `Byte` Werte mit den <xref:System.Byte.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> Methode. Die aktuelle Kultur für das Beispiel wird En-US.  
  
 [!code-cpp[System.Byte.Parse#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Byte.Parse/cpp/parse.cpp#3)]
 [!code-csharp[System.Byte.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Byte.Parse/CS/parse.cs#3)]
 [!code-vb[System.Byte.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.Parse/VB/parse.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> weist nicht das richtige Format auf.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Byte.MinValue" /> oder größer als <see cref="F:System.Byte.MaxValue" /> ist.  
  
- oder - 
 <paramref name="s" /> enthält Dezimalstellen ungleich 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> ist keine Kombination von <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />- und <see cref="F:System.Globalization.NumberStyles.HexNumber" />-Werten.</exception>
        <altmember cref="M:System.Byte.ToString" />
        <altmember cref="Overload:System.Byte.TryParse" />
        <altmember cref="F:System.Byte.MaxValue" />
        <altmember cref="F:System.Byte.MinValue" />
        <altmember cref="T:System.Globalization.NumberStyles" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <altmember cref="T:System.IFormatProvider" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static byte Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; byte" Usage="System.byte.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält. Die Zeichenfolge wird unter Verwendung des <see cref="F:System.Globalization.NumberStyles.Integer" />-Formats interpretiert.</param>
        <param name="provider">Ein Objekt, das kulturabhängige Analyseinformationen über <paramref name="s" /> bereitstellt. Wenn <paramref name="provider" /> gleich <see langword="null" /> ist, wird die aktuelle Threadkultur verwendet.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen kulturspezifischen Format in die <see cref="T:System.Byte" />-Entsprechung.</summary>
        <returns>Ein Bytewert, der der Zahl in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `s` -Parameter enthält eine Zahl im Format:  
  
 [ws] [Sign] Ziffern [ws]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionalen Leerzeichen.|  
|*sign*|Ein optionalen positiven Vorzeichen.|  
|*Ziffern*|Eine Folge von Ziffern von 0 bis 9.|  
  
 Die `s` Parameter wird interpretiert, mit der <xref:System.Globalization.NumberStyles.Integer> Stil. Zusätzlich zu den Bytewert Dezimalstellen sind dürfen nur führende und nachfolgende Leerzeichen zusammen mit einem vorangestellten Plus-oder Minuszeichen. (Wenn das Vorzeichen vorhanden ist, ein positiven Vorzeichen sein muss oder die Methode löst eine <xref:System.OverflowException>.) Style-Elemente sowie der kulturspezifischen Formatierungsinformationen explizit zu definieren, die in vorhanden sein können `s`, verwenden Sie die <xref:System.Byte.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 Die `s` -Parameter wird analysiert, die unter Verwendung der Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> angegebenen `provider`. Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung wie z. B. eine <xref:System.Globalization.NumberFormatInfo> oder <xref:System.Globalization.CultureInfo> Objekt. Die `provider` Parameter liefert kulturspezifische Informationen, die bei der Analyse verwendet. Wenn `provider` gleich `null` ist, wird die aktuelle Threadkultur verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel analysiert die zeichenfolgendarstellungen `Byte` Werte mit den <xref:System.Byte.Parse%2A> Methode.  
  
 [!code-cpp[System.Byte.Parse#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Byte.Parse/cpp/parse.cpp#2)]
 [!code-csharp[System.Byte.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Byte.Parse/CS/parse.cs#2)]
 [!code-vb[System.Byte.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.Parse/VB/parse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> weist nicht das richtige Format auf.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Byte.MinValue" /> oder größer als <see cref="F:System.Byte.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Byte.ToString" />
        <altmember cref="Overload:System.Byte.TryParse" />
        <altmember cref="F:System.Byte.MaxValue" />
        <altmember cref="F:System.Byte.MinValue" />
        <altmember cref="T:System.Globalization.NumberStyles" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <altmember cref="T:System.IFormatProvider" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static byte Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Byte" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; byte" Usage="System.byte.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static byte Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; byte" Usage="System.byte.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält. Die Zeichenfolge wird unter Verwendung des durch <paramref name="style" /> angegebenen Formats interpretiert.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="s" /> vorhanden sein können. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Informationen zum Format von <paramref name="s" /> bereitstellt. Wenn <paramref name="provider" /> gleich <see langword="null" /> ist, wird die aktuelle Threadkultur verwendet.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und kulturabhängigen Format in das entsprechende <see cref="T:System.Byte" />.</summary>
        <returns>Ein Bytewert, der der Zahl in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `style` Parameter definiert die Stilelemente (z.B. Leerzeichen oder das positiven Vorzeichen), die in dürfen die `s` Parameter, damit der Analysevorgang erfolgreich ist. Es muss eine Kombination von Bitflags aus den <xref:System.Globalization.NumberStyles> Enumeration. Abhängig vom Wert `style`, `s` Parameter die folgenden Elemente enthalten:  
  
 [ws] [$] [Sign] Ziffern [.fractional_digits] [Ziffern e [Sign]] [ws]  
  
 Oder, wenn Sie die `style` Parameter enthält <xref:System.Globalization.NumberStyles.AllowHexSpecifier>:  
  
 [ws] Hexdigits [ws]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionalen Leerzeichen. Leerzeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> Flag oder am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag.|  
|*$*|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaft der <xref:System.Globalization.NumberFormatInfo> zurückgegebenes Objekt der <xref:System.IFormatProvider.GetFormat%2A> -Methode der der `provider` Parameter. Das Währungssymbol angezeigt werden kann, im `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag.|  
|*sign*|Ein optionalen positiven Vorzeichen. (Die Methode löst eine <xref:System.OverflowException> ist ein negativen Vorzeichen vorhanden in `s`.) Die Zeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> Flag oder am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag.|  
|*Ziffern*|Eine Folge von Ziffern von 0 bis 9.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen. Das Dezimaltrennzeichen von der durch den angegebenen Kultur `provider` stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|*fractional_digits*|Ein oder mehrere Vorkommen der Ziffer 0. Bruchziffern können angezeigt werden, `s` nur, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|*e*|Das e oder E-Zeichen, die angibt, dass der Wert in Exponentialschreibweise dargestellt wird. Die s-Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag.|  
|*hexdigits*|Eine Sequenz von hexadezimalen Ziffern von 0 bis f oder 0 bis F.|  
  
> [!NOTE]
> Alle abschließenden NULL (U + 0000)-Zeichen im `s` werden ignoriert, durch den Analysevorgang, unabhängig vom Wert für die `style` Argument.

 Eine Zeichenfolge mit nur Dezimalstellen (Dies entspricht der <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die meisten der verbleibenden <xref:System.Globalization.NumberStyles> Elemente steuern, Elemente, die möglicherweise sind jedoch nicht erforderlich, in dieser Eingabezeichenfolge vorhanden sein muss. Die folgende Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Mitglieder Auswirkungen auf die Elemente, die ggf. im `s`.  
  
|Nicht zusammengesetzte NumberStyles-Werte|Elemente in s neben Ziffern zulässig|  
|----------------------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>|Nur Dezimalstellen.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>|Das Sprachelement *.* und *Bruchziffern* Elemente. Allerdings *Bruchziffern* muss lediglich eine oder mehrere 0 bestehen oder <xref:System.OverflowException> ausgelöst.|  
|<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>|Die `s` Parameter können Sie auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>|Die *ws* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>|Die *ws* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>|Ein positiven Vorzeichen können angezeigt werden, bevor Sie *Ziffern*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>|Ein positiven Vorzeichen können angezeigt werden, nach dem *Ziffern*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>|Dieses Flag wird zwar unterstützt, die Verwendung von Klammern in `s` führt zu einer <xref:System.OverflowException>.|  
|<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>|Obwohl das Gruppentrennzeichen angezeigt, im werden kann `s`, es kann nur einer oder mehreren 0-Ziffern stehen.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>|Die *$* Element.|  
  
 Wenn die <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> -Flag wird verwendet, `s` muss ein hexadezimaler Wert ohne Präfix. Beispielsweise erfolgreich analysiert, "F3", "0xF3" jedoch nicht. Die einzigen anderen Flags, die in vorhanden sein können `style` sind <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Die <xref:System.Globalization.NumberStyles> Enumeration verfügt über ein zusammengesetzter Zahlenstil <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>, die beide Flags Leerzeichen enthält.)  
  
 Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung, wie z. B. eine <xref:System.Globalization.NumberFormatInfo> oder <xref:System.Globalization.CultureInfo> Objekt. Die `provider` Parameter liefert kulturspezifische Informationen, die bei der Analyse verwendet. Wenn `provider` gleich `null` ist, wird die aktuelle Threadkultur verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird analysiert zeichenfolgendarstellungen `Byte` Werte, die mit dieser Überladung von der <xref:System.Byte.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 [!code-cpp[System.Byte.Parse#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Byte.Parse/cpp/parse.cpp#4)]
 [!code-csharp[System.Byte.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Byte.Parse/CS/parse.cs#4)]
 [!code-vb[System.Byte.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.Parse/VB/parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> weist nicht das richtige Format auf.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Byte.MinValue" /> oder größer als <see cref="F:System.Byte.MaxValue" /> ist.  
  
- oder - 
 <paramref name="s" /> enthält Dezimalstellen ungleich 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> ist keine Kombination von <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />- und <see cref="F:System.Globalization.NumberStyles.HexNumber" />-Werten.</exception>
        <altmember cref="M:System.Byte.ToString" />
        <altmember cref="F:System.Byte.MaxValue" />
        <altmember cref="F:System.Byte.MinValue" />
        <altmember cref="T:System.Globalization.NumberStyles" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <altmember cref="T:System.IFormatProvider" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns><see langword="true" />, wenn der Wert der aktuellen Instanz nicht 0 (null) ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Byte>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToBoolean%28System.Byte%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Der unveränderte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Byte>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Char" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Byte>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToChar%28System.Byte%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Diese Konvertierung wird nicht unterstützt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Diese Konvertierung wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Decimal" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Byte>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToDecimal%28System.Byte%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Double" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Byte>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToDouble%28System.Byte%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Byte>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt16%28System.Byte%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Byte>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt32%28System.Byte%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Byte>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt64%28System.Byte%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.SByte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Byte>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToSByte%28System.Byte%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Single" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Byte>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToSingle%28System.Byte%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, in den dieser <see cref="T:System.Byte" />-Wert konvertiert werden soll.</param>
        <param name="provider">Eine<see cref="T:System.IFormatProvider" />-Implementierung, die Informationen zum Format des zurückgegebenen Werts angibt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Der in <paramref name="type" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Byte>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der `static` (`Shared` in Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> Methode stattdessen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Die angeforderte Typkonvertierung wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Byte>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt16%28System.Byte%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Byte>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt32%28System.Byte%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Byte>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt64%28System.Byte%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den Wert des aktuellen <see cref="T:System.Byte" />-Objekts in die entsprechende Zeichenfolgendarstellung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="byte.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den Wert des aktuellen <see cref="T:System.Byte" />-Objekts in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieses Objekts, die aus einer Folge von Ziffern zwischen 0 und 9 ohne führende Nullen besteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert mit dem allgemeinen numerische Formatbezeichner ("G") formatiert ist und die <xref:System.Globalization.NumberFormatInfo> -Objekt für die aktuelle Threadkultur. Definieren Sie die Formatierung von der <xref:System.Byte> Zeichenfolgendarstellung des Werts, rufen die <xref:System.Byte.ToString%2A> Methode. Zum Definieren der Formatbezeichner und die Kultur, die zum Erstellen der Zeichenfolgendarstellung einer <xref:System.Byte> Wert, rufen Sie die <xref:System.Byte.ToString%2A> Methode.  
  
 .NET Framework bietet umfangreiche formatierungsunterstützung, die in den folgenden Themen zur Formatierung ausführlicher beschrieben wird:  
  
-   Weitere Informationen über numerische Formatbezeichner finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Informationen über die aktuelle Threadkultur, finden Sie unter <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt ein Array von Bytewerten. Beachten Sie, dass die <xref:System.Byte.ToString> Methode wird im Beispiel nicht explizit aufgerufen. Stattdessen, es wird implizit aufgerufen, durch die Verwendung von der [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) Feature.  
  
 [!code-cpp[System.Byte.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Byte.ToString/CPP/newbytemembers2.cpp#2)]
 [!code-csharp[System.Byte.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Byte.ToString/CS/NewByteMembers.cs#2)]
 [!code-vb[System.Byte.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.ToString/VB/NewByteMembers.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="byte.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Byte" />-Objekts unter Verwendung der angegebenen kulturspezifischen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieses Objekts in dem vom <paramref name="provider" />-Parameter angegebenen Format.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der zurückgegebene Wert wird mit dem allgemeinen numerische Formatbezeichner ("G") formatiert.  
  
 Die `provider` -Parameter ist ein Objekt, implementiert die <xref:System.IFormatProvider> Schnittstelle. Die <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Informationen zum Format der Zeichenfolge enthält, die von dieser Methode zurückgegeben wird. Das Objekt, das implementiert <xref:System.IFormatProvider> kann eine der folgenden sein:  
  
-   Ein <xref:System.Globalization.CultureInfo> -Objekt, das die Kultur darstellt, deren Formatierungsregeln verwendet werden.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo> Objekt, das numerische Formatierungsinformationen für diesen Wert enthält.  
  
-   Ein benutzerdefiniertes Objekt, das implementiert <xref:System.IFormatProvider>.  
  
 Wenn `provider` ist `null` oder <xref:System.Globalization.NumberFormatInfo> Objekt kann nicht abgerufen werden, von `provider`, der Rückgabewert formatiert wird, mit der <xref:System.Globalization.NumberFormatInfo> -Objekt für die aktuelle Threadkultur. Informationen über die aktuelle Threadkultur, finden Sie unter <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>.  
  
 .NET Framework bietet umfangreiche formatierungsunterstützung, die in den folgenden Themen zur Formatierung ausführlicher beschrieben wird:  
  
-   Weitere Informationen über numerische Formatbezeichner finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array von Bytewerten Werte und jedes Mitglied in der Konsole angezeigt, durch den Aufruf der <xref:System.Byte.ToString%28System.IFormatProvider%29> -Methode mit verschiedenen Formatanbieter.  
  
 [!code-cpp[System.Byte.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Byte.ToString/CPP/newbytemembers.cpp#3)]
 [!code-csharp[System.Byte.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Byte.ToString/CS/NewByteMembers.cs#3)]
 [!code-vb[System.Byte.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.ToString/VB/NewByteMembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Byte.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="byte.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Eine numerische Formatierungszeichenfolge.</param>
        <summary>Konvertiert den Wert des aktuellen <see cref="T:System.Byte" />-Objekts unter Verwendung des angegebenen Formats in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des aktuellen <see cref="T:System.Byte" />-Objekts im durch den <paramref name="format" />-Parameter angegebenen Format.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `format` Parameter kann entweder eine standardmäßige oder eine benutzerdefinierte numerische Formatzeichenfolge sein. Alle numerischen Standardformatzeichenfolgen als "R" (oder "R") werden unterstützt, da alle benutzerdefinierten numerischen Formatierungszeichen sind. Wenn `format` ist `null` oder eine leere Zeichenfolge (""), die mit dem allgemeinen numerische Formatbezeichner ("G") formatiert ist.  
  
 Der Rückgabewert dieser Funktion wird mit formatiert die <xref:System.Globalization.NumberFormatInfo> -Objekt für die aktuelle Threadkultur. Informationen über die aktuelle Threadkultur, finden Sie unter <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>. Aufrufen, um Formatierungsinformationen für Kulturen als der aktuellen Kultur zu ermöglichen, die <xref:System.Byte.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 .NET Framework bietet umfangreiche formatierungsunterstützung, die in den folgenden Themen zur Formatierung ausführlicher beschrieben wird:  
  
-   Weitere Informationen über numerische Formatbezeichner finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 Im folgenden Beispiel initialisiert einen <xref:System.Byte> Wert ein, und zeigt sie an die Konsole, indem Sie die unterstützen Standardformatzeichenfolgen und eine benutzerdefinierte Formatzeichenfolge. Im Beispiel wird mit En-US als aktuelle Kultur ausgeführt.  
  
 [!code-cpp[System.Byte.ToString#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Byte.ToString/CPP/newbytemembers2.cpp#4)]
 [!code-csharp[System.Byte.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Byte.ToString/CS/NewByteMembers.cs#4)]
 [!code-vb[System.Byte.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.ToString/VB/NewByteMembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> enthält einen nicht unterstützten Spezifizierer. Unterstützte Formatspezifizierer sind im Abschnitt "Hinweise" aufgeführt.</exception>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Gewusst wie: Auffüllen einer Zahl mit führenden Nullen</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="byte.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Eine standardmäßige oder benutzerdefinierte numerische Formatierungszeichenfolge.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den Wert des aktuellen <see cref="T:System.Byte" />-Objekts unter Verwendung des angegebenen Formats sowie der kulturspezifischen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des aktuellen <see cref="T:System.Byte" />-Objekts im durch die <paramref name="format" />- und <paramref name="provider" />-Parameter angegebenen Format.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Byte.ToString%28System.String%2CSystem.IFormatProvider%29> -Methode formatiert einen <xref:System.Byte> Wert in einem angegebenen Format einer angegebenen Kultur. Um eine Zahl mit dem Standardwert ("G")-Format für die aktuelle Kultur zu formatieren, rufen Sie die <xref:System.Byte.ToString> Methode. Um eine Zahl mit einem angegebenen Format für die aktuelle Kultur zu formatieren, rufen Sie die <xref:System.Byte.ToString%28System.String%29> Methode.  
  
 Die `format` Parameter kann entweder eine standardmäßige oder eine benutzerdefinierte numerische Formatzeichenfolge sein. Alle numerischen Standardformatzeichenfolgen als "R" (oder "R") werden unterstützt, da alle benutzerdefinierten numerischen Formatierungszeichen sind. Wenn `format` ist `null` oder eine leere Zeichenfolge (""), der Rückgabewert dieser Methode mit dem allgemeinen numerische Formatbezeichner ("G") formatiert ist.  
  
 Die `provider` -Parameter ist ein Objekt, implementiert die <xref:System.IFormatProvider> Schnittstelle. Die <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Informationen zum Format der Zeichenfolge enthält, die von dieser Methode zurückgegeben wird. Das Objekt, das implementiert <xref:System.IFormatProvider> kann eine der folgenden sein:  
  
-   Ein <xref:System.Globalization.CultureInfo> -Objekt, das die Kultur darstellt, deren Formatierungsregeln verwendet werden.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo> Objekt, das numerische Formatierungsinformationen für diesen Wert enthält.  
  
-   Ein benutzerdefiniertes Objekt, das implementiert <xref:System.IFormatProvider>.  
  
 Wenn `provider` ist `null` oder <xref:System.Globalization.NumberFormatInfo> Objekt kann nicht abgerufen werden, von `provider`, der Rückgabewert formatiert wird, mit der <xref:System.Globalization.NumberFormatInfo> -Objekt für die aktuelle Threadkultur. Informationen über die aktuelle Threadkultur, finden Sie unter <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>.  
  
 .NET Framework bietet umfangreiche formatierungsunterstützung, die in den folgenden Themen zur Formatierung ausführlicher beschrieben wird:  
  
-   Weitere Informationen über numerische Formatbezeichner finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Formatzeichenfolge der standard ist "N" und vier verschiedene <xref:System.Globalization.CultureInfo> Objekte an die angegebene Zeichenfolgendarstellung ein Byte-Wert in der Konsole anzeigen.  
  
 [!code-cpp[System.Byte.ToString#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Byte.ToString/CPP/newbytemembers2.cpp#5)]
 [!code-csharp[System.Byte.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Byte.ToString/CS/NewByteMembers.cs#5)]
 [!code-vb[System.Byte.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.ToString/VB/NewByteMembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> enthält einen nicht unterstützten Spezifizierer. Unterstützte Formatspezifizierer sind im Abschnitt "Hinweise" aufgeführt.</exception>
        <altmember cref="M:System.Byte.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <altmember cref="T:System.IFormattable" />
        <altmember cref="T:System.IFormatProvider" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Gewusst wie: Auffüllen einer Zahl mit führenden Nullen</related>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">Beispiel: .NET Framework 4-Hilfsprogramm zur Formatierung</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="byte.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Versucht, die Zeichenfolgendarstellung einer Zahl in deren <see cref="T:System.Byte" />-Entsprechung zu konvertieren, und gibt einen Wert zurück, der angibt, ob die Konvertierung erfolgreich durchgeführt wurde.</summary>
        <altmember cref="Overload:System.Byte.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out byte result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] unsigned int8&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.TryParse(System.ReadOnlySpan{System.Char},System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Byte) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] System::Byte % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.byte.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.Byte" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out byte result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] unsigned int8&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.TryParse(System.String,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Byte) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] System::Byte % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.byte.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Byte" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält. Die Zeichenfolge wird unter Verwendung des <see cref="F:System.Globalization.NumberStyles.Integer" />-Formats interpretiert.</param>
        <param name="result">Diese Methode gibt bei erfolgreicher Konvertierung den <see cref="T:System.Byte" />-Wert zurück, der der in <paramref name="s" /> enthaltenen Zahl entspricht, und 0 (null), wenn die Konvertierung nicht durchgeführt werden konnte. Dieser Parameter wird nicht initialisiert übergeben. Jeder Wert, der ursprünglich im bereitgestellten <paramref name="result" /> überschrieben werden.</param>
        <summary>Versucht, die Zeichenfolgendarstellung einer Zahl in deren <see cref="T:System.Byte" />-Entsprechung zu konvertieren, und gibt einen Wert zurück, der angibt, ob die Konvertierung erfolgreich durchgeführt wurde.</summary>
        <returns><see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Konvertierung schlägt fehl, und die Methode gibt `false` Wenn die `s` Parameter ist nicht im richtigen Format, wenn es ist `null` oder <xref:System.String.Empty?displayProperty=nameWithType>, oder wenn sie eine Zahl darstellt, kleiner als <xref:System.Byte.MinValue> oder größer als <xref:System.Byte.MaxValue>.  
  
 Die <xref:System.Byte.TryParse%28System.String%2CSystem.Byte%40%29?displayProperty=nameWithType> Methode ähnelt der <xref:System.Byte.Parse%28System.String%29?displayProperty=nameWithType> -Methode, außer dass <xref:System.Byte.TryParse%28System.String%2CSystem.Byte%40%29> löst keine Ausnahme aus, wenn die Konvertierung schlägt fehl.  
  
 Die `s` Parameter muss die angegebene Zeichenfolgendarstellung einer Zahl in der folgenden Form sein:  
  
```  
[ws][sign]digits[ws]  
```  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionalen Leerzeichen.|  
|*sign*|Ein optionalen positiven Vorzeichen gemäß der <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> -Eigenschaft der aktuellen Kultur.|  
|*Ziffern*|Eine Sequenz von Dezimalziffern, die zwischen 0 und 9 liegen.|  
  
 Die `s` Parameter wird interpretiert, mit der <xref:System.Globalization.NumberStyles.Integer> Stil. Zusätzlich zu den Bytewert Dezimalstellen sind dürfen nur führende und nachfolgende Leerzeichen zusammen mit einem vorangestellten Plus-oder Minuszeichen. (Wenn das Vorzeichen vorhanden ist, ein positiven Vorzeichen sein muss oder die Methode löst eine <xref:System.OverflowException>.) Style-Elemente sowie der kulturspezifischen Formatierungsinformationen explizit zu definieren, die in vorhanden sein können `s`, verwenden Sie die <xref:System.Byte.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 Die `s` -Parameter wird analysiert, die unter Verwendung der Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.  
  
 Diese Überladung von der <xref:System.Byte.TryParse%28System.String%2CSystem.Byte%40%29?displayProperty=nameWithType> Methode interpretiert alle Ziffern in der `s` Parameter als Dezimalzahlen. Um die angegebene Zeichenfolgendarstellung einer Hexadezimalzahl analysieren möchten, rufen Sie die <xref:System.Byte.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Byte%40%29?displayProperty=nameWithType> überladen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Byte.TryParse%28System.String%2CSystem.Byte%40%29> Methode mit einer Reihe von verschiedenen Zeichenfolgenwerten.  
  
 [!code-cpp[System.Byte.TryParse#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Byte.TryParse/cpp/tryparse.cpp#1)]
 [!code-csharp[System.Byte.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Byte.TryParse/cs/TryParse.cs#1)]
 [!code-vb[System.Byte.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.TryParse/vb/TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">Beispiel: .NET Framework 4-Hilfsprogramm zur Formatierung</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out byte result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] unsigned int8&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Byte) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Byte % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.byte.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.Byte" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out byte result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] unsigned int8&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Byte) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Byte % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.byte.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Byte" RefType="out" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die die zu konvertierende Zahl enthält. Die Zeichenfolge wird unter Verwendung des durch <paramref name="style" /> angegebenen Formats interpretiert.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="s" /> vorhanden sein können. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt. Wenn <paramref name="provider" /> gleich <see langword="null" /> ist, wird die aktuelle Threadkultur verwendet.</param>
        <param name="result">Diese Methode gibt bei erfolgreicher Konvertierung den Wert der ganzen 8-Bit-Zahl ohne Vorzeichen zurück, der der Zahl in <paramref name="s" /> entspricht, und 0 (null), wenn die Konvertierung nicht durchgeführt werden konnte. Die Konvertierung kann nicht durchgeführt werden, wenn der <paramref name="s" />-Parameter <see langword="null" /> oder <see cref="F:System.String.Empty" /> ist, kein gültiges Format aufweist oder eine Zahl kleiner als <see cref="F:System.Byte.MinValue" /> oder größer als <see cref="F:System.Byte.MaxValue" /> darstellt. Dieser Parameter wird nicht initialisiert übergeben. Jeder Wert, der ursprünglich im bereitgestellten <paramref name="result" /> überschrieben werden.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und kulturabhängigen Format in das entsprechende <see cref="T:System.Byte" />. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns><see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Byte.TryParse%2A> Methode entspricht der <xref:System.Byte.Parse%2A> -Methode, mit Ausnahme der <xref:System.Byte.TryParse%2A> Methode löst keine Ausnahme aus, wenn die Konvertierung schlägt fehl.  
  
 Die `s` -Parameter wird analysiert, die unter Verwendung der Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> angegebenen die `provider` Parameter.  
  
 Der Style-Parameter definiert die Stilelemente (z.B. Leerzeichen oder das positiven Vorzeichen), die in dürfen die `s` Parameter, damit der Analysevorgang erfolgreich ist. Es muss eine Kombination von Bitflags aus den <xref:System.Globalization.NumberStyles> Enumeration. Abhängig vom Wert `style`, `s` Parameter die folgenden Elemente enthalten:  
  
 [ws] [$] [Sign] Ziffern [.fractional_digits] [Ziffern e [Sign]] [ws]  
  
 Oder, wenn Sie die `style` Parameter enthält <xref:System.Globalization.NumberStyles.AllowHexSpecifier>:  
  
 [ws] Hexdigits [ws]  
  
 Elemente in eckigen Klammern ([und]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionalen Leerzeichen. Leerzeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> Flag oder am Ende des s Wenn Style enthält die <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag.|  
|*$*|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaft der <xref:System.Globalization.NumberFormatInfo> zurückgegebenes Objekt der <xref:System.IFormatProvider.GetFormat%2A> -Methode der der `provider` Parameter. Das Währungssymbol angezeigt werden kann, im `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag.|  
|*sign*|Ein optionalen positiven Vorzeichen. (Der Analysevorgang misslingt, wenn ein negativen Vorzeichen vorhanden ist `s`.) Die Zeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> Flag oder am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag.|  
|*Ziffern*|Eine Folge von Ziffern von 0 bis 9.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen. Das Dezimaltrennzeichen von der durch den angegebenen Kultur `provider` stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|*fractional_digits*|Ein oder mehrere Vorkommen der Ziffer 0. Bruchziffern können angezeigt werden, `s` nur, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|*e*|Das e oder E-Zeichen, die angibt, dass der Wert in Exponentialschreibweise dargestellt wird. Die `s` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag.|  
|*hexdigits*|Eine Sequenz von hexadezimalen Ziffern von 0 bis f oder 0 bis F.|  
  
> [!NOTE]
> Alle abschließenden NULL (U + 0000)-Zeichen im `s` werden ignoriert, durch den Analysevorgang, unabhängig vom Wert für die `style` Argument.

 Eine Zeichenfolge mit nur Dezimalstellen (Dies entspricht der <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die meisten der verbleibenden <xref:System.Globalization.NumberStyles> Elemente steuern, Elemente, die möglicherweise sind jedoch nicht erforderlich, in dieser Eingabezeichenfolge vorhanden sein muss. Die folgende Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Mitglieder Auswirkungen auf die Elemente, die ggf. im `s`.  
  
|Nicht zusammengesetzte NumberStyles-Werte|Elemente in s neben Ziffern zulässig|  
|----------------------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>|Nur Dezimalstellen.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>|Das Sprachelement *.* und *Bruchziffern* Elemente. Allerdings *Bruchziffern* muss bestehen lediglich eine oder mehrere 0-Ziffern oder der Rückgabe der Methode `false`.|  
|<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>|Die `s` Parameter können Sie auch Exponentialschreibweise. Wenn `s` eine Zahl in Exponentialschreibweise darstellt, muss eine ganze Zahl innerhalb des Bereichs von darstellen der <xref:System.Byte> Datentyp ohne eine gewisse Bruchziffern.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>|Die *ws* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>|Die *ws* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>|Ein positiven Vorzeichen können angezeigt werden, bevor Sie *Ziffern*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>|Ein positiven Vorzeichen können angezeigt werden, nach dem *Ziffern*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>|Dieses Flag wird zwar unterstützt, gibt die Methode `false` Wenn Klammern vorhanden sind `s`.|  
|<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>|Obwohl das Gruppentrennzeichen angezeigt, im werden kann `s`, es kann nur einer oder mehreren 0-Ziffern stehen.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>|Die *$* Element.|  
  
 Wenn die <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> -Flag wird verwendet, `s` muss ein hexadezimaler Wert ohne Präfix. Beispielsweise erfolgreich analysiert, "F3", "0xF3" jedoch nicht. Die einzigen anderen Flags, die in vorhanden sein können `style` sind <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Die <xref:System.Globalization.NumberStyles> Enumeration verfügt über ein zusammengesetzter Zahlenstil <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>, die beide Flags Leerzeichen enthält.)  
  
 Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung, wie z. B. eine <xref:System.Globalization.CultureInfo> Objekt oder ein <xref:System.Globalization.NumberFormatInfo> Objekt, dessen <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> Objekt. Die <xref:System.Globalization.NumberFormatInfo> Objekt stellt kulturspezifische Informationen zum Format von `s`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Byte.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Byte%40%29> Methode mit einer Reihe von verschiedenen Zeichenfolgenwerten.  
  
 [!code-cpp[System.Byte.TryParse#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Byte.TryParse/cpp/tryparse2.cpp#2)]
 [!code-csharp[System.Byte.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Byte.TryParse/cs/TryParse2.cs#2)]
 [!code-vb[System.Byte.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.TryParse/vb/TryParse2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> ist keine Kombination von <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />- und <see cref="F:System.Globalization.NumberStyles.HexNumber" />-Werten.</exception>
        <altmember cref="M:System.Byte.ToString" />
        <altmember cref="F:System.Byte.MaxValue" />
        <altmember cref="F:System.Byte.MinValue" />
        <altmember cref="T:System.Globalization.NumberStyles" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <altmember cref="T:System.IFormatProvider" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>