<Type Name="GC" FullName="System.GC">
  <Metadata><Meta Name="ms.openlocfilehash" Value="be23d111dc399e846c969bd517a2458710d1f961" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58719951" /></Metadata><TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Steuert den Garbage Collector des Systems. Das ist ein Dienst, der nicht verwendeten Speicher automatisch freigibt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Garbage Collector ist eine Komponente von common Language Runtime, die die Belegung und Freigabe des verwalteten Arbeitsspeichers steuert. Die Methoden in dieser Klasse beeinflussen, wenn die automatische speicherbereinigung ausgeführt wird, auf ein Objekt, und wenn von einem Objekt zugeordnete Ressourcen freigegeben werden. Eigenschaften in dieser Klasse stellen Informationen über die Gesamtmenge des verfügbaren Arbeitsspeichers bereit, in das System und der Alterskategorie oder der Generation, des Arbeitsspeichers für ein Objekt.  
  
 Der Garbage Collector verfolgt und im verwalteten Speicher zugeordnete Objekte freigibt. Der Garbage Collector führt regelmäßig automatische speicherbereinigung zum Freigeben des Arbeitsspeichers für Objekte, die für die keine gültigen Verweise vorhanden sind. Garbagecollection erfolgt automatisch, wenn eine Anforderung für den Arbeitsspeicher nicht freien Arbeitsspeicher erfüllt werden kann. Alternativ kann eine Anwendung mithilfe von Garbage Collection erzwingen die <xref:System.GC.Collect%2A> Methode.  
  
 Garbagecollection umfasst die folgenden Schritte aus:  
  
1.  Der Garbage Collector sucht nach verwalteten Objekte, die in verwaltetem Code verwiesen werden.  
  
2.  Der Garbage Collector versucht, die Objekte zu beenden, die nicht verwiesen wird.  
  
3.  Der Garbage Collector freigegeben Objekte, die nicht verwiesen werden und gibt ihren Speicher frei.  
  
 Dieses Thema enthält die folgenden Abschnitte:  
  
 [Der Garbage Collector und nicht verwalteten Ressourcen](#unmanaged)   
 [Das Altern von Objekten und Generationen](#generations)   
 [Unterbinden einer Garbagecollection](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a>Der Garbage Collector und nicht verwalteten Ressourcen  
 Während einer Collection wird der Garbage Collector kein Objekt frei, wenn sie eine oder mehrere Verweise auf das Objekt in verwaltetem Code findet. Allerdings wird der Garbage Collector erkennt keine Verweise auf ein Objekt von nicht verwaltetem Code und Freigeben von Objekten, die ausschließlich in nicht verwaltetem Code verwendet werden, es sei denn, Sie explizit daran gehindert, auf diese Weise kann. Die <xref:System.GC.KeepAlive%2A> Methode bietet einen Mechanismus, der verhindert, dass der Garbage Collector das Sammeln von Objekten, die in nicht verwaltetem Code noch verwendet werden.  
  
 Abgesehen von der verwalteten speicherbelegung werden Implementierungen von der Garbage Collector keine Informationen zu Ressourcen, die einem Objekt, z. B. Dateihandles oder Datenbankverbindungen geführt. Wenn ein Typ nicht verwaltete Ressourcen, die freigegeben werden müssen verwendet, bevor Instanzen des Typs freigegeben werden, kann der Typ einen Finalizer implementieren.  
  
 In den meisten Fällen sind Finalizer implementiert, durch Überschreiben der <xref:System.Object.Finalize%2A?displayProperty=nameWithType> Methode jedoch in c# oder C++ geschriebene Typen Destruktoren, wandeln Sie die von Compilern in eine Überschreibung der <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. In den meisten Fällen verfügt ein Objekt einen Finalizer, ruft der Garbage Collector sie vor dem Freigeben des Objekts. Allerdings ist nicht der Garbage Collector Finalizer in allen Situationen aufgerufen; z. B. die <xref:System.GC.SuppressFinalize%2A> Methode explizit wird verhindert, dass der Finalizer eines Objekts aufgerufen wird. Darüber hinaus muss der Garbage Collector nicht mit einem bestimmten Thread Threadobjekte oder garantieren die Reihenfolge, in der Finalizer für Objekte aufgerufen werden, die aufeinander verweisen, aber andernfalls für die Garbagecollection verfügbar sind.  
  
 In Szenarien, in denen Ressourcen zu einem bestimmten Zeitpunkt freigegeben werden müssen, können Klassen implementieren die <xref:System.IDisposable> -Schnittstelle, die enthält die <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> Methode, die Resource Management und Bereinigung Aufgaben ausführt. Klassen, in denen <xref:System.IDisposable.Dispose%2A> müssen angeben, als Teil des Klassenvertrags Wenn Klasse die Methode Consumern, um das Objekt zu bereinigen. Der Garbage Collector ist standardmäßig nicht der Fall, rufen Sie die <xref:System.IDisposable.Dispose%2A> Methode jedoch Implementierungen der <xref:System.IDisposable.Dispose%2A> Methode kann Methoden aufrufen, der <xref:System.GC> Klasse zum Anpassen des Verhaltens der Beendigung des Garbage Collectors.  
  
 Weitere Informationen zum Objekt-abschließen und das Dispose-Muster finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a>Das Altern von Objekten und Generationen  
 Der Garbage Collector in die common Language Runtime unterstützt das Altern von Objekten mithilfe von Generationen. Eine Generierung ist eine Maßeinheit für das relative Alter von Objekten im Arbeitsspeicher. Die Generierungsnummer bzw. das Alter eines Objekts gibt an die Generierung, zu der ein Objekt gehört. Weitere erstellten Objekte sind Teil der neueren Generation vor kurzem und vom niedrigere Generationszahlen als Durchlaufen der Objekte, die früher im Lebenszyklus Anwendung erstellt haben. Objekte in der neuesten Generation sind in der Generation 0. Diese Implementierung des Garbage Collectors unterstützt drei Generationen von Objekten, die Generationen 0, 1 und 2. Sie können den Wert der Abrufen der <xref:System.GC.MaxGeneration%2A> Eigenschaft, um zu bestimmen, die maximale Generationszahl, die vom System unterstützt werden.  
  
 Das Altern von Objekten kann Anwendungen, die Zielsammlung für die Garbage auf einen bestimmten Satz von Generationen statt der Garbage Collector alle Generationen ausgewertet. Überladungen der der <xref:System.GC.Collect%2A> Methode, die enthalten eine `generation` Parameter ermöglichen es Ihnen, geben Sie die älteste Generationszahl, um die Garbage Collection bereinigt werden.  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a>Unterbinden einer Garbagecollection  
 Beginnend mit der [!INCLUDE[net_v46](~/includes/net-v46-md.md)], der Garbage Collector unterstützt eine Latenzmodus ohne GC-Region, die während der Ausführung des kritischen Pfade verwendet werden kann, in der Garbage Collection kann der app-Leistung beeinträchtigen. Der Latenzmodus ohne GC-Region ist erforderlich, dass Sie die Größe des Arbeitsspeichers angeben, die ohne Störung durch den Garbage Collector zugeordnet werden können. Wenn die Laufzeit, dass der Speicher zugeordnet werden kann, wird die Runtime eine Garbagecollection nicht auszuführen, während Code im kritischen Pfad ausführt.  
  
 Sie definieren den Anfang den kritischen Pfad, der keine GC-Region durch Aufrufen einer der Überladungen der der <xref:System.GC.TryStartNoGCRegion%2A>. Sie geben Sie das Ende seiner kritischen Pfads durch den Aufruf der <xref:System.GC.EndNoGCRegion%2A> Methode.  
  
 Nicht verschachtelt werden, Aufrufe an die <xref:System.GC.TryStartNoGCRegion%2A> Methode aufzurufen, und Sie sollten nur die <xref:System.GC.EndNoGCRegion%2A> Methode, wenn die Runtime ist derzeit im Latenzmodus ohne GC-Region ist. Das heißt, Sie sollten nicht aufrufen, <xref:System.GC.TryStartNoGCRegion%2A> mehrere Male (nach dem ersten Methodenaufruf, bei nachfolgenden Aufrufen werden nicht erfolgreich), und nicht erwarten, dass Aufrufe von <xref:System.GC.EndNoGCRegion%2A> erfolgreich ist, nur weil der erste Aufruf von <xref:System.GC.TryStartNoGCRegion%2A> war erfolgreich.  
  
   
  
## Examples  
 Im folgenden Beispiel wird mehrere GC-Methoden zu generieren und Arbeitsspeicherinformationen über einen Block von nicht verwendeten Objekten in der Konsole ausgeben. Nicht verwendete Objekte sind dann gesammelt, und die resultierende Gesamtspeichergröße werden angezeigt.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
    <related type="Article" href="~/docs/standard/garbage-collection/index.md">Garbage Collection</related>
    <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Grundlagen der Garbage Collection</related>
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Die inkrementelle Menge an nicht verwaltetem Arbeitsspeicher, die belegt wurde.</param>
        <summary>Informiert die Laufzeit über eine große Belegung von nicht verwaltetem Arbeitsspeicher, der beim Planen der Garbage Collection in Erwägung gezogen werden muss.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Planen der Garbagecollection berücksichtigt die Laufzeit, wie viel verwalteten Speicher zugeordnet wird. Wenn Sie ein kleines verwaltetes Objekt über eine große Menge an nicht verwalteten Arbeitsspeicher zuordnet, kann die Laufzeit berücksichtigt nur den verwalteten Speicher und unterschätzt somit die Dringlichkeit der Planen der Garbagecollection. Die <xref:System.GC.AddMemoryPressure%2A> Methode informiert die Laufzeit über diesen zusätzlichen Druck auf dem Systemspeicher.  
  
 Im einfachsten Verwendungsmuster, ein verwaltetes Objekt ordnet nicht verwalteten Speicher in den Konstruktor, und gibt es in der `Dispose` oder `Finalize` Methode. Rufen Sie die <xref:System.GC.AddMemoryPressure%2A> Methode nach der Zuweisung der nicht verwalteten Arbeitsspeicher, und rufen Sie die <xref:System.GC.RemoveMemoryPressure%2A> Methode nach der Freigabe.  
  
 In etwas komplizierteren Szenarios, in dem nicht verwaltetem Speicher ändert sich im Wesentlichen während der Lebensdauer des verwalteten Objekts, rufen Sie die <xref:System.GC.AddMemoryPressure%2A> und <xref:System.GC.RemoveMemoryPressure%2A> Methoden, um diese inkrementellen Änderungen zur Laufzeit zu kommunizieren.  
  
> [!CAUTION]
>  Sie müssen sicherstellen, dass Sie genau die benötigte Menge Druck entfernen, die Sie hinzufügen. Andernfalls kann die Leistung des Systems in Anwendungen beeinträchtigen, die für längere Zeit ausgeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bytesAllocated" /> ist kleiner oder gleich 0.  
  
- oder - 
Auf einem 32-Bit-Computer ist <paramref name="bytesAllocated" /> größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Garbage Collection-Priorität zu bearbeiten. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht die Registrierung einer Garbage Collection-Benachrichtigung ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bricht eine Garbage Collection-Benachrichtigung, die mit registriert wurde die <xref:System.GC.RegisterForFullGCNotification%2A> Methode. Sie müssen keine diese Methode aufrufen, bevor das Anpassen von Schwellenwerten für Parameter bei nachfolgenden Aufrufen der <xref:System.GC.RegisterForFullGCNotification%2A> Methode.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Garbage Collection-Registrierung abgebrochen. In diesem Beispiel ist Teil eines umfangreicheren Beispiels für die [Garbage Collection-Benachrichtigungen](~/docs/standard/garbage-collection/notifications.md) Thema.  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Dieser Member ist nicht verfügbar, wenn die gleichzeitige Garbage Collection aktiviert ist. Weitere Informationen zum Deaktivieren der gleichzeitigen Garbage Collection finden Sie unter der [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)-Laufzeiteinstellung.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Garbage Collection-Benachrichtigungen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erzwingt eine Garbage Collection.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erzwingt eine sofortige Garbage Collection für alle Generationen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um zu versuchen, den gesamten Speicher freizugeben, die nicht zugegriffen werden kann. Es führt eine blockierende Garbagecollection für alle Generationen.  
  
 Alle Objekte, unabhängig davon, wie lange sie im Arbeitsspeicher wurden, werden für die Auflistung berücksichtigt; Allerdings werden die Objekte, die in verwaltetem Code verwiesen werden nicht gesammelt. Verwenden Sie diese Methode, um das System, um zu versuchen, die die maximale Menge an verfügbarem Arbeitsspeicher freigeben zu erzwingen.  
  
 Beginnend mit der [!INCLUDE[net_v451](~/includes/net-v451-md.md)], Sie können den großen Objektheap (LOH) komprimieren, indem Sie die Einstellung der <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> Eigenschaft, um <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> vor dem Aufruf der <xref:System.GC.Collect%2A> -Methode, wie im folgenden Beispiel wird veranschaulicht.  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.GC.Collect%2A> Methode, um eine Sammlung für alle Generationen von Speicher ausführen. Der Code generiert eine Reihe von nicht verwendeten Objekten und ruft dann die <xref:System.GC.Collect%2A> Methode, um sie aus dem Arbeitsspeicher zu bereinigen.  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">Indizierte Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">Die Anzahl der ältesten Generation, für die die Garbage Collection durchgeführt werden soll.</param>
        <summary>Erzwingt eine sofortige Garbage Collection von Generation 0 (null) bis zu einer angegebenen Generation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um zu versuchen, Arbeitsspeicher freizugeben, die nicht zugegriffen werden kann. Allerdings garantiert mit dieser Methode nicht, dass alle nicht zugegriffen werden kann Speicher in der angegebenen Generation freigegeben wird.  
  
 Wenn das Altern von Objekten implementiert wird, der Garbage Collector erfasst keine Objekte mit einer Zahl generieren, die höher als die angegebene Objektgeneration ist. Wenn das Altern von Objekten nicht implementiert ist, berücksichtigt der Garbage Collector alle Objekte während der Garbagecollection.  
  
 Verwenden der <xref:System.GC.MaxGeneration%2A> Eigenschaft, um zu bestimmen, den größten gültigen Wert für die `generation` Parameter.  
  
 Verwenden Sie der Garbage Collector alle Objekte unabhängig von deren Generierung berücksichtigen, um die Version dieser Methode, die keine Parameter akzeptiert. Damit den Garbagecollector Freigeben von Objekten, die auf der Grundlage einer <xref:System.GCCollectionMode> festlegen, verwenden Sie die <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> -methodenüberladung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.GC.Collect%2A> Methode, um eine Auflistung in einzelne Ebenen des Arbeitsspeichers führen. Der Code generiert eine Reihe von nicht verwendeten Objekten und ruft dann die <xref:System.GC.Collect%2A> Methode, um sie aus dem Arbeitsspeicher zu bereinigen.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="generation" /> ist ungültig.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">Indizierte Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation">Die Anzahl der ältesten Generation, für die die Garbage Collection durchgeführt werden soll.</param>
        <param name="mode">Ein Enumerationswert, der angibt, ob die Garbage Collection erzwungen (<see cref="F:System.GCCollectionMode.Default" /> oder <see cref="F:System.GCCollectionMode.Forced" />) oder optimiert wird (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <summary>Erzwingt eine Garbage Collection von Generation 0 (null) bis zu einer angegebenen Generation zu einem durch einen <see cref="T:System.GCCollectionMode" />-Wert angegebenen Zeitpunkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `mode` Parameter, um anzugeben, ob die automatische speicherbereinigung sofort oder erst erfolgen soll, wenn der Zeitpunkt zum Freigeben von Objekten optimal ist. Mit dieser Methode garantiert nicht, dass alle nicht zugegriffen werden kann Speicher in der angegebenen Generation freigegeben wird.  
  
 Um das Ausmaß der Garbagecollection während der wichtigen Punkten in Ihrer Anwendung anzupassen, legen Sie die <xref:System.Runtime.GCSettings.LatencyMode%2A> Eigenschaft.  
  
 Der Garbage Collector erfasst keine Objekte mit einer Generation Anzahl höher als gemäß der `generation` Parameter. Verwenden der <xref:System.GC.MaxGeneration%2A> Eigenschaft, um zu bestimmen, den größten gültigen Wert für `generation`.  
  
 Verwenden Sie der Garbage Collector alle Objekte unabhängig von deren Generierung berücksichtigen, um die Version dieser Methode, die keine Parameter akzeptiert.  
  
 Damit der Garbage Collector Objekte bis zu einer angegebenen Generation von Objekten, verwenden Sie die <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> -methodenüberladung. Wenn Sie die maximale Generierung angeben, werden alle Objekte gesammelt werden.  
  
   
  
## Examples  
 Das folgende Beispiel erzwingt eine Garbagecollection für Objekte der Generation 2 mit der <xref:System.GCCollectionMode.Optimized> festlegen.  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="generation" /> ist ungültig.  
  
- oder - 
 <paramref name="mode" /> ist keiner der <see cref="T:System.GCCollectionMode" />-Werte.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">Indizierte Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="blocking" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation">Die Anzahl der ältesten Generation, für die die Garbage Collection durchgeführt werden soll.</param>
        <param name="mode">Ein Enumerationswert, der angibt, ob die Garbage Collection erzwungen (<see cref="F:System.GCCollectionMode.Default" /> oder <see cref="F:System.GCCollectionMode.Forced" />) oder optimiert wird (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking"><see langword="true" />, um eine blockierende Garbage Collection auszuführen; <see langword="false" />, um eine Garbage Collection im Hintergrund auszuführen, sofern möglich.</param>
        <summary>Erzwingt eine Garbage Collection von Generation 0 (null) bis zu einer angegebenen Generation, angegeben durch jeweils einen <see cref="T:System.GCCollectionMode" />-Wert und mit einem Wert, der angibt, ob die Auflistung blockieren soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgende Tabelle enthält die Interaktion der `mode` und `blocking` Parameter:  
  
|`mode`|`blocking` ist `true`|`blocking` ist `false`|  
|-|-|-|  
|<xref:System.GCCollectionMode.Forced> oder <xref:System.GCCollectionMode.Default>|Eine blockierende Auflistung wird so schnell wie möglich ausgeführt. Wenn eine hintergrundauflistung ausgeführt wird und `generation` gleich 0 oder 1, die <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> Methode sofort löst eine blockierende Auflistung und gibt zurück, wenn die Auflistung abgeschlossen ist. Wenn eine hintergrundauflistung ausgeführt wird und `generation` 2 ist, wartet die Methode, bis die hintergrundsammlung beendet ist, eine blockierende Collection der Generation 2 löst und gibt dann zurück.|Eine Auflistung wird so schnell wie möglich ausgeführt. Die <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29>-Methode fordert eine Hintergrundauflistung, ist jedoch nicht garantiert. Je nach den Umständen wird eine blockierende Auflistung möglicherweise weiterhin ausgeführt. Wenn eine Hintergrundauflistung bereits ausgeführt wird, gibt die Methode sofort zurück.|  
|<xref:System.GCCollectionMode.Optimized>|Eine blockierende Auflistung kann ausgeführt werden, je nach Zustand des Garbage Collectors und des `generation`-Parameters. Der Garbage Collector versucht, eine optimale Leistung bereitzustellen.|Eine Auflistung kann ausgeführt werden, je nach Zustand des Garbage Collectors. Die <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29>-Methode fordert eine Hintergrundauflistung, ist jedoch nicht garantiert. Je nach den Umständen wird eine blockierende Auflistung möglicherweise weiterhin ausgeführt. Der Garbage Collector versucht, eine optimale Leistung bereitzustellen. Wenn eine Hintergrundauflistung bereits ausgeführt wird, gibt die Methode sofort zurück.|  
  
 Wenn ein Aufruf von der <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> Methode führt eine vollständige blockierende Garbagecollection, Sie können auch den großen Objektheap komprimieren, indem Sie festlegen der <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> Eigenschaft <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> vor dem Aufruf der <xref:System.GC.Collect%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="generation" /> ist ungültig.  
  
- oder - 
 <paramref name="mode" /> ist keiner der <see cref="T:System.GCCollectionMode" />-Werte.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="blocking" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="compacting" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="generation">Die Anzahl der ältesten Generation, für die die Garbage Collection durchgeführt werden soll.</param>
        <param name="mode">Ein Enumerationswert, der angibt, ob die Garbage Collection erzwungen (<see cref="F:System.GCCollectionMode.Default" /> oder <see cref="F:System.GCCollectionMode.Forced" />) oder optimiert wird (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking"><see langword="true" />, um eine blockierende Garbage Collection auszuführen; <see langword="false" />, um eine Garbage Collection im Hintergrund auszuführen, sofern möglich.</param>
        <param name="compacting"><see langword="true" /> zum Komprimieren des kleinen Objektheaps; <see langword="false" />, um nur Sweep durchzuführen.</param>
        <summary>Erzwingt eine Garbage Collection von Generation 0 (null) bis zu einer angegebenen Generation, angegeben durch jeweils einen <see cref="T:System.GCCollectionMode" />-Wert und mit Werten, die angeben, ob die Auflistung blockieren und komprimieren soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `blocking` ist `false`, die Freispeichersammlung entscheidet, ob ein Hintergrund- oder eine blockierende Garbagecollection ausgeführt. Wenn `compacting` ist `true`, eine blockierende Garbagecollection durchgeführt wurde.  
  
 Wenn `compacting` ist `true`, die Laufzeit komprimiert den kleinen Objektheap (SOH). Der große Objektheap (LOH) wird nicht komprimiert werden, es sei denn, die <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> -Eigenschaftensatz auf <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>. Beachten Sie, dass dadurch alle blockierende Garbage Collections, nicht nur um eine vollständige blockierende Garbage collection.  
  
 Rufen Sie die <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> Methode, mit dem kleinsten möglichen Größe, wie das folgende Codefragment veranschaulicht, der im verwalteten Heap zu reduzieren.  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 Angeben von `true` für die `compacting` Argument garantiert eine komprimierende, vollständige blockierende Garbagecollection. Festlegen der <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> Eigenschaft <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> wird sichergestellt, dass sowohl die SOH den großen Objektheap komprimiert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation">Die Objektgeneration, für die ermittelt werden soll, wie oft die Garbage Collection stattgefunden hat.</param>
        <summary>Gib die Anzahl zurück, wie oft die Garbage Collection für die angegebene Objektgeneration stattgefunden hat.</summary>
        <returns>Die Häufigkeit der Durchführung der Garbage Collection für die angegebene Generation, seitdem der Prozess gestartet wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie Ihren eigenen Resource-Manager implementieren, müssen Sie möglicherweise in regelmäßigen Abständen Erzwingen der Garbagecollection durch Aufrufen der <xref:System.GC.Collect%2A> Methode. Da dies ein aufwändiger Vorgang ist, können Sie die Leistung verbessern, durch den Aufruf überspringen, wenn vor kurzem eine Garbagecollection aufgetreten ist. Speichern Sie den Rückgabewert von <xref:System.GC.CollectionCount%2A> sofort nach dem Aufruf <xref:System.GC.Collect%2A>. Das nächste Mal, die Sie aufrufen müssen <xref:System.GC.Collect%2A>, vergleichen Sie den aktuellen Wert zurückgegebenes <xref:System.GC.CollectionCount%2A> mit dem gespeicherten Wert. Wenn die beiden Werte gleich sind, keine Sammlung in der Zwischenzeit aufgetreten ist und es ist sinnvoll, rufen Sie <xref:System.GC.Collect%2A> erneut aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="generation" /> ist kleiner als 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet den Latenzmodus ohne GC-Region.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.GC.EndNoGCRegion%2A> -Methode löst eine <xref:System.InvalidOperationException> ist der Garbage Collector nicht im Latenzmodus ohne GC-Region. Dies tritt unter den folgenden Bedingungen:  
  
-   Die <xref:System.GC.TryStartNoGCRegion%2A> Methode wurde zuvor nicht aufgerufen.  
  
-   Der Aufruf der <xref:System.GC.TryStartNoGCRegion%2A> zurückgegebene Methode `false`.  
  
-   Der Aufruf der <xref:System.GC.TryStartNoGCRegion%2A> -Methode hat eine Ausnahme ausgelöst.  
  
 Sie können aus folgenden Gründen für die Ausnahme verhindern, mithilfe von Code wie den folgenden:  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Garbage Collector befindet sich nicht im Latenzmodus ohne GC-Region.  
  
- oder - 
Der Latenzmodus ohne GC-Region wurde zuvor beendet, da eine Garbage Collection ausgelöst wurde.  
  
- oder - 
Eine Speicherbelegung hat den im Aufruf der <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />-Methode angegebenen Wert überschritten.</exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Latenzmodi</related>
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Gesamtzahl der Bytes ab, die dem aktuellen Thread seit Beginn seiner Lebensdauer zugeordnet wurden.</summary>
        <returns>Die Gesamtzahl der Bytes ab, die dem aktuellen Thread seit Beginn seiner Lebensdauer zugeordnet wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Die `GetAllocatedBytesForCurrentThread` Methode gibt die Gesamtzahl der Bytes, die auf dem verwalteten Heap zugeordnet werden, während der Lebensdauer eines Threads, die nicht die Gesamtzahl der Bytes, die Garbagecollection noch vorhanden sind. Der zurückgegebene Wert schließt systemeigenen Zuordnungen auch nicht.

Diese Methode eignet sich am besten bei der Überwachung von Szenarien zum Messen des Unterschied im Arbeitsspeicher zwischen Zeitintervalle oder Ereignisse.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die aktuelle Generationszahl eines Objekts zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, dessen Generationsdaten abgerufen werden.</param>
        <summary>Gibt die aktuelle Generationszahl des angegebenen Objekts zurück.</summary>
        <returns>Die aktuelle Generationszahl von <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode können Sie um das Alter eines Objekts zu bestimmen, und klicken Sie dann diese Informationen nutzen, mit der <xref:System.GC.Collect%2A> -Methode zum Erzwingen der Garbage Collector zum Sammeln von Objekten in der gleichen Generation. Verwenden Sie beispielsweise diese Methode auf, wenn Sie verfügen über einen Satz von Objekten, die als Gruppe erstellt werden, und, die zur gleichen Zeit nicht zugegriffen werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.GC.GetGeneration%2A> Methode, um das Alter eines Objekts zu bestimmen. Im Beispiel wird dann Garbage Collections der Arbeitsspeicher bereinigt und Vergleichen des präproduktionsclients und buchen Auflistung Arbeitsspeicher Gesamtsummen in der Konsole.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="wo">Ein <see cref="T:System.WeakReference" />, der auf das Zielobjekt verweist, dessen Generationszahl bestimmt werden soll.</param>
        <summary>Gibt die aktuelle Generationszahl für das Ziel eines angegebenen schwachen Verweises zurück.</summary>
        <returns>Die aktuelle Generationszahl des Ziels von <paramref name="wo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der <xref:System.GC.GetGeneration%2A> Methode, um das Alter eines schwachen Verweis-Objekts zu bestimmen.  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Garbage Collection ist bereits für <paramref name="wo" /> ausgeführt worden.</exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection"><see langword="true" />, um anzugeben, dass diese Methode vor der Rückgabe auf die Garbage Collection warten kann, andernfalls <see langword="false" />.</param>
        <summary>Ruft einen Schätzwert für die reservierte Anzahl von Bytes ab. Ein Parameter gibt an, ob diese Methode vor der Rückgabe eine kurze Zeit warten kann, damit das System die Garbage Collection durchführen und Objekte finalisieren kann.</summary>
        <returns>Die bestmögliche Annährung an die Anzahl der derzeit im verwalteten Speicher belegten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `forceFullCollection` Parameter `true`, diese Methode wartet vor der Rückgabe ein kurzes Intervall, während das System Garbage Collection und schließt die Objekte ab. Die Dauer des Intervalls wird eine intern angegebenen Grenzwert hängt von der Anzahl der Zyklen der Garbage Collection abgeschlossen und die Änderung hinsichtlich der Menge des Arbeitsspeichers zwischen Zyklen. Der Garbage Collector garantiert nicht, dass alle nicht zugegriffen werden kann Speicher freigegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.GC.GetTotalMemory%2A> Methode zum Abrufen und Anzeigen der Anzahl der Bytes, die derzeit im verwalteten Speicher belegt.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, auf das verwiesen werden soll.</param>
        <summary>Verweist auf das angegebene Objekt und nimmt es von Beginn der aktuellen Routine bis zum Zeitpunkt des Aufrufs dieser Methode von der Garbage Collection aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Zweck der <xref:System.GC.KeepAlive%2A> Methode ist, um sicherzustellen, dass das Vorhandensein eines Verweises auf ein Objekt, das Risiko, vorzeitig vom Garbage Collector freigegeben ist. Ist ein häufiges Szenario, in denen dies geschehen kann, wenn keine Verweise auf das Objekt in verwaltetem Code oder Daten vorliegen, aber das Objekt ist nach wie vor in nicht verwaltetem Code, z. B. Win32-APIs, die nicht verwaltete DLLs ein, oder Methoden, die mit COM.  
  
 Diese Methode verweist die `obj` Parameter, und dieses Objekt dadurch für die Garbagecollection vom Beginn der Routine, dem Punkt in der Ausführungsreihenfolge, an dem diese Methode aufgerufen. Diese Methode am Ende nicht am Anfang des Bereichs von Anweisungen, in denen `obj` muss verfügbar sein.  
  
 Die <xref:System.GC.KeepAlive%2A> Methode führt keine Operation aus und erzeugt keine Nebeneffekte als Erweiterung von der Lebensdauer des Objekts als Parameter übergeben.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein Objekt am Anfang des seine `Main` Methode und verweist nicht auf das Objekt erneut bis zum Ende, wenn die <xref:System.GC.KeepAlive%2A> Methode wird aufgerufen. Das Objekt weiterhin besteht, für die Dauer 30 Sekunden, der die `Main` -Methode, obwohl Aufrufe an die <xref:System.GC.Collect%2A> und <xref:System.GC.WaitForPendingFinalizers%2A> Methoden.  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Anzahl von Generationen ab, die das System gegenwärtig unterstützt.</summary>
        <value>Ein Wert zwischen 0 (null) und der Höchstanzahl der unterstützten Generationen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Generierungsnummer oder ALTER, eines Objekts ist eine implementierungsdefinierte relative Maßnahme der Lebensdauer eines Objekts. Die zuletzt erstellte Objekte werden in der Generation 0 und der ältesten Objekte befinden sich in einer Generation, die kleiner oder gleich der Generierung von zurückgegebenen der <xref:System.GC.MaxGeneration%2A> Eigenschaft.  
  
 Der Garbage Collector wird davon ausgegangen, dass neuere Arbeitsspeicher eher für die Garbagecollection als ältere Arbeitsspeicher ist. Daher der Garbage Collector verbessert die Leistung durch Anpassen der Generierung von Zahlen jedes Mal, es gibt Arbeitsspeicher frei, und die <xref:System.GC.MaxGeneration%2A> Eigenschaftswert im Laufe der Zeit anwachsen kann.  
  
 Wenn das Altern von Objekten implementiert wird, die <xref:System.GC.MaxGeneration%2A> Eigenschaft gibt die maximale Generationszahl, die vom System verwendet werden; andernfalls gibt diese Eigenschaft 0 (null) zurück.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die MaxGeneration-Eigenschaft verwenden, um die größte Generation derzeit verwendet anzuzeigen.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Für diese Implementierung der zurückgegebene Wert durch die <see cref="P:System.GC.MaxGeneration" /> Eigenschaft ist mit Sicherheit für die Lebensdauer einer ausgeführten Anwendung konstant bleibt.  
  
Verwenden der <see cref="P:System.GC.MaxGeneration" /> Eigenschaft, um den Höchstwert zu ermitteln, Sie, beim Aufrufen angeben können, der <see cref="M:System.GC.Collect(System.Int32)" /> -Methode, die einen Parameter für die Generierung verwendet.</para></block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold">Eine Zahl zwischen 1 und 99, die auf der Grundlage der in Generation 2 zugeordneten Objekte angibt, wann die Benachrichtigung ausgelöst werden soll.</param>
        <param name="largeObjectHeapThreshold">Eine Zahl zwischen 1 und 99, die auf der Grundlage der im großen Objektheap reservierten Objekte angibt, wann die Benachrichtigung ausgelöst werden soll.</param>
        <summary>Gibt an, dass eine Garbage Collection-Benachrichtigung ausgelöst werden soll, wenn eine vollständige Garbage Collection durch die Bedingungen begünstigt wird und wenn die Garbage Collection abgeschlossen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für jede Generierung legt der Garbage Collector einen Schwellenwert für Zuordnungen in dieser Generation fest. Wenn die Größe der Zuweisungen diesen Schwellenwert überschreitet, wird eine Garbagecollection für diese Generation ausgelöst. Für Beispiel: Wenn der Schwellenwert für die Generation 2 ist 20MB (d. h. 20MB überdauert Garbage Collections der Generation 1 und wird in Generation 2 höher gestuft) und mehr als 20MB hat noch Generation 1 vorhanden und wird aufgefordert, in Generation 2, versucht der nächsten Garbagecollection als eine Collection der Generation 2. Auf ähnliche Weise, wenn der große Objektheap (LOH) ist Schwellenwert ist 20MB und Ihre app verfügt über mehr als 20MB große Objekte zugewiesen, die nächste Garbagecollection wird auch als eine Collection der Generation 2 versucht, (da der große Objektheap nur in Gen 2-Garbage collection gesammelt werden).  
  
 Die `maxGenerationThreshold` und `largeObjectHeapThreshold` Schwellenwerte steuern, wie weit im Voraus Sie benachrichtigt werden, bevor eine vollständige Garbagecollection erfolgt. Je größer der Schwellenwert, der mehr Zuordnungen, die zwischen Benachrichtigung und die nächste vollständige Garbagecollection auftreten können.  
  
 Wenn Ihre Situationen können eine vollständige Garbagecollection durch die common Language Runtime in denen sich negativ auf die Leistung Ihrer Anwendung auswirken würde, können Sie benachrichtigt werden, wenn die Laufzeitumgebung, die eine vollständige Garbage Collection und umgehen diese Sammlung von anfordern eine Garbage Collection auslösen selbst (mithilfe der <xref:System.GC.Collect%2A> Methode), wenn Bedingungen weiterhin günstig sind. Zusätzlich zum Ändern des Garbage Collection-Zeitplans selbst, ist die vollständige GC-Benachrichtigung in den folgenden Szenarien nützlich:  
  
-   Sie überwachen, für den Ansatz der vollständigen Garbagecollection und, wenn Sie benachrichtigt werden, dass eine ansteht, reduzieren Sie Livedaten-Größe (z. B. durch die Freigabe von einige Einträge im Cache). Daher tritt die Garbagecollection, ist es möglich, mehr Arbeitsspeicher freizugeben.  
  
-   Sie überwachen, auf den Abschluss einer vollständigen Garbage Collection, damit Sie einige Statistiken sammeln können.  Beispielsweise empfiehlt es sich um die Größe des Heaps bei Beendigung der GC zu messen, damit Sie wissen, dass die Größe des live-Daten. (Nach einer vollständigen GC anfallenden ist der Heap auf die kleinste Größe).  
  
 Weitere Informationen dazu, was eine vollständige Garbagecollection darstellt, finden Sie unter [Garbage Collection-Benachrichtigungen](~/docs/standard/garbage-collection/notifications.md).  
  
 Wenn Sie für eine Garbage Collection-Benachrichtigung registrieren, können Sie benachrichtigt werden, wenn eine vollständige Garbagecollection ansteht, und wenn er abgeschlossen ist. Dieses Muster ähnelt, wie das Betriebssystem für Benachrichtigungen über unzureichenden Arbeitsspeicher überwacht.  
  
 Verwenden Sie die folgenden Richtlinien zum Angeben der `maxGenerationThreshold` und `largeObjectHeapThreshold` Parameter:  
  
-   Je größer der Schwellenwert, werden die weitere Zuordnungen zwischen der Benachrichtigung und die vollständige Garbagecollection auftreten.  
  
     Ein höheren Wert für den Schwellenwert bietet mehr Möglichkeiten für die Laufzeit für eine annähern Sammlung überprüfen. Dies erhöht die Wahrscheinlichkeit, dass Sie benachrichtigt werden soll. Allerdings sollten Sie nicht zu hohen Schwellenwert festlegen, da, die in einer mehr Zuordnungen werden vor die Laufzeit die nächste Auflistung ausgelöst.  
  
     Wenn Sie eine Sammlung selbst bei Benachrichtigung mit einem hohen Schwellenwert auslösen, sind weniger Objekte freigegeben, als von der nächsten Auflistung der Runtime freigegeben werden würde.  
  
-   Je kleiner der Wert, der weniger Zuordnungen zwischen Benachrichtigung und die vollständige Garbagecollection.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine Garbage Collection-Benachrichtigung registrieren, und Starten eines Threads zum Überwachen des Status der Garbage Collection-Benachrichtigung. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für [Garbage Collection-Benachrichtigungen](~/docs/standard/garbage-collection/notifications.md) Thema.  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxGenerationThreshold" />oder <paramref name="largeObjectHeapThreshold" /> liegt nicht zwischen 1 und 99.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Garbage Collection-Benachrichtigungen</related>
        <exception cref="T:System.InvalidOperationException">Dieser Member ist nicht verfügbar, wenn die gleichzeitige Garbage Collection aktiviert ist. Informationen zum Deaktivieren von gleichzeitig ausgeführten Garbage Collection-Vorgängen finden Sie im Artikel zur &lt;gcConcurrent&gt;-Laufzeiteinstellung.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Die Menge an nicht verwaltetem Arbeitsspeicher, die freigegeben wurde.</param>
        <summary>Informiert die Laufzeit, dass nicht verwalteter Arbeitsspeicher freigegeben wurde und beim Planen der Garbage Collection nicht mehr berücksichtigt werden muss.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Planen der Garbagecollection berücksichtigt die Laufzeit, wie viel verwalteten Speicher zugeordnet wird. Wenn Sie ein kleines verwaltetes Objekt über eine große Menge an nicht verwalteten Arbeitsspeicher zuordnet, kann die Laufzeit berücksichtigt nur den verwalteten Speicher und unterschätzt somit die Dringlichkeit der Planen der Garbagecollection. Die <xref:System.GC.AddMemoryPressure%2A> Methode informiert die Laufzeit über diesen zusätzlichen Druck auf dem Systemspeicher, und die <xref:System.GC.RemoveMemoryPressure%2A> Methode informiert die Laufzeit, dass der zusätzliche Druck freigegeben wurde.  
  
 Im einfachsten Verwendungsmuster, ein verwaltetes Objekt ordnet nicht verwalteten Speicher in den Konstruktor, und gibt es in der `Dispose` oder `Finalize` Methode. Rufen Sie die <xref:System.GC.AddMemoryPressure%2A> Methode nach der Zuweisung der nicht verwalteten Arbeitsspeicher, und rufen Sie die <xref:System.GC.RemoveMemoryPressure%2A> Methode nach der Freigabe.  
  
 In etwas komplizierteren Szenarios, in dem nicht verwaltetem Speicher ändert sich im Wesentlichen während der Lebensdauer des verwalteten Objekts, rufen Sie die <xref:System.GC.AddMemoryPressure%2A> und <xref:System.GC.RemoveMemoryPressure%2A> Methoden, um diese inkrementellen Änderungen zur Laufzeit zu kommunizieren.  
  
> [!CAUTION]
>  Sie müssen sicherstellen, dass Sie genau die benötigte Menge Druck entfernen, die Sie hinzufügen. Andernfalls kann die Leistung des Systems in Anwendungen beeinträchtigen, die für längere Zeit ausgeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bytesAllocated" /> ist kleiner oder gleich 0.  
  
- oder - 
Auf einem 32-Bit-Computer ist <paramref name="bytesAllocated" /> größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Garbage Collection-Priorität zu bearbeiten. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, für das ein Finalizer aufgerufen werden muss.</param>
        <summary>Fordert beim System den Aufruf des Finalizers für das angegebene Objekt an, für das zuvor <see cref="M:System.GC.SuppressFinalize(System.Object)" /> aufgerufen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.GC.ReRegisterForFinalize%2A> Methode fügt die `obj` Parameter, um die Liste der Objekte, die Finalisierung anfordern, bevor der Garbage Collector das Objekt freigibt. Die `obj` -Parameter muss der Aufrufer dieser Methode sein.  
  
 Aufrufen der <xref:System.GC.ReRegisterForFinalize%2A> -Methode garantiert nicht, dass der Garbage Collector den Finalizer des Objekts aufruft.  
  
 Standardmäßig werden alle Objekte, die Finalizer zu implementieren die Liste der Objekte hinzugefügt, für die Finalisierung erforderlich; jedoch ein Objekt möglicherweise bereits abgeschlossen oder der Beendigung kann durch Aufrufen von deaktiviert die <xref:System.GC.SuppressFinalize%2A> Methode.  
  
 Finalizer kann diese Methode verwenden, um zu erwecken, sich selbst oder auf ein Objekt, das darauf verweist.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie Sie die ReRegisterForFinalize-Methode verwenden, um ein Objekt ein zweites abzuschließen Zeit nach der Garbagecollection.  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, dessen Finalizer nicht ausgeführt werden darf.</param>
        <summary>Fordert die Common Language Runtime auf, den Finalizer für das angegebenen Objekt nicht aufzurufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode legt ein bit im Objektheader `obj`, die die Runtime überprüft, wenn der Finalizer aufgerufen. Ein Finalizer, der durch dargestellt wird die <xref:System.Object.Finalize%2A?displayProperty=nameWithType> -Methode wird verwendet, um nicht verwaltete Ressourcen freizugeben, bevor ein Objekt der Garbage collection unterliegt. Wenn `obj` verfügt nicht über einen Finalizer, der Aufruf der <xref:System.GC.SuppressFinalize%2A> Methode hat keine Auswirkungen.  
  
 Objekte, implementieren die <xref:System.IDisposable> Schnittstelle kann diese Methode aufrufen, aus des Objekts des <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> Implementierung, um zu verhindern, dass der Garbage Collector aufgerufen <xref:System.Object.Finalize%2A?displayProperty=nameWithType> auf ein Objekt, das es nicht erforderlich ist. In der Regel erfolgt dies um zu verhindern, dass den Finalizer Freigabe nicht verwalteter Ressourcen, die bereits durch freigegeben wurden die <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> Implementierung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.GC.SuppressFinalize%2A> -Methode in einer Ressourcenklasse, um zu verhindern, dass eine redundante Garbagecollection von aufgerufen wird. Im Beispiel wird der [dispose-Muster](~/docs/standard/garbage-collection/implementing-dispose.md) um sowohl verwaltete Ressourcen freizugeben (d. h. Objekte, die implementieren <xref:System.IDisposable>) und nicht verwalteten Ressourcen.  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
        <related type="Article" href="https://msdn.microsoft.com/library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb">Dispose-Muster</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Versucht, Garbage Collection während der Ausführung eines kritischen Pfads zu unterbinden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nicht verschachtelt werden, Aufrufe an die <xref:System.GC.TryStartNoGCRegion%2A> Methode aufzurufen, und Sie sollten nur die <xref:System.GC.EndNoGCRegion%2A> Methode, wenn die Runtime ist derzeit im Latenzmodus ohne GC-Region ist. Das heißt, Sie sollten nicht aufrufen, <xref:System.GC.TryStartNoGCRegion%2A> mehrere Male (nach dem ersten Methodenaufruf, bei nachfolgenden Aufrufen werden nicht erfolgreich), und nicht erwarten, dass Aufrufe von <xref:System.GC.EndNoGCRegion%2A> erfolgreich ist, nur weil der erste Aufruf von <xref:System.GC.TryStartNoGCRegion%2A> war erfolgreich.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize">Die Arbeitsspeichermenge in Bytes, die ohne Auslösung einer Garbage Collection zugeordnet werden muss. Diese muss kleiner als oder gleich der Größe eines kurzlebigen Segments sein. Informationen zur Größe eines kurzlebigen Segments finden Sie im Abschnitt „Kurzlebige Generationen und Segmente“ im Artikel [Grundlagen der Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <summary>Versucht, Garbage Collection während der Ausführung eines kritischen Pfads zu unterbinden, wenn eine bestimmte Arbeitsspeichermenge verfügbar ist.</summary>
        <returns><see langword="true" />, wenn die Laufzeit die erforderliche Arbeitsspeichermenge übergeben kann, und der Garbage Collector in den Latenzmodus ohne GC-Region wechseln kann; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> Methode versucht, den Garbage Collector im Latenzmodus ohne GC-Region, die automatische speicherbereinigung nicht möglich, während eine app mit einen kritischen Bereich des Codes ausgeführt wird.  Wenn die Laufzeit zunächst die angeforderte Menge an Arbeitsspeicher zugewiesen werden kann, führt der Garbage Collector eine vollständige blockierende Garbagecollection versucht, zusätzlichen Arbeitsspeicher freizugeben. Der Garbage Collector gibt Latenzmodus ohne GC-Region aus, ist dies die erforderliche Menge an Arbeitsspeicher belegt werden, in diesem Fall tatsächlich 2 * `totalSize` Bytes (er versucht, zu reservieren `totalSize` Bytes für den kleinen Objektheap und `totalSize` Bytes für der große Objektheap).  
  
 `totalSize` muss groß genug ist, aller speicherbelegungen behandelt, die in den kritischen Pfad auftreten. Dies schließt die speicherbelegungen durch die app als auch Zuordnungen, mit der die Laufzeit in der app-Namen.  
  
> [!IMPORTANT]
>  Nicht verschachtelt werden, Aufrufe an die <xref:System.GC.TryStartNoGCRegion%2A> Methode aufzurufen, und Sie sollten nur die <xref:System.GC.EndNoGCRegion%2A> Methode, wenn die Runtime ist derzeit im Latenzmodus ohne GC-Region ist. Das heißt, Sie sollten nicht aufrufen, <xref:System.GC.TryStartNoGCRegion%2A> mehrere Male (nach dem ersten Methodenaufruf, bei nachfolgenden Aufrufen werden nicht erfolgreich), und nicht erwarten, dass Aufrufe von <xref:System.GC.EndNoGCRegion%2A> erfolgreich ist, nur weil der erste Aufruf von <xref:System.GC.TryStartNoGCRegion%2A> war erfolgreich.  
  
 Sie beenden den Latenzmodus ohne GC-Region durch Aufrufen der <xref:System.GC.EndNoGCRegion%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" /> überschreitet die Größe des kurzlebigen Segments.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess ist bereits im Latenzmodus ohne GC-Region.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Grundlagen der Garbage Collection</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Latenzmodi</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize">Die Arbeitsspeichermenge in Bytes, die ohne Auslösung einer Garbage Collection zugeordnet werden muss. Diese muss kleiner als oder gleich der Größe eines kurzlebigen Segments sein. Informationen zur Größe eines kurzlebigen Segments finden Sie im Abschnitt „Kurzlebige Generationen und Segmente“ im Artikel [Grundlagen der Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="disallowFullBlockingGC"><see langword="true" />, um eine vollständige blockierende Garbage Collection zu unterdrücken, wenn der Garbage Collector die <paramref name="totalSize" />-Bytes nicht zuordnen kann, andernfalls <see langword="false" />.</param>
        <summary>Versucht, Garbage Collection während der Ausführung eines kritischen Pfads zu unterbinden, wenn eine bestimmte Arbeitsspeichermenge verfügbar ist, und steuert die Ausführung einer vollständigen blockierenden Garbage Collection durch den Garbage Collector, wenn nicht genügend Arbeitsspeicher verfügbar ist.</summary>
        <returns><see langword="true" />, wenn die Laufzeit die erforderliche Arbeitsspeichermenge übergeben kann, und der Garbage Collector in den Latenzmodus ohne GC-Region wechseln kann; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> Methode versucht, den Garbage Collector im Latenzmodus ohne GC-Region, die automatische speicherbereinigung nicht möglich, während eine app mit einen kritischen Bereich des Codes ausgeführt wird.  Wenn die Laufzeit zunächst die angeforderte Menge an Arbeitsspeicher zugewiesen werden kann, und die `disallowFullBlockingGC` Argument `false`, der Garbage Collector führt eine vollständige blockierende Garbagecollection versucht, zusätzlichen Arbeitsspeicher freizugeben, andernfalls die Zuordnung ein Fehler auftritt, und die Methode gibt `false`. Der Garbage Collector gibt Latenzmodus ohne GC-Region aus, ist dies die erforderliche Menge an Arbeitsspeicher belegt werden, in diesem Fall tatsächlich 2 * `totalSize` (er versucht, zu reservieren `totalSize` für den kleinen Objektheap und `totalSize` für großes Objekt Heap).  
  
 `totalSize` muss groß genug ist, aller speicherbelegungen behandelt, die in den kritischen Pfad auftreten. Dies schließt die speicherbelegungen durch die app als auch Zuordnungen, mit der die Laufzeit in der app-Namen.  
  
 Festlegen von `disallowFullBlockingGC` zu `true` um zu verhindern, dass einen vollständigen blockierenden Garbage Collection, wenn nicht genügend Arbeitsspeicher verfügbar ist eignet sich am besten in Lastenausgleichsszenarien: ein System kann diese Methode aufrufen, und melden Sie sich selbst als bereit für Anforderungen zurückgegeben `true`, und den Load Balancer-Anforderungen an andere Systeme umleiten, wenn zurückgegeben `false`. Sie können führen Sie dann eine vollständige blockierende Garbagecollection durch den Aufruf keine Anforderungen verarbeitet wird die <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> Methode.  
  
> [!IMPORTANT]
>  Nicht verschachtelt werden, Aufrufe an die <xref:System.GC.TryStartNoGCRegion%2A> Methode aufzurufen, und Sie sollten nur die <xref:System.GC.EndNoGCRegion%2A> Methode, wenn die Runtime ist derzeit im Latenzmodus ohne GC-Region ist. Das heißt, Sie sollten nicht aufrufen, <xref:System.GC.TryStartNoGCRegion%2A> mehrere Male (nach dem ersten Methodenaufruf, bei nachfolgenden Aufrufen werden nicht erfolgreich), und nicht erwarten, dass Aufrufe von <xref:System.GC.EndNoGCRegion%2A> erfolgreich ist, nur weil der erste Aufruf von <xref:System.GC.TryStartNoGCRegion%2A> war erfolgreich.  
  
 Sie beenden den Latenzmodus ohne GC-Region durch Aufrufen der <xref:System.GC.EndNoGCRegion%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" /> überschreitet die Größe des kurzlebigen Segments.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess ist bereits im Latenzmodus ohne GC-Region.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Grundlagen der Garbage Collection</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Latenzmodi</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lohSize" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize">Die Arbeitsspeichermenge in Bytes, die ohne Auslösung einer Garbage Collection zugeordnet werden muss. <paramref name="totalSize" /> -<paramref name="lohSize" /> muss kleiner als oder gleich der Größe eines kurzlebigen Segments sein. Informationen zur Größe eines kurzlebigen Segments finden Sie im Abschnitt „Kurzlebige Generationen und Segmente“ im Artikel [Grundlagen der Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="lohSize">Die Anzahl der Bytes in <paramref name="totalSize" />, die für Zuordnung für großen Objektheap zu verwenden ist.</param>
        <summary>Versucht, Garbage Collection während der Ausführung eines kritischen Pfads zu unterbinden, wenn eine bestimmte Arbeitsspeichermenge für den großen und den kleinen Objektheap verfügbar ist.</summary>
        <returns><see langword="true" />, wenn die Laufzeit die erforderliche Arbeitsspeichermenge übergeben kann, und der Garbage Collector in den Latenzmodus ohne GC-Region wechseln kann; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> Methode versucht, den Garbage Collector im Latenzmodus ohne GC-Region, die automatische speicherbereinigung nicht möglich, während eine app mit einen kritischen Bereich des Codes ausgeführt wird.  Wenn die Laufzeit zunächst die angeforderte Menge an Arbeitsspeicher zugewiesen werden kann, führt der Garbage Collector eine vollständige blockierende Garbagecollection versucht, zusätzlichen Arbeitsspeicher freizugeben. Der Garbage Collector in der Latenzmodus ohne GC-Region erfolgt, wenn es zuordnen kann `lohSize` für den großen Objektheap und `totalSize`  -  `lohSize` für den kleinen Objektheap (SOH).  
  
 `lohSize` muss groß genug ist, aller speicherbelegungen behandelt, die auftreten, auf dem kritischen Pfad für den großen Objektheap und `totalSize`  -  `lohSize` muss groß genug, um alle speicherbelegungen zu behandeln, die in den kritischen Pfad für das SOH auftreten. Dies schließt die speicherbelegungen durch die app als auch Zuordnungen, mit der die Laufzeit in der app-Namen.  
  
> [!IMPORTANT]
>  Nicht verschachtelt werden, Aufrufe an die <xref:System.GC.TryStartNoGCRegion%2A> Methode aufzurufen, und Sie sollten nur die <xref:System.GC.EndNoGCRegion%2A> Methode, wenn die Runtime ist derzeit im Latenzmodus ohne GC-Region ist. Das heißt, Sie sollten nicht aufrufen, <xref:System.GC.TryStartNoGCRegion%2A> mehrere Male (nach dem ersten Methodenaufruf, bei nachfolgenden Aufrufen werden nicht erfolgreich), und nicht erwarten, dass Aufrufe von <xref:System.GC.EndNoGCRegion%2A> erfolgreich ist, nur weil der erste Aufruf von <xref:System.GC.TryStartNoGCRegion%2A> war erfolgreich.  
  
 Sie beenden den Latenzmodus ohne GC-Region durch Aufrufen der <xref:System.GC.EndNoGCRegion%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" /> - <paramref name="lohSize" /> überschreitet die Größe des kurzlebigen Segments.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess ist bereits im Latenzmodus ohne GC-Region.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Grundlagen der Garbage Collection</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Latenzmodi</related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lohSize" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize">Die Arbeitsspeichermenge in Bytes, die ohne Auslösung einer Garbage Collection zugeordnet werden muss. <paramref name="totalSize" /> -<paramref name="lohSize" /> muss kleiner als oder gleich der Größe eines kurzlebigen Segments sein. Informationen zur Größe eines kurzlebigen Segments finden Sie im Abschnitt „Kurzlebige Generationen und Segmente“ im Artikel [Grundlagen der Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="lohSize">Die Anzahl der Bytes in <paramref name="totalSize" />, die für Zuordnung für großen Objektheap zu verwenden ist.</param>
        <param name="disallowFullBlockingGC"><see langword="true" />, um eine vollständige blockierende Garbage Collection zu unterdrücken, wenn der Garbage Collector den für den kleinen und den großen Objektheap angegebenen Arbeitsspeicher nicht zuordnen kann, andernfalls <see langword="false" />.</param>
        <summary>Versucht, Garbage Collection während der Ausführung eines kritischen Pfads zu unterbinden, wenn eine bestimmte Arbeitsspeichermenge für den großen und den kleinen Objektheap verfügbar ist, und steuert die Ausführung einer vollständigen blockierenden Garbage Collection durch den Garbage Collector, wenn nicht genügend Arbeitsspeicher verfügbar ist.</summary>
        <returns><see langword="true" />, wenn die Laufzeit die erforderliche Arbeitsspeichermenge übergeben kann, und der Garbage Collector in den Latenzmodus ohne GC-Region wechseln kann; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> Methode versucht, den Garbage Collector im Latenzmodus ohne GC-Region, die automatische speicherbereinigung nicht möglich, während eine app mit einen kritischen Bereich des Codes ausgeführt wird.  Wenn die Laufzeit zunächst die angeforderte Menge an Arbeitsspeicher zugewiesen werden kann, und die `disallowFullBlockingGC` Argument `false`, der Garbage Collector führt eine vollständige blockierende Garbagecollection versucht, zusätzlichen Arbeitsspeicher freizugeben, andernfalls die Zuordnung ein Fehler auftritt, und die Methode gibt `false`. Der Garbage Collector in der Latenzmodus ohne GC-Region erfolgt, wenn es zuordnen kann `lohSize` für den großen Objektheap und `totalSize`  -  `lohSize` für den kleinen Objektheap (SOH).  
  
 `lohSize` muss groß genug ist, aller speicherbelegungen behandelt, die auftreten, auf dem kritischen Pfad für den großen Objektheap und `totalSize`  -  `lohSize` muss groß genug, um alle speicherbelegungen zu behandeln, die in den kritischen Pfad für das SOH auftreten. Dies schließt die speicherbelegungen durch die app als auch Zuordnungen, mit der die Laufzeit in der app-Namen.  
  
 Festlegen von `disallowFullBlockingGC` zu `true` um zu verhindern, dass einen vollständigen blockierenden Garbage Collection, wenn nicht genügend Arbeitsspeicher verfügbar ist eignet sich am besten in Lastenausgleichsszenarien: ein System kann diese Methode aufrufen, und melden Sie sich selbst als bereit für Anforderungen zurückgegeben `true`, und den Load Balancer-Anforderungen an andere Systeme umleiten, wenn zurückgegeben `false`. Sie können führen Sie dann eine vollständige blockierende Garbagecollection durch den Aufruf keine Anforderungen verarbeitet wird die <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> Methode.  
  
> [!IMPORTANT]
>  Nicht verschachtelt werden, Aufrufe an die <xref:System.GC.TryStartNoGCRegion%2A> Methode aufzurufen, und Sie sollten nur die <xref:System.GC.EndNoGCRegion%2A> Methode, wenn die Runtime ist derzeit im Latenzmodus ohne GC-Region ist. Das heißt, Sie sollten nicht aufrufen, <xref:System.GC.TryStartNoGCRegion%2A> mehrere Male (nach dem ersten Methodenaufruf, bei nachfolgenden Aufrufen werden nicht erfolgreich), und nicht erwarten, dass Aufrufe von <xref:System.GC.EndNoGCRegion%2A> erfolgreich ist, nur weil der erste Aufruf von <xref:System.GC.TryStartNoGCRegion%2A> war erfolgreich.  
  
 Sie beenden den Latenzmodus ohne GC-Region durch Aufrufen der <xref:System.GC.EndNoGCRegion%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalSize" /> - <paramref name="lohSize" /> überschreitet die Größe des kurzlebigen Segments.</exception>
        <exception cref="T:System.InvalidOperationException">Der Prozess ist bereits im Latenzmodus ohne GC-Region.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">Grundlagen der Garbage Collection</related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">Latenzmodi</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Status einer registrierten Benachrichtigung zurück, um zu bestimmen, ob eine vollständige blockierende Garbage Collection durch die Common Language Runtime bevorsteht.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Status einer registrierten Benachrichtigung zurück, um zu bestimmen, ob eine vollständige blockierende Garbage Collection durch die Common Language Runtime bevorsteht.</summary>
        <returns>Der Status der registrierten Garbage Collection-Benachrichtigung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.GCNotificationStatus> zurückgegeben, die von dieser Methode den Status der aktuellen Garbage Collection-Benachrichtigung zu bestimmen, die mit registriert wurde-Enumeration die <xref:System.GC.RegisterForFullGCNotification%2A> Methode. Sie können auch die <xref:System.GC.WaitForFullGCComplete%2A> Methode, um zu bestimmen, ob die vollständige Garbagecollection abgeschlossen wurde.  
  
 Wenn die Enumeration zurückgibt <xref:System.GCNotificationStatus.Succeeded>, erreichen Sie Aufgaben wie z. B. verhindern, dass zusätzliche Objekte reserviert werden, und eine Auflistung mit Auslösen der <xref:System.GC.Collect%2A> Methode. Beachten Sie, dass die Benachrichtigung nicht garantiert, dass eine vollständige Garbagecollection, die Bedingungen erreicht haben den Schwellenwert an, die günstig für eine vollständige Garbagecollection ausgeführt wird ausgeführt werden.  
  
 Diese Methode wartet unbegrenzt auf eine Garbage Collection-Benachrichtigung abgerufen werden sollen. Wenn Sie möchten an einem bestimmten Timeoutzeitraum für die Methode zurückgeben, wenn die Benachrichtigung nicht abgerufen werden kann, verwenden die <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> -methodenüberladung. Wenn Sie diese Methode aufrufen, ohne dass einen Timeout, können Sie rufen die <xref:System.GC.CancelFullGCNotification%2A> Methode, wenn Sie länger als bevorzugte warten.  
  
 Befolgen Sie diese Methode mit einem Aufruf der <xref:System.GC.WaitForFullGCComplete%2A> Methode, um sicherzustellen, dass eine vollständige Garbagecollection ausgeführt wurde. Das Aufrufen dieser Methode allein bewirkt, dass die unbestimmte Ergebnisse.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie diese Methode verwenden, um zu bestimmen, ob eine vollständige blockierende Garbagecollection ansteht. Jedes Mal, wenn der Status der Benachrichtigung ist <xref:System.GCNotificationStatus.Succeeded>, die Benutzermethode `OnFullGCApproachNotify` wird aufgerufen, um Aktionen als Reaktion auf die bevorstehende Garbage Collection. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für [Garbage Collection-Benachrichtigungen](~/docs/standard/garbage-collection/notifications.md) Thema.  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Garbage Collection-Benachrichtigungen</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Die Dauer der Wartezeit, bevor ein Benachrichtigungsstatus abgerufen werden kann. Geben Sie -1 an, um unbegrenzt zu warten.</param>
        <summary>Gibt innerhalb einer angegebenen Timeoutspanne den Status einer registrierten Benachrichtigung zurück, um zu bestimmen, ob eine vollständige blockierende Garbage Collection durch die Common Language Runtime bevorsteht.</summary>
        <returns>Der Status der registrierten Garbage Collection-Benachrichtigung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.GCNotificationStatus> zurückgegeben, die von dieser Methode den Status der aktuellen Garbage Collection-Benachrichtigung zu bestimmen, die mit registriert wurde-Enumeration die <xref:System.GC.RegisterForFullGCNotification%2A> Methode. Sie können auch die <xref:System.GC.WaitForFullGCComplete%2A> Methode, um zu bestimmen, ob die vollständige Garbagecollection abgeschlossen wurde.  
  
 Beachten Sie, die diese Methode zurückgibt, sofort bei jedem Garbage Collection-Benachrichtigungsstatus abgerufen wird, unabhängig von den vom angegebenen Wert `millisecondsTimeout`. Wenn eine Garbage Collection-Benachrichtigungsstatus nicht vor dem erfolgt `millisecondsTimeout` Zeiten, diese Methode gibt <xref:System.GCNotificationStatus.NotApplicable>.  
  
 Wenn die Enumeration zurückgibt <xref:System.GCNotificationStatus.Succeeded>, erreichen Sie Aufgaben wie z. B. verhindern, dass zusätzliche Objekte reserviert werden, und eine Auflistung mit Auslösen der <xref:System.GC.Collect%2A> Methode. Beachten Sie, dass die Benachrichtigung nicht garantiert, dass eine vollständige Garbagecollection, die Bedingungen erreicht haben den Schwellenwert an, die günstig für eine vollständige Garbagecollection ausgeführt wird ausgeführt werden.  
  
 Rufen Sie die <xref:System.GC.CancelFullGCNotification%2A> Methode, wenn Sie das Timeout verstreichen warten können.  
  
 Befolgen Sie diese Methode mit einem Aufruf der <xref:System.GC.WaitForFullGCComplete%2A> Methode, um sicherzustellen, dass eine vollständige Garbagecollection ausgeführt wurde. Das Aufrufen dieser Methode allein bewirkt, dass die unbestimmte Ergebnisse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> darf nicht negativ sein oder muss kleiner oder gleich <see cref="F:System.Int32.MaxValue" /> oder -1 sein.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Garbage Collection-Benachrichtigungen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Status einer registrierten Benachrichtigung zurück, um zu bestimmen, ob eine vollständige blockierende Garbage Collection durch die Common Language Runtime abgeschlossen wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Status einer registrierten Benachrichtigung zurück, um zu bestimmen, ob eine vollständige blockierende Garbage Collection durch die Common Language Runtime abgeschlossen wurde.</summary>
        <returns>Der Status der registrierten Garbage Collection-Benachrichtigung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.GCNotificationStatus> zurückgegeben, die von dieser Methode den Status der aktuellen Garbage Collection-Benachrichtigung zu bestimmen, die mit registriert wurde-Enumeration die <xref:System.GC.RegisterForFullGCNotification%2A> Methode. Sie können auch die <xref:System.GC.WaitForFullGCApproach%2A> Methode, um zu bestimmen, ob eine vollständige Garbagecollection bevorsteht.  
  
 Wenn die Enumeration zurückgibt <xref:System.GCNotificationStatus.Succeeded>, erreichen Sie Aufgaben wie das Fortsetzen der Arbeit und Abrufen der Anzahl Auflistung mit den <xref:System.GC.CollectionCount%2A> Eigenschaft.  
  
 Diese Methode wartet unbegrenzt auf eine Garbage Collection-Benachrichtigung abgerufen werden sollen. Wenn Sie möchten an einem bestimmten Timeoutzeitraum für die Methode zurückgeben, wenn die Benachrichtigung nicht abgerufen werden kann, verwenden die <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> -methodenüberladung. Wenn Sie diese Methode aufrufen, ohne dass einen Timeout, können Sie rufen die <xref:System.GC.CancelFullGCNotification%2A> Methode, wenn Sie länger als bevorzugte warten.  
  
 Dieser Methodenaufruf sollte mit einem Aufruf von vorangestellt werden die <xref:System.GC.WaitForFullGCApproach%2A> Methode, um sicherzustellen, dass eine vollständige Garbagecollection ausgeführt wurde. Das Aufrufen dieser Methode allein kann zu unvorhersehbaren Ergebnissen führen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie diese Methode verwenden, um zu bestimmen, ob eine vollständige Garbagecollection abgeschlossen wurde. Jedes Mal, wenn der Status der Benachrichtigung ist <xref:System.GCNotificationStatus.Succeeded>, die Benutzermethode `OnFullGCCompletedNotify` wird aufgerufen, um Aktionen als Reaktion auf die vollständige Auflistung ausführen. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für [Garbage Collection-Benachrichtigungen](~/docs/standard/garbage-collection/notifications.md) Thema.  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Garbage Collection-Benachrichtigungen</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Die Dauer der Wartezeit, bevor ein Benachrichtigungsstatus abgerufen werden kann. Geben Sie -1 an, um unbegrenzt zu warten.</param>
        <summary>Gibt innerhalb einer angegebenen Timeoutspanne den Status einer registrierten Benachrichtigung zurück, um zu bestimmen, ob eine vollständige blockierende Garbage Collection durch die Common Language Runtime abgeschlossen wurde.</summary>
        <returns>Der Status der registrierten Garbage Collection-Benachrichtigung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.GCNotificationStatus> zurückgegeben, die von dieser Methode den Status der aktuellen Garbage Collection-Benachrichtigung zu bestimmen, die mit registriert wurde-Enumeration die <xref:System.GC.RegisterForFullGCNotification%2A> Methode. Sie können auch die <xref:System.GC.WaitForFullGCApproach%2A> Methode, um zu bestimmen, ob eine vollständige Garbagecollection bevorsteht.  
  
 Beachten Sie, die diese Methode zurückgibt, sofort bei jedem Garbage Collection-Benachrichtigungsstatus abgerufen wird, unabhängig von den vom angegebenen Wert `millisecondsTimeout`. Wenn eine Garbage Collection-Benachrichtigungsstatus nicht vor dem erfolgt `millisecondsTimeout` Zeiten, diese Methode gibt <xref:System.GCNotificationStatus.NotApplicable>.  
  
 Wenn die Enumeration zurückgibt <xref:System.GCNotificationStatus.Succeeded>, erreichen Sie Aufgaben wie das Fortsetzen der Arbeit und Abrufen der Anzahl Auflistung mit den <xref:System.GC.CollectionCount%2A> Eigenschaft.  
  
 Rufen Sie die <xref:System.GC.CancelFullGCNotification%2A> Methode, wenn Sie das Timeout verstreichen warten können.  
  
 Dieser Methodenaufruf sollte mit einem Aufruf von vorangestellt werden die <xref:System.GC.WaitForFullGCApproach%2A> Methode, um sicherzustellen, dass eine vollständige Garbagecollection ausgeführt wurde. Das Aufrufen dieser Methode allein kann zu unvorhersehbaren Ergebnissen führen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="millisecondsTimeout" /> darf nicht negativ sein oder muss kleiner oder gleich <see cref="F:System.Int32.MaxValue" /> oder -1 sein.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">Garbage Collection-Benachrichtigungen</related>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hält den aktuellen Thread so lange an, bis der Thread, der die Finalizerwarteschlange verarbeitet, diese Warteschlange geleert hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Garbage Collector Objekte, die freigegeben werden kann findet, wird jedes Objekt, um zu bestimmen, die finalisiert werden muss. Wenn ein Objekt einen Finalizer implementiert und Finalisierung nicht, durch den Aufruf deaktiviert wurde <xref:System.GC.SuppressFinalize%2A>, das Objekt befindet sich in einer Liste von Objekten, die als bereit für die Finalisierung markiert sind. Der Garbage Collector Ruft die <xref:System.Object.Finalize%2A> Methoden für die Objekte in der Liste auf und entfernt die Einträge aus der Liste. Diese Methode blockiert, bis alle Finalizer haben bis zum Abschluss ausgeführt.  
  
 Der Thread, der auf dem Finalizer ausgeführt werden ist nicht vorgegeben, daher besteht keine Garantie, die diese Methode beendet wird. Allerdings kann dieser Thread unterbrochen werden, von einem anderen Thread während der <xref:System.GC.WaitForPendingFinalizers%2A> -Methode wird gerade ausgeführt. Beispielsweise können Sie einen anderen Thread starten, der für eine bestimmte Zeitspanne wartet und dann diesen Thread unterbricht, wenn dieser Thread weiterhin angehalten ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.GC.WaitForPendingFinalizers%2A> Methode, um den aktuellen Thread zu anzuhalten, bis die Beendigung aller gesammelten Objekte abgeschlossen ist.  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>