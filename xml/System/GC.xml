<Type Name="GC" FullName="System.GC">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c8da855fcc4927b470eaf20796bc039b02fd4f6f" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75041855" /></Metadata><TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="80a0c-101">Steuert den Garbage Collector des Systems. Das ist ein Dienst, der nicht verwendeten Speicher automatisch freigibt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-101">Controls the system garbage collector, a service that automatically reclaims unused memory.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-102">Der Garbage Collector ist eine Common Language Runtime Komponente, die die Zuordnung und Freigabe von verwaltetem Speicher steuert.</span><span class="sxs-lookup"><span data-stu-id="80a0c-102">The garbage collector is a common language runtime component that controls the allocation and release of managed memory.</span></span> <span data-ttu-id="80a0c-103">Die Methoden in dieser Klasse beeinflussen, wenn Garbage Collection für ein-Objekt ausgeführt wird und die von einem-Objekt zugeordneten Ressourcen freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-103">The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released.</span></span> <span data-ttu-id="80a0c-104">Eigenschaften in dieser Klasse enthalten Informationen über die Gesamtmenge an verfügbarem Arbeitsspeicher im System und die Alterskategorie bzw. Generierung von Arbeitsspeicher, der einem Objekt zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-104">Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.</span></span>  
  
 <span data-ttu-id="80a0c-105">Der Garbage Collector verfolgt und gibt Objekte zurück, die im verwalteten Speicher zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="80a0c-105">The garbage collector tracks and reclaims objects allocated in managed memory.</span></span> <span data-ttu-id="80a0c-106">Der Garbage Collector führt in regelmäßigen Abständen Garbage Collection aus, um Speicher freizugeben, der Objekten zugeordnet ist, für die keine gültigen Verweise vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="80a0c-106">Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references.</span></span> <span data-ttu-id="80a0c-107">Die Garbage Collection wird automatisch durchgeführt, wenn eine Speicher Anforderung nicht mithilfe des verfügbaren freien Speichers erfüllt werden kann.</span><span class="sxs-lookup"><span data-stu-id="80a0c-107">Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory.</span></span> <span data-ttu-id="80a0c-108">Alternativ kann eine Anwendung Garbage Collection mithilfe der <xref:System.GC.Collect%2A>-Methode erzwingen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-108">Alternatively, an application can force garbage collection using the <xref:System.GC.Collect%2A> method.</span></span>  
  
 <span data-ttu-id="80a0c-109">Die Garbage Collection besteht aus den folgenden Schritten:</span><span class="sxs-lookup"><span data-stu-id="80a0c-109">Garbage collection consists of the following steps:</span></span>  
  
1.  <span data-ttu-id="80a0c-110">Der Garbage Collector sucht nach verwalteten Objekten, auf die in verwaltetem Code verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-110">The garbage collector searches for managed objects that are referenced in managed code.</span></span>  
  
2.  <span data-ttu-id="80a0c-111">Der Garbage Collector versucht, Objekte zu finalisieren, auf die nicht verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-111">The garbage collector tries to finalize objects that are not referenced.</span></span>  
  
3.  <span data-ttu-id="80a0c-112">Der Garbage Collector gibt Objekte frei, auf die nicht verwiesen wird, und gibt Ihren Arbeitsspeicher frei.</span><span class="sxs-lookup"><span data-stu-id="80a0c-112">The garbage collector frees objects that are not referenced and reclaims their memory.</span></span>  
  
 <span data-ttu-id="80a0c-113">Dieses Thema enthält folgende Abschnitte:</span><span class="sxs-lookup"><span data-stu-id="80a0c-113">This topic includes the following sections:</span></span>  
  
 <span data-ttu-id="80a0c-114">[Die Garbage Collector und nicht verwalteten Ressourcen](#unmanaged) </span><span class="sxs-lookup"><span data-stu-id="80a0c-114">[The garbage collector and unmanaged resources](#unmanaged) </span></span>  
 <span data-ttu-id="80a0c-115">[Objekt Alterung und Generations](#generations) </span><span class="sxs-lookup"><span data-stu-id="80a0c-115">[Object aging and generations](#generations) </span></span>  
 [<span data-ttu-id="80a0c-116">Garbage Collection wird nicht zugelassen</span><span class="sxs-lookup"><span data-stu-id="80a0c-116">Disallowing garbage collection</span></span>](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a><span data-ttu-id="80a0c-117">Die Garbage Collector und nicht verwalteten Ressourcen</span><span class="sxs-lookup"><span data-stu-id="80a0c-117">The garbage collector and unmanaged resources</span></span>  
 <span data-ttu-id="80a0c-118">Während einer Auflistung gibt das Garbage Collector kein Objekt frei, wenn ein oder mehrere Verweise auf das Objekt in verwaltetem Code gefunden werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-118">During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code.</span></span> <span data-ttu-id="80a0c-119">Der Garbage Collector erkennt jedoch keine Verweise auf ein Objekt aus nicht verwaltetem Code und gibt möglicherweise Objekte frei, die ausschließlich in nicht verwaltetem Code verwendet werden, es sei denn, dies wird ausdrücklich verhindert.</span><span class="sxs-lookup"><span data-stu-id="80a0c-119">However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so.</span></span> <span data-ttu-id="80a0c-120">Die <xref:System.GC.KeepAlive%2A>-Methode stellt einen Mechanismus bereit, der verhindert, dass die Garbage Collector Objekte sammelt, die noch in nicht verwaltetem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-120">The <xref:System.GC.KeepAlive%2A> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.</span></span>  
  
 <span data-ttu-id="80a0c-121">Abgesehen von verwalteten Speicher Belegungen behalten Implementierungen der Garbage Collector keine Informationen zu Ressourcen, die von einem Objekt gehalten werden, z. b. Datei Handles oder Datenbankverbindungen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-121">Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections.</span></span> <span data-ttu-id="80a0c-122">Wenn ein Typ nicht verwaltete Ressourcen verwendet, die freigegeben werden müssen, bevor Instanzen des Typs freigegeben werden, kann der Typ einen Finalizer implementieren.</span><span class="sxs-lookup"><span data-stu-id="80a0c-122">When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.</span></span>  
  
 <span data-ttu-id="80a0c-123">In den meisten Fällen werden Finalizer implementiert, indem die <xref:System.Object.Finalize%2A?displayProperty=nameWithType>-Methode überschrieben wird. Typen, die in C# geschrieben wurden C++ , oder implementieren jedoch deaktivierer, die Compiler in eine außer Kraft Setzung von <xref:System.Object.Finalize%2A?displayProperty=nameWithType>umwandeln.</span><span class="sxs-lookup"><span data-stu-id="80a0c-123">In most cases, finalizers are implemented by overriding the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="80a0c-124">Wenn ein Objekt über einen Finalizer verfügt, wird es in den meisten Fällen vom Garbage Collector aufgerufen, bevor das Objekt freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-124">In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object.</span></span> <span data-ttu-id="80a0c-125">Der Garbage Collector ist jedoch nicht erforderlich, um Finalizer in allen Situationen aufzurufen. Beispielsweise wird durch die <xref:System.GC.SuppressFinalize%2A>-Methode explizit verhindert, dass der Finalizer eines Objekts aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-125">However, the garbage collector is not required to call finalizers in all situations; for example, the <xref:System.GC.SuppressFinalize%2A> method explicitly prevents an object's finalizer from being called.</span></span> <span data-ttu-id="80a0c-126">Außerdem ist es nicht erforderlich, dass der Garbage Collector einen bestimmten Thread zum Abschließen von Objekten verwendet oder die Reihenfolge sicherstellt, in der Finalizer für Objekte aufgerufen werden, die aufeinander verweisen, aber andernfalls für Garbage Collection verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="80a0c-126">Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.</span></span>  
  
 <span data-ttu-id="80a0c-127">In Szenarien, in denen Ressourcen zu einem bestimmten Zeitpunkt freigegeben werden müssen, können Klassen die <xref:System.IDisposable>-Schnittstelle implementieren, die die <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> Methode zum Ausführen von Ressourcenverwaltungs-und Cleanuptasks enthält.</span><span class="sxs-lookup"><span data-stu-id="80a0c-127">In scenarios where resources must be released at a specific time, classes can implement the <xref:System.IDisposable> interface, which contains the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method that performs resource management and cleanup tasks.</span></span> <span data-ttu-id="80a0c-128">Klassen, die <xref:System.IDisposable.Dispose%2A> implementieren, müssen als Teil Ihres Klassen Vertrags angeben, wenn und, wenn Klassenconsumer die-Methode zum Bereinigen des-Objekts aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-128">Classes that implement <xref:System.IDisposable.Dispose%2A> must specify, as part of their class contract, if and when class consumers call the method to clean up the object.</span></span> <span data-ttu-id="80a0c-129">Der Garbage Collector ruft standardmäßig die <xref:System.IDisposable.Dispose%2A>-Methode auf. Allerdings können Implementierungen der <xref:System.IDisposable.Dispose%2A>-Methode Methoden in der <xref:System.GC>-Klasse aufzurufen, um das Finalisierungsverhalten der Garbage Collector anzupassen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-129">The garbage collector does not, by default, call the <xref:System.IDisposable.Dispose%2A> method; however, implementations of the <xref:System.IDisposable.Dispose%2A> method can call methods in the <xref:System.GC> class to customize the finalization behavior of the garbage collector.</span></span>  
  
 <span data-ttu-id="80a0c-130">Weitere Informationen zum objektfinalization und zum verwerfen-Muster finden [Sie unter Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="80a0c-130">For more information on object finalization and the dispose pattern, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a><span data-ttu-id="80a0c-131">Objekt Alterung und Generationen</span><span class="sxs-lookup"><span data-stu-id="80a0c-131">Object aging and generations</span></span>  
 <span data-ttu-id="80a0c-132">Der Garbage Collector im Common Language Runtime unterstützt die Objekt Alterung mithilfe von Generierungen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-132">The garbage collector in the common language runtime supports object aging using generations.</span></span> <span data-ttu-id="80a0c-133">Eine Generierung ist eine Maßeinheit für das relative Alter von Objekten im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="80a0c-133">A generation is a unit of measure of the relative age of objects in memory.</span></span> <span data-ttu-id="80a0c-134">Die Generierungs Nummer (oder das Alter) eines Objekts gibt die Generierung an, zu der ein Objekt gehört.</span><span class="sxs-lookup"><span data-stu-id="80a0c-134">The generation number, or age, of an object indicates the generation to which an object belongs.</span></span> <span data-ttu-id="80a0c-135">Die kürzlich erstellten Objekte sind Teil der neueren Generationen und haben niedrigere Generations Zahlen als Objekte, die zuvor im Anwendungslebenszyklus erstellt wurden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-135">Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle.</span></span> <span data-ttu-id="80a0c-136">Objekte in der letzten Generation befinden sich in der Generation 0.</span><span class="sxs-lookup"><span data-stu-id="80a0c-136">Objects in the most recent generation are in generation 0.</span></span> <span data-ttu-id="80a0c-137">Diese Implementierung des Garbage Collector unterstützt drei Generationen von Objekten, Generationen 0, 1 und 2.</span><span class="sxs-lookup"><span data-stu-id="80a0c-137">This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2.</span></span> <span data-ttu-id="80a0c-138">Sie können den Wert der <xref:System.GC.MaxGeneration%2A>-Eigenschaft abrufen, um die maximale Generierungs Nummer zu ermitteln, die vom System unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-138">You can retrieve the value of the <xref:System.GC.MaxGeneration%2A> property to determine the maximum generation number supported by the system.</span></span>  
  
 <span data-ttu-id="80a0c-139">Mithilfe der Objekt Alterung können Anwendungen Garbage Collection auf eine bestimmte Generation von Generierungen abzielen, anstatt dass der Garbage Collector alle Generationen auswerten muss.</span><span class="sxs-lookup"><span data-stu-id="80a0c-139">Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations.</span></span> <span data-ttu-id="80a0c-140">Über Ladungen der <xref:System.GC.Collect%2A>-Methode, die einen `generation`-Parameter enthalten, ermöglichen es Ihnen, die älteste Generierung anzugeben, die als Garbage Collection durchgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="80a0c-140">Overloads of the <xref:System.GC.Collect%2A> method that include a `generation` parameter allow you to specify the oldest generation to be garbage collected.</span></span>  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a><span data-ttu-id="80a0c-141">Garbage Collection wird nicht zugelassen</span><span class="sxs-lookup"><span data-stu-id="80a0c-141">Disallowing garbage collection</span></span>  
 <span data-ttu-id="80a0c-142">Beginnend mit der [!INCLUDE[net_v46](~/includes/net-v46-md.md)]unterstützt die Garbage Collector einen Latenz Modus ohne GC-Region, der während der Ausführung kritischer Pfade verwendet werden kann, bei denen sich Garbage Collection nachteilig auf die Leistung einer APP auswirken können.</span><span class="sxs-lookup"><span data-stu-id="80a0c-142">Starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance.</span></span> <span data-ttu-id="80a0c-143">Der Latenz Modus ohne GC-Region erfordert, dass Sie eine Arbeitsspeicher Menge angeben, die ohne Störungen der Garbage Collector zugeordnet werden kann.</span><span class="sxs-lookup"><span data-stu-id="80a0c-143">The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector.</span></span> <span data-ttu-id="80a0c-144">Wenn die Laufzeit diesen Arbeitsspeicher zuordnen kann, führt die Laufzeit keine Garbage Collection aus, während der Code im kritischen Pfad ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-144">If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.</span></span>  
  
 <span data-ttu-id="80a0c-145">Sie definieren den Anfang des kritischen Pfads für den Bereich "keine GC", indem Sie eine der über Ladungen des <xref:System.GC.TryStartNoGCRegion%2A>aufrufen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-145">You define the beginning of the critical path of the no GC region by calling one of the overloads of the <xref:System.GC.TryStartNoGCRegion%2A>.</span></span> <span data-ttu-id="80a0c-146">Sie geben das Ende seines kritischen Pfads an, indem Sie die <xref:System.GC.EndNoGCRegion%2A>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-146">You specify the end of its critical path by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 <span data-ttu-id="80a0c-147">Aufrufe der <xref:System.GC.TryStartNoGCRegion%2A>-Methode können nicht geschachtelt werden, und Sie sollten nur die <xref:System.GC.EndNoGCRegion%2A>-Methode aufrufen, wenn sich die Laufzeit derzeit im Latenz Modus ohne GC-Region befindet.</span><span class="sxs-lookup"><span data-stu-id="80a0c-147">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="80a0c-148">Anders ausgedrückt: Sie sollten <xref:System.GC.TryStartNoGCRegion%2A> nicht mehrmals aufrufen (nach dem ersten Methodenaufruf können nachfolgende Aufrufe nicht mehr ausgeführt werden), und Sie sollten nicht erwarten, dass Aufrufe von <xref:System.GC.EndNoGCRegion%2A> erfolgreich ausgeführt werden, da der erste Aufruf von <xref:System.GC.TryStartNoGCRegion%2A> erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="80a0c-148">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="80a0c-149">Im folgenden Beispiel werden mehrere GC-Methoden verwendet, um Generierungs-und Arbeitsspeicher Informationen zu einem Block von nicht verwendeten Objekten zu erhalten und in der Konsole zu drucken.</span><span class="sxs-lookup"><span data-stu-id="80a0c-149">The following example uses several GC methods to get generation and memory information about a block of unused objects and print it to the console.</span></span> <span data-ttu-id="80a0c-150">Die nicht verwendeten Objekte werden dann erfasst, und die resultierenden Arbeitsspeicher Summen werden angezeigt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-150">The unused objects are then collected, and the resulting memory totals are displayed.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
    <related type="Article" href="~/docs/standard/garbage-collection/index.md"><span data-ttu-id="80a0c-151">Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="80a0c-151">Garbage Collection</span></span></related>
    <related type="Article" href="~/docs/standard/garbage-collection/fundamentals.md"><span data-ttu-id="80a0c-152">Grundlagen der Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="80a0c-152">Fundamentals of Garbage Collection</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated"><span data-ttu-id="80a0c-153">Die inkrementelle Menge an nicht verwaltetem Arbeitsspeicher, die belegt wurde.</span><span class="sxs-lookup"><span data-stu-id="80a0c-153">The incremental amount of unmanaged memory that has been allocated.</span></span></param>
        <summary><span data-ttu-id="80a0c-154">Informiert die Laufzeit über eine große Belegung von nicht verwaltetem Arbeitsspeicher, der beim Planen der Garbage Collection in Erwägung gezogen werden muss.</span><span class="sxs-lookup"><span data-stu-id="80a0c-154">Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-155">Wenn Sie bestimmen, wann Garbage Collection geplant werden soll, berücksichtigt die Laufzeit, wie viel verwalteter Arbeitsspeicher zugeordnet wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-155">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="80a0c-156">Wenn ein kleines verwaltetes Objekt eine große Menge an nicht verwaltetem Arbeitsspeicher belegt, berücksichtigt die Laufzeit nur den verwalteten Speicher und schätzt dadurch die Dringlichkeit der Planung Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="80a0c-156">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="80a0c-157">Die <xref:System.GC.AddMemoryPressure%2A>-Methode informiert die Laufzeit über den zusätzlichen Druck des System Speichers.</span><span class="sxs-lookup"><span data-stu-id="80a0c-157">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory.</span></span>  
  
 <span data-ttu-id="80a0c-158">Im einfachsten Verwendungs Muster ordnet ein verwaltetes Objekt im Konstruktor nicht verwalteten Speicher zu und gibt es in der `Dispose`-oder `Finalize`-Methode frei.</span><span class="sxs-lookup"><span data-stu-id="80a0c-158">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="80a0c-159">Nennen Sie die <xref:System.GC.AddMemoryPressure%2A>-Methode, nachdem Sie den nicht verwalteten Speicher zugeordnet haben, und nennen Sie die <xref:System.GC.RemoveMemoryPressure%2A>-Methode nach der Freigabe.</span><span class="sxs-lookup"><span data-stu-id="80a0c-159">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="80a0c-160">In komplizierteren Szenarien, in denen sich die nicht verwaltete Speicher Belegung während der Lebensdauer des verwalteten Objekts erheblich ändert, können Sie die Methoden <xref:System.GC.AddMemoryPressure%2A> und <xref:System.GC.RemoveMemoryPressure%2A> abrufen, um diese inkrementellen Änderungen der Laufzeit mitzuteilen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-160">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="80a0c-161">Sie müssen sicherstellen, dass Sie genau den von Ihnen hinzu fügenden Druck Betrag entfernen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-161">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="80a0c-162">Wenn dies nicht der Fall ist, kann sich dies negativ auf die Leistung des Systems in Anwendungen auswirken, die über einen längeren Zeitraum ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-162">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="80a0c-163"><paramref name="bytesAllocated" /> ist kleiner oder gleich 0.</span><span class="sxs-lookup"><span data-stu-id="80a0c-163"><paramref name="bytesAllocated" /> is less than or equal to 0.</span></span>  
  
<span data-ttu-id="80a0c-164">- oder -</span><span class="sxs-lookup"><span data-stu-id="80a0c-164">-or-</span></span> 
<span data-ttu-id="80a0c-165">Auf einem 32-Bit-Computer ist <paramref name="bytesAllocated" /> größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="80a0c-165">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="80a0c-166">, wenn nicht verwalteter Code aufgerufen werden soll, wenn die Garbage Collection-Priorität bearbeitet wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-166">for the ability to call unmanaged code when manipulating garbage-collection priority.</span></span> <span data-ttu-id="80a0c-167">Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="80a0c-167">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="80a0c-168">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="80a0c-168">requires full trust for the immediate caller.</span></span> <span data-ttu-id="80a0c-169">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-169">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="80a0c-170">Bricht die Registrierung einer Garbage Collection-Benachrichtigung ab.</span><span class="sxs-lookup"><span data-stu-id="80a0c-170">Cancels the registration of a garbage collection notification.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-171">Mit dieser Methode wird eine Garbage Collection Benachrichtigung abgebrochen, die mit der <xref:System.GC.RegisterForFullGCNotification%2A>-Methode registriert wurde.</span><span class="sxs-lookup"><span data-stu-id="80a0c-171">This method cancels a garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="80a0c-172">Sie müssen diese Methode nicht aufrufen, bevor Sie die Schwellenwert Parameterwerte in nachfolgenden Aufrufen an die <xref:System.GC.RegisterForFullGCNotification%2A> Methode anpassen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-172">You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="80a0c-173">Im folgenden Beispiel wird eine Garbage Collection Registrierung abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-173">The following example cancels a garbage collection registration.</span></span> <span data-ttu-id="80a0c-174">Dieses Beispiel ist Teil eines größeren Beispiels, das für das Thema [Garbage Collection-Benachrichtigungen](~/docs/standard/garbage-collection/notifications.md) bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-174">This example is part of a larger example provided for the [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="80a0c-175">Dieser Member ist nicht verfügbar, wenn die gleichzeitige Garbage Collection aktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-175">This member is not available when concurrent garbage collection is enabled.</span></span> <span data-ttu-id="80a0c-176">Weitere Informationen zum Deaktivieren der gleichzeitigen Garbage Collection finden Sie unter der [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)-Laufzeiteinstellung.</span><span class="sxs-lookup"><span data-stu-id="80a0c-176">See the [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) runtime setting for information about how to disable concurrent garbage collection.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="80a0c-177">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="80a0c-177">for full trust for the immediate caller.</span></span> <span data-ttu-id="80a0c-178">Dieser Member kann nicht von Code verwendet werden, der nur teilweise vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-178">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="80a0c-179">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="80a0c-179">requires full trust for the immediate caller.</span></span> <span data-ttu-id="80a0c-180">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-180">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/garbage-collection/notifications.md"><span data-ttu-id="80a0c-181">Garbage Collection-Benachrichtigungen</span><span class="sxs-lookup"><span data-stu-id="80a0c-181">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="80a0c-182">Erzwingt eine Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="80a0c-182">Forces garbage collection.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="80a0c-183">Erzwingt eine sofortige Garbage Collection für alle Generationen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-183">Forces an immediate garbage collection of all generations.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-184">Verwenden Sie diese Methode, um den gesamten Speicher freizugeben, auf den nicht zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="80a0c-184">Use this method to try to reclaim all memory that is inaccessible.</span></span> <span data-ttu-id="80a0c-185">Sie führt eine blockierende Garbage Collection aller Generationen aus.</span><span class="sxs-lookup"><span data-stu-id="80a0c-185">It performs a blocking garbage collection of all generations.</span></span>  
  
 <span data-ttu-id="80a0c-186">Alle Objekte, unabhängig davon, wie lange Sie im Arbeitsspeicher waren, werden für die Sammlung berücksichtigt. Allerdings werden Objekte, auf die in verwaltetem Code verwiesen wird, nicht gesammelt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-186">All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected.</span></span> <span data-ttu-id="80a0c-187">Verwenden Sie diese Methode, um zu erzwingen, dass das System die maximale Menge an verfügbarem Arbeitsspeicher zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-187">Use this method to force the system to try to reclaim the maximum amount of available memory.</span></span>  
  
 <span data-ttu-id="80a0c-188">Beginnend mit dem [!INCLUDE[net_v451](~/includes/net-v451-md.md)]können Sie den großen Objekt Heap (Large Object Heap, Loh) komprimieren, indem Sie die <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>-Eigenschaft auf <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> festlegen, bevor Sie die <xref:System.GC.Collect%2A>-Methode aufrufen, wie im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="80a0c-188">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], you can compact the large object heap (LOH) by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="80a0c-189">Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.GC.Collect%2A>-Methode verwendet wird, um eine Sammlung für alle Arbeitsspeicher Generationen auszuführen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-189">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on all generations of memory.</span></span> <span data-ttu-id="80a0c-190">Der Code generiert eine Reihe von nicht verwendeten Objekten und ruft dann die <xref:System.GC.Collect%2A>-Methode auf, um Sie aus dem Arbeitsspeicher zu bereinigen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-190">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/induced.md"><span data-ttu-id="80a0c-191">Indizierte Auflistungen</span><span class="sxs-lookup"><span data-stu-id="80a0c-191">Induced Collections</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="80a0c-192">Die Anzahl der ältesten Generation, für die die Garbage Collection durchgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="80a0c-192">The number of the oldest generation to be garbage collected.</span></span></param>
        <summary><span data-ttu-id="80a0c-193">Erzwingt eine sofortige Garbage Collection von Generation 0 (null) bis zu einer angegebenen Generation.</span><span class="sxs-lookup"><span data-stu-id="80a0c-193">Forces an immediate garbage collection from generation 0 through a specified generation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-194">Verwenden Sie diese Methode, um Arbeitsspeicher freizugeben, auf den nicht zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="80a0c-194">Use this method to try to reclaim memory that is inaccessible.</span></span> <span data-ttu-id="80a0c-195">Durch die Verwendung dieser Methode ist jedoch nicht sichergestellt, dass der gesamte nicht zugängliche Speicher in der angegebenen Generation freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-195">However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="80a0c-196">Wenn die Objekt Alterung implementiert ist, sammelt die Garbage Collector keine Objekte mit einer Generierungs Nummer, die höher als die angegebene Generation ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-196">If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation.</span></span> <span data-ttu-id="80a0c-197">Wenn die Objekt Alterung nicht implementiert ist, berücksichtigt die Garbage Collector alle Objekte während des Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="80a0c-197">If object aging is not implemented, the garbage collector considers all objects during the garbage collection.</span></span>  
  
 <span data-ttu-id="80a0c-198">Verwenden Sie die <xref:System.GC.MaxGeneration%2A>-Eigenschaft, um den maximal gültigen Wert des `generation`-Parameters zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-198">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of the `generation` parameter.</span></span>  
  
 <span data-ttu-id="80a0c-199">Verwenden Sie die-Version dieser Methode, die keine Parameter annimmt, um die Garbage Collector alle Objekte unabhängig von ihrer Generierung in Erwägung zu nehmen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-199">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span> <span data-ttu-id="80a0c-200">Verwenden Sie die <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType>-Methoden Überladung, damit das Garbage Collector Objekte auf der Grundlage einer <xref:System.GCCollectionMode> Einstellung freigeben kann.</span><span class="sxs-lookup"><span data-stu-id="80a0c-200">To have the garbage collector reclaim objects based on a <xref:System.GCCollectionMode> setting, use the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="80a0c-201">Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.GC.Collect%2A>-Methode verwendet wird, um eine Auflistung auf einzelnen Arbeitsspeicher Ebenen auszuführen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-201">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on individual layers of memory.</span></span> <span data-ttu-id="80a0c-202">Der Code generiert eine Reihe von nicht verwendeten Objekten und ruft dann die <xref:System.GC.Collect%2A>-Methode auf, um Sie aus dem Arbeitsspeicher zu bereinigen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-202">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="80a0c-203"><paramref name="generation" /> ist nicht gültig.</span><span class="sxs-lookup"><span data-stu-id="80a0c-203"><paramref name="generation" /> is not valid.</span></span></exception>
        <related type="Article" href="~/docs/standard/garbage-collection/induced.md"><span data-ttu-id="80a0c-204">Indizierte Auflistungen</span><span class="sxs-lookup"><span data-stu-id="80a0c-204">Induced Collections</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="80a0c-205">Die Anzahl der ältesten Generation, für die die Garbage Collection durchgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="80a0c-205">The number of the oldest generation to be garbage collected.</span></span></param>
        <param name="mode"><span data-ttu-id="80a0c-206">Ein Enumerationswert, der angibt, ob die Garbage Collection erzwungen (<see cref="F:System.GCCollectionMode.Default" /> oder <see cref="F:System.GCCollectionMode.Forced" />) oder optimiert wird (<see cref="F:System.GCCollectionMode.Optimized" />).</span><span class="sxs-lookup"><span data-stu-id="80a0c-206">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span></span></param>
        <summary><span data-ttu-id="80a0c-207">Erzwingt eine Garbage Collection von Generation 0 (null) bis zu einer angegebenen Generation zu einem durch einen <see cref="T:System.GCCollectionMode" />-Wert angegebenen Zeitpunkt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-207">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-208">Verwenden Sie den `mode`-Parameter, um anzugeben, ob Garbage Collection sofort oder nur dann erfolgen soll, wenn die Zeit zum Freigeben von Objekten optimal ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-208">Use the `mode` parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects.</span></span> <span data-ttu-id="80a0c-209">Durch die Verwendung dieser Methode wird nicht sichergestellt, dass der gesamte Speicherplatz in der angegebenen Generation nicht zugänglich ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-209">Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="80a0c-210">Legen Sie die <xref:System.Runtime.GCSettings.LatencyMode%2A>-Eigenschaft fest, um die Eindring Kraft Garbage Collection während kritischer Zeiträume in der Anwendung anzupassen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-210">To adjust the intrusiveness of garbage collection during critical periods in your application, set the <xref:System.Runtime.GCSettings.LatencyMode%2A> property.</span></span>  
  
 <span data-ttu-id="80a0c-211">Der-Garbage Collector sammelt keine-Objekte, deren Generierungs Nummer höher ist als vom `generation`-Parameter angegeben.</span><span class="sxs-lookup"><span data-stu-id="80a0c-211">The garbage collector does not collect objects with a generation number higher than specified by the `generation` parameter.</span></span> <span data-ttu-id="80a0c-212">Verwenden Sie die <xref:System.GC.MaxGeneration%2A>-Eigenschaft, um den maximal gültigen Wert `generation`zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="80a0c-212">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of `generation`.</span></span>  
  
 <span data-ttu-id="80a0c-213">Verwenden Sie die-Version dieser Methode, die keine Parameter annimmt, um die Garbage Collector alle Objekte unabhängig von ihrer Generierung in Erwägung zu nehmen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-213">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span>  
  
 <span data-ttu-id="80a0c-214">Verwenden Sie die <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType>-Methoden Überladung, damit das Garbage Collector Objekte bis zu einer angegebenen Generation von Objekten zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-214">To have the garbage collector reclaim objects up to a specified generation of objects, use the <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="80a0c-215">Wenn Sie die maximale Generierung angeben, werden alle Objekte gesammelt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-215">When you specify the maximum generation, all objects are collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="80a0c-216">Im folgenden Beispiel wird eine Garbage Collection für Objekte der Generation 2 mit der <xref:System.GCCollectionMode.Optimized>-Einstellung erzwungen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-216">The following example forces a garbage collection for generation 2 objects with the <xref:System.GCCollectionMode.Optimized> setting.</span></span>  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="80a0c-217"><paramref name="generation" /> ist nicht gültig.</span><span class="sxs-lookup"><span data-stu-id="80a0c-217"><paramref name="generation" /> is not valid.</span></span>  
  
<span data-ttu-id="80a0c-218">- oder -</span><span class="sxs-lookup"><span data-stu-id="80a0c-218">-or-</span></span> 
 <span data-ttu-id="80a0c-219"><paramref name="mode" /> ist keiner der <see cref="T:System.GCCollectionMode" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="80a0c-219"><paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span></span></exception>
        <related type="Article" href="~/docs/standard/garbage-collection/induced.md"><span data-ttu-id="80a0c-220">Indizierte Auflistungen</span><span class="sxs-lookup"><span data-stu-id="80a0c-220">Induced Collections</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="blocking" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="80a0c-221">Die Anzahl der ältesten Generation, für die die Garbage Collection durchgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="80a0c-221">The number of the oldest generation to be garbage collected.</span></span></param>
        <param name="mode"><span data-ttu-id="80a0c-222">Ein Enumerationswert, der angibt, ob die Garbage Collection erzwungen (<see cref="F:System.GCCollectionMode.Default" /> oder <see cref="F:System.GCCollectionMode.Forced" />) oder optimiert wird (<see cref="F:System.GCCollectionMode.Optimized" />).</span><span class="sxs-lookup"><span data-stu-id="80a0c-222">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span></span></param>
        <param name="blocking"><span data-ttu-id="80a0c-223"><see langword="true" />, um eine blockierende Garbage Collection auszuführen; <see langword="false" />, um eine Garbage Collection im Hintergrund auszuführen, sofern möglich.</span><span class="sxs-lookup"><span data-stu-id="80a0c-223"><see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span></span></param>
        <summary><span data-ttu-id="80a0c-224">Erzwingt eine Garbage Collection von Generation 0 (null) bis zu einer angegebenen Generation, angegeben durch jeweils einen <see cref="T:System.GCCollectionMode" />-Wert und mit einem Wert, der angibt, ob die Auflistung blockieren soll.</span><span class="sxs-lookup"><span data-stu-id="80a0c-224">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with a value specifying whether the collection should be blocking.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-225">In der folgenden Tabelle wird die Interaktion der Parameter `mode` und `blocking` zusammengefasst:</span><span class="sxs-lookup"><span data-stu-id="80a0c-225">The following table summarizes the interaction of the `mode` and `blocking` parameters:</span></span>  
  
|`mode`|<span data-ttu-id="80a0c-226">`blocking` ist gleich `true`.</span><span class="sxs-lookup"><span data-stu-id="80a0c-226">`blocking` is `true`</span></span>|<span data-ttu-id="80a0c-227">`blocking` ist gleich `false`.</span><span class="sxs-lookup"><span data-stu-id="80a0c-227">`blocking` is `false`</span></span>|  
|-|-|-|  
|<span data-ttu-id="80a0c-228"><xref:System.GCCollectionMode.Forced> oder <xref:System.GCCollectionMode.Default></span><span class="sxs-lookup"><span data-stu-id="80a0c-228"><xref:System.GCCollectionMode.Forced> or <xref:System.GCCollectionMode.Default></span></span>|<span data-ttu-id="80a0c-229">Eine blockierende Auflistung wird so schnell wie möglich ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-229">A blocking collection is performed as soon as possible.</span></span> <span data-ttu-id="80a0c-230">Wenn eine Hintergrund Auflistung ausgeführt wird und `generation` 0 oder 1 ist, löst die <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29>-Methode sofort eine blockierende Auflistung aus und gibt zurück, wenn die Auflistung abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-230">If a background collection is in progress and `generation` is 0 or 1, the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method immediately triggers a blocking collection and returns when the collection is finished.</span></span> <span data-ttu-id="80a0c-231">Wenn eine Hintergrund Auflistung ausgeführt wird und `generation` 2 ist, wartet die Methode, bis die Hintergrund Auflistung abgeschlossen ist, löst eine blockierende Sammlung der Generation 2 aus und gibt dann zurück.</span><span class="sxs-lookup"><span data-stu-id="80a0c-231">If a background collection is in progress and `generation` is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</span></span>|<span data-ttu-id="80a0c-232">Eine Auflistung wird so schnell wie möglich ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-232">A collection is performed as soon as possible.</span></span> <span data-ttu-id="80a0c-233">Die <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29>-Methode fordert eine Hintergrundauflistung, ist jedoch nicht garantiert. Je nach den Umständen wird eine blockierende Auflistung möglicherweise weiterhin ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-233">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="80a0c-234">Wenn eine Hintergrundauflistung bereits ausgeführt wird, gibt die Methode sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="80a0c-234">If a background collection is already in progress, the method returns immediately.</span></span>|  
|<xref:System.GCCollectionMode.Optimized>|<span data-ttu-id="80a0c-235">Eine blockierende Auflistung kann ausgeführt werden, je nach Zustand des Garbage Collectors und des `generation`-Parameters.</span><span class="sxs-lookup"><span data-stu-id="80a0c-235">A blocking collection may be performed, depending on the state of the garbage collector and the `generation` parameter.</span></span> <span data-ttu-id="80a0c-236">Der Garbage Collector versucht, eine optimale Leistung bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-236">The garbage collector tries to provide optimal performance.</span></span>|<span data-ttu-id="80a0c-237">Eine Auflistung kann ausgeführt werden, je nach Zustand des Garbage Collectors.</span><span class="sxs-lookup"><span data-stu-id="80a0c-237">A collection may be performed, depending on the state of the garbage collector.</span></span> <span data-ttu-id="80a0c-238">Die <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29>-Methode fordert eine Hintergrundauflistung, ist jedoch nicht garantiert. Je nach den Umständen wird eine blockierende Auflistung möglicherweise weiterhin ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-238">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="80a0c-239">Der Garbage Collector versucht, eine optimale Leistung bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-239">The garbage collector tries to provide optimal performance.</span></span> <span data-ttu-id="80a0c-240">Wenn eine Hintergrundauflistung bereits ausgeführt wird, gibt die Methode sofort zurück.</span><span class="sxs-lookup"><span data-stu-id="80a0c-240">If a background collection is already in progress, the method returns immediately.</span></span>|  
  
 <span data-ttu-id="80a0c-241">Wenn ein Aufruf der <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29>-Methode eine vollständige blockierende Garbage Collection ausführt, können Sie auch den großen Objekt Heap komprimieren, indem Sie die <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>-Eigenschaft auf <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> festlegen, bevor Sie die <xref:System.GC.Collect%2A>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-241">If a call to the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="80a0c-242"><paramref name="generation" /> ist nicht gültig.</span><span class="sxs-lookup"><span data-stu-id="80a0c-242"><paramref name="generation" /> is not valid.</span></span>  
  
<span data-ttu-id="80a0c-243">- oder -</span><span class="sxs-lookup"><span data-stu-id="80a0c-243">-or-</span></span> 
 <span data-ttu-id="80a0c-244"><paramref name="mode" /> ist keiner der <see cref="T:System.GCCollectionMode" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="80a0c-244"><paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="blocking" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="compacting" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="80a0c-245">Die Anzahl der ältesten Generation, für die die Garbage Collection durchgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="80a0c-245">The number of the oldest generation to be garbage collected.</span></span></param>
        <param name="mode"><span data-ttu-id="80a0c-246">Ein Enumerationswert, der angibt, ob die Garbage Collection erzwungen (<see cref="F:System.GCCollectionMode.Default" /> oder <see cref="F:System.GCCollectionMode.Forced" />) oder optimiert wird (<see cref="F:System.GCCollectionMode.Optimized" />).</span><span class="sxs-lookup"><span data-stu-id="80a0c-246">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span></span></param>
        <param name="blocking"><span data-ttu-id="80a0c-247"><see langword="true" />, um eine blockierende Garbage Collection auszuführen; <see langword="false" />, um eine Garbage Collection im Hintergrund auszuführen, sofern möglich.</span><span class="sxs-lookup"><span data-stu-id="80a0c-247"><see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span></span></param>
        <param name="compacting"><span data-ttu-id="80a0c-248"><see langword="true" /> zum Komprimieren des kleinen Objektheaps; <see langword="false" />, um nur Sweep durchzuführen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-248"><see langword="true" /> to compact the small object heap; <see langword="false" /> to sweep only.</span></span></param>
        <summary><span data-ttu-id="80a0c-249">Erzwingt eine Garbage Collection von Generation 0 (null) bis zu einer angegebenen Generation, angegeben durch jeweils einen <see cref="T:System.GCCollectionMode" />-Wert und mit Werten, die angeben, ob die Auflistung blockieren und komprimieren soll.</span><span class="sxs-lookup"><span data-stu-id="80a0c-249">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with values that specify whether the collection should be blocking and compacting.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-250">Wenn `blocking` `false`ist, entscheidet der GC, ob ein Hintergrund oder eine blockierende Garbage Collection durchgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="80a0c-250">If `blocking` is `false`, the GC decides whether to perform a background or a blocking garbage collection.</span></span> <span data-ttu-id="80a0c-251">Wenn `compacting` `true`ist, wird eine blockierende Garbage Collection durchführt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-251">If `compacting` is `true`, it performs a blocking garbage collection.</span></span>  
  
 <span data-ttu-id="80a0c-252">Wenn `compacting` `true`ist, komprimiert die Runtime den Small Object Heap (SoH).</span><span class="sxs-lookup"><span data-stu-id="80a0c-252">If `compacting` is `true`, the runtime compacts the small object heap (SOH).</span></span> <span data-ttu-id="80a0c-253">Der große Objekt Heap (Loh) wird nicht komprimiert, es sei denn, die <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>-Eigenschaft ist auf <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>festgelegt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-253">The large object heap (LOH) is not compacted unless the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property is set to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>.</span></span> <span data-ttu-id="80a0c-254">Beachten Sie, dass dies alle blockierenden Garbage Collections umfasst, nicht nur vollständige blockierende Garbage Collections.</span><span class="sxs-lookup"><span data-stu-id="80a0c-254">Note that this includes all blocking garbage collections, not just full blocking garbage collections.</span></span>  
  
 <span data-ttu-id="80a0c-255">Sie können die <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>-Methode aufrufen, um den verwalteten Heap auf die kleinste mögliche Größe zu reduzieren, wie das folgende Code Fragment veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="80a0c-255">You can call the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.</span></span>  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 <span data-ttu-id="80a0c-256">Wenn Sie `true` für das `compacting`-Argument angeben, wird eine komprimierende, vollständige blockierende Garbage Collection garantiert.</span><span class="sxs-lookup"><span data-stu-id="80a0c-256">Specifying `true` for the `compacting` argument guarantees a compacting, full blocking garbage collection.</span></span> <span data-ttu-id="80a0c-257">Wenn Sie die <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>-Eigenschaft auf <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> festlegen, wird sichergestellt, dass sowohl Loh als auch SoH komprimiert werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-257">Setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> ensures that both the LOH and SOH are compacted.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="80a0c-258">Die Objektgeneration, für die ermittelt werden soll, wie oft die Garbage Collection stattgefunden hat.</span><span class="sxs-lookup"><span data-stu-id="80a0c-258">The generation of objects for which the garbage collection count is to be determined.</span></span></param>
        <summary><span data-ttu-id="80a0c-259">Gib die Anzahl zurück, wie oft die Garbage Collection für die angegebene Objektgeneration stattgefunden hat.</span><span class="sxs-lookup"><span data-stu-id="80a0c-259">Returns the number of times garbage collection has occurred for the specified generation of objects.</span></span></summary>
        <returns><span data-ttu-id="80a0c-260">Die Häufigkeit der Durchführung der Garbage Collection für die angegebene Generation, seitdem der Prozess gestartet wurde.</span><span class="sxs-lookup"><span data-stu-id="80a0c-260">The number of times garbage collection has occurred for the specified generation since the process was started.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-261">Wenn Sie Ihre eigene Ressourcenverwaltung implementieren, müssen Sie möglicherweise Garbage Collection regelmäßig erzwingen, indem Sie die <xref:System.GC.Collect%2A>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-261">If you implement your own resource management, you might need to force garbage collection periodically by calling the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="80a0c-262">Da dies ein kostspieliger Vorgang ist, können Sie die Leistung verbessern, indem Sie den-Befehl überspringen, wenn eine Garbage Collection vor kurzem aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-262">Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently.</span></span> <span data-ttu-id="80a0c-263">Speichern Sie den Wert, der von <xref:System.GC.CollectionCount%2A> unmittelbar nach dem Aufrufen von <xref:System.GC.Collect%2A>zurückgegeben</span><span class="sxs-lookup"><span data-stu-id="80a0c-263">Save the value returned by <xref:System.GC.CollectionCount%2A> immediately after calling <xref:System.GC.Collect%2A>.</span></span> <span data-ttu-id="80a0c-264">Wenn Sie das nächste Mal <xref:System.GC.Collect%2A>abrufen müssen, vergleichen Sie den von <xref:System.GC.CollectionCount%2A> zurückgegebenen aktuellen Wert mit dem gespeicherten Wert.</span><span class="sxs-lookup"><span data-stu-id="80a0c-264">The next time you need to call <xref:System.GC.Collect%2A>, compare the current value returned by <xref:System.GC.CollectionCount%2A> to the saved value.</span></span> <span data-ttu-id="80a0c-265">Wenn die beiden Werte gleich sind, ist in der Zwischenzeit keine Auflistung aufgetreten, und es ist sinnvoll, <xref:System.GC.Collect%2A> erneut aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-265">If the two values are equal, no collection has occurred in the interim and it is reasonable to call <xref:System.GC.Collect%2A> again.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="80a0c-266"><paramref name="generation" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="80a0c-266"><paramref name="generation" /> is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="80a0c-267">Beendet den Latenzmodus ohne GC-Region.</span><span class="sxs-lookup"><span data-stu-id="80a0c-267">Ends the no GC region latency mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-268">Die <xref:System.GC.EndNoGCRegion%2A>-Methode löst eine <xref:System.InvalidOperationException> aus, wenn sich die Garbage Collector nicht im Latenz Modus ohne GC-Region befindet.</span><span class="sxs-lookup"><span data-stu-id="80a0c-268">The <xref:System.GC.EndNoGCRegion%2A> method throws an <xref:System.InvalidOperationException> if the garbage collector is not in no GC region latency mode.</span></span> <span data-ttu-id="80a0c-269">Dies tritt unter den folgenden Bedingungen auf:</span><span class="sxs-lookup"><span data-stu-id="80a0c-269">This occurs under any of the following conditions:</span></span>  
  
-   <span data-ttu-id="80a0c-270">Die <xref:System.GC.TryStartNoGCRegion%2A>-Methode wurde zuvor nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-270">The <xref:System.GC.TryStartNoGCRegion%2A> method was not called previously.</span></span>  
  
-   <span data-ttu-id="80a0c-271">Der aufzurufende <xref:System.GC.TryStartNoGCRegion%2A> Methode hat `false`zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="80a0c-271">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method returned `false`.</span></span>  
  
-   <span data-ttu-id="80a0c-272">Beim Abrufen der <xref:System.GC.TryStartNoGCRegion%2A>-Methode wurde eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="80a0c-272">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method threw an exception.</span></span>  
  
 <span data-ttu-id="80a0c-273">Sie können eine Ausnahme aus einem der folgenden Gründe vermeiden, indem Sie Code wie den folgenden verwenden:</span><span class="sxs-lookup"><span data-stu-id="80a0c-273">You can prevent an exception for any of these reasons by using code such as the following:</span></span>  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="80a0c-274">Der Garbage Collector befindet sich nicht im Latenzmodus ohne GC-Region.</span><span class="sxs-lookup"><span data-stu-id="80a0c-274">The garbage collector is not in no GC region latency mode.</span></span>  
  
<span data-ttu-id="80a0c-275">- oder -</span><span class="sxs-lookup"><span data-stu-id="80a0c-275">-or-</span></span> 
<span data-ttu-id="80a0c-276">Der Latenzmodus ohne GC-Region wurde zuvor beendet, da eine Garbage Collection ausgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="80a0c-276">The no GC region latency mode was ended previously because a garbage collection was induced.</span></span>  
  
<span data-ttu-id="80a0c-277">- oder -</span><span class="sxs-lookup"><span data-stu-id="80a0c-277">-or-</span></span> 
<span data-ttu-id="80a0c-278">Eine Speicherbelegung hat den im Aufruf der <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />-Methode angegebenen Wert überschritten.</span><span class="sxs-lookup"><span data-stu-id="80a0c-278">A memory allocation exceeded the amount specified in the call to the <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> method.</span></span></exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
        <related type="Article" href="~/docs/standard/garbage-collection/latency.md"><span data-ttu-id="80a0c-279">Latenzmodi</span><span class="sxs-lookup"><span data-stu-id="80a0c-279">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="80a0c-280">Ruft die Gesamtzahl der Bytes ab, die dem aktuellen Thread seit Beginn seiner Lebensdauer zugeordnet wurden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-280">Gets the total number of bytes allocated to the current thread since the beginning of its lifetime.</span></span></summary>
        <returns><span data-ttu-id="80a0c-281">Die Gesamtzahl der Bytes ab, die dem aktuellen Thread seit Beginn seiner Lebensdauer zugeordnet wurden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-281">The total number of bytes allocated to the current thread since the beginning of its lifetime.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="80a0c-282">Die `GetAllocatedBytesForCurrentThread`-Methode gibt die Gesamtanzahl der Bytes zurück, die während der Lebensdauer eines Threads im verwalteten Heap zugeordnet wurden, nicht die Gesamtanzahl der Bytes, die Garbage Collection noch nicht vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="80a0c-282">The `GetAllocatedBytesForCurrentThread` method returns the total number of bytes allocated on the managed heap during the lifetime of a thread, not the total number of bytes that have survived garbage collection.</span></span> <span data-ttu-id="80a0c-283">Der zurückgegebene Wert enthält auch keine nativen Zuordnungen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-283">The returned value also does not include any native allocations.</span></span>

<span data-ttu-id="80a0c-284">Diese Methode ist besonders nützlich bei Überwachungs Szenarien, um den Unterschied bei der Speicher Belegung Zwischenzeit Intervallen oder Ereignissen zu messen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-284">This method is most useful in monitoring scenarios for measuring the difference in memory allocation between time intervals or events.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGCMemoryInfo">
      <MemberSignature Language="C#" Value="public static GCMemoryInfo GetGCMemoryInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCMemoryInfo GetGCMemoryInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGCMemoryInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGCMemoryInfo () As GCMemoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCMemoryInfo GetGCMemoryInfo();" />
      <MemberSignature Language="F#" Value="static member GetGCMemoryInfo : unit -&gt; GCMemoryInfo" Usage="System.GC.GetGCMemoryInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.GCMemoryInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="80a0c-285">Ruft Arbeitsspeicherinformationen für die Garbage Collection ab.</span><span class="sxs-lookup"><span data-stu-id="80a0c-285">Gets garbage collection memory information.</span></span></summary>
        <returns><span data-ttu-id="80a0c-286">Ein Objekt, das Informationen zur Arbeitsspeicherauslastung durch den Garbage Collector enthält.</span><span class="sxs-lookup"><span data-stu-id="80a0c-286">An object that contains information about the garbage collector's memory usage.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="80a0c-287">Gibt die aktuelle Generationszahl eines Objekts zurück.</span><span class="sxs-lookup"><span data-stu-id="80a0c-287">Returns the current generation number of an object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="80a0c-288">Das Objekt, dessen Generationsdaten abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-288">The object that generation information is retrieved for.</span></span></param>
        <summary><span data-ttu-id="80a0c-289">Gibt die aktuelle Generationszahl des angegebenen Objekts zurück.</span><span class="sxs-lookup"><span data-stu-id="80a0c-289">Returns the current generation number of the specified object.</span></span></summary>
        <returns><span data-ttu-id="80a0c-290">Die aktuelle Generationszahl von <paramref name="obj" />.</span><span class="sxs-lookup"><span data-stu-id="80a0c-290">The current generation number of <paramref name="obj" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-291">Verwenden Sie diese Methode, um das Alter eines Objekts zu bestimmen, und verwenden Sie diese Informationen dann mit der <xref:System.GC.Collect%2A>-Methode, um zu erzwingen, dass die Garbage Collector Objekte in derselben Generation sammeln.</span><span class="sxs-lookup"><span data-stu-id="80a0c-291">Use this method to determine the age of an object, and then use that information with the <xref:System.GC.Collect%2A> method to force the garbage collector to collect objects in the same generation.</span></span> <span data-ttu-id="80a0c-292">Verwenden Sie diese Methode z. b., wenn Sie über einen Satz von Objekten verfügen, die als Gruppe erstellt werden und auf die nicht gleichzeitig zugegriffen werden kann.</span><span class="sxs-lookup"><span data-stu-id="80a0c-292">For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="80a0c-293">Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.GC.GetGeneration%2A>-Methode verwendet wird, um das Alter eines Objekts zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-293">The following example demonstrates how to use the <xref:System.GC.GetGeneration%2A> method to determine the age of an object.</span></span> <span data-ttu-id="80a0c-294">Im Beispiel werden dann Garbage Collections zum Bereinigen des Arbeitsspeichers durchführt und die Gesamtwerte für die vorab-und nach Sammlungs Erfassung in der-Konsole verglichen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-294">The example then performs garbage collections to clean up memory and compare the pre and post collection memory totals in the console.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="wo"><span data-ttu-id="80a0c-295">Ein <see cref="T:System.WeakReference" />, der auf das Zielobjekt verweist, dessen Generationszahl bestimmt werden soll.</span><span class="sxs-lookup"><span data-stu-id="80a0c-295">A <see cref="T:System.WeakReference" /> that refers to the target object whose generation number is to be determined.</span></span></param>
        <summary><span data-ttu-id="80a0c-296">Gibt die aktuelle Generationszahl für das Ziel eines angegebenen schwachen Verweises zurück.</span><span class="sxs-lookup"><span data-stu-id="80a0c-296">Returns the current generation number of the target of a specified weak reference.</span></span></summary>
        <returns><span data-ttu-id="80a0c-297">Die aktuelle Generationszahl des Ziels von <paramref name="wo" />.</span><span class="sxs-lookup"><span data-stu-id="80a0c-297">The current generation number of the target of <paramref name="wo" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="80a0c-298">Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.GC.GetGeneration%2A>-Methode verwendet wird, um das Alter eines schwachen Verweis Objekts zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-298">The following example demonstrates the use of the <xref:System.GC.GetGeneration%2A> method to determine the age of a weak reference object.</span></span>  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="80a0c-299">Garbage Collection ist bereits für <paramref name="wo" /> ausgeführt worden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-299">Garbage collection has already been performed on <paramref name="wo" />.</span></span></exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalAllocatedBytes">
      <MemberSignature Language="C#" Value="public static long GetTotalAllocatedBytes (bool precise = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalAllocatedBytes(bool precise) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalAllocatedBytes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalAllocatedBytes (Optional precise As Boolean = false) As Long" />
      <MemberSignature Language="F#" Value="static member GetTotalAllocatedBytes : bool -&gt; int64" Usage="System.GC.GetTotalAllocatedBytes precise" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="precise" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="precise"><span data-ttu-id="80a0c-300">Bei <see langword="true" /> eine genaue Zahl erfassen. Ansonsten eine ungefähre Anzahl erfassen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-300">If <see langword="true" />, gather a precise number; otherwise, gather an approximate count.</span></span> <span data-ttu-id="80a0c-301">Das Erfassen eines genauen Wertes führt zu erheblichen Leistungseinbußen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-301">Gathering a precise value entails a significant performance penalty.</span></span></param>
        <summary><span data-ttu-id="80a0c-302">Ruft die Anzahl der Bytes ab, die über die Lebensdauer des Prozesses zugeordnet wurden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-302">Gets a count of the bytes allocated over the lifetime of the process.</span></span></summary>
        <returns><span data-ttu-id="80a0c-303">Die Gesamtzahl der über die Lebensdauer des Prozesses zugeordneten Bytes.</span><span class="sxs-lookup"><span data-stu-id="80a0c-303">The total number of bytes allocated over the lifetime of the process.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection"><span data-ttu-id="80a0c-304"><see langword="true" />, um anzugeben, dass diese Methode vor der Rückgabe auf die Garbage Collection warten kann, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="80a0c-304"><see langword="true" /> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="80a0c-305">Ruft einen Schätzwert für die reservierte Anzahl von Bytes ab.</span><span class="sxs-lookup"><span data-stu-id="80a0c-305">Retrieves the number of bytes currently thought to be allocated.</span></span> <span data-ttu-id="80a0c-306">Ein Parameter gibt an, ob diese Methode vor der Rückgabe eine kurze Zeit warten kann, damit das System die Garbage Collection durchführen und Objekte finalisieren kann.</span><span class="sxs-lookup"><span data-stu-id="80a0c-306">A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</span></span></summary>
        <returns><span data-ttu-id="80a0c-307">Die bestmögliche Annäherung an die Anzahl der derzeit im verwalteten Speicher belegten Bytes.</span><span class="sxs-lookup"><span data-stu-id="80a0c-307">A number that is the best available approximation of the number of bytes currently allocated in managed memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-308">Wenn der `forceFullCollection`-Parameter `true`ist, wartet diese Methode vor der Rückgabe ein kurzes Intervall, während das System Garbage sammelt und Objekte abschließt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-308">If the `forceFullCollection` parameter is `true`, this method waits a short interval before returning while the system collects garbage and finalizes objects.</span></span> <span data-ttu-id="80a0c-309">Die Dauer des Intervalls ist ein intern festgelegter Grenzwert, der durch die Anzahl der abgeschlossenen Garbage Collection Zyklen und die Änderung der Menge an Arbeitsspeicher, die zwischen Zyklen wieder hergestellt wurde, bestimmt wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-309">The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles.</span></span> <span data-ttu-id="80a0c-310">Der Garbage Collector garantiert nicht, dass der gesamte nicht verfügbare Arbeitsspeicher erfasst wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-310">The garbage collector does not guarantee that all inaccessible memory is collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="80a0c-311">Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.GC.GetTotalMemory%2A>-Methode verwendet wird, um die Anzahl der derzeit im verwalteten Speicher belegten Bytes zu erhalten und anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-311">The following example demonstrates how to use the <xref:System.GC.GetTotalMemory%2A> method to get and display the number of bytes currently allocated in managed memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="80a0c-312">Das Objekt, auf das verwiesen werden soll.</span><span class="sxs-lookup"><span data-stu-id="80a0c-312">The object to reference.</span></span></param>
        <summary><span data-ttu-id="80a0c-313">Verweist auf das angegebene Objekt und nimmt es von Beginn der aktuellen Routine bis zum Zeitpunkt des Aufrufs dieser Methode von der Garbage Collection aus.</span><span class="sxs-lookup"><span data-stu-id="80a0c-313">References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-314">Der Zweck der <xref:System.GC.KeepAlive%2A> Methode besteht darin sicherzustellen, dass ein Verweis auf ein Objekt vorhanden ist, das durch die Garbage Collector vorzeitig freigegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="80a0c-314">The purpose of the <xref:System.GC.KeepAlive%2A> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector.</span></span> <span data-ttu-id="80a0c-315">Ein häufiges Szenario, in dem dies vorkommen kann, ist, wenn es keine Verweise auf das Objekt in verwaltetem Code oder in Daten gibt. das Objekt wird jedoch weiterhin in nicht verwaltetem Code verwendet, wie z. b. Windows-APIs, nicht verwaltete DLLs oder Methoden, die com verwenden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-315">A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Windows APIs, unmanaged DLLs, or methods using COM.</span></span>  
  
 <span data-ttu-id="80a0c-316">Diese Methode verweist auf den `obj`-Parameter, sodass das Objekt vom Anfang der Routine bis zum Punkt in der Ausführungsreihenfolge, in der diese Methode aufgerufen wird, für Garbage Collection nicht infrage kommt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-316">This method references the `obj` parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called.</span></span> <span data-ttu-id="80a0c-317">Codieren Sie diese Methode am Ende und nicht am Anfang des Bereichs von Anweisungen, in denen `obj` verfügbar sein muss.</span><span class="sxs-lookup"><span data-stu-id="80a0c-317">Code this method at the end, not the beginning, of the range of instructions where `obj` must be available.</span></span>  
  
 <span data-ttu-id="80a0c-318">Die <xref:System.GC.KeepAlive%2A>-Methode führt keinen Vorgang aus und erzeugt keine Nebeneffekte, außer wenn die Lebensdauer des Objekts, das als Parameter übergeben wird, verlängert wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-318">The <xref:System.GC.KeepAlive%2A> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="80a0c-319">Im folgenden Codebeispiel wird ein-Objekt am Anfang der `Main`-Methode erstellt, und es wird erst wieder auf das-Objekt verwiesen, wenn die <xref:System.GC.KeepAlive%2A>-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-319">The following code example creates an object at the beginning of its `Main` method and does not refer to the object again until the end, when the <xref:System.GC.KeepAlive%2A> method is called.</span></span> <span data-ttu-id="80a0c-320">Das-Objekt wird für die 30-Sekunden-Dauer der `Main`-Methode beibehalten, trotz der Aufrufe der Methoden <xref:System.GC.Collect%2A> und <xref:System.GC.WaitForPendingFinalizers%2A>.</span><span class="sxs-lookup"><span data-stu-id="80a0c-320">The object persists for the 30-second duration of the `Main` method, despite calls to the <xref:System.GC.Collect%2A> and <xref:System.GC.WaitForPendingFinalizers%2A> methods.</span></span>  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="80a0c-321">Ruft die maximale Anzahl von Generationen ab, die das System gegenwärtig unterstützt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-321">Gets the maximum number of generations that the system currently supports.</span></span></summary>
        <value><span data-ttu-id="80a0c-322">Ein Wert zwischen 0 (null) und der Höchstanzahl der unterstützten Generationen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-322">A value that ranges from zero to the maximum number of supported generations.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-323">Die Generierungs Nummer (oder das Alter) eines Objekts ist ein durch die Implementierung definiertes relativer Measure der Lebensdauer eines Objekts.</span><span class="sxs-lookup"><span data-stu-id="80a0c-323">The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan.</span></span> <span data-ttu-id="80a0c-324">Die zuletzt erstellten Objekte befinden sich in der Generation 0 und die ältesten Objekte in einer Generation, die kleiner oder gleich der Generierung ist, die von der <xref:System.GC.MaxGeneration%2A>-Eigenschaft zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-324">The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <xref:System.GC.MaxGeneration%2A> property.</span></span>  
  
 <span data-ttu-id="80a0c-325">Der Garbage Collector geht davon aus, dass der neuere Arbeitsspeicher eher für Garbage Collection als älterer Arbeitsspeicher geeignet ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-325">The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory.</span></span> <span data-ttu-id="80a0c-326">Dadurch wird die Leistung des Garbage Collector verbessert, indem bei jeder Freigabe von Speicher die Generations Zahlen angepasst werden, und der Wert der <xref:System.GC.MaxGeneration%2A>-Eigenschaft kann im Laufe der Zeit zunehmen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-326">Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <xref:System.GC.MaxGeneration%2A> property value can grow over time.</span></span>  
  
 <span data-ttu-id="80a0c-327">Wenn die Objekt Alterung implementiert ist, gibt die <xref:System.GC.MaxGeneration%2A>-Eigenschaft die maximale Generierungs Nummer zurück, die vom System verwendet wird. Andernfalls gibt diese Eigenschaft 0 (null) zurück.</span><span class="sxs-lookup"><span data-stu-id="80a0c-327">If object aging is implemented, the <xref:System.GC.MaxGeneration%2A> property returns the maximum generation number used by the system; otherwise, this property returns zero.</span></span>  
  
 <span data-ttu-id="80a0c-328">Bei dieser Implementierung bleibt der von der <xref:System.GC.MaxGeneration>-Eigenschaft zurückgegebene Wert für die Lebensdauer einer ausgeführten Anwendung garantiert konstant.</span><span class="sxs-lookup"><span data-stu-id="80a0c-328">For this implementation, the value returned by the <xref:System.GC.MaxGeneration> property is guaranteed to remain constant for the lifetime of an executing application.</span></span>  
  
 <span data-ttu-id="80a0c-329">Verwenden Sie die <xref:System.GC.MaxGeneration>-Eigenschaft, um den maximalen Wert zu bestimmen, den Sie beim Aufrufen der <xref:System.GC.Collect%28System.Int32%29>-Methode angeben können, die einen Generierungs Parameter annimmt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-329">Use the <xref:System.GC.MaxGeneration> property to determine the maximum value you can specify when calling the <xref:System.GC.Collect%28System.Int32%29> method that takes a generation parameter.</span></span>
 
 
## Examples  
 <span data-ttu-id="80a0c-330">Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.GC.MaxGeneration>-Eigenschaft verwendet wird, um die größte Generierungs Nummer anzuzeigen, die zurzeit verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-330">The following example demonstrates how to use the <xref:System.GC.MaxGeneration> property to display the largest generation number currently in use.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold"><span data-ttu-id="80a0c-331">Eine Zahl zwischen 1 und 99, die auf der Grundlage der in Generation 2 zugeordneten Objekte angibt, wann die Benachrichtigung ausgelöst werden soll.</span><span class="sxs-lookup"><span data-stu-id="80a0c-331">A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.</span></span></param>
        <param name="largeObjectHeapThreshold"><span data-ttu-id="80a0c-332">Eine Zahl zwischen 1 und 99, die auf der Grundlage der im großen Objektheap reservierten Objekte angibt, wann die Benachrichtigung ausgelöst werden soll.</span><span class="sxs-lookup"><span data-stu-id="80a0c-332">A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.</span></span></param>
        <summary><span data-ttu-id="80a0c-333">Gibt an, dass eine Garbage Collection-Benachrichtigung ausgelöst werden soll, wenn eine vollständige Garbage Collection durch die Bedingungen begünstigt wird und wenn die Garbage Collection abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="80a0c-333">Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-334">Für jede Generierung legt die Garbage Collector einen Schwellenwert für Zuordnungen in diese Generation fest.</span><span class="sxs-lookup"><span data-stu-id="80a0c-334">For each generation, the garbage collector sets a threshold for allocations into that generation.</span></span> <span data-ttu-id="80a0c-335">Wenn die Größe der Zuordnungen diesen Schwellenwert überschreitet, wird eine Garbage Collection für diese Generation ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="80a0c-335">When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation.</span></span> <span data-ttu-id="80a0c-336">Wenn der Schwellenwert der Generation 2 z. b. 20 MB beträgt (was bedeutet, dass 20 MB Sammlungen der Generation 1 überstehen und in Generation 2 herauf gestuft werden), und mehr als 20 MB Generation 1 erhalten haben und zu Generation 2 aufgefordert werden, wird der nächste Garbage Collection versucht. als Sammlung der Generation 2.</span><span class="sxs-lookup"><span data-stu-id="80a0c-336">For example, if generation 2's threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection.</span></span> <span data-ttu-id="80a0c-337">Wenn der Schwellenwert des großen Objekt Heaps 20 MB beträgt und Ihre APP mehr als 20 MB großen Objekten zugeordnet hat, wird der nächste Garbage Collection auch als eine Sammlung der Generation 2 versucht (da der Loh nur in Gen2 Garbage Collections erfasst wird).</span><span class="sxs-lookup"><span data-stu-id="80a0c-337">Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).</span></span>  
  
 <span data-ttu-id="80a0c-338">Mit den Schwellenwerten für `maxGenerationThreshold` und `largeObjectHeapThreshold` wird gesteuert, wie viel im Voraus benachrichtigt wird, bevor ein vollständiger Garbage Collection auftritt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-338">The `maxGenerationThreshold` and `largeObjectHeapThreshold` thresholds control how much in advance you are notified before a full garbage collection occurs.</span></span> <span data-ttu-id="80a0c-339">Umso höher der Schwellenwert ist, desto mehr Zuordnungen können zwischen der Benachrichtigung und der nächsten vollständigen Garbage Collection auftreten.</span><span class="sxs-lookup"><span data-stu-id="80a0c-339">The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.</span></span>  
  
 <span data-ttu-id="80a0c-340">In Situationen, in denen sich eine vollständige Garbage Collection durch die Common Language Runtime nachteilig auf die Leistung Ihrer Anwendung auswirkt, können Sie benachrichtigen, dass Sie benachrichtigt werden, wenn die Laufzeit eine vollständige Garbage Collection durchführt, und diese Auflistung umgehen, indem Sie eine Auflistung selbst (mithilfe der <xref:System.GC.Collect%2A>-Methode) auslösen, wenn die Bedingungen weiterhin günstig sind.</span><span class="sxs-lookup"><span data-stu-id="80a0c-340">If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <xref:System.GC.Collect%2A> method) when conditions are still favorable.</span></span> <span data-ttu-id="80a0c-341">Zusätzlich zum Ändern des Garbage Collection Zeitplans selbst ist die vollständige GC-Benachrichtigung für die folgenden Szenarien hilfreich:</span><span class="sxs-lookup"><span data-stu-id="80a0c-341">In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:</span></span>  
  
-   <span data-ttu-id="80a0c-342">Sie überwachen den Ansatz eines vollständigen Garbage Collection, und wenn Sie benachrichtigt werden, dass ein solcher Ansatz bevorsteht, verringern Sie die Größe der Livedaten (z. b. durch das Freigeben von Cache Einträgen).</span><span class="sxs-lookup"><span data-stu-id="80a0c-342">You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries).</span></span> <span data-ttu-id="80a0c-343">Wenn die Garbage Collection auftritt, kann dadurch mehr Arbeitsspeicher freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-343">As a result, when the garbage collection occurs, it is able to reclaim more memory.</span></span>  
  
-   <span data-ttu-id="80a0c-344">Sie überwachen den Abschluss einer vollständigen Garbage Collection, sodass Sie einige Statistiken sammeln können.</span><span class="sxs-lookup"><span data-stu-id="80a0c-344">You monitor for the completion of a full garbage collection so that you can collect some statistics.</span></span>  <span data-ttu-id="80a0c-345">Beispielsweise können Sie die Größe des Heaps bei der GC-Vervollständigung Messen, damit Sie die Größe der Livedaten kennen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-345">For example, you might want to measure the size of the heap at GC completion so that you know the size of live data.</span></span> <span data-ttu-id="80a0c-346">(Nach einer vollständigen GC hat der Heap seine kleinste Größe.)</span><span class="sxs-lookup"><span data-stu-id="80a0c-346">(After a full GC, the heap is at its smallest size.)</span></span>  
  
 <span data-ttu-id="80a0c-347">Weitere Informationen über das, was eine vollständige Garbage Collection darstellt, finden Sie unter Benachrichtigungen über die [Garbage Collection](~/docs/standard/garbage-collection/notifications.md).</span><span class="sxs-lookup"><span data-stu-id="80a0c-347">For more information about what represents a full garbage collection, see [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md).</span></span>  
  
 <span data-ttu-id="80a0c-348">Wenn Sie sich für eine Garbage Collection Benachrichtigung registrieren, können Sie benachrichtigt werden, wenn sich ein vollständiger Garbage Collection nähert und wenn er abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-348">When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed.</span></span> <span data-ttu-id="80a0c-349">Dieses Muster ähnelt der Art und Weise, wie das Betriebssystem auf Benachrichtigungen mit geringem Arbeitsspeicher überwacht</span><span class="sxs-lookup"><span data-stu-id="80a0c-349">This pattern resembles how the operating system monitors for low memory notifications.</span></span>  
  
 <span data-ttu-id="80a0c-350">Beachten Sie die folgenden Richtlinien, um die Parameter `maxGenerationThreshold` und `largeObjectHeapThreshold` anzugeben:</span><span class="sxs-lookup"><span data-stu-id="80a0c-350">Use the following guidelines for specifying the `maxGenerationThreshold` and `largeObjectHeapThreshold` parameters:</span></span>  
  
-   <span data-ttu-id="80a0c-351">Je größer der Schwellenwert ist, desto mehr Zuordnungen werden zwischen der Benachrichtigung und der vollständigen Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="80a0c-351">The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.</span></span>  
  
     <span data-ttu-id="80a0c-352">Ein größerer Schwellenwert bietet mehr Möglichkeiten für die Laufzeit, eine bevorstehende Auflistung zu überprüfen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-352">A larger threshold value provides more opportunities for the runtime to check for an approaching collection.</span></span> <span data-ttu-id="80a0c-353">Dadurch wird die Wahrscheinlichkeit erhöht, dass Sie benachrichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-353">This increases the likelihood that you will be notified.</span></span> <span data-ttu-id="80a0c-354">Sie sollten jedoch den Schwellenwert nicht zu hoch festlegen, da dies zu einer größeren Anzahl von Zuordnungen führt, bevor die Laufzeit die nächste Auflistung auslöst.</span><span class="sxs-lookup"><span data-stu-id="80a0c-354">However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.</span></span>  
  
     <span data-ttu-id="80a0c-355">Wenn Sie eine Sammlung selbst bei einer Benachrichtigung mit einem hohen Schwellenwert auslösen, werden weniger Objekte freigegeben, als von der nächsten Auflistung der Laufzeit freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-355">When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.</span></span>  
  
-   <span data-ttu-id="80a0c-356">Je kleiner der Schwellenwert ist, desto geringer sind die Zuordnungen zwischen der Benachrichtigung und der vollständigen Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="80a0c-356">The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="80a0c-357">Im folgenden Beispiel wird gezeigt, wie Sie eine Garbage Collection Benachrichtigung registrieren und einen Thread starten, um den Status der Garbage Collection Benachrichtigung zu überwachen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-357">The following example shows how to register a garbage collection notification and start a thread to monitor the status of the garbage collection notification.</span></span> <span data-ttu-id="80a0c-358">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für das Thema zur [Garbage Collection-Benachrichtigungen](~/docs/standard/garbage-collection/notifications.md) bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-358">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="80a0c-359"><paramref name="maxGenerationThreshold" />oder <paramref name="largeObjectHeapThreshold" /> liegt nicht zwischen 1 und 99.</span><span class="sxs-lookup"><span data-stu-id="80a0c-359"><paramref name="maxGenerationThreshold" /> or <paramref name="largeObjectHeapThreshold" /> is not between 1 and 99.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="80a0c-360">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="80a0c-360">for full trust for the immediate caller.</span></span> <span data-ttu-id="80a0c-361">Dieser Member kann nicht von Code verwendet werden, der nur teilweise vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-361">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="80a0c-362">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="80a0c-362">requires full trust for the immediate caller.</span></span> <span data-ttu-id="80a0c-363">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-363">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/garbage-collection/notifications.md"><span data-ttu-id="80a0c-364">Garbage Collection-Benachrichtigungen</span><span class="sxs-lookup"><span data-stu-id="80a0c-364">Garbage Collection Notifications</span></span></related>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="80a0c-365">Dieser Member ist nicht verfügbar, wenn die gleichzeitige Garbage Collection aktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-365">This member is not available when concurrent garbage collection is enabled.</span></span> <span data-ttu-id="80a0c-366">Informationen zum Deaktivieren von gleichzeitig ausgeführten Garbage Collection-Vorgängen finden Sie im Artikel zur &lt;gcConcurrent&gt;-Laufzeiteinstellung.</span><span class="sxs-lookup"><span data-stu-id="80a0c-366">See the &lt;gcConcurrent&gt; runtime setting for information about how to disable concurrent garbage collection.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated"><span data-ttu-id="80a0c-367">Die Menge an nicht verwaltetem Arbeitsspeicher, die freigegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="80a0c-367">The amount of unmanaged memory that has been released.</span></span></param>
        <summary><span data-ttu-id="80a0c-368">Informiert die Laufzeit, dass nicht verwalteter Arbeitsspeicher freigegeben wurde und beim Planen der Garbage Collection nicht mehr berücksichtigt werden muss.</span><span class="sxs-lookup"><span data-stu-id="80a0c-368">Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-369">Wenn Sie bestimmen, wann Garbage Collection geplant werden soll, berücksichtigt die Laufzeit, wie viel verwalteter Arbeitsspeicher zugeordnet wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-369">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="80a0c-370">Wenn ein kleines verwaltetes Objekt eine große Menge an nicht verwaltetem Arbeitsspeicher belegt, berücksichtigt die Laufzeit nur den verwalteten Speicher und schätzt dadurch die Dringlichkeit der Planung Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="80a0c-370">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="80a0c-371">Die <xref:System.GC.AddMemoryPressure%2A>-Methode informiert die Laufzeit über den zusätzlichen Druck des System Speichers, und die <xref:System.GC.RemoveMemoryPressure%2A>-Methode informiert die Laufzeit darüber, dass der zusätzliche Druck freigegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="80a0c-371">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory, and the <xref:System.GC.RemoveMemoryPressure%2A> method informs the runtime that the additional pressure has been released.</span></span>  
  
 <span data-ttu-id="80a0c-372">Im einfachsten Verwendungs Muster ordnet ein verwaltetes Objekt im Konstruktor nicht verwalteten Speicher zu und gibt es in der `Dispose`-oder `Finalize`-Methode frei.</span><span class="sxs-lookup"><span data-stu-id="80a0c-372">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="80a0c-373">Nennen Sie die <xref:System.GC.AddMemoryPressure%2A>-Methode, nachdem Sie den nicht verwalteten Speicher zugeordnet haben, und nennen Sie die <xref:System.GC.RemoveMemoryPressure%2A>-Methode nach der Freigabe.</span><span class="sxs-lookup"><span data-stu-id="80a0c-373">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="80a0c-374">In komplizierteren Szenarien, in denen sich die nicht verwaltete Speicher Belegung während der Lebensdauer des verwalteten Objekts erheblich ändert, können Sie die Methoden <xref:System.GC.AddMemoryPressure%2A> und <xref:System.GC.RemoveMemoryPressure%2A> abrufen, um diese inkrementellen Änderungen der Laufzeit mitzuteilen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-374">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="80a0c-375">Sie müssen sicherstellen, dass Sie genau den von Ihnen hinzu fügenden Druck Betrag entfernen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-375">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="80a0c-376">Wenn dies nicht der Fall ist, kann sich dies negativ auf die Leistung des Systems in Anwendungen auswirken, die über einen längeren Zeitraum ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-376">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="80a0c-377"><paramref name="bytesAllocated" /> ist kleiner oder gleich 0.</span><span class="sxs-lookup"><span data-stu-id="80a0c-377"><paramref name="bytesAllocated" /> is less than or equal to 0.</span></span>  
  
<span data-ttu-id="80a0c-378">- oder -</span><span class="sxs-lookup"><span data-stu-id="80a0c-378">-or-</span></span> 
<span data-ttu-id="80a0c-379">Auf einem 32-Bit-Computer ist <paramref name="bytesAllocated" /> größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="80a0c-379">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="80a0c-380">, wenn nicht verwalteter Code aufgerufen werden soll, wenn die Garbage Collection-Priorität bearbeitet wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-380">for the ability to call unmanaged code when manipulating garbage-collection priority.</span></span> <span data-ttu-id="80a0c-381">Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="80a0c-381">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="80a0c-382">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="80a0c-382">requires full trust for the immediate caller.</span></span> <span data-ttu-id="80a0c-383">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-383">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="80a0c-384">Das Objekt, für das ein Finalizer aufgerufen werden muss.</span><span class="sxs-lookup"><span data-stu-id="80a0c-384">The object that a finalizer must be called for.</span></span></param>
        <summary><span data-ttu-id="80a0c-385">Fordert beim System den Aufruf des Finalizers für das angegebene Objekt an, für das zuvor <see cref="M:System.GC.SuppressFinalize(System.Object)" /> aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="80a0c-385">Requests that the system call the finalizer for the specified object for which <see cref="M:System.GC.SuppressFinalize(System.Object)" /> has previously been called.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-386">Die <xref:System.GC.ReRegisterForFinalize%2A>-Methode fügt der Liste von Objekten, die die Beendigung anfordern, den `obj`-Parameter hinzu, bevor der Garbage Collector das Objekt freigibt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-386">The <xref:System.GC.ReRegisterForFinalize%2A> method adds the `obj` parameter to the list of objects that request finalization before the garbage collector frees the object.</span></span> <span data-ttu-id="80a0c-387">Der `obj`-Parameter muss der Aufrufer dieser Methode sein.</span><span class="sxs-lookup"><span data-stu-id="80a0c-387">The `obj` parameter must be the caller of this method.</span></span>  
  
 <span data-ttu-id="80a0c-388">Wenn Sie die <xref:System.GC.ReRegisterForFinalize%2A>-Methode aufrufen, wird nicht garantiert, dass der Garbage Collector den Finalizer eines Objekts aufruft.</span><span class="sxs-lookup"><span data-stu-id="80a0c-388">Calling the <xref:System.GC.ReRegisterForFinalize%2A> method does not guarantee that the garbage collector will call an object's finalizer.</span></span>  
  
 <span data-ttu-id="80a0c-389">Standardmäßig werden alle Objekte, die Finalizer implementieren, der Liste von Objekten hinzugefügt, die abgeschlossen werden müssen. ein Objekt wurde jedoch möglicherweise bereits abgeschlossen oder hat die Finalisierung durch Aufrufen der <xref:System.GC.SuppressFinalize%2A>-Methode deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="80a0c-389">By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <xref:System.GC.SuppressFinalize%2A> method.</span></span>  
  
 <span data-ttu-id="80a0c-390">Ein Finalizer kann diese Methode verwenden, um sich selbst oder ein Objekt, auf das er verweist, wieder zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-390">A finalizer can use this method to resurrect itself or an object that it references.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="80a0c-391">Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.GC.ReRegisterForFinalize%2A>-Methode verwendet wird, um ein Objekt ein zweites Mal nach Garbage Collection zu finalisieren.</span><span class="sxs-lookup"><span data-stu-id="80a0c-391">The following example demonstrates how to use the <xref:System.GC.ReRegisterForFinalize%2A> method to finalize an object a second time after garbage collection.</span></span>  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="80a0c-392"><paramref name="obj" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="80a0c-392"><paramref name="obj" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="80a0c-393">Das Objekt, dessen Finalizer nicht ausgeführt werden darf.</span><span class="sxs-lookup"><span data-stu-id="80a0c-393">The object whose finalizer must not be executed.</span></span></param>
        <summary><span data-ttu-id="80a0c-394">Fordert die Common Language Runtime auf, den Finalizer für das angegebene Objekt nicht aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-394">Requests that the common language runtime not call the finalizer for the specified object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="80a0c-395">Diese Methode legt ein Bit im Objekt Header von `obj`fest, das von der Laufzeit beim Aufrufen von Finalizern überprüft wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-395">This method sets a bit in the object header of `obj`, which the runtime checks when calling finalizers.</span></span> <span data-ttu-id="80a0c-396">Ein Finalizer, der durch die <xref:System.Object.Finalize%2A?displayProperty=nameWithType>-Methode dargestellt wird, wird verwendet, um nicht verwaltete Ressourcen freizugeben, bevor ein Objekt in der Garbage Collection erfasst wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-396">A finalizer, which is represented by the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method, is used to release unmanaged resources before an object is garbage-collected.</span></span> <span data-ttu-id="80a0c-397">Wenn `obj` keinen Finalizer aufweist oder der GC den Finalizer-Thread bereits signalisiert hat, den Finalizer auszuführen, hat der <xref:System.GC.SuppressFinalize%2A> Methode keine Auswirkung.</span><span class="sxs-lookup"><span data-stu-id="80a0c-397">If `obj` does not have a finalizer or the GC has already signaled the finalizer thread to run the finalizer, the call to the <xref:System.GC.SuppressFinalize%2A> method has no effect.</span></span>  
  
 <span data-ttu-id="80a0c-398">Objekte, die die <xref:System.IDisposable>-Schnittstelle implementieren, können diese Methode aus der <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>-Implementierung des Objekts aufrufen, um zu verhindern, dass der Garbage Collector <xref:System.Object.Finalize%2A?displayProperty=nameWithType> für ein Objekt aufruft, das dies nicht erfordert.</span><span class="sxs-lookup"><span data-stu-id="80a0c-398">Objects that implement the <xref:System.IDisposable> interface can call this method from the object's <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation to prevent the garbage collector from calling <xref:System.Object.Finalize%2A?displayProperty=nameWithType> on an object that does not require it.</span></span> <span data-ttu-id="80a0c-399">In der Regel wird dies durchgeführt, um zu verhindern, dass der Finalizer nicht verwaltete Ressourcen freigibt, die bereits von der <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>-Implementierung freigegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-399">Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="80a0c-400">Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.GC.SuppressFinalize%2A>-Methode in einer Ressourcen Klasse verwendet wird, um zu verhindern, dass redundante Garbage Collection aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-400">The following example demonstrates how to use the <xref:System.GC.SuppressFinalize%2A> method in a resource class to prevent a redundant garbage collection from being called.</span></span> <span data-ttu-id="80a0c-401">Im Beispiel wird das Verwerfen- [Muster](~/docs/standard/garbage-collection/implementing-dispose.md) verwendet, um sowohl verwaltete Ressourcen (d. h. Objekte, die <xref:System.IDisposable>) als auch nicht verwaltete Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="80a0c-401">The example uses the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose.md) to free both managed resources (that is, objects that implement <xref:System.IDisposable>) and unmanaged resources.</span></span>  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="80a0c-402"><paramref name="obj" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="80a0c-402"><paramref name="obj" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="80a0c-403">Dispose-Muster</span><span class="sxs-lookup"><span data-stu-id="80a0c-403">Dispose Pattern</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="80a0c-404">Versucht, Garbage Collection während der Ausführung eines kritischen Pfads zu unterbinden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-404">Attempts to disallow garbage collection during the execution of a critical path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="80a0c-405">Aufrufe der <xref:System.GC.TryStartNoGCRegion%2A>-Methode können nicht geschachtelt werden, und Sie sollten nur die <xref:System.GC.EndNoGCRegion%2A>-Methode aufrufen, wenn sich die Laufzeit derzeit im Latenz Modus ohne GC-Region befindet.</span><span class="sxs-lookup"><span data-stu-id="80a0c-405">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="80a0c-406">Anders ausgedrückt: Sie sollten <xref:System.GC.TryStartNoGCRegion%2A> nicht mehrmals aufrufen (nach dem ersten Methodenaufruf können nachfolgende Aufrufe nicht mehr ausgeführt werden), und Sie sollten nicht erwarten, dass Aufrufe von <xref:System.GC.EndNoGCRegion%2A> erfolgreich ausgeführt werden, da der erste Aufruf von <xref:System.GC.TryStartNoGCRegion%2A> erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="80a0c-406">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="80a0c-407">Die Arbeitsspeichermenge in Bytes, die ohne Auslösung einer Garbage Collection zugeordnet werden muss.</span><span class="sxs-lookup"><span data-stu-id="80a0c-407">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="80a0c-408">Diese muss kleiner als oder gleich der Größe eines kurzlebigen Segments sein.</span><span class="sxs-lookup"><span data-stu-id="80a0c-408">It must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="80a0c-409">Informationen zur Größe eines kurzlebigen Segments finden Sie im Abschnitt „Kurzlebige Generationen und Segmente“ im Artikel [Grundlagen der Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md).</span><span class="sxs-lookup"><span data-stu-id="80a0c-409">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <summary><span data-ttu-id="80a0c-410">Versucht, Garbage Collection während der Ausführung eines kritischen Pfads zu unterbinden, wenn eine bestimmte Arbeitsspeichermenge verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-410">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.</span></span></summary>
        <returns><span data-ttu-id="80a0c-411"><see langword="true" />, wenn die Laufzeit die erforderliche Arbeitsspeichermenge übergeben kann, und der Garbage Collector in den Latenzmodus ohne GC-Region wechseln kann; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="80a0c-411"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-412">Die <xref:System.GC.TryStartNoGCRegion%28System.Int64%29>-Methode versucht, die Garbage Collector in den Latenz Modus ohne GC-Region zu platzieren, was Garbage Collection nicht zulässt, während eine APP einen kritischen Code Bereich ausführt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-412">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="80a0c-413">Wenn die Laufzeit die angeforderte Arbeitsspeicher Menge nicht anfänglich zuordnen kann, führt die Garbage Collector eine vollständige blockierende Garbage Collection aus, um zusätzlichen Arbeitsspeicher freizugeben.</span><span class="sxs-lookup"><span data-stu-id="80a0c-413">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="80a0c-414">Der Garbage Collector wechselt in den Latenz Modus ohne GC-Region, wenn er die erforderliche Arbeitsspeicher Menge zuordnen kann, in diesem Fall tatsächlich 2 \* `totalSize` bytes (er versucht, `totalSize` Bytes für den kleinen Objekt Heap zuzuordnen, und `totalSize` Bytes für den großen Objekt Heap).</span><span class="sxs-lookup"><span data-stu-id="80a0c-414">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` bytes (it attempts to allocate `totalSize` bytes for the small object heap and `totalSize` bytes for the large object heap).</span></span>  
  
 <span data-ttu-id="80a0c-415">`totalSize` müssen groß genug sein, um alle Speicher Belegungen zu verarbeiten, die im kritischen Pfad auftreten.</span><span class="sxs-lookup"><span data-stu-id="80a0c-415">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="80a0c-416">Dies schließt Zuordnungen von der APP sowie Zuordnungen ein, die die Laufzeit im Auftrag der APP vornimmt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-416">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="80a0c-417">Aufrufe der <xref:System.GC.TryStartNoGCRegion%2A>-Methode können nicht geschachtelt werden, und Sie sollten nur die <xref:System.GC.EndNoGCRegion%2A>-Methode aufrufen, wenn sich die Laufzeit derzeit im Latenz Modus ohne GC-Region befindet.</span><span class="sxs-lookup"><span data-stu-id="80a0c-417">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="80a0c-418">Anders ausgedrückt: Sie sollten <xref:System.GC.TryStartNoGCRegion%2A> nicht mehrmals aufrufen (nach dem ersten Methodenaufruf können nachfolgende Aufrufe nicht mehr ausgeführt werden), und Sie sollten nicht erwarten, dass Aufrufe von <xref:System.GC.EndNoGCRegion%2A> erfolgreich ausgeführt werden, da der erste Aufruf von <xref:System.GC.TryStartNoGCRegion%2A> erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="80a0c-418">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="80a0c-419">Wenn Sie die <xref:System.GC.EndNoGCRegion%2A>-Methode aufrufen, beenden Sie den Latenz Modus ohne GC-Region.</span><span class="sxs-lookup"><span data-stu-id="80a0c-419">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="80a0c-420"><paramref name="totalSize" /> überschreitet die Größe des kurzlebigen Segments.</span><span class="sxs-lookup"><span data-stu-id="80a0c-420"><paramref name="totalSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="80a0c-421">Der Prozess ist bereits im Latenzmodus ohne GC-Region.</span><span class="sxs-lookup"><span data-stu-id="80a0c-421">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="~/docs/standard/garbage-collection/fundamentals.md"><span data-ttu-id="80a0c-422">Grundlagen der Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="80a0c-422">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="~/docs/standard/garbage-collection/latency.md"><span data-ttu-id="80a0c-423">Latenzmodi</span><span class="sxs-lookup"><span data-stu-id="80a0c-423">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="80a0c-424">Die Arbeitsspeichermenge in Bytes, die ohne Auslösung einer Garbage Collection zugeordnet werden muss.</span><span class="sxs-lookup"><span data-stu-id="80a0c-424">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="80a0c-425">Diese muss kleiner als oder gleich der Größe eines kurzlebigen Segments sein.</span><span class="sxs-lookup"><span data-stu-id="80a0c-425">It must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="80a0c-426">Informationen zur Größe eines kurzlebigen Segments finden Sie im Abschnitt „Kurzlebige Generationen und Segmente“ im Artikel [Grundlagen der Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md).</span><span class="sxs-lookup"><span data-stu-id="80a0c-426">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <param name="disallowFullBlockingGC"><span data-ttu-id="80a0c-427"><see langword="true" />, um eine vollständige blockierende Garbage Collection zu unterdrücken, wenn der Garbage Collector die <paramref name="totalSize" />-Bytes nicht zuordnen kann, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="80a0c-427"><see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <paramref name="totalSize" /> bytes; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="80a0c-428">Versucht, Garbage Collection während der Ausführung eines kritischen Pfads zu unterbinden, wenn eine bestimmte Arbeitsspeichermenge verfügbar ist, und steuert die Ausführung einer vollständigen blockierenden Garbage Collection durch den Garbage Collector, wenn nicht genügend Arbeitsspeicher verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-428">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span></span></summary>
        <returns><span data-ttu-id="80a0c-429"><see langword="true" />, wenn die Laufzeit die erforderliche Arbeitsspeichermenge übergeben kann, und der Garbage Collector in den Latenzmodus ohne GC-Region wechseln kann; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="80a0c-429"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-430">Die <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29>-Methode versucht, die Garbage Collector in den Latenz Modus ohne GC-Region zu platzieren, was Garbage Collection nicht zulässt, während eine APP einen kritischen Code Bereich ausführt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-430">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="80a0c-431">Wenn die Laufzeit die angeforderte Menge an Arbeitsspeicher nicht anfänglich zuordnen kann und das `disallowFullBlockingGC` Argument `false`ist, führt der Garbage Collector eine vollständige Blockierung aus Garbage Collection in einem Versuch, zusätzlichen Arbeitsspeicher freizugeben. Andernfalls schlägt die Zuordnung fehl, und die Methode gibt `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="80a0c-431">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="80a0c-432">Der Garbage Collector wechselt in den Latenz Modus ohne GC-Region, wenn er die erforderliche Arbeitsspeicher Menge zuordnen kann, in diesem Fall tatsächlich 2 \* `totalSize` (er versucht, `totalSize` für den kleinen Objekt Heap zuzuordnen, und `totalSize` für den großen Objekt Heap).</span><span class="sxs-lookup"><span data-stu-id="80a0c-432">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` (it attempts to allocate `totalSize` for the small object heap and `totalSize` for the large object heap).</span></span>  
  
 <span data-ttu-id="80a0c-433">`totalSize` müssen groß genug sein, um alle Speicher Belegungen zu verarbeiten, die im kritischen Pfad auftreten.</span><span class="sxs-lookup"><span data-stu-id="80a0c-433">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="80a0c-434">Dies schließt Zuordnungen von der APP sowie Zuordnungen ein, die die Laufzeit im Auftrag der APP vornimmt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-434">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="80a0c-435">Wenn Sie `disallowFullBlockingGC` auf `true` festlegen, um eine vollständige Blockierung zu verhindern Garbage Collection wenn nicht genügend Arbeitsspeicher verfügbar ist, ist in Lasten Ausgleichs Szenarien besonders nützlich: ein System kann diese Methode anrufen und sich selbst als bereit für die Annahme von Anforderungen melden, wenn `true`zurückgegeben wird, und der Load Balancer muss Anforderungen an andere Systeme weiterleiten, wenn er `false`zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-435">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="80a0c-436">Sie kann dann eine vollständige blockierende Garbage Collection ausführen, wenn keine Anforderungen durch Aufrufen der <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>-Methode verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-436">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="80a0c-437">Aufrufe der <xref:System.GC.TryStartNoGCRegion%2A>-Methode können nicht geschachtelt werden, und Sie sollten nur die <xref:System.GC.EndNoGCRegion%2A>-Methode aufrufen, wenn sich die Laufzeit derzeit im Latenz Modus ohne GC-Region befindet.</span><span class="sxs-lookup"><span data-stu-id="80a0c-437">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="80a0c-438">Anders ausgedrückt: Sie sollten <xref:System.GC.TryStartNoGCRegion%2A> nicht mehrmals aufrufen (nach dem ersten Methodenaufruf können nachfolgende Aufrufe nicht mehr ausgeführt werden), und Sie sollten nicht erwarten, dass Aufrufe von <xref:System.GC.EndNoGCRegion%2A> erfolgreich ausgeführt werden, da der erste Aufruf von <xref:System.GC.TryStartNoGCRegion%2A> erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="80a0c-438">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="80a0c-439">Wenn Sie die <xref:System.GC.EndNoGCRegion%2A>-Methode aufrufen, beenden Sie den Latenz Modus ohne GC-Region.</span><span class="sxs-lookup"><span data-stu-id="80a0c-439">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="80a0c-440"><paramref name="totalSize" /> überschreitet die Größe des kurzlebigen Segments.</span><span class="sxs-lookup"><span data-stu-id="80a0c-440"><paramref name="totalSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="80a0c-441">Der Prozess ist bereits im Latenzmodus ohne GC-Region.</span><span class="sxs-lookup"><span data-stu-id="80a0c-441">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="~/docs/standard/garbage-collection/fundamentals.md"><span data-ttu-id="80a0c-442">Grundlagen der Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="80a0c-442">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="~/docs/standard/garbage-collection/latency.md"><span data-ttu-id="80a0c-443">Latenzmodi</span><span class="sxs-lookup"><span data-stu-id="80a0c-443">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="lohSize" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="80a0c-444">Die Arbeitsspeichermenge in Bytes, die ohne Auslösung einer Garbage Collection zugeordnet werden muss.</span><span class="sxs-lookup"><span data-stu-id="80a0c-444">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="80a0c-445"><paramref name="totalSize" /> -<paramref name="lohSize" /> muss kleiner als oder gleich der Größe eines kurzlebigen Segments sein.</span><span class="sxs-lookup"><span data-stu-id="80a0c-445"><paramref name="totalSize" /> -<paramref name="lohSize" /> must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="80a0c-446">Informationen zur Größe eines kurzlebigen Segments finden Sie im Abschnitt „Kurzlebige Generationen und Segmente“ im Artikel [Grundlagen der Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md).</span><span class="sxs-lookup"><span data-stu-id="80a0c-446">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <param name="lohSize"><span data-ttu-id="80a0c-447">Die Anzahl der Bytes in <paramref name="totalSize" />, die für Zuordnung für großen Objektheap zu verwenden ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-447">The number of bytes in <paramref name="totalSize" /> to use for large object heap (LOH) allocations.</span></span></param>
        <summary><span data-ttu-id="80a0c-448">Versucht, Garbage Collection während der Ausführung eines kritischen Pfads zu unterbinden, wenn eine bestimmte Arbeitsspeichermenge für den großen und den kleinen Objektheap verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-448">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.</span></span></summary>
        <returns><span data-ttu-id="80a0c-449"><see langword="true" />, wenn die Laufzeit die erforderliche Arbeitsspeichermenge übergeben kann, und der Garbage Collector in den Latenzmodus ohne GC-Region wechseln kann; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="80a0c-449"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-450">Die <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29>-Methode versucht, die Garbage Collector in den Latenz Modus ohne GC-Region zu platzieren, was Garbage Collection nicht zulässt, während eine APP einen kritischen Code Bereich ausführt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-450">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="80a0c-451">Wenn die Laufzeit die angeforderte Arbeitsspeicher Menge nicht anfänglich zuordnen kann, führt die Garbage Collector eine vollständige blockierende Garbage Collection aus, um zusätzlichen Arbeitsspeicher freizugeben.</span><span class="sxs-lookup"><span data-stu-id="80a0c-451">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="80a0c-452">Die Garbage Collector wechselt in den Latenz Modus ohne GC-Region, wenn Sie `lohSize` für die Loh-und `totalSize`- - `lohSize` für den Small Object Heap (SoH) zuordnen kann.</span><span class="sxs-lookup"><span data-stu-id="80a0c-452">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` - `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="80a0c-453">`lohSize` müssen groß genug sein, um alle Speicher Belegungen zu verarbeiten, die im kritischen Pfad für den Loh auftreten, und `totalSize` - `lohSize` müssen groß genug sein, um alle Speicher Belegungen zu verarbeiten, die im kritischen Pfad für den SoH auftreten.</span><span class="sxs-lookup"><span data-stu-id="80a0c-453">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` - `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="80a0c-454">Dies schließt Zuordnungen von der APP sowie Zuordnungen ein, die die Laufzeit im Auftrag der APP vornimmt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-454">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="80a0c-455">Aufrufe der <xref:System.GC.TryStartNoGCRegion%2A>-Methode können nicht geschachtelt werden, und Sie sollten nur die <xref:System.GC.EndNoGCRegion%2A>-Methode aufrufen, wenn sich die Laufzeit derzeit im Latenz Modus ohne GC-Region befindet.</span><span class="sxs-lookup"><span data-stu-id="80a0c-455">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="80a0c-456">Anders ausgedrückt: Sie sollten <xref:System.GC.TryStartNoGCRegion%2A> nicht mehrmals aufrufen (nach dem ersten Methodenaufruf können nachfolgende Aufrufe nicht mehr ausgeführt werden), und Sie sollten nicht erwarten, dass Aufrufe von <xref:System.GC.EndNoGCRegion%2A> erfolgreich ausgeführt werden, da der erste Aufruf von <xref:System.GC.TryStartNoGCRegion%2A> erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="80a0c-456">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="80a0c-457">Wenn Sie die <xref:System.GC.EndNoGCRegion%2A>-Methode aufrufen, beenden Sie den Latenz Modus ohne GC-Region.</span><span class="sxs-lookup"><span data-stu-id="80a0c-457">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="80a0c-458"><paramref name="totalSize" /> - <paramref name="lohSize" /> überschreitet die Größe des kurzlebigen Segments.</span><span class="sxs-lookup"><span data-stu-id="80a0c-458"><paramref name="totalSize" /> - <paramref name="lohSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="80a0c-459">Der Prozess ist bereits im Latenzmodus ohne GC-Region.</span><span class="sxs-lookup"><span data-stu-id="80a0c-459">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="~/docs/standard/garbage-collection/fundamentals.md"><span data-ttu-id="80a0c-460">Grundlagen der Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="80a0c-460">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="~/docs/standard/garbage-collection/latency.md"><span data-ttu-id="80a0c-461">Latenzmodi</span><span class="sxs-lookup"><span data-stu-id="80a0c-461">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="lohSize" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="80a0c-462">Die Arbeitsspeichermenge in Bytes, die ohne Auslösung einer Garbage Collection zugeordnet werden muss.</span><span class="sxs-lookup"><span data-stu-id="80a0c-462">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="80a0c-463"><paramref name="totalSize" /> -<paramref name="lohSize" /> muss kleiner als oder gleich der Größe eines kurzlebigen Segments sein.</span><span class="sxs-lookup"><span data-stu-id="80a0c-463"><paramref name="totalSize" /> -<paramref name="lohSize" /> must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="80a0c-464">Informationen zur Größe eines kurzlebigen Segments finden Sie im Abschnitt „Kurzlebige Generationen und Segmente“ im Artikel [Grundlagen der Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md).</span><span class="sxs-lookup"><span data-stu-id="80a0c-464">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <param name="lohSize"><span data-ttu-id="80a0c-465">Die Anzahl der Bytes in <paramref name="totalSize" />, die für Zuordnung für großen Objektheap zu verwenden ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-465">The number of bytes in <paramref name="totalSize" /> to use for large object heap (LOH) allocations.</span></span></param>
        <param name="disallowFullBlockingGC"><span data-ttu-id="80a0c-466"><see langword="true" />, um eine vollständige blockierende Garbage Collection zu unterdrücken, wenn der Garbage Collector den für den kleinen und den großen Objektheap angegebenen Arbeitsspeicher nicht zuordnen kann, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="80a0c-466"><see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="80a0c-467">Versucht, Garbage Collection während der Ausführung eines kritischen Pfads zu unterbinden, wenn eine bestimmte Arbeitsspeichermenge für den großen und den kleinen Objektheap verfügbar ist, und steuert die Ausführung einer vollständigen blockierenden Garbage Collection durch den Garbage Collector, wenn nicht genügend Arbeitsspeicher verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-467">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span></span></summary>
        <returns><span data-ttu-id="80a0c-468"><see langword="true" />, wenn die Laufzeit die erforderliche Arbeitsspeichermenge übergeben kann, und der Garbage Collector in den Latenzmodus ohne GC-Region wechseln kann; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="80a0c-468"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-469">Die <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29>-Methode versucht, die Garbage Collector in den Latenz Modus ohne GC-Region zu platzieren, was Garbage Collection nicht zulässt, während eine APP einen kritischen Code Bereich ausführt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-469">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="80a0c-470">Wenn die Laufzeit die angeforderte Menge an Arbeitsspeicher nicht anfänglich zuordnen kann und das `disallowFullBlockingGC` Argument `false`ist, führt der Garbage Collector eine vollständige Blockierung aus Garbage Collection in einem Versuch, zusätzlichen Arbeitsspeicher freizugeben. Andernfalls schlägt die Zuordnung fehl, und die Methode gibt `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="80a0c-470">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="80a0c-471">Die Garbage Collector wechselt in den Latenz Modus ohne GC-Region, wenn Sie `lohSize` für die Loh-und `totalSize`- - `lohSize` für den Small Object Heap (SoH) zuordnen kann.</span><span class="sxs-lookup"><span data-stu-id="80a0c-471">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` - `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="80a0c-472">`lohSize` müssen groß genug sein, um alle Speicher Belegungen zu verarbeiten, die im kritischen Pfad für den Loh auftreten, und `totalSize` - `lohSize` müssen groß genug sein, um alle Speicher Belegungen zu verarbeiten, die im kritischen Pfad für den SoH auftreten.</span><span class="sxs-lookup"><span data-stu-id="80a0c-472">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` - `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="80a0c-473">Dies schließt Zuordnungen von der APP sowie Zuordnungen ein, die die Laufzeit im Auftrag der APP vornimmt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-473">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="80a0c-474">Wenn Sie `disallowFullBlockingGC` auf `true` festlegen, um eine vollständige Blockierung zu verhindern Garbage Collection wenn nicht genügend Arbeitsspeicher verfügbar ist, ist in Lasten Ausgleichs Szenarien besonders nützlich: ein System kann diese Methode anrufen und sich selbst als bereit für die Annahme von Anforderungen melden, wenn `true`zurückgegeben wird, und der Load Balancer muss Anforderungen an andere Systeme weiterleiten, wenn er `false`zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="80a0c-474">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="80a0c-475">Sie kann dann eine vollständige blockierende Garbage Collection ausführen, wenn keine Anforderungen durch Aufrufen der <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>-Methode verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-475">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="80a0c-476">Aufrufe der <xref:System.GC.TryStartNoGCRegion%2A>-Methode können nicht geschachtelt werden, und Sie sollten nur die <xref:System.GC.EndNoGCRegion%2A>-Methode aufrufen, wenn sich die Laufzeit derzeit im Latenz Modus ohne GC-Region befindet.</span><span class="sxs-lookup"><span data-stu-id="80a0c-476">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="80a0c-477">Anders ausgedrückt: Sie sollten <xref:System.GC.TryStartNoGCRegion%2A> nicht mehrmals aufrufen (nach dem ersten Methodenaufruf können nachfolgende Aufrufe nicht mehr ausgeführt werden), und Sie sollten nicht erwarten, dass Aufrufe von <xref:System.GC.EndNoGCRegion%2A> erfolgreich ausgeführt werden, da der erste Aufruf von <xref:System.GC.TryStartNoGCRegion%2A> erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="80a0c-477">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="80a0c-478">Wenn Sie die <xref:System.GC.EndNoGCRegion%2A>-Methode aufrufen, beenden Sie den Latenz Modus ohne GC-Region.</span><span class="sxs-lookup"><span data-stu-id="80a0c-478">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="80a0c-479"><paramref name="totalSize" /> - <paramref name="lohSize" /> überschreitet die Größe des kurzlebigen Segments.</span><span class="sxs-lookup"><span data-stu-id="80a0c-479"><paramref name="totalSize" /> - <paramref name="lohSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="80a0c-480">Der Prozess ist bereits im Latenzmodus ohne GC-Region.</span><span class="sxs-lookup"><span data-stu-id="80a0c-480">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="~/docs/standard/garbage-collection/fundamentals.md"><span data-ttu-id="80a0c-481">Grundlagen der Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="80a0c-481">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="~/docs/standard/garbage-collection/latency.md"><span data-ttu-id="80a0c-482">Latenzmodi</span><span class="sxs-lookup"><span data-stu-id="80a0c-482">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="80a0c-483">Gibt den Status einer registrierten Benachrichtigung zurück, um zu bestimmen, ob eine vollständige blockierende Garbage Collection durch die Common Language Runtime bevorsteht.</span><span class="sxs-lookup"><span data-stu-id="80a0c-483">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="80a0c-484">Gibt den Status einer registrierten Benachrichtigung zurück, um zu bestimmen, ob eine vollständige blockierende Garbage Collection durch die Common Language Runtime bevorsteht.</span><span class="sxs-lookup"><span data-stu-id="80a0c-484">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span></span></summary>
        <returns><span data-ttu-id="80a0c-485">Der Status der registrierten Garbage Collection-Benachrichtigung.</span><span class="sxs-lookup"><span data-stu-id="80a0c-485">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-486">Verwenden Sie die <xref:System.GCNotificationStatus> Enumeration, die von dieser Methode zurückgegeben wird, um den Status der aktuellen Garbage Collection Benachrichtigung zu bestimmen, die mit der <xref:System.GC.RegisterForFullGCNotification%2A>-Methode registriert wurde.</span><span class="sxs-lookup"><span data-stu-id="80a0c-486">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="80a0c-487">Sie können auch die <xref:System.GC.WaitForFullGCComplete%2A>-Methode verwenden, um zu bestimmen, ob die vollständige Garbage Collection abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="80a0c-487">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="80a0c-488">Wenn die Enumeration <xref:System.GCNotificationStatus.Succeeded>zurückgibt, können Sie Aufgaben wie das verhindern, dass zusätzliche Objekte zugewiesen werden, und eine Auflistung selbst mit der <xref:System.GC.Collect%2A>-Methode ausführen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-488">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="80a0c-489">Beachten Sie, dass die Benachrichtigung nicht gewährleistet, dass eine vollständige Garbage Collection erfolgt. nur diese Bedingungen haben den Schwellenwert erreicht, der für eine vollständige Garbage Collection vorteilhaft ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-489">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="80a0c-490">Diese Methode wartet unbegrenzt, bis eine Garbage Collection Benachrichtigung abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-490">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="80a0c-491">Wenn Sie einen Timeout Zeitraum angeben möchten, damit die Methode zurückgegeben wird, wenn die Benachrichtigung nicht abgerufen werden kann, verwenden Sie die <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType>-Methoden Überladung.</span><span class="sxs-lookup"><span data-stu-id="80a0c-491">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="80a0c-492">Wenn Sie diese Methode ohne Angabe eines Timeouts aufzurufen, können Sie die <xref:System.GC.CancelFullGCNotification%2A>-Methode aufzurufen, wenn Sie länger als bevorzugt warten.</span><span class="sxs-lookup"><span data-stu-id="80a0c-492">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="80a0c-493">Befolgen Sie diese Methode, wenn Sie die <xref:System.GC.WaitForFullGCComplete%2A>-Methode verwenden, um sicherzustellen, dass Sie eine vollständige Garbage Collection haben.</span><span class="sxs-lookup"><span data-stu-id="80a0c-493">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="80a0c-494">Durch das eigenständige Aufrufen dieser Methode werden unbeendete Ergebnisse verursacht.</span><span class="sxs-lookup"><span data-stu-id="80a0c-494">Calling this method alone causes indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="80a0c-495">Im folgenden Beispiel wird gezeigt, wie mit dieser Methode bestimmt wird, ob eine vollständige blockierende Garbage Collection fast erreicht wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-495">The following example shows how to use this method to determine whether a full, blocking garbage collection is approaching.</span></span> <span data-ttu-id="80a0c-496">Wenn der Status der Benachrichtigung <xref:System.GCNotificationStatus.Succeeded>ist, wird die Benutzer Methode `OnFullGCApproachNotify` aufgerufen, um Aktionen als Reaktion auf die nähernde Auflistung auszuführen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-496">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCApproachNotify` is called to perform actions in response to the approaching collection.</span></span> <span data-ttu-id="80a0c-497">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für das Thema zur [Garbage Collection-Benachrichtigungen](~/docs/standard/garbage-collection/notifications.md) bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-497">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="80a0c-498">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="80a0c-498">for full trust for the immediate caller.</span></span> <span data-ttu-id="80a0c-499">Dieser Member kann nicht von Code verwendet werden, der nur teilweise vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-499">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="80a0c-500">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="80a0c-500">requires full trust for the immediate caller.</span></span> <span data-ttu-id="80a0c-501">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-501">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/garbage-collection/notifications.md"><span data-ttu-id="80a0c-502">Garbage Collection-Benachrichtigungen</span><span class="sxs-lookup"><span data-stu-id="80a0c-502">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="80a0c-503">Die Dauer der Wartezeit, bevor ein Benachrichtigungsstatus abgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="80a0c-503">The length of time to wait before a notification status can be obtained.</span></span> <span data-ttu-id="80a0c-504">Geben Sie -1 an, um unbegrenzt zu warten.</span><span class="sxs-lookup"><span data-stu-id="80a0c-504">Specify -1 to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="80a0c-505">Gibt innerhalb einer angegebenen Timeoutspanne den Status einer registrierten Benachrichtigung zurück, um zu bestimmen, ob eine vollständige blockierende Garbage Collection durch die Common Language Runtime bevorsteht.</span><span class="sxs-lookup"><span data-stu-id="80a0c-505">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span></span></summary>
        <returns><span data-ttu-id="80a0c-506">Der Status der registrierten Garbage Collection-Benachrichtigung.</span><span class="sxs-lookup"><span data-stu-id="80a0c-506">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-507">Verwenden Sie die <xref:System.GCNotificationStatus> Enumeration, die von dieser Methode zurückgegeben wird, um den Status der aktuellen Garbage Collection Benachrichtigung zu bestimmen, die mit der <xref:System.GC.RegisterForFullGCNotification%2A>-Methode registriert wurde.</span><span class="sxs-lookup"><span data-stu-id="80a0c-507">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="80a0c-508">Sie können auch die <xref:System.GC.WaitForFullGCComplete%2A>-Methode verwenden, um zu bestimmen, ob die vollständige Garbage Collection abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="80a0c-508">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="80a0c-509">Beachten Sie, dass diese Methode sofort zurückgegeben wird, wenn ein Garbage Collection Benachrichtigungs Status abgerufen wird, unabhängig von dem durch `millisecondsTimeout`angegebenen Wert.</span><span class="sxs-lookup"><span data-stu-id="80a0c-509">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="80a0c-510">Wenn ein Garbage Collection Benachrichtigungs Status vor `millisecondsTimeout` Timeouts nicht abgerufen wird, gibt diese Methode <xref:System.GCNotificationStatus.NotApplicable>zurück.</span><span class="sxs-lookup"><span data-stu-id="80a0c-510">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="80a0c-511">Wenn die Enumeration <xref:System.GCNotificationStatus.Succeeded>zurückgibt, können Sie Aufgaben wie das verhindern, dass zusätzliche Objekte zugewiesen werden, und eine Auflistung selbst mit der <xref:System.GC.Collect%2A>-Methode ausführen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-511">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="80a0c-512">Beachten Sie, dass die Benachrichtigung nicht gewährleistet, dass eine vollständige Garbage Collection erfolgt. nur diese Bedingungen haben den Schwellenwert erreicht, der für eine vollständige Garbage Collection vorteilhaft ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-512">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="80a0c-513">Sie können die <xref:System.GC.CancelFullGCNotification%2A>-Methode aufzurufen, wenn Sie nicht warten können, bis der Timeout Zeitraum abläuft.</span><span class="sxs-lookup"><span data-stu-id="80a0c-513">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="80a0c-514">Befolgen Sie diese Methode, wenn Sie die <xref:System.GC.WaitForFullGCComplete%2A>-Methode verwenden, um sicherzustellen, dass Sie eine vollständige Garbage Collection haben.</span><span class="sxs-lookup"><span data-stu-id="80a0c-514">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="80a0c-515">Durch das eigenständige Aufrufen dieser Methode werden unbeendete Ergebnisse verursacht.</span><span class="sxs-lookup"><span data-stu-id="80a0c-515">Calling this method alone causes indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="80a0c-516"><paramref name="millisecondsTimeout" /> muss entweder nicht negativ bzw. kleiner oder gleich <see cref="F:System.Int32.MaxValue" /> oder -1 sein.</span><span class="sxs-lookup"><span data-stu-id="80a0c-516"><paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="80a0c-517">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="80a0c-517">for full trust for the immediate caller.</span></span> <span data-ttu-id="80a0c-518">Dieser Member kann nicht von Code verwendet werden, der nur teilweise vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-518">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="80a0c-519">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="80a0c-519">requires full trust for the immediate caller.</span></span> <span data-ttu-id="80a0c-520">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-520">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/garbage-collection/notifications.md"><span data-ttu-id="80a0c-521">Garbage Collection-Benachrichtigungen</span><span class="sxs-lookup"><span data-stu-id="80a0c-521">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="80a0c-522">Gibt den Status einer registrierten Benachrichtigung zurück, um zu bestimmen, ob eine vollständige blockierende Garbage Collection durch die Common Language Runtime abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="80a0c-522">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="80a0c-523">Gibt den Status einer registrierten Benachrichtigung zurück, um zu bestimmen, ob eine vollständige blockierende Garbage Collection durch die Common Language Runtime abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="80a0c-523">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span></span></summary>
        <returns><span data-ttu-id="80a0c-524">Der Status der registrierten Garbage Collection-Benachrichtigung.</span><span class="sxs-lookup"><span data-stu-id="80a0c-524">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-525">Verwenden Sie die <xref:System.GCNotificationStatus> Enumeration, die von dieser Methode zurückgegeben wird, um den Status der aktuellen Garbage Collection Benachrichtigung zu bestimmen, die mit der <xref:System.GC.RegisterForFullGCNotification%2A>-Methode registriert wurde.</span><span class="sxs-lookup"><span data-stu-id="80a0c-525">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="80a0c-526">Sie können auch die <xref:System.GC.WaitForFullGCApproach%2A>-Methode verwenden, um zu bestimmen, ob eine vollständige Garbage Collection bevorstehend ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-526">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="80a0c-527">Wenn die Enumeration <xref:System.GCNotificationStatus.Succeeded>zurückgibt, können Sie Aufgaben wie das Fortsetzen der Arbeit und das Abrufen einer Sammlungs Anzahl mit der <xref:System.GC.CollectionCount%2A>-Eigenschaft ausführen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-527">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="80a0c-528">Diese Methode wartet unbegrenzt, bis eine Garbage Collection Benachrichtigung abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-528">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="80a0c-529">Wenn Sie einen Timeout Zeitraum angeben möchten, damit die Methode zurückgegeben wird, wenn die Benachrichtigung nicht abgerufen werden kann, verwenden Sie die <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType>-Methoden Überladung.</span><span class="sxs-lookup"><span data-stu-id="80a0c-529">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="80a0c-530">Wenn Sie diese Methode ohne Angabe eines Timeouts aufzurufen, können Sie die <xref:System.GC.CancelFullGCNotification%2A>-Methode aufzurufen, wenn Sie länger als bevorzugt warten.</span><span class="sxs-lookup"><span data-stu-id="80a0c-530">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="80a0c-531">Diesem Methoden Befehl sollte ein aufzurufende <xref:System.GC.WaitForFullGCApproach%2A>-Methode vorangestellt sein, um sicherzustellen, dass Sie über eine vollständige Garbage Collection verfügen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-531">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="80a0c-532">Wenn Sie nur diese Methode aufrufen, können unbeendete Ergebnisse erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-532">Calling this method alone can produce indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="80a0c-533">Im folgenden Beispiel wird gezeigt, wie diese Methode verwendet wird, um zu bestimmen, ob eine vollständige Garbage Collection abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="80a0c-533">The following example shows how to use this method to determine whether a full garbage collection has completed.</span></span> <span data-ttu-id="80a0c-534">Wenn der Status der Benachrichtigung <xref:System.GCNotificationStatus.Succeeded>ist, wird die Benutzer Methode `OnFullGCCompletedNotify` aufgerufen, um Aktionen als Reaktion auf die abgeschlossene Auflistung auszuführen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-534">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCCompletedNotify` is called to perform actions in response to the completed collection.</span></span> <span data-ttu-id="80a0c-535">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für das Thema zur [Garbage Collection-Benachrichtigungen](~/docs/standard/garbage-collection/notifications.md) bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-535">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="80a0c-536">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="80a0c-536">for full trust for the immediate caller.</span></span> <span data-ttu-id="80a0c-537">Dieser Member kann nicht von Code verwendet werden, der nur teilweise vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-537">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="80a0c-538">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="80a0c-538">requires full trust for the immediate caller.</span></span> <span data-ttu-id="80a0c-539">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-539">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/garbage-collection/notifications.md"><span data-ttu-id="80a0c-540">Garbage Collection-Benachrichtigungen</span><span class="sxs-lookup"><span data-stu-id="80a0c-540">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="80a0c-541">Die Dauer der Wartezeit, bevor ein Benachrichtigungsstatus abgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="80a0c-541">The length of time to wait before a notification status can be obtained.</span></span> <span data-ttu-id="80a0c-542">Geben Sie -1 an, um unbegrenzt zu warten.</span><span class="sxs-lookup"><span data-stu-id="80a0c-542">Specify -1 to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="80a0c-543">Gibt innerhalb einer angegebenen Timeoutspanne den Status einer registrierten Benachrichtigung zurück, um zu bestimmen, ob eine vollständige blockierende Garbage Collection durch die Common Language Runtime abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="80a0c-543">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</span></span></summary>
        <returns><span data-ttu-id="80a0c-544">Der Status der registrierten Garbage Collection-Benachrichtigung.</span><span class="sxs-lookup"><span data-stu-id="80a0c-544">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-545">Verwenden Sie die <xref:System.GCNotificationStatus> Enumeration, die von dieser Methode zurückgegeben wird, um den Status der aktuellen Garbage Collection Benachrichtigung zu bestimmen, die mit der <xref:System.GC.RegisterForFullGCNotification%2A>-Methode registriert wurde.</span><span class="sxs-lookup"><span data-stu-id="80a0c-545">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="80a0c-546">Sie können auch die <xref:System.GC.WaitForFullGCApproach%2A>-Methode verwenden, um zu bestimmen, ob eine vollständige Garbage Collection bevorstehend ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-546">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="80a0c-547">Beachten Sie, dass diese Methode sofort zurückgegeben wird, wenn ein Garbage Collection Benachrichtigungs Status abgerufen wird, unabhängig von dem durch `millisecondsTimeout`angegebenen Wert.</span><span class="sxs-lookup"><span data-stu-id="80a0c-547">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="80a0c-548">Wenn ein Garbage Collection Benachrichtigungs Status vor `millisecondsTimeout` Timeouts nicht abgerufen wird, gibt diese Methode <xref:System.GCNotificationStatus.NotApplicable>zurück.</span><span class="sxs-lookup"><span data-stu-id="80a0c-548">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="80a0c-549">Wenn die Enumeration <xref:System.GCNotificationStatus.Succeeded>zurückgibt, können Sie Aufgaben wie das Fortsetzen der Arbeit und das Abrufen einer Sammlungs Anzahl mit der <xref:System.GC.CollectionCount%2A>-Eigenschaft ausführen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-549">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="80a0c-550">Sie können die <xref:System.GC.CancelFullGCNotification%2A>-Methode aufzurufen, wenn Sie nicht warten können, bis der Timeout Zeitraum abläuft.</span><span class="sxs-lookup"><span data-stu-id="80a0c-550">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="80a0c-551">Diesem Methoden Befehl sollte ein aufzurufende <xref:System.GC.WaitForFullGCApproach%2A>-Methode vorangestellt sein, um sicherzustellen, dass Sie über eine vollständige Garbage Collection verfügen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-551">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="80a0c-552">Wenn Sie nur diese Methode aufrufen, können unbeendete Ergebnisse erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-552">Calling this method alone can produce indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="80a0c-553"><paramref name="millisecondsTimeout" /> muss entweder nicht negativ bzw. kleiner oder gleich <see cref="F:System.Int32.MaxValue" /> oder -1 sein.</span><span class="sxs-lookup"><span data-stu-id="80a0c-553"><paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="80a0c-554">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="80a0c-554">for full trust for the immediate caller.</span></span> <span data-ttu-id="80a0c-555">Dieser Member kann nicht von Code verwendet werden, der nur teilweise vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-555">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="80a0c-556">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="80a0c-556">requires full trust for the immediate caller.</span></span> <span data-ttu-id="80a0c-557">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-557">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/garbage-collection/notifications.md"><span data-ttu-id="80a0c-558">Garbage Collection-Benachrichtigungen</span><span class="sxs-lookup"><span data-stu-id="80a0c-558">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="80a0c-559">Hält den aktuellen Thread so lange an, bis der Thread, der die Finalizerwarteschlange verarbeitet, diese Warteschlange geleert hat.</span><span class="sxs-lookup"><span data-stu-id="80a0c-559">Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="80a0c-560">Wenn die Garbage Collector Objekte findet, die freigegeben werden können, überprüft Sie jedes Objekt, um die finalisierungsanforderungen des Objekts zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="80a0c-560">When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements.</span></span> <span data-ttu-id="80a0c-561">Wenn ein Objekt einen Finalizer implementiert und die Beendigung durch Aufrufen von <xref:System.GC.SuppressFinalize%2A>nicht deaktiviert ist, wird das Objekt in einer Liste von-Objekten abgelegt, die als bereit für den Abschluss markiert sind.</span><span class="sxs-lookup"><span data-stu-id="80a0c-561">If an object implements a finalizer and has not disabled finalization by calling <xref:System.GC.SuppressFinalize%2A>, the object is placed in a list of objects that are marked as ready for finalization.</span></span> <span data-ttu-id="80a0c-562">Der Garbage Collector Ruft die <xref:System.Object.Finalize%2A> Methoden für die Objekte in dieser Liste auf und entfernt die Einträge aus der Liste.</span><span class="sxs-lookup"><span data-stu-id="80a0c-562">The garbage collector calls the <xref:System.Object.Finalize%2A> methods for the objects in this list and removes the entries from the list.</span></span> <span data-ttu-id="80a0c-563">Diese Methode wird blockiert, bis alle Finalizer vollständig ausgeführt wurden.</span><span class="sxs-lookup"><span data-stu-id="80a0c-563">This method blocks until all finalizers have run to completion.</span></span>  
  
 <span data-ttu-id="80a0c-564">Der Thread, für den Finalizer ausgeführt werden, ist nicht angegeben, daher gibt es keine Garantie dafür, dass diese Methode beendet wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-564">The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate.</span></span> <span data-ttu-id="80a0c-565">Dieser Thread kann jedoch von einem anderen Thread unterbrochen werden, während die <xref:System.GC.WaitForPendingFinalizers%2A> Methode ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="80a0c-565">However, this thread can be interrupted by another thread while the <xref:System.GC.WaitForPendingFinalizers%2A> method is in progress.</span></span> <span data-ttu-id="80a0c-566">Sie können z. b. einen anderen Thread starten, der einen bestimmten Zeitraum wartet, und diesen Thread dann unterbrechen, wenn dieser Thread weiterhin angehalten ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-566">For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="80a0c-567">Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.GC.WaitForPendingFinalizers%2A>-Methode verwendet wird, um den aktuellen Thread anzuhalten, bis die Finalisierung aller gesammelten Objekte abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="80a0c-567">The following example demonstrates how to use the <xref:System.GC.WaitForPendingFinalizers%2A> method to suspend the current thread until finalization of all the collected objects is complete.</span></span>  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
