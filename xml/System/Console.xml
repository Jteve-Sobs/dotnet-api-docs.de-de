<Type Name="Console" FullName="System.Console">
  <Metadata><Meta Name="ms.openlocfilehash" Value="51b39a0783cb082b242d7cb352aefbc7c27a5a82" /><Meta Name="ms.sourcegitcommit" Value="f11e0152a1dd5d85dbd684f07123f1829eed3f3a" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="01/17/2020" /><Meta Name="ms.locfileid" Value="76165082" /></Metadata><TypeSignature Language="C#" Value="public static class Console" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Console extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Console" />
  <TypeSignature Language="VB.NET" Value="Public Class Console" />
  <TypeSignature Language="C++ CLI" Value="public ref class Console abstract sealed" />
  <TypeSignature Language="F#" Value="type Console = class" />
  <AssemblyInfo>
    <AssemblyName>System.Console</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt die Standardstreams für Eingabe, Ausgabe und Fehler bei Konsolenanwendungen dar. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Konsole handelt es sich um ein Betriebssystemfenster, in dem Benutzer mit dem Betriebssystem oder einer textbasierten Konsolenanwendung interagieren, indem Texteingaben über die Computertastatur eingegeben werden und die Textausgabe aus dem Computerterminal gelesen wird. Beispielsweise wird im Windows-Betriebssystem die-Konsole als Eingabe Aufforderungs Fenster bezeichnet und akzeptiert MS-DOS-Befehle. Die <xref:System.Console>-Klasse bietet grundlegende Unterstützung für Anwendungen, die Zeichen aus der Konsole lesen und in diese schreiben.  
  
 Weitere Informationen zum Entwickeln mit der <xref:System.Console>-Klasse finden Sie in den folgenden Abschnitten:  
  
-   [Konsolen-e/a-Streams](#Streams)  
  
-   [Bildschirm Puffer und Konsolenfenster](#Buffer)  
  
-   [Unicode-Unterstützung für die Konsole](#Unicode)  
  
-   [Allgemeine Vorgänge](#Operations)  
  
-   [Anmerkungen zu .net Core](#Core)  
  
<a name="Streams"></a>   
## <a name="console-io-streams"></a>Konsolen-e/a-Streams  
 Beim Starten einer Konsolenanwendung ordnet das Betriebssystem automatisch drei e/a-Streams der Konsole zu: Standardeingabe Datenstrom, Standardausgabestream und standardfehlerausgabestream. Die Anwendung kann Benutzereingaben aus dem Standardeingabestream lesen. Schreiben von normalen Daten in den Standardausgabestream und schreiben Fehler Daten in den standardfehlerausgabestream. Diese Streams werden Ihrer Anwendung als Werte der Eigenschaften <xref:System.Console.In%2A?displayProperty=nameWithType>, <xref:System.Console.Out%2A?displayProperty=nameWithType>und <xref:System.Console.Error%2A?displayProperty=nameWithType> präsentiert.  
  
 Standardmäßig ist der Wert der <xref:System.Console.In%2A>-Eigenschaft ein <xref:System.IO.TextReader?displayProperty=nameWithType> Objekt, das die Tastatur darstellt, und die Werte der Eigenschaften <xref:System.Console.Out%2A> und <xref:System.Console.Error%2A> sind <xref:System.IO.TextWriter?displayProperty=nameWithType> Objekte, die ein Konsolenfenster darstellen. Sie können diese Eigenschaften jedoch auf Streams festlegen, die das Konsolenfenster oder die Tastatur nicht darstellen. Beispielsweise können Sie diese Eigenschaften auf Streams festlegen, die Dateien darstellen. Rufen Sie die Standardeingabe, Standardausgabe oder Standardfehlerstream umgeleitet, die <xref:System.Console.SetIn%2A?displayProperty=nameWithType>, <xref:System.Console.SetOut%2A?displayProperty=nameWithType>, oder <xref:System.Console.SetError%2A?displayProperty=nameWithType> Methode bzw. E/a-Vorgänge, die diese Streams verwenden, sind synchronisiert. Dies bedeutet, dass mehrere Threads die Datenströme lesen oder in diese schreiben können. Dies bedeutet, dass Methoden, die normalerweise asynchron sind, z. b. <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType>, synchron ausgeführt werden, wenn das Objekt einen Konsolen Datenstrom darstellt.  
  
> [!NOTE]
>  Verwenden Sie die <xref:System.Console>-Klasse nicht, um die Ausgabe in unbeaufsichtigten Anwendungen, z. b. Server Anwendungen, anzuzeigen. Aufrufe von Methoden wie <xref:System.Console.Write%2A?displayProperty=nameWithType> und <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> haben keine Auswirkung in GUI-Anwendungen.  
  
 <xref:System.Console> Klassenmember, die normal funktionieren, wenn der zugrunde liegende Stream an eine Konsole geleitet wird, können eine Ausnahme auslösen, wenn der Stream z. b. an eine Datei umgeleitet wird. Program mieren Sie Ihre Anwendung, um <xref:System.IO.IOException?displayProperty=nameWithType> Ausnahmen abzufangen, wenn Sie einen Standardstream umleiten Sie können auch die Eigenschaften <xref:System.Console.IsOutputRedirected%2A>, <xref:System.Console.IsInputRedirected%2A>und <xref:System.Console.IsErrorRedirected%2A> verwenden, um zu bestimmen, ob ein Standardstream umgeleitet wird, bevor Sie einen Vorgang ausführen, der eine <xref:System.IO.IOException?displayProperty=nameWithType> Ausnahme auslöst.  
  
 Es ist manchmal hilfreich, die Member der Streamobjekte, die durch die Eigenschaften <xref:System.Console.In%2A>, <xref:System.Console.Out%2A>und <xref:System.Console.Error%2A> dargestellt werden, explizit aufzurufen. Standardmäßig liest die <xref:System.Console.ReadLine%2A?displayProperty=nameWithType>-Methode z. b. Eingaben aus dem Standardeingabestream. Ebenso schreibt die <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>-Methode Daten in den Standardausgabestream, und die Daten folgen der standardmäßigen Zeilen Beendigungs Zeichenfolge, bei der es sich um einen Wagen Rücklauf und einen Zeilenvorschub ("\r\n") handelt. Allerdings bietet die <xref:System.Console>-Klasse keine entsprechende Methode zum Schreiben von Daten in den standardfehlerausgabestream oder eine Eigenschaft zum Ändern der Zeilen Beendigungs Zeichenfolge für Daten, die in diesen Stream geschrieben werden.  
  
 Sie können dieses Problem beheben, indem Sie die <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType>-Eigenschaft der <xref:System.Console.Out%2A>-oder <xref:System.Console.Error%2A>-Eigenschaft auf eine andere zeilenabbruch Zeichenfolge festlegen. Beispielsweise legt die folgende C# Anweisung die Zeilen Beendigungs Zeichenfolge für den standardfehlerausgabestream auf zwei Wagen Rücklauf-und Zeilenvorschub Sequenzen fest:  
  
 `Console.Error.NewLine = "\r\n\r\n";`  
  
 Sie können dann wie in der folgenden C# Anweisung explizit die <xref:System.IO.TextWriter.WriteLine%2A>-Methode des fehlerausgabestreamobjekts aufzurufen:  
  
 `Console.Error.WriteLine();`  
  
<a name="Buffer"></a>   
## <a name="screen-buffer-and-console-window"></a>Bildschirm Puffer und Konsolenfenster  
 Zwei eng verwandte Features der-Konsole sind der Bildschirm Puffer und das Konsolenfenster. Text wird tatsächlich aus Streams gelesen oder in diese geschrieben, die sich im Besitz der Konsole befinden, aber anscheinend aus der Konsole gelesen oder in einen Bereich geschrieben werden, der als Bildschirm Puffer bezeichnet wird. Der Bildschirm Puffer ist ein Attribut der-Konsole und wird als rechteckiges Raster von Zeilen und Spalten organisiert, wobei jede Raster Überschneidung oder Zeichen Zelle ein Zeichen enthalten kann. Jedes Zeichen verfügt über eine eigene Vordergrundfarbe, und jede Zeichen Zelle hat eine eigene Hintergrundfarbe.  
  
 Der Bildschirm Puffer wird über einen rechteckigen Bereich angezeigt, der als Konsolenfenster bezeichnet wird. Das Konsolenfenster ist ein weiteres Attribut der Konsole. Dabei handelt es sich nicht um die Konsole, bei der es sich um ein Betriebssystemfenster handelt. Das Konsolenfenster wird in Zeilen und Spalten angeordnet, ist kleiner als oder gleich der Größe des Bildschirm Puffers und kann verschoben werden, um unterschiedliche Bereiche des zugrunde liegenden Bildschirm Puffers anzuzeigen. Wenn der Bildschirm Puffer größer als das Konsolenfenster ist, zeigt die Konsole automatisch Bild Lauf leisten an, damit das Konsolenfenster über dem Bildschirm Pufferbereich neu positioniert werden kann.  
  
 Ein Cursor gibt die Bildschirm Puffer Position an, an der der Text gerade gelesen oder geschrieben wird. Der Cursor kann ausgeblendet oder sichtbar gemacht werden, und seine Höhe kann geändert werden. Wenn der Cursor sichtbar ist, wird die Position des Konsolenfensters automatisch verschoben, sodass sich der Cursor immer in der Ansicht befindet.  
  
 Der Ursprung für Zeichen Zell Koordinaten im Bildschirm Puffer ist die linke obere Ecke, und die Positionen des Cursors und des Konsolenfensters werden relativ zu diesem Ursprung gemessen. Verwenden von Null basierten Indizes zum Angeben von Positionen Das heißt, dass die oberste Zeile als Zeile 0 und die Spalte ganz links als Spalte 0 angegeben wird. Der Höchstwert für die Zeilen-und Spalten Indizes ist <xref:System.Int16.MaxValue?displayProperty=nameWithType>.  
  
<a name="Unicode"></a>   
## <a name="unicode-support-for-the-console"></a>Unicode-Unterstützung für die Konsole  
 Im Allgemeinen liest die-Konsole Eingaben und schreibt die Ausgabe mithilfe der aktuellen Konsolen Codepage, die standardmäßig vom System Gebiets Schema definiert wird. Eine Codepage kann nur eine Teilmenge der verfügbaren Unicode-Zeichen verarbeiten. Wenn Sie also versuchen, Zeichen anzuzeigen, die nicht von einer bestimmten Codepage zugeordnet sind, kann die Konsole nicht alle Zeichen anzeigen oder Sie genau darstellen. Dieses Problem wird anhand des folgenden Beispiels veranschaulicht. Es wird versucht, die Zeichen des kyrillischen Alphabets von u + 0410 bis u + 044f auf der Konsole anzuzeigen. Wenn Sie das Beispiel auf einem System ausführen, das die Konsolen Codepage 437 verwendet, wird jedes Zeichen durch ein Fragezeichen (?) ersetzt, da kyrillische Zeichen nicht den Zeichen in der Codepage 437 zugeordnet werden.  
  
 [!code-csharp[System.Console.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/unicode1.cs#1)]
 [!code-vb[System.Console.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/unicode1.vb#1)]  
 [!code-fsharp[System.Console.Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.console.class/fs/unicode1.fs#1)]
  
 Neben der Unterstützung von Codepages unterstützt die <xref:System.Console>-Klasse die UTF-8-Codierung mit der <xref:System.Text.UTF8Encoding>-Klasse. Beginnend mit dem .NET Framework 4,5 unterstützt die <xref:System.Console>-Klasse auch die UTF-16-Codierung mit der <xref:System.Text.UnicodeEncoding>-Klasse. , Um Unicode-Zeichen in der Konsole anzuzeigen. Legen Sie für die <xref:System.Console.OutputEncoding%2A>-Eigenschaft entweder <xref:System.Text.UTF8Encoding> oder <xref:System.Text.UnicodeEncoding>fest.  
  
 Die Unterstützung für Unicode-Zeichen erfordert, dass der Encoder ein bestimmtes Unicode-Zeichen erkennt und außerdem eine Schriftart erfordert, die die Symbole enthält, die zum Rendering dieses Zeichens erforderlich sind. Um Unicode-Zeichen erfolgreich in der Konsole anzuzeigen, muss die Konsolen Schriftart auf eine nicht-Raster-oder TrueType-Schriftart wie Consolas oder Lucida Console festgelegt werden. Im folgenden Beispiel wird gezeigt, wie Sie die Schriftart Programm gesteuert von einer Raster Schriftart in eine Lucida-Konsole ändern können.  
  
 [!code-csharp[System.Console.Class.Unsafe#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class.unsafe/cs/setfont1.cs#3)]
 [!code-vb[System.Console.Class.Unsafe#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class.unsafe/vb/setfont1.vb#3)]  
 [!code-fsharp[System.Console.Class.Unsafe#3](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.console.class.unsafe/fs/setfont1.fs#3)]
  
 TrueType-Schriftarten können jedoch nur eine Teilmenge der Symbole anzeigen. Beispielsweise zeigt die Schriftart der Lucida-Konsole nur 643 von ungefähr 64.000 verfügbaren Zeichen von u + 0021 bis U + FB02 an. Öffnen Sie in der Systemsteuerung das Applet **Fonts** , wählen Sie die Option **Zeichen suchen** aus, und wählen Sie die Schriftart aus, deren Zeichensatz Sie in der Liste **Schriftart** des Fensters **Zeichen** Zuordnung untersuchen möchten, um anzuzeigen, welche Zeichen eine bestimmte Schriftart unterstützt.  
  
 Windows verwendet Schriftart Verknüpfungen, um Symbole anzuzeigen, die in einer bestimmten Schriftart nicht verfügbar sind. Weitere Informationen über die Schriftart Verknüpfung zum Anzeigen zusätzlicher Zeichensätze finden Sie unterschritt Weise Anleitung für die [Globalisierung: Schriftarten](https://go.microsoft.com/fwlink/?LinkId=229111). Verknüpfte Schriftarten sind im Unterschlüssel HKEY_LOCAL_MACHINE \SOFTWARE\Microsoft\Windows nt\currentversion\fontlink\systemlink der Registrierung definiert. Jeder diesem Unterschlüssel zugeordnete Eintrag entspricht dem Namen einer Basis Schriftart, und sein Wert ist ein Zeichen folgen Array, das die Schriftart Dateien und die Schriftarten definiert, die mit der Basis Schriftart verknüpft sind. Jedes Element des Arrays definiert eine verknüpfte Schriftart und hat die Form *Schriftart-Dateiname*,*Schriftart Name*. Das folgende Beispiel veranschaulicht, wie Sie eine verknüpfte Schriftart namens Simsun in einer Schriftart Datei mit dem Namen Simsun. TTC, die vereinfachte Han-Zeichen anzeigt, Programm gesteuert definieren können.  
  
 [!code-csharp[System.Console.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/fontlink1.cs#2)]
 [!code-vb[System.Console.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/fontlink1.vb#2)]  
 [!code-fsharp[System.Console.Class#2](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.console.class/fs/fontlink1.fs#2)]
  
 Für die Unicode-Unterstützung der-Konsole gelten die folgenden Einschränkungen:  
  
-   UTF-32-Codierung wird nicht unterstützt. Die einzigen unterstützten Unicode-Codierungen sind UTF-8 und UTF-16, die durch die Klassen "<xref:System.Text.UTF8Encoding>" und "<xref:System.Text.UnicodeEncoding>" dargestellt werden.  
  
-   Die bidirektionale Ausgabe wird nicht unterstützt.  
  
-   Die Anzeige von Zeichen außerhalb der grundlegenden mehrsprachigen Ebene (d. h. von Ersatz Zeichen Paaren) wird nicht unterstützt, auch wenn Sie in einer verknüpften Schriftart Datei definiert sind.  
  
-   Die Anzeige von Zeichen in komplexen Skripts wird nicht unterstützt.  
  
-   Das Kombinieren von Zeichen folgen (d. h. Zeichen, die aus einem Basiszeichen und einem oder mehreren kombinierten Zeichen bestehen) werden als separate Zeichen angezeigt. Um diese Einschränkung zu umgehen, können Sie die anzuzeigende Zeichenfolge normalisieren, indem Sie die <xref:System.String.Normalize%2A?displayProperty=nameWithType>-Methode aufrufen, bevor Sie die Ausgabe an die Konsole senden. Im folgenden Beispiel wird der Konsole eine Zeichenfolge, die die kombinierte Zeichen Sequenz u + 0061 U + 0308 enthält, als zwei Zeichen angezeigt, bevor die Ausgabe Zeichenfolge normalisiert wird, und als einzelnes Zeichen, nachdem die <xref:System.String.Normalize%2A?displayProperty=nameWithType>-Methode aufgerufen wurde.  
  
     [!code-csharp[System.Console.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/normalize1.cs#5)]
     [!code-vb[System.Console.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/normalize1.vb#5)]  
     [!code-fsharp[System.Console.Class#5](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.console.class/fs/normalize1.fs#5)]
  
     Beachten Sie, dass die Normalisierung nur dann eine geeignete Lösung ist, wenn der Unicode-Standard für das Zeichen ein vorzusammen gesetztes Formular enthält, das einer bestimmten kombinierten Zeichen Sequenz entspricht.  
  
-   Wenn eine Schriftart ein Symbol für einen Codepunkt im privaten Verwendungsbereich bereitstellt, wird dieses Symbol angezeigt. Da Zeichen im privaten Verwendungsbereich jedoch anwendungsspezifisch sind, ist dies möglicherweise nicht das erwartete Symbol.  
  
 Im folgenden Beispiel wird ein Bereich von Unicode-Zeichen in der Konsole angezeigt. Das Beispiel akzeptiert drei Befehlszeilenparameter: den Anfang des anzuzeigenden Bereichs, das Ende des anzuzeigenden Bereichs und ob die aktuelle Konsolen Codierung (`false`) oder die UTF-16-Codierung (`true`) verwendet werden soll. Dabei wird davon ausgegangen, dass die Konsole eine TrueType-Schriftart verwendet.  
  
 [!code-csharp[System.Console.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/example3.cs#4)]
 [!code-vb[System.Console.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/example3.vb#4)]  
 [!code-fsharp[System.Console.Class#4](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.console.class/fs/example3.fs#4)]
  
<a name="Operations"></a>   
## <a name="common-operations"></a>Allgemeine Vorgänge  
 Die <xref:System.Console>-Klasse enthält die folgenden Methoden zum Lesen von Konsolen Eingaben und zum Schreiben der Konsolenausgabe:  
  
-   Die über Ladungen der <xref:System.Console.ReadKey%2A>-Methode lesen ein einzelnes Zeichen.  
  
-   Die <xref:System.Console.ReadLine%2A>-Methode liest eine ganze Zeile der Eingabe.  
  
-   Die <xref:System.Console.Write%2A>-Methoden Überladungen konvertieren eine Instanz eines Werttyps, eines Zeichen Arrays oder eines Satzes von Objekten in eine formatierte oder unformatierte Zeichenfolge und schreiben diese Zeichenfolge dann in die Konsole.  
  
-   Ein paralleler Satz <xref:System.Console.WriteLine%2A> Methoden Überladungen gibt dieselbe Zeichenfolge aus wie die <xref:System.Console.Write%2A> Überladungen, aber auch eine Zeichenfolge für die Zeilen Beendigung.  
  
 Die <xref:System.Console>-Klasse enthält auch Methoden und Eigenschaften, mit denen die folgenden Vorgänge durchgeführt werden können:  
  
-   Gibt die Größe des Bildschirm Puffers an oder legt Sie fest. Mit den Eigenschaften "<xref:System.Console.BufferHeight%2A>" und "<xref:System.Console.BufferWidth%2A>" können Sie die Puffer Höhe bzw.-Breite abrufen bzw. festlegen, und mit der <xref:System.Console.SetBufferSize%2A>-Methode können Sie die Puffergröße in einem einzelnen Methoden Aufrufsatz festlegen.  
  
-   Gibt die Größe des Konsolenfensters an oder legt Sie fest. Mit den Eigenschaften "<xref:System.Console.WindowHeight%2A>" und "<xref:System.Console.WindowWidth%2A>" können Sie die Fensterhöhe und-Breite abrufen bzw. festlegen, und mit der <xref:System.Console.SetWindowSize%2A>-Methode können Sie die Fenstergröße in einem einzelnen Methoden Aufrufsatz festlegen.  
  
-   Gibt die Größe des Cursors an oder legt Sie fest. Die <xref:System.Console.CursorSize%2A>-Eigenschaft gibt die Höhe des Cursors in einer Zeichen Zelle an.  
  
-   Gibt die Position des Konsolenfensters relativ zum Bildschirm Puffer an oder legt diese fest. Mit den Eigenschaften "<xref:System.Console.WindowTop%2A>" und "<xref:System.Console.WindowLeft%2A>" können Sie die oberste Zeile und die ganz links stehende Spalte des Bildschirm Puffers, der im Konsolenfenster angezeigt wird, Abrufen oder festlegen, und mit der <xref:System.Console.SetWindowPosition%2A>-Methode können Sie diese Werte in einem einzigen Methoden Aufrufsatz festlegen.  
  
-   Ruft die Position des Cursors ab oder legt Sie fest, indem die Eigenschaften <xref:System.Console.CursorTop%2A> und <xref:System.Console.CursorLeft%2A> oder die Position des Cursors durch Aufrufen der <xref:System.Console.SetCursorPosition%2A>-Methode festgelegt oder festgelegt wird.  
  
-   Verschieben oder löschen Sie Daten im Bildschirm Puffer, indem Sie die <xref:System.Console.MoveBufferArea%2A>-oder <xref:System.Console.Clear%2A>-Methode aufrufen.  
  
-   Rufen Sie die Vordergrund-und Hintergrundfarben mithilfe der Eigenschaften <xref:System.Console.ForegroundColor%2A> und <xref:System.Console.BackgroundColor%2A> ab, oder setzen Sie den Hintergrund und den Vordergrund auf ihre Standardfarben zurück, indem Sie die <xref:System.Console.ResetColor%2A>-Methode aufrufen.  
  
-   Geben Sie den Sound eines Signal durch den Konsolen Sprecher ein, indem Sie die <xref:System.Console.Beep%2A>-Methode aufrufen.  
  
<a name="Core"></a>   
## <a name="includenet_coreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Anmerkungen zu dieser Version  
 In der .NET Framework auf dem Desktop verwendet die <xref:System.Console>-Klasse die von `GetConsoleCP` und `GetConsoleOutputCP`zurückgegebene Codierung, bei der es sich in der Regel um eine Code Page Codierung handelt. Beispielsweise handelt es sich bei Systemen, deren Kultur Englisch (USA) ist, auf der Codepage 437, die standardmäßig verwendet wird. [!INCLUDE[net_core](~/includes/net-core-md.md)] können jedoch nur eine begrenzte Teilmenge dieser Codierungen verfügbar machen. Wenn dies der Fall ist, wird <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> als Standard Codierung für die Konsole verwendet.  
  
 Wenn Ihre APP von bestimmten Code Page Codierungen abhängig ist, können Sie Sie trotzdem verfügbar machen, indem Sie die folgenden Schritte ausführen, *bevor* Sie <xref:System.Console> Methoden aufgerufen werden:  
  
1.  Fügen Sie dem Projekt einen Verweis auf die System. Text. Encoding. Codepages. dll-Assembly hinzu.  
  
2.  Rufen Sie das <xref:System.Text.EncodingProvider>-Objekt aus der <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType>-Eigenschaft ab.  
  
3.  Übergeben Sie das <xref:System.Text.EncodingProvider>-Objekt an die <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType>-Methode, um die zusätzlichen Codierungen bereitzustellen, die vom Codierungs Anbieter unterstützt werden.  
  
 Die <xref:System.Console>-Klasse verwendet dann automatisch die Standardsystem Codierung anstelle von UTF8, vorausgesetzt, dass Sie den Codierungs Anbieter registriert haben, bevor Sie <xref:System.Console> Ausgabemethoden aufrufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Daten aus den standardmäßigen Eingabe-und Ausgabedaten strömen gelesen und in diese geschrieben werden. Beachten Sie, dass diese Streams mithilfe der Methoden <xref:System.Console.SetIn%2A> und <xref:System.Console.SetOut%2A> umgeleitet werden können.  
  
 [!code-cpp[Classic Console Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Console Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Console Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Console Example/CS/source.cs#1)]
 [!code-vb[Classic Console Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Console Example/VB/source.vb#1)]  
 [!code-fsharp[Classic Console Example#1](~/samples/snippets/fsharp/VS_Snippets_CLR_Classic/classic Console Example/FS/source.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="BackgroundColor">
      <MemberSignature Language="C#" Value="public static ConsoleColor BackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ConsoleColor BackgroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Console.BackgroundColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BackgroundColor As ConsoleColor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property ConsoleColor BackgroundColor { ConsoleColor get(); void set(ConsoleColor value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundColor : ConsoleColor with get, set" Usage="System.Console.BackgroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Hintergrundfarbe der Konsole ab oder legt diese fest.</summary>
        <value>Ein Wert, der die Hintergrundfarbe der Konsole, d. h. die hinter jedem Zeichen angezeigte Farbe angibt. Die Standardeinstellung ist schwarz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Änderung an der <xref:System.Console.BackgroundColor%2A>-Eigenschaft wirkt sich nur auf die Ausgabe aus, die nach der Änderung der Hintergrundfarbe in einzelne Zeichen Zellen geschrieben wird. Wenn Sie die Hintergrundfarbe des Konsolenfensters als Ganzes ändern möchten, legen Sie die <xref:System.Console.BackgroundColor%2A>-Eigenschaft fest, und nennen Sie die <xref:System.Console.Clear%2A>-Methode. Dies wird im folgenden Beispiel veranschaulicht.  
  
 [!code-csharp[System.Console.BackgroundColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.backgroundcolor/cs/backgroundcolor1.cs#1)]
 [!code-vb[System.Console.BackgroundColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.backgroundcolor/vb/backgroundcolor1.vb#1)]  
  
 Ein Get-Vorgang für eine Windows-basierte Anwendung, in der keine Konsole vorhanden ist, gibt <xref:System.ConsoleColor.Black?displayProperty=nameWithType>zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Werte der <xref:System.ConsoleColor>-Enumeration in einem Array gespeichert und die aktuellen Werte der <xref:System.Console.BackgroundColor%2A> und <xref:System.Console.ForegroundColor%2A> Eigenschaften in Variablen gespeichert. Anschließend ändert Sie die Vordergrundfarbe in jede Farbe in der <xref:System.ConsoleColor> Enumeration außer der Farbe, die mit dem aktuellen Hintergrund übereinstimmt, und ändert die Hintergrundfarbe in jede Farbe in der <xref:System.ConsoleColor> Enumeration außer der Farbe, die mit dem aktuellen Vordergrund übereinstimmt. (Wenn die Vordergrundfarbe mit der Hintergrundfarbe identisch ist, ist der Text nicht sichtbar.) Zum Schluss ruft Sie die <xref:System.Console.ResetColor%2A>-Methode auf, um die ursprünglichen Konsolen Farben wiederherzustellen.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die in einem Set-Vorgang angegebene Farbe ist kein gültiges Member von <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigung, um diese Aktion durchzuführen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Beep">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Sound eines Signaltons auf dem Konsolenlautsprecher wieder.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberSignature Language="F#" Value="static member Beep : unit -&gt; unit" Usage="System.Console.Beep " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Sound eines Signaltons auf dem Konsolenlautsprecher wieder.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig wird das Signal für eine Dauer von 200 Millisekunden mit einer Häufigkeit von 800 Hertz abgespielt.  
  
> [!NOTE]
>  Die <xref:System.Console.Beep%2A>-Methode wird in den 64-Bit-Editionen von Windows Vista und Windows XP nicht unterstützt.  
  
 <xref:System.Console.Beep%2A> umschließt einen [aufzurufenden Windows-Beep-Funktion](https://msdn.microsoft.com/library/windows/desktop/ms679277.aspx). Ob <xref:System.Console.Beep%2A> einen Sound für Windows-Versionen vor Windows 7 erzeugen, hängt von der Anwesenheit eines Zeit Geber Chips mit 8254-programmierbarer Intervalle ab. Ab Windows 7 hängt dies vom Standard Sound-Gerät ab.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Console.Beep%2A> Methode. Im Beispiel wird eine Zahl von 1 bis 9 als Befehlszeilenargument akzeptiert, und das Signal wird so oft wiedergegeben.  
  
 [!code-cpp[console.beep#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.beep/CPP/beep.cpp#1)]
 [!code-csharp[console.beep#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.beep/CS/beep.cs#1)]
 [!code-vb[console.beep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.beep/VB/beep.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.HostProtectionException">Diese Methode wurde auf einem Server, z. B. einem SQL-Server ausgeführt, der keinen Zugriff auf eine Benutzeroberfläche gestattet.</exception>
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep (int frequency, int duration);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep(int32 frequency, int32 duration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Beep(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Beep (frequency As Integer, duration As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep(int frequency, int duration);" />
      <MemberSignature Language="F#" Value="static member Beep : int * int -&gt; unit" Usage="System.Console.Beep (frequency, duration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frequency" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="duration" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="frequency">Die Frequenz des Signaltons zwischen 37 und 32767 Hertz.</param>
        <param name="duration">Die Dauer des Signaltons in Millisekunden.</param>
        <summary>Gibt den Sound eines Signaltons mit einer angegebenen Frequenz und Dauer auf dem Konsolenlautsprecher wieder.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.Beep%2A> umschließt einen [aufzurufenden Windows-Beep-Funktion](https://msdn.microsoft.com/library/windows/desktop/ms679277.aspx). Ob <xref:System.Console.Beep%2A> einen Sound für Windows-Versionen vor Windows 7 erzeugen, hängt von der Anwesenheit eines Zeit Geber Chips mit 8254-programmierbarer Intervalle ab. Ab Windows 7 hängt dies vom Standard Sound-Gerät ab.  
  
> [!NOTE]
>  Die <xref:System.Console.Beep%2A>-Methode wird in den 64-Bit-Editionen von Windows Vista und Windows XP nicht unterstützt.  
  
   
  
## Examples  
 In diesem Beispiel wird die <xref:System.Console.Beep%2A>-Methode veranschaulicht, indem die ersten Notizen eines Titels über den Konsolen Sprecher abgespielt werden.  
  
 [!code-cpp[console.beep2#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.beep2/CPP/b2.cpp#1)]
 [!code-csharp[console.beep2#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.beep2/CS/b2.cs#1)]
 [!code-vb[console.beep2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.beep2/VB/b2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="frequency" /> ist kleiner als 37 oder größer als 32767 Hertz.  
  
- oder - 
 <paramref name="duration" /> ist kleiner gleich 0 (null).</exception>
        <exception cref="T:System.Security.HostProtectionException">Diese Methode wurde auf einem Server wie SQL Server ausgeführt, der keinen Zugriff auf die Konsole gestattet.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows.</exception>
      </Docs>
    </Member>
    <Member MemberName="BufferHeight">
      <MemberSignature Language="C#" Value="public static int BufferHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BufferHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.BufferHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BufferHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int BufferHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BufferHeight : int with get, set" Usage="System.Console.BufferHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe des Pufferbereichs ab oder legt diese fest.</summary>
        <value>Die aktuelle Höhe des Pufferbereichs in Zeilen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft definiert die Anzahl der Zeilen (oder Zeilen), die im Puffer gespeichert sind, auf den von einem Fenster im Konsolenmodus zugegriffen wird. Im Gegensatz dazu definiert die <xref:System.Console.WindowHeight%2A>-Eigenschaft die Anzahl der Zeilen, die tatsächlich im Konsolenfenster zu einem bestimmten Zeitpunkt angezeigt werden. Wenn die Anzahl der Zeilen, die tatsächlich in den Puffer geschrieben werden, die Anzahl der Zeilen überschreitet, die von der <xref:System.Console.WindowHeight%2A>-Eigenschaft definiert werden, kann das Fenster vertikal gescrollt werden, sodass eine zusammenhängende Anzahl von Zeilen angezeigt wird, die gleich der Eigenschaft <xref:System.Console.WindowHeight%2A> sind und sich an einer beliebigen Stelle im Puffer befinden.  
  
 Wenn der Wert der <xref:System.Console.BufferHeight%2A>-Eigenschaft durch einen Set-Vorgang verringert wird, werden die obersten Zeilen entfernt. Wenn z. b. die Zeilen Anzahl von 300 auf 250 reduziert wird, werden die Zeilen 0 bis 49 entfernt, und die vorhandenen Zeilen 50 bis 299 werden Zeilen 0 bis 249.  
  
   
  
## Examples  
 In diesem Beispiel werden die Eigenschaften <xref:System.Console.BufferHeight%2A> und <xref:System.Console.BufferWidth%2A> veranschaulicht. Das Beispiel meldet die Dimensionen eines Betriebssystem Fensters, das auf eine Puffergröße von 300 Zeilen und 85 Spalten festgelegt ist.  
  
 [!code-cpp[console.bufferHW#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.bufferHW/CPP/hw.cpp#1)]
 [!code-csharp[console.bufferHW#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.bufferHW/CS/hw.cs#1)]
 [!code-vb[console.bufferHW#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.bufferHW/VB/hw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert in einem Set-Vorgang ist kleiner als oder gleich 0 (null).  
  
- oder - 
Der Wert in einem Set-Vorgang ist größer als oder gleich <see cref="F:System.Int16.MaxValue" />.  
  
- oder - 
Der Wert in einem Set-Vorgang ist kleiner als <see cref="P:System.Console.WindowTop" /> + <see cref="P:System.Console.WindowHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigung, um diese Aktion durchzuführen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der set-Vorgang wird unter einem anderen Betriebssystem als Windows aufgerufen.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BufferWidth">
      <MemberSignature Language="C#" Value="public static int BufferWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BufferWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.BufferWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BufferWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int BufferWidth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BufferWidth : int with get, set" Usage="System.Console.BufferWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Breite des Pufferbereichs ab oder legt diese fest.</summary>
        <value>Die aktuelle Breite des Pufferbereichs in Spalten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert der <xref:System.Console.BufferWidth%2A>-Eigenschaft durch einen Set-Vorgang verringert wird, werden die äußersten rechten Spalten entfernt. Wenn beispielsweise die Anzahl der Spalten von 80 auf 60 reduziert wird, werden die Spalten 60 bis 79 der einzelnen Zeilen entfernt.  
  
   
  
## Examples  
 In diesem Beispiel werden die Eigenschaften <xref:System.Console.BufferHeight%2A> und <xref:System.Console.BufferWidth%2A> veranschaulicht. Das Beispiel meldet die Dimensionen eines Betriebssystem Fensters, das auf eine Puffergröße von 300 Zeilen und 85 Spalten festgelegt ist.  
  
 [!code-cpp[console.bufferHW#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.bufferHW/CPP/hw.cpp#1)]
 [!code-csharp[console.bufferHW#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.bufferHW/CS/hw.cs#1)]
 [!code-vb[console.bufferHW#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.bufferHW/VB/hw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert in einem Set-Vorgang ist kleiner als oder gleich 0 (null).  
  
- oder - 
Der Wert in einem Set-Vorgang ist größer als oder gleich <see cref="F:System.Int16.MaxValue" />.  
  
- oder - 
Der Wert in einem Set-Vorgang ist kleiner als <see cref="P:System.Console.WindowLeft" /> + <see cref="P:System.Console.WindowWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigung, um diese Aktion durchzuführen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der set-Vorgang wird unter einem anderen Betriebssystem als Windows aufgerufen.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CancelKeyPress">
      <MemberSignature Language="C#" Value="public static event ConsoleCancelEventHandler CancelKeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ConsoleCancelEventHandler CancelKeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Console.CancelKeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event CancelKeyPress As ConsoleCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event ConsoleCancelEventHandler ^ CancelKeyPress;" />
      <MemberSignature Language="F#" Value="member this.CancelKeyPress : ConsoleCancelEventHandler " Usage="member this.CancelKeyPress : System.ConsoleCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die <see cref="F:System.ConsoleModifiers.Control" />-Modifizierertaste (STRG) und entweder die <see cref="F:System.ConsoleKey.C" />-Konsolentaste (c) oder die UNTBR-TASTE gleichzeitig gedrückt werden (STRG+C oder STRG+UNTBR).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird zusammen mit <xref:System.ConsoleCancelEventHandler?displayProperty=nameWithType> und <xref:System.ConsoleCancelEventArgs?displayProperty=nameWithType>verwendet. Das <xref:System.Console.CancelKeyPress>-Ereignis ermöglicht einer Konsolenanwendung, das STRG + C-Signal abzufangen, damit der Ereignishandler entscheiden kann, ob die Ausführung oder das Beenden fortgesetzt werden soll. Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Wenn der Benutzer entweder STRG + C oder Strg + Pause drückt, wird das <xref:System.Console.CancelKeyPress>-Ereignis ausgelöst, und der <xref:System.ConsoleCancelEventHandler>-Ereignishandler der Anwendung wird ausgeführt. Dem Ereignishandler wird ein <xref:System.ConsoleCancelEventArgs> Objekt mit zwei nützlichen Eigenschaften übermittelt:  
  
-   <xref:System.ConsoleCancelEventArgs.SpecialKey%2A>, mit dem Sie bestimmen können, ob der Handler als Ergebnis des Benutzers aufgerufen wurde, drücken Sie STRG + C (der-Eigenschafts Wert ist <xref:System.ConsoleSpecialKey.ControlC?displayProperty=nameWithType>) oder Strg + Pause (der-Eigenschafts Wert ist <xref:System.ConsoleSpecialKey.ControlBreak?displayProperty=nameWithType>).  
  
-   <xref:System.ConsoleCancelEventArgs.Cancel%2A>, mit dem Sie bestimmen können, wie Ihre Anwendung auf den Benutzer reagieren soll, indem Sie STRG + C oder Strg + Pause drücken. Standardmäßig wird die <xref:System.ConsoleCancelEventArgs.Cancel%2A>-Eigenschaft `false`, was bewirkt, dass die Programmausführung beendet wird, wenn der Ereignishandler beendet wird. Durch Ändern der-Eigenschaft in `true` wird angegeben, dass die Anwendung weiterhin ausgeführt werden soll.  
  
> [!TIP]
>  Wenn Ihre Anwendung einfache Anforderungen hat, können Sie anstelle dieses Ereignisses die <xref:System.Console.TreatControlCAsInput%2A>-Eigenschaft verwenden. Durch Festlegen dieser Eigenschaft auf `false`können Sie sicherstellen, dass die Anwendung immer beendet wird, wenn der Benutzer STRG + C drückt. Wenn Sie Sie auf "`true`" festlegen, können Sie sicherstellen, dass die Anwendung durch Drücken von STRG + C nicht beendet wird.  
  
 Der Ereignishandler für dieses Ereignis wird für einen Thread Pool Thread ausgeführt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das <xref:System.Console.CancelKeyPress>-Ereignis verwendet wird. Wenn Sie STRG + C drücken, wird der Lesevorgang unterbrochen, und der `myHandler` Ereignishandler wird aufgerufen. Beim Eintritt in den-Ereignishandler wird die <xref:System.ConsoleCancelEventArgs.Cancel%2A?displayProperty=nameWithType>-Eigenschaft `false`. Dies bedeutet, dass der aktuelle Prozess beendet wird, wenn der Ereignishandler beendet wird. Allerdings legt der Ereignishandler die <xref:System.ConsoleCancelEventArgs.Cancel%2A?displayProperty=nameWithType>-Eigenschaft auf `true`fest. Dies bedeutet, dass der Prozess nicht beendet wird und der Lesevorgang fortgesetzt wird.  
  
 [!code-cpp[console.cancelkeypress#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cancelkeypress/cpp/ckp.cpp#1)]
 [!code-csharp[console.cancelkeypress#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cancelkeypress/cs/ckp.cs#1)]
 [!code-vb[console.cancelkeypress#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cancelkeypress/vb/ckp.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="T:System.ConsoleCancelEventArgs" />
        <altmember cref="T:System.ConsoleCancelEventHandler" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
      </Docs>
    </Member>
    <Member MemberName="CapsLock">
      <MemberSignature Language="C#" Value="public static bool CapsLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CapsLock" />
      <MemberSignature Language="DocId" Value="P:System.Console.CapsLock" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CapsLock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CapsLock { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CapsLock : bool" Usage="System.Console.CapsLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die FESTSTELLTASTE-Tastaturumschalttaste aktiviert oder deaktiviert ist.</summary>
        <value><see langword="true" />, wenn die FESTSTELLTASTE aktiviert ist, <see langword="false" />, wenn die FESTSTELLTASTE deaktiviert ist.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Der get-Vorgang wird unter einem anderen Betriebssystem als Windows aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear();" />
      <MemberSignature Language="F#" Value="static member Clear : unit -&gt; unit" Usage="System.Console.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht die Anzeigeinformationen aus dem Konsolenpuffer und dem entsprechenden Konsolenfenster.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verwenden der <xref:System.Console.Clear%2A>-Methode entspricht dem Aufrufen des MS-DOS-`cls` Befehls im Eingabe Aufforderungs Fenster. Wenn die <xref:System.Console.Clear%2A>-Methode aufgerufen wird, führt der Cursor automatisch einen Bildlauf zur oberen linken Ecke des Fensters durch, und der Inhalt des Bildschirm Puffers wird mithilfe der aktuellen Vordergrundfarbe des Hintergrunds auf Leerzeichen festgelegt.  
  
> [!NOTE]
>  Wenn Sie versuchen, die <xref:System.Console.Clear%2A>-Methode aufzurufen, wenn die Ausgabe einer Konsolenanwendung in eine Datei umgeleitet wird, wird eine <xref:System.IO.IOException>ausgelöst. Um dies zu verhindern, umschließen Sie immer einen Aufruf der <xref:System.Console.Clear%2A> Methode in einer `try`...`catch` Baustein.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die-Methode <xref:System.Console.Clear%2A> verwendet, um die-Konsole zu löschen, bevor eine-Schleife ausgeführt wird. der Benutzer wird aufgefordert, eine Vordergrund-und Hintergrundfarbe auszuwählen und eine anzuzeigende Zeichenfolge einzugeben. Wenn der Benutzer entscheidet, das Programm nicht zu beenden, werden die ursprünglichen Vordergrund-und Hintergrundfarben der Konsole wieder hergestellt, und die <xref:System.Console.Clear%2A>-Methode wird erneut aufgerufen, bevor die Schleife erneut ausgeführt wird.  
  
 [!code-csharp[System.Console.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.clear/cs/clear1.cs#1)]
 [!code-vb[System.Console.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.clear/vb/clear1.vb#1)]  
  
 Das Beispiel basiert auf einer `GetKeyPress`-Methode, um die Auswahl einer Vorder-und Hintergrundfarbe für den Benutzer zu überprüfen.  
  
 In diesem Beispiel werden die Eigenschaften <xref:System.Console.CursorLeft%2A> und <xref:System.Console.CursorTop%2A> sowie die Methoden <xref:System.Console.SetCursorPosition%2A> und <xref:System.Console.Clear%2A> veranschaulicht. Im Beispiel wird der Cursor positioniert, der bestimmt, wo der nächste Schreibvorgang ausgeführt wird, um mit einer Kombination aus den Zeichen folgen "+", "&#124;" und "-" ein 5 Zeichen um 5 Zeichen zu zeichnen. Beachten Sie, dass das Rechteck mit weniger Schritten gezeichnet werden kann, indem eine Kombination aus anderen Zeichen folgen verwendet wird.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
      </Docs>
    </Member>
    <Member MemberName="CursorLeft">
      <MemberSignature Language="C#" Value="public static int CursorLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorLeft" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorLeft : int with get, set" Usage="System.Console.CursorLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Spaltenposition des Cursors im Pufferbereich ab oder legt diese fest.</summary>
        <value>Die aktuelle Position des Cursors in Spalten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In diesem Beispiel werden die Eigenschaften <xref:System.Console.CursorLeft%2A> und <xref:System.Console.CursorTop%2A> sowie die Methoden <xref:System.Console.SetCursorPosition%2A> und <xref:System.Console.Clear%2A> veranschaulicht. Im Beispiel wird der Cursor positioniert, der bestimmt, wo der nächste Schreibvorgang ausgeführt wird, um mit einer Kombination aus den Zeichen folgen "+", "&#124;" und "-" ein 5 Zeichen um 5 Zeichen zu zeichnen. Beachten Sie, dass das Rechteck mit weniger Schritten gezeichnet werden kann, indem eine Kombination aus anderen Zeichen folgen verwendet wird.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert in einem Set-Vorgang ist kleiner als 0 (null).  
  
- oder - 
Der Wert in einem Set-Vorgang ist größer als oder gleich <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigung, um diese Aktion durchzuführen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorSize">
      <MemberSignature Language="C#" Value="public static int CursorSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorSize" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorSize : int with get, set" Usage="System.Console.CursorSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe des Cursors innerhalb einer Zeichenzelle ab oder legt diese fest.</summary>
        <value>Die Größe des Cursors in Prozent der Höhe einer Zeichenzelle. Der Eigenschaftswert liegt zwischen 1 und 100.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Cursor Darstellung unterscheidet sich von einer horizontalen Linie am unteren Rand der Zelle, wenn der Eigenschafts Wert 1 ist, um die Zelle vollständig auszufüllen, wenn der Eigenschafts Wert 100 ist.  
  
   
  
## Examples  
 In diesem Beispiel wird die <xref:System.Console.CursorSize%2A>-Eigenschaft veranschaulicht. Im Beispiel wird die Größe des Cursors jedes Mal vergrößert, wenn eine Konsolen Taste gedrückt wird. Anschließend wird der Cursor vor dem beenden wieder in der ursprünglichen Größe wieder hergestellt.  
  
 [!code-cpp[console.cursorsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorsize/CPP/csize.cpp#1)]
 [!code-csharp[console.cursorsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorsize/CS/csize.cs#1)]
 [!code-vb[console.cursorsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorsize/VB/csize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der in einem Set-Vorgang angegebene Wert ist kleiner als 1 oder größer als 100.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigung, um diese Aktion durchzuführen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der set-Vorgang wird unter einem anderen Betriebssystem als Windows aufgerufen.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorTop">
      <MemberSignature Language="C#" Value="public static int CursorTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorTop" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorTop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorTop : int with get, set" Usage="System.Console.CursorTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeilenposition des Cursors im Pufferbereich ab oder legt diese fest.</summary>
        <value>Die aktuelle Position des Cursors in Zeilen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In diesem Beispiel werden die Eigenschaften <xref:System.Console.CursorLeft%2A> und <xref:System.Console.CursorTop%2A> sowie die Methoden <xref:System.Console.SetCursorPosition%2A> und <xref:System.Console.Clear%2A> veranschaulicht. Im Beispiel wird der Cursor positioniert, der bestimmt, wo der nächste Schreibvorgang ausgeführt wird, um mit einer Kombination aus den Zeichen folgen "+", "&#124;" und "-" ein 5 Zeichen um 5 Zeichen zu zeichnen. Beachten Sie, dass das Rechteck mit weniger Schritten gezeichnet werden kann, indem eine Kombination aus anderen Zeichen folgen verwendet wird.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert in einem Set-Vorgang ist kleiner als 0 (null).  
  
- oder - 
Der Wert in einem Set-Vorgang ist größer als oder gleich <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigung, um diese Aktion durchzuführen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorVisible">
      <MemberSignature Language="C#" Value="public static bool CursorVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CursorVisible" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorVisible" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CursorVisible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CursorVisible : bool with get, set" Usage="System.Console.CursorVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Cursor sichtbar ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der Cursor sichtbar ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In diesem Beispiel wird die <xref:System.Console.CursorVisible%2A>-Eigenschaft veranschaulicht. Im Beispiel wird der Cursor sichtbar, wenn die erste Spalte der Eingabe ein "+"-Zeichen oder unsichtbar ist, wenn es sich bei der Eingabe um ein "-"-Zeichen handelt.  
  
 [!code-cpp[console.cursorvis#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorvis/CPP/vis.cpp#1)]
 [!code-csharp[console.cursorvis#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorvis/CS/vis.cs#1)]
 [!code-vb[console.cursorvis#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorvis/VB/vis.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigung, um diese Aktion durchzuführen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der get-Vorgang wird unter einem anderen Betriebssystem als Windows aufgerufen.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextWriter Error" />
      <MemberSignature Language="DocId" Value="P:System.Console.Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Error As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextWriter ^ Error { System::IO::TextWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.TextWriter" Usage="System.Console.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Standard-Fehlerausgabestream ab.</summary>
        <value>Ein <see cref="T:System.IO.TextWriter" />, der den Standard-Fehlerausgabestream darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Standardfehlerstream wird standardmäßig auf die Konsole festgelegt. Sie kann mit der <xref:System.Console.SetError%2A>-Methode auf einen anderen Stream festgelegt werden. Nachdem der Standardfehlerstream umgeleitet wurde, kann er erneut abgerufen werden, indem die <xref:System.Console.OpenStandardError%2A>-Methode aufgerufen wird.  
  
 In Konsolen Anwendungen, deren Informationsausgabe häufig in eine Datei umgeleitet wird, kann der Standardfehlerstream, der über die <xref:System.Console.Error%2A>-Eigenschaft verfügbar ist, zum Anzeigen von Informationen in der Konsole verwendet werden, auch wenn die Ausgabe umgeleitet wird. Im folgenden Beispiel werden Produkt Tabellen für 10 Zahlen gleichzeitig, beginnend mit 1, angezeigt. Nach jedem Satz von 10 Zahlen wird die <xref:System.Console.Error%2A>-Eigenschaft verwendet, um den Benutzer zu Fragen, ob der nächste Satz angezeigt werden soll. Wenn die Standardausgabe an eine Datei umgeleitet wird, wird der Benutzer nach wie vor gefragt, ob die Routine den nächsten Satz von Produkten generieren soll.  
  
 [!code-csharp[System.Console.Error#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.error/cs/error1.cs#1)]
 [!code-vb[System.Console.Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.error/vb/error1.vb#1)]  
  
   
  
## Examples  
 Das folgende Beispiel ist ein Befehlszeilen-Hilfsprogramm mit dem Namen ExpandTabs, das Tabstopp Zeichen in einer Textdatei durch vier Leerzeichen ersetzt, den Wert, der von der `tabSize` Variable definiert wird. Dabei werden die standardmäßigen Eingabe-und Ausgabedaten Ströme an Dateien umgeleitet, die <xref:System.Console.Error%2A>-Eigenschaft wird jedoch verwendet, um den Standardfehlerstream in die Konsole zu schreiben. Sie kann über die Befehlszeile gestartet werden, indem Sie den Namen der Datei angeben, die Tabstopp Zeichen und den Namen der Ausgabedatei enthält.  
  
 [!code-cpp[Console-EXPANDTABSEX#1](~/samples/snippets/cpp/VS_Snippets_CLR/Console-EXPANDTABSEX/CPP/expandtabsex.cpp#1)]
 [!code-csharp[Console-EXPANDTABSEX#1](~/samples/snippets/csharp/VS_Snippets_CLR/Console-EXPANDTABSEX/CS/expandtabsex.cs#1)]
 [!code-vb[Console-EXPANDTABSEX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Console-EXPANDTABSEX/VB/expandtabsex.vb#1)]  
  
 Das folgende Beispiel ist ein einfacher Textdatei-Viewer, der den Inhalt einer oder mehrerer Textdateien in der Konsole anzeigt. Wenn keine Befehlszeilenargumente vorhanden sind oder Dateien, die als Befehlszeilenargumente weitergegeben wurden, nicht vorhanden sind, wird im Beispiel die <xref:System.Console.SetError%2A>-Methode aufgerufen, um Fehlerinformationen in eine Datei umzuleiten, die <xref:System.Console.OpenStandardError%2A>-Methode beim erneuten Abrufen des Standardfehlerstreams aufzurufen, und es wird angegeben, dass Fehlerinformationen in eine Datei geschrieben wurden.  
  
 [!code-csharp[System.Console.OpenStandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.openstandarderror/cs/viewtextfile.cs#1)]
 [!code-vb[System.Console.OpenStandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.openstandarderror/vb/viewtextfile.vb#1)]  
  
 Beachten Sie, dass die <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType>-Eigenschaft auf `true` festgelegt ist, bevor Sie den Fehler Datenstrom erneut abrufen. Dadurch wird sichergestellt, dass die Ausgabe sofort an die Konsole gesendet wird, anstatt gepuffert zu werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ForegroundColor">
      <MemberSignature Language="C#" Value="public static ConsoleColor ForegroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ConsoleColor ForegroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Console.ForegroundColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ForegroundColor As ConsoleColor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property ConsoleColor ForegroundColor { ConsoleColor get(); void set(ConsoleColor value); };" />
      <MemberSignature Language="F#" Value="member this.ForegroundColor : ConsoleColor with get, set" Usage="System.Console.ForegroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Vordergrundfarbe der Konsole ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.ConsoleColor" />, die die Vordergrundfarbe der Konsole angibt, d. h. die Farbe, in der alle Zeichen angezeigt werden. Die Standardeinstellung ist grau.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Get-Vorgang für eine Windows-basierte Anwendung, in der keine Konsole vorhanden ist, gibt <xref:System.ConsoleColor.Gray>zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird überprüft, ob die Hintergrundfarbe der Konsole schwarz ist, und wenn dies der Fall ist, wird die Hintergrundfarbe in rot und die Vordergrundfarbe in Schwarz geändert.  
  
 [!code-csharp[System.ConsoleColor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/Example2.cs#2)] 
 [!code-vb[System.ConsoleColor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/Example2.vb#2)]  
  
 Im folgenden Beispiel werden die Werte der <xref:System.ConsoleColor>-Enumeration in einem Array gespeichert und die aktuellen Werte der <xref:System.Console.BackgroundColor%2A> und <xref:System.Console.ForegroundColor%2A> Eigenschaften in Variablen gespeichert. Anschließend ändert Sie die Vordergrundfarbe in jede Farbe in der <xref:System.ConsoleColor> Enumeration außer der Farbe, die mit dem aktuellen Hintergrund übereinstimmt, und ändert die Hintergrundfarbe in jede Farbe in der <xref:System.ConsoleColor> Enumeration außer der Farbe, die mit dem aktuellen Vordergrund übereinstimmt. (Wenn die Vordergrundfarbe mit der Hintergrundfarbe identisch ist, ist der Text nicht sichtbar.) Zum Schluss ruft Sie die <xref:System.Console.ResetColor%2A>-Methode auf, um die ursprünglichen Konsolen Farben wiederherzustellen.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die in einem Set-Vorgang angegebene Farbe ist kein gültiges Member von <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigung, um diese Aktion durchzuführen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="In">
      <MemberSignature Language="C#" Value="public static System.IO.TextReader In { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextReader In" />
      <MemberSignature Language="DocId" Value="P:System.Console.In" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property In As TextReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextReader ^ In { System::IO::TextReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.In : System.IO.TextReader" Usage="System.Console.In" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Standardeingabestream ab.</summary>
        <value>Ein <see cref="T:System.IO.TextReader" />, der den Standardeingabestream darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird standardmäßig auf den Standardeingabestream festgelegt. Diese Eigenschaft kann mit der <xref:System.Console.SetIn%2A>-Methode auf einen anderen Stream festgelegt werden.  
  
 Lesevorgänge auf dem Standardeingabestream werden synchron ausgeführt. Das heißt, dass Sie blockiert werden, bis der angegebene Lesevorgang abgeschlossen ist. Dies gilt auch, wenn eine asynchrone Methode, z. b. <xref:System.IO.TextReader.ReadLineAsync%2A>, für das <xref:System.IO.TextReader> Objekt aufgerufen wird, das von der <xref:System.Console.In%2A>-Eigenschaft zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `In`-Eigenschaft veranschaulicht.  
  
 [!code-cpp[consolein#1](~/samples/snippets/cpp/VS_Snippets_CLR/consolein/CPP/consolein.cpp#1)]
 [!code-csharp[consolein#1](~/samples/snippets/csharp/VS_Snippets_CLR/consolein/CS/consolein.cs#1)]
 [!code-vb[consolein#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/consolein/VB/consolein.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Console.OpenStandardInput" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.Out" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="InputEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding InputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding InputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Console.InputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property InputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ InputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputEncoding : System.Text.Encoding with get, set" Usage="System.Console.InputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Codierung ab, die die Konsole verwendet, um die Eingabe zu lesen, oder legt diese fest.</summary>
        <value>Die Codierung, die verwendet wird, um die Konsoleneingabe zu lesen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Konsole verwendet die Eingabe Codierung, um Tastatureingaben in ein entsprechendes Zeichen zu übersetzen. Die Eingabe Codierung enthält eine Codepage, die den einzelnen Zeichen 256 Tastatur Zeichen Codes zuordnet. Zu verschiedenen Codepages gehören verschiedene spezielle Zeichen, die normalerweise für eine Sprache oder eine Gruppe von Sprachen angepasst sind.  
  
 Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]kann ein Get-Vorgang eine Eigenschaft anstelle der aktuellen Eingabe Codierung der Konsole einen zwischengespeicherten Wert zurückgeben. Dies kann vorkommen, wenn der Wert der <xref:System.Console.InputEncoding%2A>-Eigenschaft durch andere Mittel als eine Zuweisung zur <xref:System.Console.InputEncoding%2A> Eigenschaft geändert wird, z. b. das Aufrufen der Windows `SetConsoleCP`-Funktion oder die Verwendung des `chcp` Befehls aus einem PowerShell-Skript.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Eigenschaftswert in einer Set-Operation ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Während der Ausführung dieses Vorgangs ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.Security.SecurityException">Ihre Anwendung verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Lese-und Schreibvorgänge für Windows und untergeordnete Fenster der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName="IsErrorRedirected">
      <MemberSignature Language="C#" Value="public static bool IsErrorRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsErrorRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsErrorRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsErrorRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsErrorRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsErrorRedirected : bool" Usage="System.Console.IsErrorRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Fehlerausgabedatenstrom von dem Standardfehlerstream umgeleitet wurde.</summary>
        <value><see langword="true" />, wenn die Fehlerausgabe umgeleitet wird; andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
        <altmember cref="M:System.Console.OpenStandardError" />
      </Docs>
    </Member>
    <Member MemberName="IsInputRedirected">
      <MemberSignature Language="C#" Value="public static bool IsInputRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsInputRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsInputRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsInputRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsInputRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInputRedirected : bool" Usage="System.Console.IsInputRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Eingabe aus dem Standardeingabestream umgeleitet wurde.</summary>
        <value><see langword="true" />, wenn die Eingabe umgeleitet wird, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
        <altmember cref="M:System.Console.OpenStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="IsOutputRedirected">
      <MemberSignature Language="C#" Value="public static bool IsOutputRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsOutputRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsOutputRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsOutputRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsOutputRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOutputRedirected : bool" Usage="System.Console.IsOutputRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Ausgabe aus dem Standardausgabestream umgeleitet wurde.</summary>
        <value><see langword="true" />, wenn die Ausgabe umgeleitet wird, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
        <altmember cref="M:System.Console.OpenStandardError" />
      </Docs>
    </Member>
    <Member MemberName="KeyAvailable">
      <MemberSignature Language="C#" Value="public static bool KeyAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool KeyAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Console.KeyAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property KeyAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool KeyAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyAvailable : bool" Usage="System.Console.KeyAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Tastendruck im Eingabestream vorhanden ist.</summary>
        <value><see langword="true" />, wenn ein Tastendruck vorhanden ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Eigenschafts Wert wird sofort zurückgegeben. Das heißt, die <xref:System.Console.KeyAvailable%2A>-Eigenschaft blockiert Eingaben erst, wenn ein Tastendruck verfügbar ist.  
  
 Verwenden Sie die <xref:System.Console.KeyAvailable%2A>-Eigenschaft in Verbindung mit nur der <xref:System.Console.ReadKey%2A>-Methode, nicht der <xref:System.Console.Read%2A>-oder <xref:System.Console.ReadLine%2A>-Methoden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Console.KeyAvailable%2A>-Eigenschaft verwendet wird, um eine Schleife zu erstellen, die ausgeführt wird, bis eine Taste gedrückt wird.  
  
 [!code-cpp[console.keyavailable#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.keyavailable/CPP/ka.cpp#1)]
 [!code-csharp[console.keyavailable#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.keyavailable/CS/ka.cs#1)]
 [!code-vb[console.keyavailable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.keyavailable/VB/ka.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.InvalidOperationException">Standardeingabe wird nicht an die Tastatur gesendet, sondern in eine Datei umgeleitet.</exception>
      </Docs>
    </Member>
    <Member MemberName="LargestWindowHeight">
      <MemberSignature Language="C#" Value="public static int LargestWindowHeight { get; }" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property int32 LargestWindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.LargestWindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LargestWindowHeight As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int LargestWindowHeight { int get(); };" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.LargestWindowHeight : int" Usage="System.Console.LargestWindowHeight" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public static int LargestWindowHeight { get; set; }" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property LargestWindowHeight As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int LargestWindowHeight { int get(); void set(int value); };" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.LargestWindowHeight : int with get, set" Usage="System.Console.LargestWindowHeight" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die entsprechend der aktuellen Schriftart und Bildschirmauflösung größtmögliche Anzahl von Konsolenfensterzeilen ab.</summary>
        <value>Die Höhe des größtmöglichen Konsolenfensters in Zeilen.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LargestWindowWidth">
      <MemberSignature Language="C#" Value="public static int LargestWindowWidth { get; }" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property int32 LargestWindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.LargestWindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LargestWindowWidth As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int LargestWindowWidth { int get(); };" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.LargestWindowWidth : int" Usage="System.Console.LargestWindowWidth" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public static int LargestWindowWidth { get; set; }" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property LargestWindowWidth As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int LargestWindowWidth { int get(); void set(int value); };" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.LargestWindowWidth : int with get, set" Usage="System.Console.LargestWindowWidth" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die entsprechend der aktuellen Schriftart und Bildschirmauflösung größtmögliche Anzahl von Konsolenfensterspalten ab.</summary>
        <value>Die Breite des größtmöglichen Konsolenfensters in Spalten.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveBufferArea">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert einen angegebenen Quellbereich des Bildschirmpuffers in einen angegebenen Zielbereich.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveBufferArea">
      <MemberSignature Language="C#" Value="public static void MoveBufferArea (int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveBufferArea(int32 sourceLeft, int32 sourceTop, int32 sourceWidth, int32 sourceHeight, int32 targetLeft, int32 targetTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveBufferArea (sourceLeft As Integer, sourceTop As Integer, sourceWidth As Integer, sourceHeight As Integer, targetLeft As Integer, targetTop As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);" />
      <MemberSignature Language="F#" Value="static member MoveBufferArea : int * int * int * int * int * int -&gt; unit" Usage="System.Console.MoveBufferArea (sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceLeft" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceTop" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceWidth" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceHeight" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetLeft" Type="System.Int32" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetTop" Type="System.Int32" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceLeft">Die am weitesten links stehende Spalte des Quellbereichs.</param>
        <param name="sourceTop">Die oberste Zeile des Quellbereichs.</param>
        <param name="sourceWidth">Die Anzahl der Spalten im Quellbereich.</param>
        <param name="sourceHeight">Die Anzahl der Zeilen im Quellbereich.</param>
        <param name="targetLeft">Die am weitesten links stehende Spalte des Zielbereichs.</param>
        <param name="targetTop">Die oberste Zeile des Zielbereichs.</param>
        <summary>Kopiert einen angegebenen Quellbereich des Bildschirmpuffers in einen angegebenen Zielbereich.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Ziel-und Quellparameter eine Position angeben, die sich außerhalb der Grenzen des aktuellen Bildschirm Puffers befindet, wird nur der Teil des Quell Bereichs kopiert, der in den Zielbereich passt. Das heißt, der Quellbereich wird abgeschnitten, damit er an den aktuellen Bildschirm Puffer angepasst wird.  
  
 Mit der <xref:System.Console.MoveBufferArea%2A>-Methode wird der Quellbereich in den Zielbereich kopiert. Wenn sich der Zielbereich nicht mit dem Quellbereich überschneidet, wird der Quellbereich mithilfe der aktuellen Vordergrund-und Hintergrundfarben mit Leerzeichen gefüllt. Andernfalls wird der überschneidende Teil des Quell Bereichs nicht ausgefüllt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Mindestens einer der Parameter ist kleiner als 0 (null).  
  
- oder - 
 <paramref name="sourceLeft" /> oder <paramref name="targetLeft" /> ist größer oder gleich <see cref="P:System.Console.BufferWidth" />.  
  
- oder - 
 <paramref name="sourceTop" /> oder <paramref name="targetTop" /> ist größer oder gleich <see cref="P:System.Console.BufferHeight" />.  
  
- oder - 
 <paramref name="sourceTop" /> + <paramref name="sourceHeight" /> ist größer oder gleich <see cref="P:System.Console.BufferHeight" />.  
  
- oder - 
 <paramref name="sourceLeft" /> + <paramref name="sourceWidth" /> ist größer oder gleich <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigung, um diese Aktion durchzuführen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MoveBufferArea">
      <MemberSignature Language="C#" Value="public static void MoveBufferArea (int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveBufferArea(int32 sourceLeft, int32 sourceTop, int32 sourceWidth, int32 sourceHeight, int32 targetLeft, int32 targetTop, char sourceChar, valuetype System.ConsoleColor sourceForeColor, valuetype System.ConsoleColor sourceBackColor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Char,System.ConsoleColor,System.ConsoleColor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveBufferArea (sourceLeft As Integer, sourceTop As Integer, sourceWidth As Integer, sourceHeight As Integer, targetLeft As Integer, targetTop As Integer, sourceChar As Char, sourceForeColor As ConsoleColor, sourceBackColor As ConsoleColor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);" />
      <MemberSignature Language="F#" Value="static member MoveBufferArea : int * int * int * int * int * int * char * ConsoleColor * ConsoleColor -&gt; unit" Usage="System.Console.MoveBufferArea (sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop, sourceChar, sourceForeColor, sourceBackColor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceLeft" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceTop" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceWidth" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceHeight" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetLeft" Type="System.Int32" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="targetTop" Type="System.Int32" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceChar" Type="System.Char" Index="6" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceForeColor" Type="System.ConsoleColor" Index="7" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceBackColor" Type="System.ConsoleColor" Index="8" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceLeft">Die am weitesten links stehende Spalte des Quellbereichs.</param>
        <param name="sourceTop">Die oberste Zeile des Quellbereichs.</param>
        <param name="sourceWidth">Die Anzahl der Spalten im Quellbereich.</param>
        <param name="sourceHeight">Die Anzahl der Zeilen im Quellbereich.</param>
        <param name="targetLeft">Die am weitesten links stehende Spalte des Zielbereichs.</param>
        <param name="targetTop">Die oberste Zeile des Zielbereichs.</param>
        <param name="sourceChar">Das zum Ausfüllen des Quellbereichs verwendete Zeichen.</param>
        <param name="sourceForeColor">Die zum Ausfüllen des Quellbereichs verwendete Vordergrundfarbe.</param>
        <param name="sourceBackColor">Die zum Ausfüllen des Quellbereichs verwendete Hintergrundfarbe.</param>
        <summary>Kopiert einen angegebenen Quellbereich des Bildschirmpuffers in einen angegebenen Zielbereich.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Ziel-und Quellparameter eine Position angeben, die sich über die Grenzen des aktuellen Bildschirm Puffers hinaus befindet, wird nur der Teil des Quell Bereichs kopiert, der in den Zielbereich passt. Das heißt, der Quellbereich wird abgeschnitten, damit er an den aktuellen Bildschirm Puffer angepasst wird.  
  
 Mit der <xref:System.Console.MoveBufferArea%2A>-Methode wird der Quellbereich in den Zielbereich kopiert. Wenn sich der Zielbereich nicht mit dem Quellbereich überschneidet, wird der Quellbereich mit dem durch `sourceChar`angegebenen Zeichen gefüllt, wobei die durch `sourceForeColor` und `sourceBackColor`angegebenen Farben verwendet werden. Andernfalls wird der überschneidende Teil des Quell Bereichs nicht ausgefüllt.  
  
 Die <xref:System.Console.MoveBufferArea%2A>-Methode führt keinen Vorgang aus, wenn `sourceWidth` oder `sourceHeight` 0 (null) ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Mindestens einer der Parameter ist kleiner als 0 (null).  
  
- oder - 
 <paramref name="sourceLeft" /> oder <paramref name="targetLeft" /> ist größer oder gleich <see cref="P:System.Console.BufferWidth" />.  
  
- oder - 
 <paramref name="sourceTop" /> oder <paramref name="targetTop" /> ist größer oder gleich <see cref="P:System.Console.BufferHeight" />.  
  
- oder - 
 <paramref name="sourceTop" /> + <paramref name="sourceHeight" /> ist größer oder gleich <see cref="P:System.Console.BufferHeight" />.  
  
- oder - 
 <paramref name="sourceLeft" /> + <paramref name="sourceWidth" /> ist größer oder gleich <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.ArgumentException">Einer oder beide Farbparameter sind kein Member der <see cref="T:System.ConsoleColor" />-Enumeration.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigung, um diese Aktion durchzuführen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NumberLock">
      <MemberSignature Language="C#" Value="public static bool NumberLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool NumberLock" />
      <MemberSignature Language="DocId" Value="P:System.Console.NumberLock" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NumberLock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool NumberLock { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.NumberLock : bool" Usage="System.Console.NumberLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die NUM-Tastaturumschalttaste aktiviert oder deaktiviert ist.</summary>
        <value><see langword="true" />, wenn die NUM-TASTE aktiviert ist, <see langword="false" />, wenn die NUM-TASTE deaktiviert ist.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">Der get-Vorgang wird unter einem anderen Betriebssystem als Windows aufgerufen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardError">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Standardfehlerstream ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardError">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardError ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardError" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardError () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardError();" />
      <MemberSignature Language="F#" Value="static member OpenStandardError : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Standardfehlerstream ab.</summary>
        <returns>Der Standardfehlerstream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um den Standardfehlerstream erneut abzurufen, nachdem er durch die <xref:System.Console.SetError%2A>-Methode geändert wurde.  
  
   
  
## Examples  
 Das folgende Beispiel ist ein einfacher Textdatei-Viewer, der den Inhalt einer oder mehrerer Textdateien in der Konsole anzeigt. Wenn keine Befehlszeilenargumente vorhanden sind oder Dateien, die als Befehlszeilenargumente weitergegeben wurden, nicht vorhanden sind, wird im Beispiel die <xref:System.Console.SetError%2A>-Methode aufgerufen, um Fehlerinformationen in eine Datei umzuleiten, die <xref:System.Console.OpenStandardError%2A>-Methode beim erneuten Abrufen des Standardfehlerstreams aufzurufen, und es wird angegeben, dass Fehlerinformationen in eine Datei geschrieben wurden.  
  
 [!code-csharp[System.Console.OpenStandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.openstandarderror/cs/viewtextfile.cs#1)]
 [!code-vb[System.Console.OpenStandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.openstandarderror/vb/viewtextfile.vb#1)]  
  
 Beachten Sie, dass die <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType>-Eigenschaft auf `true` festgelegt ist, bevor Sie den Fehler Datenstrom erneut abrufen. Dadurch wird sichergestellt, dass die Ausgabe sofort an die Konsole gesendet wird, anstatt gepuffert zu werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardError">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardError (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardError(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardError(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardError (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardError(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardError : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardError bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Die Größe des internen Streampuffers.</param>
        <summary>Ruft den Standardfehlerstream ab, der auf eine angegebene Puffergröße festgelegt wird.</summary>
        <returns>Der Standardfehlerstream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um den Standardfehlerstream erneut abzurufen, nachdem er durch die <xref:System.Console.SetError%2A>-Methode geändert wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> ist kleiner gleich 0 (null).</exception>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardInput">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Standardeingabestream ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardInput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardInput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardInput () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardInput();" />
      <MemberSignature Language="F#" Value="static member OpenStandardInput : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardInput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Standardeingabestream ab.</summary>
        <returns>Der Standardeingabestream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um den Standardeingabestream erneut abzurufen, nachdem er durch die <xref:System.Console.SetIn%2A>-Methode geändert wurde.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `OpenStandardInput`-Eigenschaft veranschaulicht.  
  
 [!code-cpp[System.Console.OpenStandartInput#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CPP/decode.cpp#1)]
 [!code-csharp[System.Console.OpenStandartInput#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CS/decode.cs#1)]
 [!code-vb[System.Console.OpenStandartInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.OpenStandartInput/VB/decode.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardInput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardInput (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardInput(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardInput (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardInput(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardInput : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardInput bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Die Größe des internen Streampuffers.</param>
        <summary>Ruft den Standardeingabestream ab, der auf eine angegebene Puffergröße festgelegt wird.</summary>
        <returns>Der Standardeingabestream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um den Standardausgabestream erneut abzurufen, nachdem er durch die <xref:System.Console.SetIn%2A>-Methode geändert wurde.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `OpenStandardInput`-Eigenschaft veranschaulicht.  
  
 [!code-cpp[System.Console.OpenStandartInput#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CPP/decode.cpp#1)]
 [!code-csharp[System.Console.OpenStandartInput#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CS/decode.cs#1)]
 [!code-vb[System.Console.OpenStandartInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.OpenStandartInput/VB/decode.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> ist kleiner gleich 0 (null).</exception>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardOutput">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Standardausgabestream ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardOutput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardOutput ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardOutput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardOutput () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardOutput();" />
      <MemberSignature Language="F#" Value="static member OpenStandardOutput : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardOutput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Standardausgabestream ab.</summary>
        <returns>Der Standardausgabestream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um den Standardausgabestream erneut abzurufen, nachdem er durch die <xref:System.Console.SetOut%2A>-Methode geändert wurde.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Console.OpenStandardOutput%2A>-Methode veranschaulicht. Hierdurch werden vier aufeinander folgende Leerzeichen in einer Zeichenfolge durch ein Tabstoppzeichen ersetzt. Um es auszuführen, müssen Sie zwei Befehlszeilenargumente angeben. Das erste ist der Name einer vorhandenen Textdatei, in die der Standardeingabestream umgeleitet wird. Das zweite ist der Name einer Datei, in die der Standardausgabestream umgeleitet wird. Diese Datei muss nicht vorhanden sein. Wenn das der Fall ist, wird der Inhalt überschrieben.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsOutputRedirected" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardOutput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardOutput (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardOutput(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardOutput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardOutput (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardOutput(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardOutput : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardOutput bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Die Größe des internen Streampuffers.</param>
        <summary>Ruft den Standardausgabestream ab, der auf eine angegebene Puffergröße festgelegt wird.</summary>
        <returns>Der Standardausgabestream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um den Standardausgabestream erneut abzurufen, nachdem er durch die <xref:System.Console.SetOut%2A>-Methode geändert wurde.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Console.OpenStandardOutput%2A>-Methode veranschaulicht. Hierdurch werden vier aufeinander folgende Leerzeichen in einer Zeichenfolge durch ein Tabstoppzeichen ersetzt. Um es auszuführen, müssen Sie zwei Befehlszeilenargumente angeben. Das erste ist der Name einer vorhandenen Textdatei, in die der Standardeingabestream umgeleitet wird. Das zweite ist der Name einer Datei, in die der Standardausgabestream umgeleitet wird. Diese Datei muss nicht vorhanden sein. Wenn das der Fall ist, wird der Inhalt überschrieben.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> ist kleiner gleich 0 (null).</exception>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsOutputRedirected" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Out">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter Out { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextWriter Out" />
      <MemberSignature Language="DocId" Value="P:System.Console.Out" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Out As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextWriter ^ Out { System::IO::TextWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Out : System.IO.TextWriter" Usage="System.Console.Out" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Standardausgabestream ab.</summary>
        <value>Ein <see cref="T:System.IO.TextWriter" />, der den Standardausgabestream darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird standardmäßig auf den Standardausgabestream festgelegt. Diese Eigenschaft kann mit der <xref:System.Console.SetOut%2A>-Methode auf einen anderen Stream festgelegt werden.  
  
 Beachten Sie, dass Aufrufe von `Console.Out.WriteLine` Methoden den Aufrufen der entsprechenden <xref:System.Console.WriteLine%2A> Methoden entsprechen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Console.Out%2A>-Eigenschaft verwendet, um ein Array mit den Namen der Dateien im aktuellen Verzeichnis der Anwendung für das Standardausgabe Gerät anzuzeigen. Anschließend wird die Standardausgabe in eine Datei mit dem Namen files. txt festgelegt, und die Array Elemente werden in der Datei aufgelistet. Schließlich wird die Ausgabe auf den Standardausgabestream festgelegt, und die Array Elemente werden erneut für das Standardausgabe Gerät angezeigt.  
  
 [!code-csharp[System.Console.Out#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.out/cs/out1.cs#1)]
 [!code-vb[System.Console.Out#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.out/vb/out1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.In" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OutputEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding OutputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding OutputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Console.OutputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property OutputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ OutputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OutputEncoding : System.Text.Encoding with get, set" Usage="System.Console.OutputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Codierung ab, die die Konsole verwendet, um die Ausgabe zu schreiben, oder legt diese fest.</summary>
        <value>Die Codierung, die verwendet wird, um die Konsolenausgabe zu schreiben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die-Konsole verwendet die Ausgabe Codierung, um von einer Anwendung geschriebene Zeichen in entsprechende Konsolen Anzeige Zeichen zu übersetzen. Die Standard Codepage, die von der-Konsole verwendet wird, wird durch das Gebiets Schema des Systems bestimmt.  
  
 Beginnend mit dem [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]kann ein Get-Vorgang eine Eigenschaft anstelle der aktuellen Ausgabe Codierung der Konsole einen zwischengespeicherten Wert zurückgeben. Dies kann vorkommen, wenn der Wert der <xref:System.Console.OutputEncoding%2A>-Eigenschaft durch andere Mittel als eine Zuweisung zur <xref:System.Console.OutputEncoding%2A> Eigenschaft geändert wird, z. b. beim Aufrufen der Windows `SetConsoleOutputCP`-Funktion.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Eigenschaftswert in einer Set-Operation ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Während der Ausführung dieses Vorgangs ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.Security.SecurityException">Ihre Anwendung verfügt nicht über die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Lese-und Schreibvorgänge für Windows und untergeordnete Fenster der obersten Ebene.  Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Von den Unicode-Codierungen unterstützt die <see cref="T:System.Console" />-Klasse die UTF-8-Codierung mit der <see cref="T:System.Text.UTF8Encoding" />-Klasse und beginnend mit dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)]die UTF-16-Codierung mit der <see cref="T:System.Text.UnicodeEncoding" />-Klasse. UTF-32-Codierung mit der <see cref="T:System.Text.UTF32Encoding" />-Klasse wird nicht unterstützt. Beim Versuch, die Ausgabe Codierung auf UTF-32 festzulegen, wird eine <see cref="T:System.IO.IOException" />ausgelöst.  
  
Beachten Sie, dass bei der erfolgreichen Anzeige von Unicode-Zeichen in der Konsole Folgendes erforderlich ist: 
-Die-Konsole muss eine TrueType-Schriftart wie Lucida Console oder Consolas zum Anzeigen von Zeichen verwenden.  
  
-Eine von der-Konsole verwendete Schriftart muss das jeweilige Symbol oder die Symbole definieren, die angezeigt werden sollen. Die-Konsole kann die Schriftart Verknüpfung nutzen, um Symbole aus verknüpften Schriftarten anzuzeigen, wenn die Basis Schriftart keine Definition für das Symbol enthält.  
  
Weitere Informationen zur Unterstützung der Unicode-Codierung durch die-Konsole finden Sie im Abschnitt "Unicode-Unterstützung für die-Konsole" in der <see cref="T:System.Console" />-Klasse.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Read" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Read();" />
      <MemberSignature Language="F#" Value="static member Read : unit -&gt; int" Usage="System.Console.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das nächste Zeichen aus dem Standardeingabestream.</summary>
        <returns>Das nächste Zeichen aus dem Eingabestream bzw. -1, wenn derzeit keine weiteren Zeichen gelesen werden können.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Console.Read%2A>-Methode blockiert deren Rückgabe, während Sie Eingabezeichen eingeben. Sie wird beendet, wenn Sie die <xref:System.ConsoleKey.Enter> Taste drücken. Durch Drücken der EINGABETASTE wird eine Platt Form abhängige Zeilen Beendigungs Sequenz an Ihre Eingabe angehängt (z. b. fügt Windows eine Wagen Rücklauf-Zeilenvorschub Sequenz an). Bei nachfolgenden Aufrufen der <xref:System.Console.Read%2A>-Methode werden die Eingaben jeweils ein Zeichen abgerufen. Nachdem das endgültige Zeichen abgerufen wurde, wird die Rückgabe <xref:System.Console.Read%2A> blockiert, und der Durchlauf wird wiederholt.  
  
> [!IMPORTANT]
>  Die <xref:System.Console.ReadLine%2A>-Methode oder die <xref:System.Console.KeyAvailable%2A>-Eigenschaft und <xref:System.Console.ReadKey%2A>-Methode sind der Verwendung der <xref:System.Console.Read%2A>-Methode vorzuziehen.  
  
 Beachten Sie, dass die-Methode nicht-1 zurückgibt, es sei denn, Sie führen eine der folgenden Aktionen aus:  
  
-   Drücken Sie gleichzeitig die <xref:System.ConsoleModifiers.Control> Modifizierertaste und <xref:System.ConsoleKey.Z> Konsolen Taste (STRG + Z), wodurch die dateiendebedingung signalisiert wird.  
  
-   Drücken Sie einen entsprechenden Schlüssel, der die dateiendebedingung anzeigt, z. b. den F6-Funktionsschlüssel in Windows.  
  
-   Leiten Sie den Eingabedaten Strom an eine Quelle, z. b. eine Textdatei, mit einem tatsächlichen Dateiendezeichen um.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Console.Read%2A> Methode.  
  
 [!code-cpp[console.read#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.read/CPP/read.cpp#1)]
 [!code-csharp[console.read#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.read/CS/read.cs#1)]
 [!code-vb[console.read#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.read/VB/read.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadKey">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die nächste vom Benutzer gedrückte Zeichen- oder Funktionstaste ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public static ConsoleKeyInfo ReadKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ConsoleKeyInfo ReadKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadKey () As ConsoleKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ConsoleKeyInfo ReadKey();" />
      <MemberSignature Language="F#" Value="static member ReadKey : unit -&gt; ConsoleKeyInfo" Usage="System.Console.ReadKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die nächste vom Benutzer gedrückte Zeichen- oder Funktionstaste ab. Die gedrückte Taste wird im Konsolenfenster angezeigt.</summary>
        <returns>Ein Objekt, das die <see cref="T:System.ConsoleKey" />-Konstante und ggf. das Unicode-Zeichen beschreibt, die der gedrückten Konsolentaste entsprechen. Das <see cref="T:System.ConsoleKeyInfo" />-Objekt beschreibt außerdem in einer bitweisen Kombination von <see cref="T:System.ConsoleModifiers" />-Werten, ob eine oder mehrere der Modifizierertasten UMSCHALTTASTE, ALT oder STRG gleichzeitig mit der Konsolentaste gedrückt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Console.ReadKey%2A>-Methode wartet, d. h. Blöcke auf dem Thread, der die <xref:System.Console.ReadKey%2A>-Methode ausgibt, bis ein Zeichen oder eine Funktionstaste gedrückt wird. Ein Zeichen-oder Funktionsschlüssel kann in Kombination mit einem oder mehreren alt-, STRG-oder UMSCHALT-modifiziererschlüsseln gedrückt werden. Wenn Sie jedoch eine Modifizierertaste allein drücken, wird die <xref:System.Console.ReadKey%2A>-Methode nicht zurückgegeben.  
  
 Abhängig von Ihrer Anwendung können Sie die <xref:System.Console.ReadKey%2A>-Methode in Verbindung mit der <xref:System.Console.KeyAvailable%2A>-Eigenschaft verwenden.  
  
 Die <xref:System.Console.ReadKey%2A>-Methode liest von der Tastatur, auch wenn die Standardeingabe mit der <xref:System.Console.SetIn%2A>-Methode zu einer Datei umgeleitet wird.  
  
   
  
## Examples  
 Eine der häufigsten Verwendungsmöglichkeiten der <xref:System.Console.ReadKey>-Methode besteht darin, die Programmausführung anzuhalten, bis der Benutzer eine Taste drückt und die APP entweder beendet wird oder ein zusätzliches Informationsfenster anzeigt. Im folgenden Beispiel wird die <xref:System.Console.ReadKey>-Methode verwendet, um zu warten, bis der Benutzer die EINGABETASTE drückt, bevor die APP beendet wird.  
  
 [!code-csharp[System.Console.ReadKey#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Console.ReadKey/cs/ReadKey1.cs#1)]
 [!code-vb[System.Console.ReadKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Console.ReadKey/vb/ReadKey1.vb#1)]  
  
 Beachten Sie, dass bei dieser Überladung der <xref:System.Console.ReadKey%2A>-Methode standardmäßig alle anzeigbaren Schlüssel, die der Benutzer auf die Konsole drückt, wiederholt werden. Um diese zu unterdrücken, müssen Sie die <xref:System.Console.ReadKey%2A>-Methode mit einem `intercept`-Argument von `true`abrufen.  
  
 Im folgenden Beispiel wird die <xref:System.Console.ReadKey>-Methode verwendet, um Informationen über den Schlüssel anzuzeigen, den der Benutzer gedrückt hat. 
  
 [!code-cpp[console.readkey1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey1/CPP/rk.cpp#1)]
 [!code-csharp[console.readkey1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey1/CS/rk.cs#1)]
 [!code-vb[console.readkey1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey1/VB/rk.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Console.In" />-Eigenschaft wird von einem anderen Stream als der Konsole umgeleitet.</exception>
        <altmember cref="T:System.ConsoleKey" />
        <altmember cref="P:System.Console.KeyAvailable" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public static ConsoleKeyInfo ReadKey (bool intercept);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ConsoleKeyInfo ReadKey(bool intercept) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadKey(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadKey (intercept As Boolean) As ConsoleKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ConsoleKeyInfo ReadKey(bool intercept);" />
      <MemberSignature Language="F#" Value="static member ReadKey : bool -&gt; ConsoleKeyInfo" Usage="System.Console.ReadKey intercept" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intercept" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="intercept">Bestimmt, ob die gedrückte Taste im Konsolenfenster angezeigt werden soll. <see langword="true" />, wenn die gedrückte Taste nicht angezeigt werden soll, andernfalls <see langword="false" />.</param>
        <summary>Ruft die nächste vom Benutzer gedrückte Zeichen- oder Funktionstaste ab. Die gedrückte Taste wird optional im Konsolenfenster angezeigt.</summary>
        <returns>Ein Objekt, das die <see cref="T:System.ConsoleKey" />-Konstante und ggf. das Unicode-Zeichen beschreibt, die der gedrückten Konsolentaste entsprechen. Das <see cref="T:System.ConsoleKeyInfo" />-Objekt beschreibt außerdem in einer bitweisen Kombination von <see cref="T:System.ConsoleModifiers" />-Werten, ob eine oder mehrere der Modifizierertasten UMSCHALTTASTE, ALT oder STRG gleichzeitig mit der Konsolentaste gedrückt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Console.ReadKey%2A>-Methode wartet, d. h. Blöcke auf dem Thread, der die <xref:System.Console.ReadKey%2A>-Methode ausgibt, bis ein Zeichen oder eine Funktionstaste gedrückt wird. Ein Zeichen-oder Funktionsschlüssel kann in Kombination mit einem oder mehreren alt-, STRG-oder UMSCHALT-modifiziererschlüsseln gedrückt werden. Wenn Sie jedoch eine Modifizierertaste allein drücken, wird die <xref:System.Console.ReadKey%2A>-Methode nicht zurückgegeben.  
  
 Wenn der `intercept`-Parameter `true`ist, wird die gedrückte Taste abgefangen und nicht im Konsolenfenster angezeigt. Andernfalls wird die gedrückte Taste angezeigt.  
  
 Abhängig von Ihrer Anwendung können Sie die <xref:System.Console.ReadKey%2A>-Methode in Verbindung mit der <xref:System.Console.KeyAvailable%2A>-Eigenschaft verwenden.  
  
 Die <xref:System.Console.ReadKey%2A>-Methode liest von der Tastatur, auch wenn die Standardeingabe mit der <xref:System.Console.SetIn%2A>-Methode zu einer Datei umgeleitet wird.  
  
   
  
## Examples  
 Eine der häufigsten Verwendungsmöglichkeiten der <xref:System.Console.ReadKey%2A>-Methode besteht darin, die Programmausführung anzuhalten, bis der Benutzer eine Taste drückt und die APP entweder beendet wird oder ein zusätzliches Informationsfenster anzeigt. Im folgenden Beispiel wird die <xref:System.Console.ReadKey%28System.Boolean%29>-Methode verwendet, um zu warten, bis der Benutzer die EINGABETASTE drückt, bevor die APP beendet wird. Beachten Sie Folgendes: Wenn der Benutzer einen anderen Schlüssel drückt, wird er nicht in der Konsole angezeigt.  
  
 [!code-csharp[System.Console.ReadKey#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Console.ReadKey/cs/ReadKey2.cs#2)]
 [!code-vb[System.Console.ReadKey#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Console.ReadKey/vb/ReadKey2.vb#2)]  
  
 Im folgenden Beispiel wird die <xref:System.Console.ReadKey%28System.Boolean%29>-Methode verwendet, um Informationen über den von einem Benutzer gedrückten Schlüssel anzuzeigen, ohne diesen Schlüssel an der Konsole wiederzugeben.  
  
 [!code-cpp[console.readkey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey2/CPP/rkbool.cpp#1)]
 [!code-csharp[console.readkey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey2/CS/rkbool.cs#1)]
 [!code-vb[console.readkey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey2/VB/rkbool.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Console.In" />-Eigenschaft wird von einem anderen Stream als der Konsole umgeleitet.</exception>
        <altmember cref="T:System.ConsoleKey" />
        <altmember cref="P:System.Console.KeyAvailable" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public static string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="static member ReadLine : unit -&gt; string" Usage="System.Console.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest die nächste Zeile von Zeichen aus dem Standardeingabestream.</summary>
        <returns>Die nächste Zeile von Zeichen aus dem Eingabestream oder <see langword="null" />, wenn keine weiteren Zeilen verfügbar sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Console.ReadLine%2A>-Methode liest eine Zeile aus dem Standardeingabestream. (Die Definition einer Zeile finden Sie im Absatz nach der folgenden Liste.) Dies bedeutet Folgendes:  
  
-   Wenn das Standardeingabe Gerät die Tastatur ist, wird die <xref:System.Console.ReadLine%2A>-Methode blockiert, bis der Benutzer die **Eingabe** Taste drückt.  
  
     Eine der gängigsten Verwendungsmöglichkeiten der <xref:System.Console.ReadLine%2A>-Methode besteht darin, die Programmausführung anzuhalten, bevor die Konsole gelöscht und neue Informationen angezeigt werden. Alternativ können Sie den Benutzer auffordern, die Eingabetaste zu drücken, bevor Sie die Anwendung beenden. Das folgende Beispiel veranschaulicht dies.  
  
     [!code-cpp[System.Console.ReadLine#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.ReadLine/cpp/ReadLineSimple.cpp#6)]
     [!code-csharp[System.Console.ReadLine#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLineSimple.cs#6)]
     [!code-vb[System.Console.ReadLine#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLineSimple.vb#6)]  
  
-   Wenn die Standardeingabe an eine Datei umgeleitet wird, liest die <xref:System.Console.ReadLine%2A>-Methode eine Textzeile aus einer Datei. Beispielsweise ist Folgendes eine Textdatei mit dem Namen ReadLine1. txt:  
  
    ```  
  
    This is the first line.  
    This is the second line.  
    This is the third line.  
    This is the fourth line.  
  
    ```  
  
     Im folgenden Beispiel wird die <xref:System.Console.ReadLine%2A>-Methode verwendet, um Eingaben zu lesen, die aus einer Datei umgeleitet werden. Der Lesevorgang wird beendet, wenn die Methode `null`zurückgibt, wodurch angegeben wird, dass keine Zeilen gelesen werden sollen.  
  
     [!code-csharp[System.Console.ReadLine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLine3.cs#3)]
     [!code-vb[System.Console.ReadLine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLine3.vb#3)]  
  
     Nachdem Sie das Beispiel in eine ausführbare Datei mit dem Namen ReadLine1. exe kompiliert haben, können Sie es über die Befehlszeile mit der Syntax ausführen.  
  
    ```  
    ReadLine1 < ReadLine1.txt  
    ```  
  
     , um den Inhalt der Datei zu lesen und in der Konsole anzuzeigen.  
  
 Eine Zeile wird als Sequenz von Zeichen, gefolgt von einem Wagen Rücklauf Zeichen (hexadezimal 0x000d), einem Zeilenvorschub (hexadezimal 0x000a) oder dem Wert der <xref:System.Environment.NewLine%2A?displayProperty=nameWithType>-Eigenschaft definiert. Die zurückgegebene Zeichenfolge enthält nicht die abschließenden (n) Zeichen. Standardmäßig liest die-Methode Eingaben aus einem 256-Zeichen-Eingabepuffer. Da dies die <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> Zeichen enthält, kann die-Methode Zeilen lesen, die bis zu 254 Zeichen enthalten. Um längere Zeilen zu lesen, müssen Sie die <xref:System.Console.OpenStandardInput%28System.Int32%29>-Methode abrufen.  
  
 Die <xref:System.Console.ReadLine%2A>-Methode wird synchron ausgeführt. Das heißt, es wird blockiert, bis eine Zeile gelesen oder die Tastenkombination STRG + Z gedrückt ist. Die <xref:System.Console.In%2A>-Eigenschaft gibt ein <xref:System.IO.TextReader> Objekt zurück, das den Standardeingabestream darstellt und sowohl eine synchrone <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType>-Methode als auch eine asynchrone <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType>-Methode aufweist. Wenn jedoch als Standardeingabestream der Konsole verwendet wird, wird der <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType> synchron statt asynchron ausgeführt und gibt erst dann eine `Task<String>` zurück, nachdem der Lesevorgang abgeschlossen wurde.  
  
 Wenn diese Methode eine <xref:System.OutOfMemoryException> Ausnahme auslöst, wird die Position des Readers im zugrunde liegenden <xref:System.IO.Stream> Objekt um die Anzahl der Zeichen erweitert, die von der Methode gelesen werden konnten, aber die bereits in den internen <xref:System.Console.ReadLine%2A> Puffer gelesenen Zeichen werden verworfen. Da die Position des Readers im Stream nicht geändert werden kann, können die bereits gelesenen Zeichen nicht wieder hergestellt werden, und der Zugriff ist nur möglich, wenn die <xref:System.IO.TextReader>erneut initialisiert wird. Wenn die ursprüngliche Position innerhalb des Streams unbekannt ist oder der Stream keine Suchvorgänge unterstützt, muss die zugrunde liegende <xref:System.IO.Stream> ebenfalls erneut initialisiert werden. Um eine solche Situation zu vermeiden und robusten Code zu liefern, sollten Sie die <xref:System.Console.KeyAvailable%2A>-Eigenschaft und <xref:System.Console.ReadKey%2A>-Methode verwenden und die Lesezeichen in einem vorab zugeordneten Puffer speichern.  
  
 Wenn das STRG + Z-Zeichen gedrückt wird, wenn die Methode Eingaben aus der Konsole liest, gibt die Methode `null`zurück. Dadurch kann der Benutzer weitere Tastatureingaben verhindern, wenn die <xref:System.Console.ReadLine%2A>-Methode in einer-Schleife aufgerufen wird. Dieses Szenario wird im folgenden Beispiel veranschaulicht.  
  
 [!code-cpp[System.Console.ReadLine#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.ReadLine/cpp/readline2.cpp#1)]
 [!code-csharp[System.Console.ReadLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLine2.cs#1)]
 [!code-vb[System.Console.ReadLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLine2.vb#1)]  
  
   
  
## Examples  
 Im folgenden Beispiel sind zwei Befehlszeilenargumente erforderlich: der Name einer vorhandenen Textdatei und der Name einer Datei, in die die Ausgabe geschrieben werden soll. Die vorhandene Textdatei wird geöffnet, und die Standardeingabe wird von der Tastatur an die Datei umgeleitet. Außerdem wird die Standardausgabe von der Konsole an die Ausgabedatei umgeleitet. Anschließend verwendet er die <xref:System.Console.ReadLine%2A?displayProperty=nameWithType>-Methode, um jede Zeile in der Datei zu lesen, ersetzt jede Sequenz von vier Leerzeichen durch ein Tabstopp Zeichen und verwendet die <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>-Methode, um das Ergebnis in die Ausgabedatei zu schreiben.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Speicher vorhanden, um einen Puffer für die zurückgegebene Zeichenfolge zuzuordnen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Anzahl der Zeichen in der nächsten Zeile von Zeichen ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="ResetColor">
      <MemberSignature Language="C#" Value="public static void ResetColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ResetColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetColor();" />
      <MemberSignature Language="F#" Value="static member ResetColor : unit -&gt; unit" Usage="System.Console.ResetColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt die Vordergrund- und Hintergrundkonsolenfarben auf die entsprechenden Standardwerte fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Vordergrund-und Hintergrundfarben werden in den Farben wieder hergestellt, die beim Beginn des aktuellen Prozesses vorhanden waren. Weitere Informationen finden Sie unter den Eigenschaften <xref:System.Console.ForegroundColor%2A> und <xref:System.Console.BackgroundColor%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Werte der <xref:System.ConsoleColor>-Enumeration in einem Array gespeichert und die aktuellen Werte der <xref:System.Console.BackgroundColor%2A> und <xref:System.Console.ForegroundColor%2A> Eigenschaften in Variablen gespeichert. Anschließend ändert Sie die Vordergrundfarbe in jede Farbe in der <xref:System.ConsoleColor> Enumeration außer der Farbe, die mit dem aktuellen Hintergrund übereinstimmt, und ändert die Hintergrundfarbe in jede Farbe in der <xref:System.ConsoleColor> Enumeration außer der Farbe, die mit dem aktuellen Vordergrund übereinstimmt. (Wenn die Vordergrundfarbe mit der Hintergrundfarbe identisch ist, ist der Text nicht sichtbar.) Zum Schluss ruft Sie die <xref:System.Console.ResetColor%2A>-Methode auf, um die ursprünglichen Konsolen Farben wiederherzustellen.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigung, um diese Aktion durchzuführen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetBufferSize">
      <MemberSignature Language="C#" Value="public static void SetBufferSize (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBufferSize(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetBufferSize(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetBufferSize (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBufferSize(int width, int height);" />
      <MemberSignature Language="F#" Value="static member SetBufferSize : int * int -&gt; unit" Usage="System.Console.SetBufferSize (width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="height" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="width">Die Breite des Pufferbereichs in Spalten.</param>
        <param name="height">Die Höhe des Pufferbereichs in Zeilen.</param>
        <summary>Legt die Höhe und die Breite des Bildschirmpufferbereichs auf die angegebenen Werte fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel werden die Eigenschaften <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>und <xref:System.Console.CursorVisible%2A> veranschaulicht. und die Methoden <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>und <xref:System.Console.ReadKey%2A>. Im Beispiel wird ein Raster Muster basierend auf der Bildschirm Puffer Breite im Bildschirm Puffer gezeichnet. Im Beispiel wird das Konsolenfenster in Reaktion darauf verschoben, welche der nach-oben-Taste, nach-unten-Taste, nach-links-Taste oder nach-rechts-Taste gedrückt wird. Mit dem Raster Muster können Sie die Bewegung des Konsolenfensters relativ zum Bildschirm Puffer erkennen.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
 [!code-fsharp[console.windowLT#1](~/samples/snippets/fsharp/VS_Snippets_CLR/console.windowLT/FS/wlt.fs#1)] 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="height" /> oder <paramref name="width" /> ist kleiner oder gleich 0 (null).  
  
- oder - 
 <paramref name="height" /> oder <paramref name="width" /> ist größer oder gleich <see cref="F:System.Int16.MaxValue" />.  
  
- oder - 
 <paramref name="width" /> ist kleiner als <see cref="P:System.Console.WindowLeft" /> + <see cref="P:System.Console.WindowWidth" />  
  
- oder - 
 <paramref name="height" /> ist kleiner als <see cref="P:System.Console.WindowTop" /> + <see cref="P:System.Console.WindowHeight" /></exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigung, um diese Aktion durchzuführen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCursorPosition">
      <MemberSignature Language="C#" Value="public static void SetCursorPosition (int left, int top);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCursorPosition(int32 left, int32 top) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetCursorPosition(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCursorPosition (left As Integer, top As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCursorPosition(int left, int top);" />
      <MemberSignature Language="F#" Value="static member SetCursorPosition : int * int -&gt; unit" Usage="System.Console.SetCursorPosition (left, top)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="top" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Die Spaltenposition des Cursors. Spalten werden von links nach rechts beginnend mit 0 nummeriert.</param>
        <param name="top">Die Zeilenposition des Cursors. Zeilen werden von oben nach unten nummeriert und beginnen mit 0.</param>
        <summary>Legt die Position des Cursors fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Console.SetCursorPosition%2A>-Methode, um anzugeben, wo der nächste Schreibvorgang im Konsolenfenster beginnen soll. Wenn die angegebene Cursorposition außerhalb des Bereichs liegt, der derzeit im Konsolenfenster sichtbar ist, wird der Fenster Ursprung automatisch geändert, um den Cursor sichtbar zu machen.  
  
 Der Cursor wechselt automatisch zur nächsten Zeichenposition, wenn ein Zeichen in das Konsolenfenster geschrieben wird. Wenn sich der Cursor in der unteren rechten Zeichenposition des Konsolenfensters befindet, bewirkt der nächste Schreibvorgang, dass das Konsolenfenster einen Bildlauf durchführen kann, sodass der Cursor sichtbar bleibt. Wenn Sie ein Zeichen an die untere rechte Zeichenposition schreiben möchten, ohne dass im Konsolenfenster ein Bildlauf durchgeführt werden soll, verwenden Sie die <xref:System.Console.MoveBufferArea%2A>-Methode, um ein Zeichen an diese Position zu verschieben.  
  
   
  
## Examples  
 In diesem Beispiel werden die Eigenschaften <xref:System.Console.CursorLeft%2A> und <xref:System.Console.CursorTop%2A> sowie die Methoden <xref:System.Console.SetCursorPosition%2A> und <xref:System.Console.Clear%2A> veranschaulicht. Im Beispiel wird der Cursor positioniert, der bestimmt, wo der nächste Schreibvorgang ausgeführt wird, um mit einer Kombination aus den Zeichen folgen "+", "&#124;" und "-" ein 5 Zeichen um 5 Zeichen zu zeichnen. Beachten Sie, dass das Rechteck mit weniger Schritten gezeichnet werden kann, indem eine Kombination aus anderen Zeichen folgen verwendet wird.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="left" /> oder <paramref name="top" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="left" /> ist größer gleich <see cref="P:System.Console.BufferWidth" />.  
  
- oder - 
 <paramref name="top" /> ist größer gleich <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigung, um diese Aktion durchzuführen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetError">
      <MemberSignature Language="C#" Value="public static void SetError (System.IO.TextWriter newError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetError(class System.IO.TextWriter newError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetError(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetError (newError As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetError(System::IO::TextWriter ^ newError);" />
      <MemberSignature Language="F#" Value="static member SetError : System.IO.TextWriter -&gt; unit" Usage="System.Console.SetError newError" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newError" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="newError">Ein Datenstrom, der die neue Standardfehlerausgabe darstellt.</param>
        <summary>Legt die <see cref="P:System.Console.Error" />-Eigenschaft auf den angegebenen <see cref="T:System.IO.TextWriter" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig wird die <xref:System.Console.Error%2A>-Eigenschaft auf den standardfehlerausgabestream festgelegt.  
  
 Eine <xref:System.IO.StreamWriter>, die eine <xref:System.IO.FileStream> kapselt, kann zum Senden von Fehlermeldungen an eine Datei verwendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie der Standardfehlerstream in eine Datei umgeleitet wird.  
  
 [!code-cpp[System.Console.SetError#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.SetError/cpp/seterror1.cpp#1)]
 [!code-csharp[System.Console.SetError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.SetError/cs/SetError1.cs#1)]
 [!code-vb[System.Console.SetError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.SetError/vb/SetError1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newError" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwaltetem Code. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="P:System.Console.Error" />
      </Docs>
    </Member>
    <Member MemberName="SetIn">
      <MemberSignature Language="C#" Value="public static void SetIn (System.IO.TextReader newIn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIn(class System.IO.TextReader newIn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetIn(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetIn (newIn As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetIn(System::IO::TextReader ^ newIn);" />
      <MemberSignature Language="F#" Value="static member SetIn : System.IO.TextReader -&gt; unit" Usage="System.Console.SetIn newIn" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newIn" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="newIn">Ein Datenstrom, der die neue Standardeingabe darstellt.</param>
        <summary>Legt die <see cref="P:System.Console.In" />-Eigenschaft auf den angegebenen <see cref="T:System.IO.TextReader" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig wird die <xref:System.Console.In%2A>-Eigenschaft auf den Standardeingabestream festgelegt.  
  
 Eine <xref:System.IO.StreamReader>, die eine <xref:System.IO.FileStream> kapselt, kann zum Empfangen von Eingaben aus einer Datei verwendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Console.SetIn%2A>-Methode veranschaulicht. Hierdurch werden vier aufeinander folgende Leerzeichen in einer Zeichenfolge durch ein Tabstoppzeichen ersetzt. Um es auszuführen, müssen Sie zwei Befehlszeilenargumente angeben. Das erste ist der Name einer vorhandenen Textdatei, in die der Standardeingabestream umgeleitet wird. Das zweite ist der Name einer Datei, in die der Standardausgabestream umgeleitet wird. Diese Datei muss nicht vorhanden sein. Wenn das der Fall ist, wird der Inhalt überschrieben.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newIn" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwaltetem Code. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.TextReader" />
        <altmember cref="P:System.Console.In" />
      </Docs>
    </Member>
    <Member MemberName="SetOut">
      <MemberSignature Language="C#" Value="public static void SetOut (System.IO.TextWriter newOut);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetOut(class System.IO.TextWriter newOut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetOut(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetOut (newOut As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetOut(System::IO::TextWriter ^ newOut);" />
      <MemberSignature Language="F#" Value="static member SetOut : System.IO.TextWriter -&gt; unit" Usage="System.Console.SetOut newOut" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newOut" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="newOut">Ein Textwriter, der als neue Standardausgabe verwendet werden soll.</param>
        <summary>Legt die <see cref="P:System.Console.Out" />-Eigenschaft fest, die auf das <see cref="T:System.IO.TextWriter" />-Objekt ausgerichtet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig wird die <xref:System.Console.Out%2A>-Eigenschaft auf den Standardausgabestream festgelegt.  
  
 Eine <xref:System.IO.StreamWriter>, die eine <xref:System.IO.FileStream> kapselt, kann verwendet werden, um die Ausgabe an eine Datei zu senden. Beispiel:  
  
 [!code-cpp[System.Console.SetOut#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.setout/cpp/source.cpp#1)]
 [!code-csharp[System.Console.SetOut#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.setout/cs/source.cs#1)]
 [!code-vb[System.Console.SetOut#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.setout/vb/source.vb#1)]  
  
 Das tatsächliche Objekt, das von <xref:System.Console.Out%2A> zurückgegeben wird, kann ein synchronisierter Wrapper um den bereitgestellten TextWriter sein.
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Console.SetOut%2A>-Methode veranschaulicht. Hierdurch werden vier aufeinander folgende Leerzeichen in einer Zeichenfolge durch ein Tabstoppzeichen ersetzt. Um es auszuführen, müssen Sie zwei Befehlszeilenargumente angeben. Das erste ist der Name einer vorhandenen Textdatei, in die der Standardeingabestream umgeleitet wird. Das zweite ist der Name einer Datei, in die der Standardausgabestream umgeleitet wird. Diese Datei muss nicht vorhanden sein. Wenn das der Fall ist, wird der Inhalt überschrieben.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newOut" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwaltetem Code. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="P:System.Console.Out" />
      </Docs>
    </Member>
    <Member MemberName="SetWindowPosition">
      <MemberSignature Language="C#" Value="public static void SetWindowPosition (int left, int top);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetWindowPosition(int32 left, int32 top) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetWindowPosition(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetWindowPosition (left As Integer, top As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetWindowPosition(int left, int top);" />
      <MemberSignature Language="F#" Value="static member SetWindowPosition : int * int -&gt; unit" Usage="System.Console.SetWindowPosition (left, top)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="top" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Die Spaltenposition der linken oberen Ecke des Konsolenfensters.</param>
        <param name="top">Die Zeilenposition der linken oberen Ecke des Konsolenfensters.</param>
        <summary>Legt die Position des Konsolenfensters relativ zum Bildschirmpuffer fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Fenster Betriebssystem wird das Konsolenfenster angezeigt, und im Konsolenfenster wird ein Teil des Bildschirm Puffers angezeigt. Die <xref:System.Console.SetWindowPosition%2A>-Methode wirkt sich auf die Position des Konsolenfensters relativ zum Bildschirm Puffer aus, wirkt sich jedoch nicht auf die Position des Betriebssystem Fensters relativ zum Desktop aus.  
  
 Die Konsolen-und Betriebssystemfenster wirken sich in der Regel nicht gegenseitig aus. Wenn der Bildschirm Puffer jedoch nicht in den aktuellen Grenzen des Konsolenfensters angezeigt werden kann, fügt das Betriebssystem automatisch Schiebe leisten an das Betriebssystemfenster an. Wenn Sie in diesem Fall die Schiebe leisten des Betriebssystem Fensters verschieben, wirkt sich dies auf die Position des Konsolenfensters aus. Wenn Sie das Konsolenfenster mit der <xref:System.Console.SetWindowPosition%2A>-Methode bewegen, wirkt sich dies auf die Position der Scrollleisten des Betriebssystem Fensters aus  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Eigenschaften <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>und <xref:System.Console.CursorVisible%2A> veranschaulicht. und die Methoden <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>und <xref:System.Console.ReadKey%2A>. Im Beispiel wird ein Raster Muster basierend auf der Bildschirm Puffer Breite im Bildschirm Puffer gezeichnet. Im Beispiel wird das Konsolenfenster in Reaktion darauf verschoben, welche der nach-oben-Taste, nach-unten-Taste, nach-links-Taste oder nach-rechts-Taste gedrückt wird. Mit dem Raster Muster können Sie die Bewegung des Konsolenfensters relativ zum Bildschirm Puffer erkennen.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
 [!code-fsharp[console.windowLT#1](~/samples/snippets/fsharp/VS_Snippets_CLR/console.windowLT/FS/wlt.fs#1)] 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="left" /> oder <paramref name="top" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="left" /> + <see cref="P:System.Console.WindowWidth" /> ist größer als <see cref="P:System.Console.BufferWidth" />.  
  
- oder - 
 <paramref name="top" /> + <see cref="P:System.Console.WindowHeight" /> ist größer als <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigung, um diese Aktion durchzuführen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetWindowSize">
      <MemberSignature Language="C#" Value="public static void SetWindowSize (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetWindowSize(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetWindowSize(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetWindowSize (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetWindowSize(int width, int height);" />
      <MemberSignature Language="F#" Value="static member SetWindowSize : int * int -&gt; unit" Usage="System.Console.SetWindowSize (width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="height" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="width">Die Breite des Konsolenfensters in Spalten.</param>
        <param name="height">Die Höhe des Konsolenfensters in Zeilen.</param>
        <summary>Legt die Höhe und die Breite des Konsolenfensters auf die angegebenen Werte fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In diesem Beispiel werden die <xref:System.Console.SetWindowSize%2A>-Methode und die Eigenschaften <xref:System.Console.WindowWidth%2A> und <xref:System.Console.WindowHeight%2A> veranschaulicht. Sie müssen das Beispiel ausführen, um die vollständige Auswirkung der Änderung der Größe des Konsolenfensters anzuzeigen.  
  
 Im Beispiel werden die Dimensionen eines Konsolenfensters, das auf 85-Spalten und 43 Zeilen festgelegt ist, und dann auf das Drücken einer Taste gewartet. Wenn eine Taste gedrückt wird, werden die Abmessungen des Konsolenfensters halbiert, die neuen Dimensionen werden gemeldet, und das Beispiel wartet auf einen anderen Tastendruck. Wenn eine Taste gedrückt wird, wird das Konsolenfenster in seinen ursprünglichen Dimensionen wieder hergestellt, und das Beispiel wird beendet.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="width" /> oder <paramref name="height" /> ist kleiner oder gleich 0 (null).  
  
- oder - 
 <paramref name="width" /> plus <see cref="P:System.Console.WindowLeft" /> oder <paramref name="height" /> plus <see cref="P:System.Console.WindowTop" /> ist größer oder gleich <see cref="F:System.Int16.MaxValue" />.  
  
- oder - 
 <paramref name="width" /> oder <paramref name="height" /> ist größer als die größtmögliche Fensterbreite oder -höhe für die aktuelle Bildschirmauflösung und Konsolenschriftart.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigung, um diese Aktion durchzuführen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public static string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string Title" />
      <MemberSignature Language="DocId" Value="P:System.Console.Title" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Console.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den auf der Konsolentitelleiste anzuzeigenden Titel ab oder legt diesen fest.</summary>
        <value>Die Zeichenfolge, die auf der Titelleiste der Konsole angezeigt werden soll. Die maximale Länge der Titelzeichenfolge beträgt 24500 Zeichen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In diesem Beispiel wird die <xref:System.Console.Title%2A>-Eigenschaft veranschaulicht. Das Beispiel zeigt den aktuellen Titel des Betriebssystem Fensters an, wartet auf einen Tastendruck und zeigt dann einen neuen Titel an.  
  
 [!code-cpp[console.title#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.title/CPP/mytitle.cpp#1)]
 [!code-csharp[console.title#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.title/CS/mytitle.cs#1)]
 [!code-vb[console.title#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.title/VB/mytitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">In einem Get-Vorgang umfasst der abgerufene Titel mehr als 24500 Zeichen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">In einem Set-Vorgang umfasst der angegebene Titel mehr als 24500 Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException">In einem Set-Vorgang ist der angegebene Titel <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der get-Vorgang wird unter einem anderen Betriebssystem als Windows aufgerufen.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TreatControlCAsInput">
      <MemberSignature Language="C#" Value="public static bool TreatControlCAsInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool TreatControlCAsInput" />
      <MemberSignature Language="DocId" Value="P:System.Console.TreatControlCAsInput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property TreatControlCAsInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool TreatControlCAsInput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TreatControlCAsInput : bool with get, set" Usage="System.Console.TreatControlCAsInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt diesen fest, der angibt, ob die Kombination der <see cref="F:System.ConsoleModifiers.Control" />-Modifizierertaste und der <see cref="F:System.ConsoleKey.C" />-Konsolentaste (STRG+C) als normale Eingabe oder als vom Betriebssystem zu behandelnde Unterbrechung behandelt wird.</summary>
        <value><see langword="true" />, wenn STRG+C als normale Eingabe behandelt wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert der <xref:System.Console.TreatControlCAsInput%2A>-Eigenschaft `false` und STRG + C gedrückt ist, werden die gedrückten Tasten nicht im Eingabepuffer gespeichert, und das Betriebssystem beendet den aktuell ausgeführten Prozess. Dies ist der Standardwert.  
  
> [!CAUTION]
>  Verwenden Sie diese Eigenschaft mit bedacht, da die Festlegung auf `true` eine derart dramatische Auswirkung hat. Die meisten Benutzer erwarten STRG + C, um eine Konsolenanwendung zu beenden. Wenn Sie die Auswirkung von STRG + C deaktivieren, muss der Benutzer daran denken, die Anwendung mit Strg + Pause zu beenden. Dies ist eine weniger vertraute Tastenkombination.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Console.TreatControlCAsInput%2A>-Eigenschaft veranschaulicht.  
  
 [!code-cpp[console.readkey1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey1/CPP/rk.cpp#1)]
 [!code-csharp[console.readkey1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey1/CS/rk.cs#1)]
 [!code-vb[console.readkey1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey1/VB/rk.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der Eingabemodus des Konsoleneingabepuffers kann weder abgerufen noch festgelegt werden.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="F:System.ConsoleModifiers.Control" />
        <altmember cref="F:System.ConsoleKey.C" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public static int WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowHeight : int with get, set" Usage="System.Console.WindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe des Konsolenfensterbereichs ab oder legt diese fest.</summary>
        <value>Die Höhe des Konsolenfensters in Zeilen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie versuchen, den Wert der <xref:System.Console.WindowHeight%2A>-Eigenschaft festzulegen, wenn die Ausgabe umgeleitet wird, wird entweder eine <xref:System.ArgumentOutOfRangeException> oder eine <xref:System.IO.IOException> Ausnahme ausgelöst. Um eine Ausnahme zu verhindern, können Sie den Wert dieser Eigenschaft nur festlegen, wenn die <xref:System.Console.IsOutputRedirected%2A>-Eigenschaft `false`zurückgibt.  
  
   
  
## Examples  
 In diesem Beispiel werden die <xref:System.Console.SetWindowSize%2A>-Methode und die Eigenschaften <xref:System.Console.WindowWidth%2A> und <xref:System.Console.WindowHeight%2A> veranschaulicht. Sie müssen das Beispiel ausführen, um die vollständige Auswirkung der Änderung der Größe des Konsolenfensters anzuzeigen.  
  
 Das Beispiel meldet die Abmessungen eines Konsolenfensters, das auf 85 Spalten und 43 Zeilen festgelegt ist, und wartet dann auf einen Tastendruck. Wenn eine Taste gedrückt wird, werden die Abmessungen des Konsolenfensters halbiert, die neuen Dimensionen werden gemeldet, und das Beispiel wartet auf einen anderen Tastendruck. Wenn eine Taste gedrückt wird, wird das Konsolenfenster in den ursprünglichen Dimensionen wieder hergestellt, und das Beispiel wird beendet.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert der <see cref="P:System.Console.WindowWidth" />-Eigenschaft oder der Wert der <see cref="P:System.Console.WindowHeight" />-Eigenschaft muss kleiner als oder gleich 0 sein.  
  
- oder - 
Der Wert der <see cref="P:System.Console.WindowHeight" />-Eigenschaft plus dem Wert der <see cref="P:System.Console.WindowTop" />-Eigenschaft muss größer als oder gleich <see cref="F:System.Int16.MaxValue" /> sein.  
  
- oder - 
Der Wert der <see cref="P:System.Console.WindowWidth" />-Eigenschaft oder der Wert der <see cref="P:System.Console.WindowHeight" />-Eigenschaft ist größer als die größtmögliche Fensterbreite oder -höhe für die aktuelle Bildschirmauflösung und Konsolenschriftart.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Lesen oder Schreiben von Informationen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der set-Vorgang wird unter einem anderen Betriebssystem als Windows aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowLeft">
      <MemberSignature Language="C#" Value="public static int WindowLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowLeft" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowLeft : int with get, set" Usage="System.Console.WindowLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die am weitesten links stehende Position des Konsolenfensterbereichs im Verhältnis zum Bildschirmpuffer ab oder legt diese fest.</summary>
        <value>Die am weitesten links stehende Konsolenfensterposition in Spalten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Konsole stellt ein rechteckiges Fenster in einem größeren rechteckigen Pufferbereich dar. Sowohl das Fenster als auch der Puffer werden vertikal anhand der Anzahl der Zeilen und der horizontalen Anzahl der Spalten gemessen. Die Abmessungen des Puffer Bereichs werden durch die Eigenschaften <xref:System.Console.BufferHeight%2A> und <xref:System.Console.BufferWidth%2A> definiert. Die Abmessungen des Konsolen Bereichs werden durch die Eigenschaften <xref:System.Console.WindowHeight%2A> und <xref:System.Console.WindowWidth%2A> definiert. Die <xref:System.Console.WindowLeft%2A>-Eigenschaft bestimmt, welche Spalte des Puffer Bereichs in der ersten Spalte des Konsolenfensters angezeigt wird. Der Wert der <xref:System.Console.WindowLeft%2A>-Eigenschaft kann zwischen 0 und <xref:System.Console.BufferWidth%2A> - <xref:System.Console.WindowWidth%2A>liegen. Wenn versucht wird, ihn auf einen Wert außerhalb dieses Bereichs festzulegen, wird eine <xref:System.ArgumentOutOfRangeException>ausgelöst.  
  
 Wenn ein Konsolenfenster zum ersten Mal geöffnet wird, ist der Standardwert der <xref:System.Console.WindowLeft%2A>-Eigenschaft 0 (null). Dies bedeutet, dass die erste Spalte, die von der Konsole angezeigt wird, der ersten Spalte (der Spalte an der Position 0) im Pufferbereich entspricht. Die Standardbreite des Konsolenfensters und des Puffer Bereichs beträgt 80 Spalten. Dies bedeutet, dass die <xref:System.Console.WindowLeft%2A>-Eigenschaft nur geändert werden kann, wenn das Konsolenfenster schmaler geworden ist oder der Pufferbereich breiter ist.  
  
 Wenn die Breite des Puffer Bereichs die Breite des Konsolenfensters überschreitet, wird der Wert der <xref:System.Console.WindowLeft%2A>-Eigenschaft automatisch angepasst, wenn der Benutzer die horizontale Schiebe Leiste verwendet, um die Beziehung des Fensters zum Pufferbereich zu definieren.  
  
 Wenn Sie versuchen, den Wert der <xref:System.Console.WindowLeft%2A>-Eigenschaft festzulegen, wenn die Ausgabe umgeleitet wird, wird eine <xref:System.IO.IOException> Ausnahme ausgelöst. Um die Ausnahme zu verhindern, können Sie den Wert dieser Eigenschaft nur festlegen, wenn die <xref:System.Console.IsOutputRedirected%2A>-Eigenschaft `false`zurückgibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein 80-spaltige Konsolenfenster geöffnet, und es wird ein Pufferbereich definiert, der 120 Spalten breit ist. Er zeigt Informationen über die Fenster-und Puffergröße an und wartet dann darauf, dass der Benutzer entweder die nach-links-Taste oder die nach-rechts-Taste drückt. Im ersten Fall wird der Wert der <xref:System.Console.WindowLeft%2A>-Eigenschaft um eins verringert, wenn das Ergebnis ein gültiger Wert ist. Im letzteren Fall wird der Wert der <xref:System.Console.WindowLeft%2A>-Eigenschaft um eins erhöht, wenn das Ergebnis zulässig wäre. Beachten Sie, dass im Beispiel keine <xref:System.ArgumentOutOfRangeException>behandelt werden muss, da überprüft wird, ob der Wert, der der <xref:System.Console.WindowLeft%2A>-Eigenschaft zugewiesen werden soll, nicht negativ ist, und dass die Summe der <xref:System.Console.WindowLeft%2A>-und <xref:System.Console.WindowWidth%2A>-Eigenschaften den <xref:System.Console.BufferWidth%2A>-Eigenschafts Wert nicht überschreitet.  
  
 [!code-cpp[System.Console.WindowLeft#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.windowleft/cpp/windowleft1.cpp#1)]
 [!code-csharp[System.Console.WindowLeft#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.windowleft/cs/windowleft1.cs#1)]
 [!code-vb[System.Console.WindowLeft#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.windowleft/vb/windowleft1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">In einem SET-Vorgang ist der zuzuweisende Wert kleiner als 0 (null).  
  
- oder - 
Als Ergebnis der Zuweisung würde <see cref="P:System.Console.WindowLeft" /> plus <see cref="P:System.Console.WindowWidth" /> den Wert für <see cref="P:System.Console.BufferWidth" /> überschreiten.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Lesen oder Schreiben von Informationen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der set-Vorgang wird unter einem anderen Betriebssystem als Windows aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowTop">
      <MemberSignature Language="C#" Value="public static int WindowTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowTop" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowTop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowTop : int with get, set" Usage="System.Console.WindowTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die oberste Position des Konsolenfensterbereichs im Verhältnis zum Bildschirmpuffer ab oder legt diese fest.</summary>
        <value>Die oberste Konsolenfensterposition in Zeilen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Konsole stellt ein rechteckiges Fenster in einem größeren rechteckigen Pufferbereich dar. Sowohl das Fenster als auch der Puffer werden vertikal anhand der Anzahl der Zeilen und der horizontalen Anzahl der Spalten gemessen. Die Abmessungen des Puffer Bereichs werden durch die Eigenschaften <xref:System.Console.BufferHeight%2A> und <xref:System.Console.BufferWidth%2A> definiert. Die Abmessungen des Konsolen Bereichs werden durch die Eigenschaften <xref:System.Console.WindowHeight%2A> und <xref:System.Console.WindowWidth%2A> definiert. Die <xref:System.Console.WindowTop%2A>-Eigenschaft bestimmt, welche Zeile des Puffer Bereichs in der ersten Spalte des Konsolenfensters angezeigt wird. Der Wert der <xref:System.Console.WindowTop%2A>-Eigenschaft kann zwischen 0 und <xref:System.Console.BufferHeight%2A> - <xref:System.Console.WindowHeight%2A>liegen. Wenn versucht wird, ihn auf einen Wert außerhalb dieses Bereichs festzulegen, wird eine <xref:System.ArgumentOutOfRangeException>ausgelöst.  
  
 Wenn Sie versuchen, den Wert der <xref:System.Console.WindowTop%2A>-Eigenschaft festzulegen, wenn die Ausgabe umgeleitet wird, wird eine <xref:System.IO.IOException> Ausnahme ausgelöst. Um die Ausnahme zu verhindern, können Sie den Wert dieser Eigenschaft nur festlegen, wenn die <xref:System.Console.IsOutputRedirected%2A>-Eigenschaft `false`zurückgibt.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Eigenschaften <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>und <xref:System.Console.CursorVisible%2A> veranschaulicht. und die Methoden <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>und <xref:System.Console.ReadKey%2A>. Im Beispiel wird ein Raster Muster basierend auf der Bildschirm Puffer Breite im Bildschirm Puffer gezeichnet. Im Beispiel wird das Konsolenfenster in Reaktion darauf verschoben, welche der nach-oben-Taste, nach-unten-Taste, nach-links-Taste oder nach-rechts-Taste gedrückt wird. Mit dem Raster Muster können Sie die Bewegung des Konsolenfensters relativ zum Bildschirm Puffer erkennen.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
 [!code-fsharp[console.windowLT#1](~/samples/snippets/fsharp/VS_Snippets_CLR/console.windowLT/FS/wlt.fs#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">In einem SET-Vorgang ist der zuzuweisende Wert kleiner als 0 (null).  
  
- oder - 
Als Ergebnis der Zuweisung würde <see cref="P:System.Console.WindowTop" /> plus <see cref="P:System.Console.WindowHeight" /> den Wert für <see cref="P:System.Console.BufferHeight" /> überschreiten.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Lesen oder Schreiben von Informationen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der set-Vorgang wird unter einem anderen Betriebssystem als Windows aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public static int WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowWidth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowWidth : int with get, set" Usage="System.Console.WindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Breite des Konsolenfensters ab oder legt diese fest.</summary>
        <value>Die Breite des Konsolenfensters in Spalten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie versuchen, den Wert der <xref:System.Console.WindowWidth%2A>-Eigenschaft festzulegen, wenn die Ausgabe umgeleitet wird, wird entweder eine <xref:System.ArgumentOutOfRangeException> oder eine <xref:System.IO.IOException> Ausnahme ausgelöst. Um eine Ausnahme zu verhindern, können Sie den Wert dieser Eigenschaft nur festlegen, wenn die <xref:System.Console.IsOutputRedirected%2A>-Eigenschaft `false`zurückgibt.  
  
   
  
## Examples  
 In diesem Beispiel werden die <xref:System.Console.SetWindowSize%2A>-Methode und die Eigenschaften <xref:System.Console.WindowWidth%2A> und <xref:System.Console.WindowHeight%2A> veranschaulicht. Sie müssen das Beispiel ausführen, um die vollständige Auswirkung der Änderung der Größe des Konsolenfensters anzuzeigen.  
  
 Das Beispiel meldet die Abmessungen eines Konsolenfensters, das auf 85 Spalten und 43 Zeilen festgelegt ist, und wartet dann auf einen Tastendruck. Wenn eine Taste gedrückt wird, werden die Abmessungen des Konsolenfensters halbiert, die neuen Dimensionen werden gemeldet, und das Beispiel wartet auf einen anderen Tastendruck. Wenn eine Taste gedrückt wird, wird das Konsolenfenster in den ursprünglichen Dimensionen wieder hergestellt, und das Beispiel wird beendet.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert der <see cref="P:System.Console.WindowWidth" />-Eigenschaft oder der Wert der <see cref="P:System.Console.WindowHeight" />-Eigenschaft muss kleiner als oder gleich 0 sein.  
  
- oder - 
Der Wert der <see cref="P:System.Console.WindowHeight" />-Eigenschaft plus dem Wert der <see cref="P:System.Console.WindowTop" />-Eigenschaft muss größer als oder gleich <see cref="F:System.Int16.MaxValue" /> sein.  
  
- oder - 
Der Wert der <see cref="P:System.Console.WindowWidth" />-Eigenschaft oder der Wert der <see cref="P:System.Console.WindowHeight" />-Eigenschaft ist größer als die größtmögliche Fensterbreite oder -höhe für die aktuelle Bildschirmauflösung und Konsolenschriftart.</exception>
        <exception cref="T:System.IO.IOException">Fehler beim Lesen oder Schreiben von Informationen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der set-Vorgang wird unter einem anderen Betriebssystem als Windows aufgerufen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt die Textdarstellung des angegebenen booleschen Werts oder der angegebenen booleschen Werte in den Standardausgabestream.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(bool value);" />
      <MemberSignature Language="F#" Value="static member Write : bool -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt die Textdarstellung des angegebenen booleschen Werts in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Textdarstellung `value` wird durch Aufrufen von <xref:System.Boolean.ToString%2A?displayProperty=nameWithType>erzeugt, der entweder <xref:System.Boolean.TrueString?displayProperty=nameWithType> oder <xref:System.Boolean.FalseString?displayProperty=nameWithType>ausgibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `Write`-Methode veranschaulicht.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(char value);" />
      <MemberSignature Language="F#" Value="static member Write : char -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt das angegebene Unicode-Zeichen in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `Write`-Methode veranschaulicht.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (buffer As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(cli::array &lt;char&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="static member Write : char[] -&gt; unit" Usage="System.Console.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array von Unicode-Zeichen.</param>
        <summary>Schreibt das angegebene Array von Unicode-Zeichen in den Standardausgabestream.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member Write : decimal -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt die Textdarstellung des angegebenen <see cref="T:System.Decimal" />-Werts in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Textdarstellung `value` wird durch Aufrufen von <xref:System.Decimal.ToString%2A?displayProperty=nameWithType>erzeugt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `Write`-Methode veranschaulicht.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(double value);" />
      <MemberSignature Language="F#" Value="static member Write : double -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt die Textdarstellung der angegebenen Gleitkommazahl mit doppelter Genauigkeit in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Textdarstellung `value` wird durch Aufrufen der <xref:System.Double.ToString%2A?displayProperty=nameWithType>-Methode erzeugt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `Write`-Methode veranschaulicht.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int value);" />
      <MemberSignature Language="F#" Value="static member Write : int -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt die Textdarstellung der angegebenen 32-Bit-Ganzzahl mit Vorzeichen in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Textdarstellung `value` wird durch Aufrufen der <xref:System.Int32.ToString%2A?displayProperty=nameWithType>-Methode erzeugt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `Write`-Methode veranschaulicht.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(long value);" />
      <MemberSignature Language="F#" Value="static member Write : int64 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt die Textdarstellung der angegebenen 64-Bit-Ganzzahl mit Vorzeichen in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Textdarstellung `value` wird durch Aufrufen der <xref:System.Int64.ToString%2A?displayProperty=nameWithType>-Methode erzeugt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `Write`-Methode veranschaulicht.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Write : obj -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert oder <see langword="null" />.</param>
        <summary>Schreibt die Textdarstellung des angegebenen Objekts in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `value` `null`ist, wird nichts geschrieben, und es wird keine Ausnahme ausgelöst. Andernfalls wird die `ToString`-Methode von `value` aufgerufen, um die Zeichen folgen Darstellung zu schaffen, und die resultierende Zeichenfolge wird in den Standardausgabestream geschrieben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `Write`-Methode veranschaulicht.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(float value);" />
      <MemberSignature Language="F#" Value="static member Write : single -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt die Textdarstellung der angegebenen Gleitkommazahl mit einfacher Genauigkeit in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Textdarstellung `value` wird durch Aufrufen der <xref:System.Single.ToString%2A?displayProperty=nameWithType>-Methode erzeugt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `Write`-Methode veranschaulicht.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Write : string -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt die angegebene Zeichenfolge in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn value `null`ist, wird nichts in den Standardausgabestream geschrieben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `Write`-Methode veranschaulicht.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member Write : uint32 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt die Textdarstellung der angegebenen 32-Bit-Ganzzahl ohne Vorzeichen in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Textdarstellung `value` wird durch Aufrufen der <xref:System.UInt32.ToString%2A?displayProperty=nameWithType>-Methode erzeugt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `Write`-Methode veranschaulicht.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member Write : uint64 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt die Textdarstellung der angegebenen 64-Bit-Ganzzahl ohne Vorzeichen in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Textdarstellung `value` wird durch Aufrufen der <xref:System.UInt64.ToString%2A?displayProperty=nameWithType>-Methode erzeugt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `Write`-Methode veranschaulicht.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj -&gt; unit" Usage="System.Console.Write (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Eine kombinierte Formatierungszeichenfolge.</param>
        <param name="arg0">Ein mit <paramref name="format" /> zu schreibendes Objekt.</param>
        <summary>Schreibt die Textdarstellung des angegebenen Objekts unter Verwendung der angegebenen Formatinformationen in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) der .NET Framework, um den Wert eines Objekts in seine Textdarstellung zu konvertieren und diese Darstellung in eine Zeichenfolge einzubetten. Die resultierende Zeichenfolge wird in den Ausgabestream geschrieben.  
  
 Der `format`-Parameter besteht aus null oder mehr Text Läufen mit NULL oder mehr indizierten Platzhaltern, so genannten Format Elementen, die einem Objekt in der Parameterliste dieser Methode entsprechen. Der Formatierungsprozess ersetzt jedes Format Element durch die Textdarstellung des Werts des entsprechenden Objekts.  
  
 Die Syntax eines Format Elements ist `{`*Index*[`,`*Alignment*] [`:`*FormatString*]`}`, das einen obligatorischen Index, die optionale Länge und Ausrichtung des formatierten Texts und eine optionale Zeichenfolge mit formatspezifiziererzeichen angibt, die festlegt, wie der Wert des entsprechenden Objekts formatiert wird.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird.  
  
-   Weitere Informationen über das Feature für die kombinierte Formatierung, das von Methoden wie <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>und einigen über Ladungen von <xref:System.Console.WriteLine%2A>unterstützt wird, finden Sie unter [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md).  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zu Format Bezeichnerzeichen für Datum und Uhrzeit finden Sie unter Standard Format Zeichenfolgen für [Datum und](~/docs/standard/base-types/standard-date-and-time-format-strings.md) Uhrzeit und [benutzerdefinierte Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md)Zeichenfolgen für Datum und Uhrzeit.  
  
-   Weitere Informationen zu enumerationsformatbezeichnerwerten finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Standardformatbezeichner für Zahlen, Datumsangaben und Enumerationen mithilfe der `WriteLine`-Methode veranschaulicht.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)] 
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Console.Write%2A>-Methode veranschaulicht.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Die Formatangabe in <paramref name="format" /> ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, params object[] arg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object[] arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, ParamArray arg As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ arg);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj[] -&gt; unit" Usage="System.Console.Write (format, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-1.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Eine kombinierte Formatierungszeichenfolge.</param>
        <param name="arg">Ein mit <paramref name="format" /> zu schreibendes Array von Objekten.</param>
        <summary>Schreibt die Textdarstellung des angegebenen Arrays von Objekten unter Verwendung der angegebenen Formatinformationen in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) der .NET Framework, um den Wert eines Objekts in seine Textdarstellung zu konvertieren und diese Darstellung in eine Zeichenfolge einzubetten. Die resultierende Zeichenfolge wird in den Ausgabestream geschrieben.  
  
 Der `format`-Parameter besteht aus null oder mehr Text Läufen mit NULL oder mehr indizierten Platzhaltern, so genannten Format Elementen, die einem Objekt in der Parameterliste dieser Methode entsprechen. Der Formatierungsprozess ersetzt jedes Format Element durch die Textdarstellung des Werts des entsprechenden Objekts.  
  
 Die Syntax eines Format Elements ist `{`*Index*[`,`*Alignment*] [`:`*FormatString*]`}`, das einen obligatorischen Index, die optionale Länge und Ausrichtung des formatierten Texts und eine optionale Zeichenfolge mit formatspezifiziererzeichen angibt, die festlegt, wie der Wert des entsprechenden Objekts formatiert wird.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird.  
  
-   Weitere Informationen über das Feature für die kombinierte Formatierung, das von Methoden wie <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>und einigen über Ladungen von <xref:System.Console.WriteLine%2A>unterstützt wird, finden Sie unter [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md).  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zu Format Bezeichnerzeichen für Datum und Uhrzeit finden Sie unter Standard Format Zeichenfolgen für [Datum und](~/docs/standard/base-types/standard-date-and-time-format-strings.md) Uhrzeit und [benutzerdefinierte Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md)Zeichenfolgen für Datum und Uhrzeit.  
  
-   Weitere Informationen zu enumerationsformatbezeichnerwerten finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Der `arg`-Parameter ist ein Parameter Array. Argumente können als Array oder als Liste von fünf oder mehr Elementen an die Methode weitergegeben werden. Die Beispiele veranschaulichen beide Formen des Methoden Aufrufes.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine `Person`-Klasse mit einer Reihe von Eigenschaften definiert, die Informationen zu einer Person bereitstellen. Die `GetDescription`-Methode gibt ein Array zurück, das alle Eigenschaftswerte außer eins enthält. Im Beispiel wird dann das Array verwendet, das von der `GetDescription`-Methode zurückgegeben wird, um die Werte des Person-Objekts anzuzeigen.  
  
 [!code-csharp[System.Console.Write#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.write/cs/WriteParams1.cs#1)]
 [!code-vb[System.Console.Write#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.write/vb/WriteParams1.vb#1)]  
  
 Beachten Sie, dass im Beispiel anstelle der <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29>-Methode die <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29>-Methode aufgerufen wird, da versucht wird, den Wert der `Person.Remarks`-Eigenschaft in derselben Zeile anzuzeigen. Zu diesem Zweck wird der Wert der Eigenschaften <xref:System.Console.CursorLeft%2A> und <xref:System.Console.WindowWidth%2A> untersucht, um zu bestimmen, ob genügend Speicherplatz für die-Anmerkung vorhanden ist.  Wenn dies der Fall ist, wird die Zeile angezeigt. Wenn dies nicht der Fall ist, wird eine Zeile geschrieben, drei Leerzeichen werden eingerückt und die Anmerkung angezeigt.  
  
 Das folgende Beispiel ist mit dem ersten identisch, mit der Ausnahme, dass es eine fünf-Element-Liste als `arg` Argument anstelle eines Parameter Arrays bereitstellt.  
  
 [!code-csharp[System.Console.Write#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.write/cs/WriteParams2.cs#2)]
 [!code-vb[System.Console.Write#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.write/vb/WriteParams2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> oder <paramref name="arg" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Die Formatangabe in <paramref name="format" /> ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Diese Methode wird nicht von C++ Code aufgerufen. Der C++ Compiler löst Aufrufe von [System. Console. Write](xref:System.Console.Write*) auf, die eine Zeichenfolge und eine Liste mit vier oder mehr Objekt Parametern als Aufruf an <see cref="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" />enthalten. Sie löst Aufrufe von [System. Console. Write](xref:System.Console.Write*) auf, die eine Zeichenfolge und ein Objekt Array als Aufruf an <see cref="M:System.Console.Write(System.String,System.Object)" />enthalten.</para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Write : char[] * int * int -&gt; unit" Usage="System.Console.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array von Unicode-Zeichen.</param>
        <param name="index">Die Anfangsposition in <paramref name="buffer" />.</param>
        <param name="count">Die Anzahl der zu schreibenden Zeichen.</param>
        <summary>Schreibt das angegebene Unterarray von Unicode-Zeichen in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode schreibt `count` Zeichen, beginnend an der Position `index` `buffer`, in den Standardausgabestream.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> plus <paramref name="count" /> geben eine Position an, die nicht innerhalb von <paramref name="buffer" /> liegt.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Eine kombinierte Formatierungszeichenfolge.</param>
        <param name="arg0">Das erste mit <paramref name="format" /> zu schreibende Objekt.</param>
        <param name="arg1">Das zweite mit <paramref name="format" /> zu schreibende Objekt.</param>
        <summary>Schreibt die Textdarstellung der angegebenen Objekte unter Verwendung der angegebenen Formatinformationen in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) der .NET Framework, um den Wert eines Objekts in seine Textdarstellung zu konvertieren und diese Darstellung in eine Zeichenfolge einzubetten. Die resultierende Zeichenfolge wird in den Ausgabestream geschrieben.  
  
 Der `format`-Parameter besteht aus null oder mehr Text Läufen mit NULL oder mehr indizierten Platzhaltern, so genannten Format Elementen, die einem Objekt in der Parameterliste dieser Methode entsprechen. Der Formatierungsprozess ersetzt jedes Format Element durch die Textdarstellung des Werts des entsprechenden Objekts.  
  
 Die Syntax eines Format Elements ist `{`*Index*[`,`*Alignment*] [`:`*FormatString*]`}`, das einen obligatorischen Index, die optionale Länge und Ausrichtung des formatierten Texts und eine optionale Zeichenfolge mit formatspezifiziererzeichen angibt, die festlegt, wie der Wert des entsprechenden Objekts formatiert wird.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird.  
  
-   Weitere Informationen über das Feature für die kombinierte Formatierung, das von Methoden wie <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>und einigen über Ladungen von <xref:System.Console.WriteLine%2A>unterstützt wird, finden Sie unter [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md).  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zu Format Bezeichnerzeichen für Datum und Uhrzeit finden Sie unter Standard Format Zeichenfolgen für [Datum und](~/docs/standard/base-types/standard-date-and-time-format-strings.md) Uhrzeit und [benutzerdefinierte Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md)Zeichenfolgen für Datum und Uhrzeit.  
  
-   Weitere Informationen zu enumerationsformatbezeichnerwerten finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Standardformatbezeichner für Zahlen, Datumsangaben und Enumerationen mithilfe der `WriteLine`-Methode veranschaulicht.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 Im folgenden Beispiel wird die Verwendung der `Write`-Methode veranschaulicht.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Die Formatangabe in <paramref name="format" /> ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object, arg2 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Eine kombinierte Formatierungszeichenfolge.</param>
        <param name="arg0">Das erste mit <paramref name="format" /> zu schreibende Objekt.</param>
        <param name="arg1">Das zweite mit <paramref name="format" /> zu schreibende Objekt.</param>
        <param name="arg2">Das dritte mit <paramref name="format" /> zu schreibende Objekt.</param>
        <summary>Schreibt die Textdarstellung der angegebenen Objekte unter Verwendung der angegebenen Formatinformationen in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) der .NET Framework, um den Wert eines Objekts in seine Textdarstellung zu konvertieren und diese Darstellung in eine Zeichenfolge einzubetten. Die resultierende Zeichenfolge wird in den Ausgabestream geschrieben.  
  
 Der `format`-Parameter besteht aus null oder mehr Text Läufen mit NULL oder mehr indizierten Platzhaltern, so genannten Format Elementen, die einem Objekt in der Parameterliste dieser Methode entsprechen. Der Formatierungsprozess ersetzt jedes Format Element durch die Textdarstellung des Werts des entsprechenden Objekts.  
  
 Die Syntax eines Format Elements ist `{`*Index*[`,`*Alignment*] [`:`*FormatString*]`}`, das einen obligatorischen Index, die optionale Länge und Ausrichtung des formatierten Texts und eine optionale Zeichenfolge mit formatspezifiziererzeichen angibt, die festlegt, wie der Wert des entsprechenden Objekts formatiert wird.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird.  
  
-   Weitere Informationen über das Feature für die kombinierte Formatierung, das von Methoden wie <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>und einigen über Ladungen von <xref:System.Console.WriteLine%2A>unterstützt wird, finden Sie unter [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md).  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zu Format Bezeichnerzeichen für Datum und Uhrzeit finden Sie unter Standard Format Zeichenfolgen für [Datum und](~/docs/standard/base-types/standard-date-and-time-format-strings.md) Uhrzeit und [benutzerdefinierte Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md)Zeichenfolgen für Datum und Uhrzeit.  
  
-   Weitere Informationen zu enumerationsformatbezeichnerwerten finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Standardformatbezeichner für Zahlen, Datumsangaben und Enumerationen mithilfe der `WriteLine`-Methode veranschaulicht.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 Im folgenden Beispiel wird die Verwendung der `Write`-Methode veranschaulicht.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Die Formatangabe in <paramref name="format" /> ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Eine kombinierte Formatierungszeichenfolge.</param>
        <param name="arg0">Das erste mit <paramref name="format" /> zu schreibende Objekt.</param>
        <param name="arg1">Das zweite mit <paramref name="format" /> zu schreibende Objekt.</param>
        <param name="arg2">Das dritte mit <paramref name="format" /> zu schreibende Objekt.</param>
        <param name="arg3">Das vierte mit <paramref name="format" /> zu schreibende Objekt.</param>
        <summary>Schreibt die Textdarstellung der angegebenen Objekte und der Parameterliste von variabler Länge unter Verwendung der angegebenen Formatinformationen in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese API ist nicht CLS-kompatibel. Die CLS-konforme Alternative ist <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>. Der C# -und der-Visual Basic Compiler lösen einen aufzurufenden Rückruf dieser Methode automatisch als <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) der .NET Framework, um den Wert eines Objekts in seine Textdarstellung zu konvertieren und diese Darstellung in eine Zeichenfolge einzubetten. Die resultierende Zeichenfolge wird in den Ausgabestream geschrieben.  
  
 Der `format`-Parameter besteht aus null oder mehr Text Läufen mit NULL oder mehr indizierten Platzhaltern, so genannten Format Elementen, die einem Objekt in der Parameterliste dieser Methode entsprechen. Der Formatierungsprozess ersetzt jedes Format Element durch die Textdarstellung des Werts des entsprechenden Objekts.  
  
 Die Syntax eines Format Elements ist `{`*Index*[`,`*Alignment*] [`:`*FormatString*]`}`, das einen obligatorischen Index, die optionale Länge und Ausrichtung des formatierten Texts und eine optionale Zeichenfolge mit formatspezifiziererzeichen angibt, die festlegt, wie der Wert des entsprechenden Objekts formatiert wird.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird.  
  
-   Weitere Informationen über das Feature für die kombinierte Formatierung, das von Methoden wie <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>und einigen über Ladungen von <xref:System.Console.WriteLine%2A>unterstützt wird, finden Sie unter [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md).  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zu Format Bezeichnerzeichen für Datum und Uhrzeit finden Sie unter Standard Format Zeichenfolgen für [Datum und](~/docs/standard/base-types/standard-date-and-time-format-strings.md) Uhrzeit und [benutzerdefinierte Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md)Zeichenfolgen für Datum und Uhrzeit.  
  
-   Weitere Informationen zu enumerationsformatbezeichnerwerten finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung von Variablen Parametern mit der <xref:System.Console.Write%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>-Methode veranschaulicht. Die-Methode wird mit einer zusammengesetzten Format Zeichenfolge und fünf Format Elementen aufgerufen.  
  
 [!code-cpp[System.Console.Write#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.write/cpp/con_write.cpp#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Die Formatangabe in <paramref name="format" /> ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Diese Methode ist mit dem <see langword="vararg" />-Schlüsselwort gekennzeichnet, was bedeutet, dass Sie eine Variable Anzahl von Parametern unterstützt. Die-Methode kann aus Visual C++aufgerufen werden, Sie kann jedoch nicht von C# oder Visual Basic Code aufgerufen werden. Der C# -und der-Visual Basic Compiler lösen Aufrufe <see cref="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" /> als Aufrufe von <see cref="M:System.Console.Write(System.String,System.Object[])" />.</para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt die angegebenen Daten, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardzeilen Abschluss Zeichen ist eine Zeichenfolge, deren Wert ein Wagen Rücklauf ist, gefolgt von einem Zeilenvorschub (" C#\r\n" in, oder `vbCrLf` in Visual Basic). Sie können das Zeilen Abschluss Zeichen ändern, indem Sie die <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType>-Eigenschaft der <xref:System.Console.Out%2A>-Eigenschaft auf eine andere Zeichenfolge festlegen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine();" />
      <MemberSignature Language="F#" Value="static member WriteLine : unit -&gt; unit" Usage="System.Console.WriteLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schreibt das aktuelle Zeichen für den Zeilenabschluss in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardzeilen Abschluss Zeichen ist eine Zeichenfolge, deren Wert ein Wagen Rücklauf ist, gefolgt von einem Zeilenvorschub (" C#\r\n" in, oder `vbCrLf` in Visual Basic). Sie können das Zeilen Abschluss Zeichen ändern, indem Sie die <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType>-Eigenschaft der <xref:System.Console.Out%2A>-Eigenschaft auf eine andere Zeichenfolge festlegen. Dies wird im Beispiel veranschaulicht.  
  
   
  
## Examples  
 Im Beispiel wird das Zeichen für den Zeilen Abschluss vom Standardwert "\r\n" oder `vbCrLf` in "\r\n\r\n" oder `vbCrLf` + `vbCrLf`geändert. Anschließend werden die Methoden <xref:System.Console.WriteLine> und <xref:System.Console.WriteLine%28System.String%29> aufgerufen, um die Ausgabe in der Konsole anzuzeigen.  
  
 [!code-cpp[System.Console.WriteLine#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/newline1.cpp#2)]
 [!code-csharp-interactive[System.Console.WriteLine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/newline1.cs#2)]
 [!code-vb[System.Console.WriteLine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/newline1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="P:System.IO.TextWriter.NewLine" />
        <altmember cref="P:System.Console.Out" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(bool value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : bool -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt die Textdarstellung des angegebenen booleschen Werts, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Textdarstellung `value` wird durch Aufrufen der <xref:System.Boolean.ToString%2A?displayProperty=nameWithType>-Methode erzeugt.  
  
 Weitere Informationen zum Zeichen für den Zeilen Abschluss finden Sie im Abschnitt "Hinweise" der <xref:System.Console.WriteLine%2A>-Methode, die keine Parameter annimmt.  
  
   
  
## Examples  
 Im folgenden Beispiel werden zehn ganzzahlige ganze Zahlen generiert und die <xref:System.Console.WriteLine%28System.Boolean%29?displayProperty=nameWithType>-Methode verwendet, um anzugeben, ob Sie gerade sind.  
  
 [!code-cpp[System.Console.WriteLine#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_boolean1.cpp#4)]
 [!code-csharp-interactive[System.Console.WriteLine#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/writeline_boolean1.cs#4)]
 [!code-vb[System.Console.WriteLine#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/writeline_boolean1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(char value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt das angegebene Unicode-Zeichen, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zum Zeichen für den Zeilen Abschluss finden Sie im Abschnitt "Hinweise" der <xref:System.Console.WriteLine%2A>-Methode, die keine Parameter annimmt.  
  
   
  
## Examples  
 Das folgende Beispiel ist ein Tipp Rechner, der einen 18%-Tipp berechnet und die <xref:System.Console.WriteLine%2A>-Methode verwendet, um die Menge der ursprünglichen Kosten, den Trinkgeld und den Gesamtbetrag anzuzeigen. Das Beispiel ist eine Konsolenanwendung, die erfordert, dass der Benutzer die Menge der ursprünglichen Kosten als Befehlszeilenparameter bereitstellt.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (buffer As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(cli::array &lt;char&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char[] -&gt; unit" Usage="System.Console.WriteLine buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array von Unicode-Zeichen.</param>
        <summary>Schreibt das angegebenen Array von Unicode-Zeichen, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zum Zeichen für den Zeilen Abschluss finden Sie im Abschnitt "Hinweise" der <xref:System.Console.WriteLine%2A>-Methode, die keine Parameter annimmt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : decimal -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt die Textdarstellung des angegebenen <see cref="T:System.Decimal" />-Werts, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Textdarstellung `value` wird durch Aufrufen der <xref:System.Decimal.ToString%2A?displayProperty=nameWithType>-Methode erzeugt.  
  
 Weitere Informationen zum Zeichen für den Zeilen Abschluss finden Sie im Abschnitt "Hinweise" der <xref:System.Console.WriteLine%2A>-Methode, die keine Parameter annimmt.  
  
   
  
## Examples  
 Das folgende Beispiel ist ein Tipp Rechner, der einen 18%-Tipp berechnet und die <xref:System.Console.WriteLine%2A>-Methode verwendet, um die Menge der ursprünglichen Kosten, den Trinkgeld und den Gesamtbetrag anzuzeigen. Das Beispiel ist eine Konsolenanwendung, die erfordert, dass der Benutzer die Menge der ursprünglichen Kosten als Befehlszeilenparameter bereitstellt.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(double value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : double -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt die Textdarstellung der angegebenen Gleitkommazahl mit doppelter Genauigkeit, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Textdarstellung `value` wird durch Aufrufen der <xref:System.Double.ToString%2A?displayProperty=nameWithType>-Methode erzeugt.  
  
 Weitere Informationen zum Zeichen für den Zeilen Abschluss finden Sie im Abschnitt "Hinweise" der <xref:System.Console.WriteLine%2A>-Methode, die keine Parameter annimmt.  
  
   
  
## Examples  
 Das folgende Beispiel ist ein Tipp Rechner, der einen 18%-Tipp berechnet und die <xref:System.Console.WriteLine%2A>-Methode verwendet, um die Menge der ursprünglichen Kosten, den Trinkgeld und den Gesamtbetrag anzuzeigen. Das Beispiel ist eine Konsolenanwendung, die erfordert, dass der Benutzer die Menge der ursprünglichen Kosten als Befehlszeilenparameter bereitstellt.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt die Textdarstellung der angegebenen 32-Bit-Ganzzahl mit Vorzeichen, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Textdarstellung `value` wird durch Aufrufen der <xref:System.Int32.ToString%2A?displayProperty=nameWithType>-Methode erzeugt.  
  
 Weitere Informationen zum Zeichen für den Zeilen Abschluss finden Sie im Abschnitt "Hinweise" der <xref:System.Console.WriteLine%2A>-Methode, die keine Parameter annimmt.  
  
   
  
## Examples  
 Das folgende Beispiel ist ein Tipp Rechner, der einen 18%-Tipp berechnet und die <xref:System.Console.WriteLine%2A>-Methode verwendet, um die Menge der ursprünglichen Kosten, den Trinkgeld und den Gesamtbetrag anzuzeigen. Das Beispiel ist eine Konsolenanwendung, die erfordert, dass der Benutzer die Menge der ursprünglichen Kosten als Befehlszeilenparameter bereitstellt.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(long value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int64 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt die Textdarstellung der angegebenen 64-Bit-Ganzzahl mit Vorzeichen, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Textdarstellung `value` wird durch Aufrufen der <xref:System.Int64.ToString%2A?displayProperty=nameWithType>-Methode erzeugt.  
  
 Weitere Informationen zum Zeichen für den Zeilen Abschluss finden Sie im Abschnitt "Hinweise" der <xref:System.Console.WriteLine%2A>-Methode, die keine Parameter annimmt.  
  
   
  
## Examples  
 Das folgende Beispiel ist ein Tipp Rechner, der einen 18%-Tipp berechnet und die <xref:System.Console.WriteLine%2A>-Methode verwendet, um die Menge der ursprünglichen Kosten, den Trinkgeld und den Gesamtbetrag anzuzeigen. Das Beispiel ist eine Konsolenanwendung, die erfordert, dass der Benutzer die Menge der ursprünglichen Kosten als Befehlszeilenparameter bereitstellt.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : obj -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt die Textdarstellung des angegebenen Objekts, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `value``null` ist, wird nur das Zeichen für den Zeilenabschluss geschrieben. Andernfalls wird die `ToString`-Methode von `value` aufgerufen, um die Zeichen folgen Darstellung zu schaffen, und die resultierende Zeichenfolge wird in den Standardausgabestream geschrieben.  
  
 Weitere Informationen zum Zeichen für den Zeilen Abschluss finden Sie im Abschnitt "Hinweise" der <xref:System.Console.WriteLine%2A>-Methode, die keine Parameter annimmt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Console.WriteLine%28System.Object%29>-Methode verwendet, um jeden Wert in einem Objekt Array der Konsole anzuzeigen.  
  
 [!code-cpp[System.Console.WriteLine#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_obj1.cpp#3)]
 [!code-csharp-interactive[System.Console.WriteLine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/writeline_obj1.cs#3)]
 [!code-vb[System.Console.WriteLine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/writeline_obj1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(float value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : single -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt die Textdarstellung der angegebenen Gleitkommazahl mit einfacher Genauigkeit, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Textdarstellung `value` wird durch Aufrufen der <xref:System.Single.ToString%2A?displayProperty=nameWithType>-Methode erzeugt.  
  
 Weitere Informationen zum Zeichen für den Zeilen Abschluss finden Sie im Abschnitt "Hinweise" der <xref:System.Console.WriteLine%2A>-Methode, die keine Parameter annimmt.  
  
   
  
## Examples  
 Das folgende Beispiel ist ein Tipp Rechner, der einen 18%-Tipp berechnet und die <xref:System.Console.WriteLine%2A>-Methode verwendet, um die Menge der ursprünglichen Kosten, den Trinkgeld und den Gesamtbetrag anzuzeigen. Das Beispiel ist eine Konsolenanwendung, die erfordert, dass der Benutzer die Menge der ursprünglichen Kosten als Befehlszeilenparameter bereitstellt.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt den angegebenen Zeichenfolgenwert, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn value `null`ist, wird nur das Zeichen für den Zeilen Abschluss in den Standardausgabestream geschrieben.  
  
 Weitere Informationen zum Zeichen für den Zeilen Abschluss finden Sie im Abschnitt "Hinweise" der <xref:System.Console.WriteLine>-Methode.  
  
   
  
## Examples  
 Im Beispiel wird das Zeichen für den Zeilen Abschluss vom Standardwert "\r\n" oder `vbCrLf` in "\r\n\r\n" oder `vbCrLf` + `vbCrLf`geändert. Anschließend werden die Methoden <xref:System.Console.WriteLine> und <xref:System.Console.WriteLine%28System.String%29> aufgerufen, um die Ausgabe in der Konsole anzuzeigen.  
  
 [!code-cpp[System.Console.WriteLine#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/newline1.cpp#2)]
 [!code-csharp-interactive[System.Console.WriteLine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/newline1.cs#2)]
 [!code-vb[System.Console.WriteLine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/newline1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : uint32 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt die Textdarstellung der angegebenen 32-Bit-Ganzzahl ohne Vorzeichen, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Textdarstellung `value` wird durch Aufrufen der <xref:System.UInt32.ToString%2A?displayProperty=nameWithType>-Methode erzeugt.  
  
 Weitere Informationen zum Zeichen für den Zeilen Abschluss finden Sie im Abschnitt "Hinweise" der <xref:System.Console.WriteLine%2A>-Methode, die keine Parameter annimmt.  
  
   
  
## Examples  
 Das folgende Beispiel ist ein Tipp Rechner, der einen 18%-Tipp berechnet und die <xref:System.Console.WriteLine%2A>-Methode verwendet, um die Menge der ursprünglichen Kosten, den Trinkgeld und den Gesamtbetrag anzuzeigen. Das Beispiel ist eine Konsolenanwendung, die erfordert, dass der Benutzer die Menge der ursprünglichen Kosten als Befehlszeilenparameter bereitstellt.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : uint64 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Der zu schreibende Wert.</param>
        <summary>Schreibt die Textdarstellung der angegebenen 64-Bit-Ganzzahl ohne Vorzeichen, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Textdarstellung `value` wird durch Aufrufen der <xref:System.UInt64.ToString%2A?displayProperty=nameWithType>-Methode erzeugt.  
  
 Weitere Informationen zum Zeichen für den Zeilen Abschluss finden Sie im Abschnitt "Hinweise" der <xref:System.Console.WriteLine%2A>-Methode, die keine Parameter annimmt.  
  
   
  
## Examples  
 Das folgende Beispiel ist ein Tipp Rechner, der einen 18%-Tipp berechnet und die <xref:System.Console.WriteLine%2A>-Methode verwendet, um die Menge der ursprünglichen Kosten, den Trinkgeld und den Gesamtbetrag anzuzeigen. Das Beispiel ist eine Konsolenanwendung, die erfordert, dass der Benutzer die Menge der ursprünglichen Kosten als Befehlszeilenparameter bereitstellt.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Eine kombinierte Formatierungszeichenfolge.</param>
        <param name="arg0">Ein mit <paramref name="format" /> zu schreibendes Objekt.</param>
        <summary>Schreibt die Textdarstellung des angegebenen Objekts, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, unter Verwendung der angegebenen Formatinformationen in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) der .NET Framework, um den Wert eines Objekts in seine Textdarstellung zu konvertieren und diese Darstellung in eine Zeichenfolge einzubetten. Die resultierende Zeichenfolge wird in den Ausgabestream geschrieben.  
  
 Der `format`-Parameter besteht aus null oder mehr Text Läufen mit NULL oder mehr indizierten Platzhaltern, so genannten Format Elementen, die einem Objekt in der Parameterliste dieser Methode entsprechen. Der Formatierungsprozess ersetzt jedes Format Element durch die Textdarstellung des Werts des entsprechenden Objekts.  
  
 Die Syntax eines Format Elements ist `{`*Index*[`,`*Alignment*] [`:`*FormatString*]`}`, das einen obligatorischen Index, die optionale Länge und Ausrichtung des formatierten Texts und eine optionale Zeichenfolge mit formatspezifiziererzeichen angibt, die festlegt, wie der Wert des entsprechenden Objekts formatiert wird.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird.  
  
-   Weitere Informationen über das Feature für die kombinierte Formatierung, das von Methoden wie <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>und einigen über Ladungen von <xref:System.Console.WriteLine%2A>unterstützt wird, finden Sie unter [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md).  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zu Format Bezeichnerzeichen für Datum und Uhrzeit finden Sie unter Standard Format Zeichenfolgen für [Datum und](~/docs/standard/base-types/standard-date-and-time-format-strings.md) Uhrzeit und [benutzerdefinierte Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md)Zeichenfolgen für Datum und Uhrzeit.  
  
-   Weitere Informationen zu enumerationsformatbezeichnerwerten finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Weitere Informationen zum Zeichen für den Zeilen Abschluss finden Sie im Abschnitt "Hinweise" der <xref:System.Console.WriteLine%2A>-Methode, die keine Parameter annimmt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Console.WriteLine%28System.String%2CSystem.Object%29>-Methode aufgerufen, um fünf zufällig generierte <xref:System.Boolean> Werte anzuzeigen.  
  
 [!code-csharp-interactive[System.Console.WriteLine#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/WriteLine6.cs#6)]
 [!code-vb[System.Console.WriteLine#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/WriteLine6.vb#6)]  
  
 Im folgenden Beispiel wird die <xref:System.Console.WriteLine%28System.String%2CSystem.Object%29>-Methode aufgerufen, um das aktuelle Datum anzuzeigen.   Beachten Sie, dass das Format Element im `format`-Argument die "D"- [Standardformat Zeichenfolge für Datum und Uhrzeit](~/docs/standard/base-types/standard-date-and-time-format-strings.md) verwendet, um das Datum im langen Datumsformat der aktuellen Kultur anzuzeigen.  
  
 [!code-csharp[System.Console.WriteLine#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/WriteLine7.cs#7)]
 [!code-vb[System.Console.WriteLine#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/WriteLine7.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Die Formatangabe in <paramref name="format" /> ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, params object[] arg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object[] arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, ParamArray arg As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ arg);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj[] -&gt; unit" Usage="System.Console.WriteLine (format, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-1.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Eine kombinierte Formatierungszeichenfolge.</param>
        <param name="arg">Ein mit <paramref name="format" /> zu schreibendes Array von Objekten.</param>
        <summary>Schreibt die Textdarstellung des angegebenen Arrays von Objekten, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, unter Verwendung der angegebenen Formatinformationen in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) der .NET Framework, um den Wert eines Objekts in seine Textdarstellung zu konvertieren und diese Darstellung in eine Zeichenfolge einzubetten. Die resultierende Zeichenfolge wird in den Ausgabestream geschrieben.  
  
 Der `format`-Parameter besteht aus null oder mehr Text Läufen mit NULL oder mehr indizierten Platzhaltern, so genannten Format Elementen, die einem Objekt in der Parameterliste dieser Methode entsprechen. Der Formatierungsprozess ersetzt jedes Format Element durch die Textdarstellung des Werts des entsprechenden Objekts.  
  
 Die Syntax eines Format Elements ist `{`*Index*[`,`*Alignment*] [`:`*FormatString*]`}`, das einen obligatorischen Index, die optionale Länge und Ausrichtung des formatierten Texts und eine optionale Zeichenfolge mit formatspezifiziererzeichen angibt, die festlegt, wie der Wert des entsprechenden Objekts formatiert wird.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird.  
  
-   Weitere Informationen über das Feature für die kombinierte Formatierung, das von Methoden wie <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>und einigen über Ladungen von <xref:System.Console.WriteLine%2A>unterstützt wird, finden Sie unter [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md).  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zu Format Bezeichnerzeichen für Datum und Uhrzeit finden Sie unter Standard Format Zeichenfolgen für [Datum und](~/docs/standard/base-types/standard-date-and-time-format-strings.md) Uhrzeit und [benutzerdefinierte Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md)Zeichenfolgen für Datum und Uhrzeit.  
  
-   Weitere Informationen zu enumerationsformatbezeichnerwerten finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Weitere Informationen zum Zeichen für den Zeilen Abschluss finden Sie im Abschnitt "Hinweise" der <xref:System.Console.WriteLine%2A>-Methode, die keine Parameter annimmt.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Standardformatbezeichner für Zahlen, Datumsangaben und Enumerationen veranschaulicht.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 Das folgende Beispiel ist ein Tipp Rechner, der einen 18%-Tipp berechnet und die <xref:System.Console.WriteLine%2A>-Methode verwendet, um die Menge der ursprünglichen Kosten, den Trinkgeld und den Gesamtbetrag anzuzeigen. Das Beispiel ist eine Konsolenanwendung, die erfordert, dass der Benutzer die Menge der ursprünglichen Kosten als Befehlszeilenparameter bereitstellt.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> oder <paramref name="arg" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Die Formatangabe in <paramref name="format" /> ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Diese Methode wird nicht von C++ Code aufgerufen. Der C++ Compiler löst Aufrufe von [System. Console. Write teline](xref:System.Console.WriteLine*) auf, die eine Zeichenfolge und eine Liste mit vier oder mehr Objekt Parametern als Aufruf an <see cref="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" />enthalten. Sie löst Aufrufe von [System. Console. Write teline](xref:System.Console.WriteLine*) auf, die eine Zeichenfolge und ein Objekt Array als Aufruf an <see cref="M:System.Console.WriteLine(System.String,System.Object)" />enthalten.</para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char[] * int * int -&gt; unit" Usage="System.Console.WriteLine (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array von Unicode-Zeichen.</param>
        <param name="index">Die Anfangsposition in <paramref name="buffer" />.</param>
        <param name="count">Die Anzahl der zu schreibenden Zeichen.</param>
        <summary>Schreibt das angegebene Unterarray von Unicode-Zeichen, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode schreibt `count` Zeichen, beginnend an der Position `index` `buffer`, in den Standardausgabestream.  
  
 Weitere Informationen zum Zeichen für den Zeilen Abschluss finden Sie im Abschnitt "Hinweise" der <xref:System.Console.WriteLine%2A>-Methode, die keine Parameter annimmt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> plus <paramref name="count" /> geben eine Position an, die nicht innerhalb von <paramref name="buffer" /> liegt.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Eine kombinierte Formatierungszeichenfolge.</param>
        <param name="arg0">Das erste mit <paramref name="format" /> zu schreibende Objekt.</param>
        <param name="arg1">Das zweite mit <paramref name="format" /> zu schreibende Objekt.</param>
        <summary>Schreibt die Textdarstellung der angegebenen Objekte, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, unter Verwendung der angegebenen Formatinformationen in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) der .NET Framework, um den Wert eines Objekts in seine Textdarstellung zu konvertieren und diese Darstellung in eine Zeichenfolge einzubetten. Die resultierende Zeichenfolge wird in den Ausgabestream geschrieben.  
  
 Der `format`-Parameter besteht aus null oder mehr Text Läufen mit NULL oder mehr indizierten Platzhaltern, so genannten Format Elementen, die einem Objekt in der Parameterliste dieser Methode entsprechen. Der Formatierungsprozess ersetzt jedes Format Element durch die Textdarstellung des Werts des entsprechenden Objekts.  
  
 Die Syntax eines Format Elements ist `{`*Index*[`,`*Alignment*] [`:`*FormatString*]`}`, das einen obligatorischen Index, die optionale Länge und Ausrichtung des formatierten Texts und eine optionale Zeichenfolge mit formatspezifiziererzeichen angibt, die festlegt, wie der Wert des entsprechenden Objekts formatiert wird.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird.  
  
-   Weitere Informationen über das Feature für die kombinierte Formatierung, das von Methoden wie <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>und einigen über Ladungen von <xref:System.Console.WriteLine%2A>unterstützt wird, finden Sie unter [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md).  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zu Format Bezeichnerzeichen für Datum und Uhrzeit finden Sie unter Standard Format Zeichenfolgen für [Datum und](~/docs/standard/base-types/standard-date-and-time-format-strings.md) Uhrzeit und [benutzerdefinierte Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md)Zeichenfolgen für Datum und Uhrzeit.  
  
-   Weitere Informationen zu enumerationsformatbezeichnerwerten finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Weitere Informationen zum Zeichen für den Zeilen Abschluss finden Sie im Abschnitt "Hinweise" der <xref:System.Console.WriteLine%2A>-Methode, die keine Parameter annimmt.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Standardformatbezeichner für Zahlen, Datumsangaben und Enumerationen veranschaulicht.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 Das folgende Beispiel ist ein Tipp Rechner, der einen 18%-Tipp berechnet und die <xref:System.Console.WriteLine%2A>-Methode verwendet, um die Menge der ursprünglichen Kosten, den Trinkgeld und den Gesamtbetrag anzuzeigen. Das Beispiel ist eine Konsolenanwendung, die erfordert, dass der Benutzer die Menge der ursprünglichen Kosten als Befehlszeilenparameter bereitstellt.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Die Formatangabe in <paramref name="format" /> ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object, arg2 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Eine kombinierte Formatierungszeichenfolge.</param>
        <param name="arg0">Das erste mit <paramref name="format" /> zu schreibende Objekt.</param>
        <param name="arg1">Das zweite mit <paramref name="format" /> zu schreibende Objekt.</param>
        <param name="arg2">Das dritte mit <paramref name="format" /> zu schreibende Objekt.</param>
        <summary>Schreibt die Textdarstellung der angegebenen Objekte, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, unter Verwendung der angegebenen Formatinformationen in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) der .NET Framework, um den Wert eines Objekts in seine Textdarstellung zu konvertieren und diese Darstellung in eine Zeichenfolge einzubetten. Die resultierende Zeichenfolge wird in den Ausgabestream geschrieben.  
  
 Der `format`-Parameter besteht aus null oder mehr Text Läufen mit NULL oder mehr indizierten Platzhaltern, so genannten Format Elementen, die einem Objekt in der Parameterliste dieser Methode entsprechen. Der Formatierungsprozess ersetzt jedes Format Element durch die Textdarstellung des Werts des entsprechenden Objekts.  
  
 Die Syntax eines Format Elements ist `{`*Index*[`,`*Alignment*] [`:`*FormatString*]`}`, das einen obligatorischen Index, die optionale Länge und Ausrichtung des formatierten Texts und eine optionale Zeichenfolge mit formatspezifiziererzeichen angibt, die festlegt, wie der Wert des entsprechenden Objekts formatiert wird.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird.  
  
-   Weitere Informationen über das Feature für die kombinierte Formatierung, das von Methoden wie <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>und einigen über Ladungen von <xref:System.Console.WriteLine%2A>unterstützt wird, finden Sie unter [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md).  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zu Format Bezeichnerzeichen für Datum und Uhrzeit finden Sie unter Standard Format Zeichenfolgen für [Datum und](~/docs/standard/base-types/standard-date-and-time-format-strings.md) Uhrzeit und [benutzerdefinierte Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md)Zeichenfolgen für Datum und Uhrzeit.  
  
-   Weitere Informationen zu enumerationsformatbezeichnerwerten finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Weitere Informationen zum Zeichen für den Zeilen Abschluss finden Sie im Abschnitt "Hinweise" der <xref:System.Console.WriteLine%2A>-Methode, die keine Parameter annimmt.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Standardformatbezeichner für Zahlen, Datumsangaben und Enumerationen veranschaulicht.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 Das folgende Beispiel ist ein Tipp Rechner, der einen 18%-Tipp berechnet und die <xref:System.Console.WriteLine%2A>-Methode verwendet, um die Menge der ursprünglichen Kosten, den Trinkgeld und den Gesamtbetrag anzuzeigen. Das Beispiel ist eine Konsolenanwendung, die erfordert, dass der Benutzer die Menge der ursprünglichen Kosten als Befehlszeilenparameter bereitstellt.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Die Formatangabe in <paramref name="format" /> ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Eine kombinierte Formatierungszeichenfolge.</param>
        <param name="arg0">Das erste mit <paramref name="format" /> zu schreibende Objekt.</param>
        <param name="arg1">Das zweite mit <paramref name="format" /> zu schreibende Objekt.</param>
        <param name="arg2">Das dritte mit <paramref name="format" /> zu schreibende Objekt.</param>
        <param name="arg3">Das vierte mit <paramref name="format" /> zu schreibende Objekt.</param>
        <summary>Schreibt die Textdarstellung der angegebenen Objekte und der Parameterliste variabler Länge, gefolgt vom aktuellen Zeichen für den Zeilenabschluss, unter Verwendung der angegebenen Formatinformationen in den Standardausgabestream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese API ist nicht CLS-kompatibel. Die CLS-konforme Alternative ist <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>. Der C# -und der-Visual Basic Compiler lösen einen aufzurufenden Rückruf dieser Methode automatisch als <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) der .NET Framework, um den Wert eines Objekts in seine Textdarstellung zu konvertieren und diese Darstellung in eine Zeichenfolge einzubetten. Die resultierende Zeichenfolge wird in den Ausgabestream geschrieben.  
  
 Der `format`-Parameter besteht aus null oder mehr Text Läufen mit NULL oder mehr indizierten Platzhaltern, so genannten Format Elementen, die einem Objekt in der Parameterliste dieser Methode entsprechen. Der Formatierungsprozess ersetzt jedes Format Element durch die Textdarstellung des Werts des entsprechenden Objekts.  
  
 Die Syntax eines Format Elements ist `{`*Index*[`,`*Alignment*] [`:`*FormatString*]`}`, das einen obligatorischen Index, die optionale Länge und Ausrichtung des formatierten Texts und eine optionale Zeichenfolge mit formatspezifiziererzeichen angibt, die festlegt, wie der Wert des entsprechenden Objekts formatiert wird.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird.  
  
-   Weitere Informationen über das Feature für die kombinierte Formatierung, das von Methoden wie <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>und einigen über Ladungen von <xref:System.Console.WriteLine%2A>unterstützt wird, finden Sie unter [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md).  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zu Format Bezeichnerzeichen für Datum und Uhrzeit finden Sie unter Standard Format Zeichenfolgen für [Datum und](~/docs/standard/base-types/standard-date-and-time-format-strings.md) Uhrzeit und [benutzerdefinierte Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md)Zeichenfolgen für Datum und Uhrzeit.  
  
-   Weitere Informationen zu enumerationsformatbezeichnerwerten finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Weitere Informationen zum Zeichen für den Zeilen Abschluss finden Sie im Abschnitt "Hinweise" der <xref:System.Console.WriteLine%2A>-Methode, die keine Parameter annimmt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung von Variablen Argumenten mit der <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>-Methode veranschaulicht. Die-Methode wird mit einer zusammengesetzten Format Zeichenfolge und fünf Format Elementen aufgerufen.  
  
 [!code-cpp[System.Console.WriteLine#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_vararg.cpp#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Die Formatangabe in <paramref name="format" /> ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">zum Ändern von sicheren Fenstern und untergeordneten Fenstern der obersten Ebene. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Diese Methode ist mit dem <see langword="vararg" />-Schlüsselwort gekennzeichnet, was bedeutet, dass Sie eine Variable Anzahl von Parametern unterstützt. Die-Methode kann aus Visual C++aufgerufen werden, Sie kann jedoch nicht von C# oder Visual Basic Code aufgerufen werden. Der C# -und der-Visual Basic Compiler lösen Aufrufe <see cref="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" /> als Aufrufe von <see cref="M:System.Console.WriteLine(System.String,System.Object[])" />.</para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
      </Docs>
    </Member>
  </Members>
</Type>
