<Type Name="MemoryExtensions" FullName="System.MemoryExtensions">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a7366569c7628fc9e3cf491a65d067d6ef8f1387" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82441419" /></Metadata><TypeSignature Language="C#" Value="public static class MemoryExtensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit MemoryExtensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.MemoryExtensions" />
  <TypeSignature Language="VB.NET" Value="Public Module MemoryExtensions" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryExtensions abstract sealed" />
  <TypeSignature Language="F#" Value="type MemoryExtensions = class" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="a7dcd-101">Bietet Erweiterungsmethoden für die Memory- und Span-bezogenen Typen wie <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> und <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-101">Provides extension methods for for the memory- and span-related types, such as <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" />, and <see cref="T:System.ReadOnlySpan`1" />.</span></span></summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory (text As String) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="a7dcd-102">Die Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-102">The target string.</span></span></param>
        <summary><span data-ttu-id="a7dcd-103">Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über den Abschnitt der Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-103">Creates a new <see langword="ReadOnlyMemory&lt;Char&gt;" /> over the portion of the target string.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-104">Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge oder <see langword="default" />, wenn <paramref name="text" /><see langword="null" /> ist.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-104">The read-only character memory representation of the string, or <see langword="default" /> if <paramref name="text" /> is <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text, Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text, valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String,System.Index)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory (text As String, startIndex As Index) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text, Index startIndex);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string * Index -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory (text, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Index" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="a7dcd-105">Die Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-105">The target string.</span></span></param>
        <param name="startIndex"><span data-ttu-id="a7dcd-106">Der Index, an dem dieser Slice beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-106">The index at which to begin this slice.</span></span></param>
        <summary><span data-ttu-id="a7dcd-107">Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über einen Abschnitt der Zielzeichenfolge, beginnend bei einem angegebenen Index.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-107">Creates a new <see langword="ReadOnlyMemory&lt;Char&gt;" /> over a portion of the target string starting at a specified index.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-108">Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-108">The read-only character memory representation of the string.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory (text As String, start As Integer) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text, int start);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string * int -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory (text, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="a7dcd-109">Die Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-109">The target string.</span></span></param>
        <param name="start"><span data-ttu-id="a7dcd-110">Der Index, an dem dieser Slice beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-110">The index at which to begin this slice.</span></span></param>
        <summary><span data-ttu-id="a7dcd-111">Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über einen Abschnitt der Zielzeichenfolge, beginnend bei einer angegebenen Zeichenposition.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-111">Creates a new <see langword="ReadOnlyMemory&lt;Char&gt;" /> over a portion of the target string starting at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-112">Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge oder <see langword="default" />, wenn <paramref name="text" /><see langword="null" /> ist.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-112">The read-only character memory representation of the string, or <see langword="default" /> if <paramref name="text" /> is <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a7dcd-113"><paramref name="start" /> liegt nicht im Bereich von <paramref name="text" />. (<paramref name="start" /> ist &lt; 0 oder &gt; <c>text.Length</c>).</span><span class="sxs-lookup"><span data-stu-id="a7dcd-113"><paramref name="start" /> is not in the range of <paramref name="text" /> (<paramref name="start" /> is &lt; 0 or &gt; <c>text.Length</c>).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text, Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text, valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String,System.Range)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory (text As String, range As Range) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text, Range range);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string * Range -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory (text, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="range" Type="System.Range" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="a7dcd-114">Die Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-114">The target string.</span></span></param>
        <param name="range"><span data-ttu-id="a7dcd-115">Der Bereich, der den Anfang und die Länge der unterteilten Zeichenfolge angibt.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-115">The range that indicates the start and length of the sliced string.</span></span></param>
        <summary><span data-ttu-id="a7dcd-116">Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über einen angegebenen Bereich der Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-116">Creates a new <see langword="ReadOnlyMemory&lt;Char&gt;" /> over a specified range of the target string.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-117">Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-117">The read-only character memory representation of the string.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory (text As String, start As Integer, length As Integer) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string * int * int -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory (text, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="a7dcd-118">Die Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-118">The target string.</span></span></param>
        <param name="start"><span data-ttu-id="a7dcd-119">Der Index, an dem dieser Slice beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-119">The index at which to begin this slice.</span></span></param>
        <param name="length"><span data-ttu-id="a7dcd-120">Die gewünschte Länge des Slices.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-120">The desired length for the slice.</span></span></param>
        <summary><span data-ttu-id="a7dcd-121">Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über einen Abschnitt der Zielzeichenfolge, beginnend bei einer angegebenen Position mit einer Länge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-121">Creates a new <see langword="ReadOnlyMemory&lt;Char&gt;" /> over a portion of the target string beginning at a specified position with a length.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-122">Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge oder <see langword="default" />, wenn <paramref name="text" /><see langword="null" /> ist.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-122">The read-only character memory representation of the string, or <see langword="default" /> if <paramref name="text" /> is <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a7dcd-123"><paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="text" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-123"><paramref name="start" />, <paramref name="length" />, or <paramref name="start" /> + <paramref name="length" /> is not in the range of <paramref name="text" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (segment As ArraySegment(Of T)) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="F#" Value="static member AsMemory : ArraySegment&lt;'T&gt; -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory segment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-124">Der Typ des Segments.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-124">The type of the segment.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="a7dcd-125">Das zu konvertierende Segment.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-125">The segment to convert.</span></span></param>
        <summary><span data-ttu-id="a7dcd-126">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarraysegments.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-126">Creates a new memory region over the portion of the target array segment.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-127">Die Speicherdarstellung des Segments.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-127">The memory representation of the segment.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (array As T()) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-128">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-128">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="a7dcd-129">Das zu konvertierende Array.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-129">The array to convert.</span></span></param>
        <summary><span data-ttu-id="a7dcd-130">Erstellt einen neuen Speicherbereich über dem Zielarray.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-130">Creates a new memory region over the target array.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-131">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-131">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this ArraySegment&lt;T&gt; segment, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (segment As ArraySegment(Of T), start As Integer) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(ArraySegment&lt;T&gt; segment, int start);" />
      <MemberSignature Language="F#" Value="static member AsMemory : ArraySegment&lt;'T&gt; * int -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (segment, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-132">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-132">The type of the array.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="a7dcd-133">Das Zielarraysegment.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-133">The target array segment.</span></span></param>
        <param name="start"><span data-ttu-id="a7dcd-134">Der Index, an dem der Speicher beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-134">The index at which to begin the memory.</span></span></param>
        <summary><span data-ttu-id="a7dcd-135">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarraysegments, beginnend an einer angegebenen Position bis zum Ende des Segments.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-135">Creates a new memory region over the portion of the target array segment starting at a specified position to the end of the segment.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-136">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-136">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-137">Gibt `default` zurück, wenn `segment` `null`ist.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-137">Returns `default` when `segment` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="a7dcd-138"><paramref name="segment" /> ist kovariant, und den Typ von <paramref name="segment" /> ist nicht genau <see langword="T[]" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-138"><paramref name="segment" /> is covariant, and the type of <paramref name="segment" /> is not exactly <see langword="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a7dcd-139"><paramref name="start" /> ist kleiner als 0 oder größer als <see langword="segment.Count" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-139"><paramref name="start" /> is less than 0 or greater than <see langword="segment.Count" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array, Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array, valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[],System.Index)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (array As T(), startIndex As Index) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array, Index startIndex);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] * Index -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (array, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Index" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-140">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-140">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="a7dcd-141">Das zu konvertierende Array.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-141">The array to convert.</span></span></param>
        <param name="startIndex"><span data-ttu-id="a7dcd-142">Die erste Position des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-142">The first position of the array.</span></span></param>
        <summary><span data-ttu-id="a7dcd-143">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarrays, beginnend bei einem angegebenen Index bis zum Ende des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-143">Creates a new memory region over the portion of the target array starting at a specified index to the end of the array.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-144">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-144">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (array As T(), start As Integer) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array, int start);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] * int -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (array, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-145">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-145">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="a7dcd-146">Das Zielarray.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-146">The target array.</span></span></param>
        <param name="start"><span data-ttu-id="a7dcd-147">Der Index, an dem der Speicher beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-147">The index at which to begin the memory.</span></span></param>
        <summary><span data-ttu-id="a7dcd-148">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarrays, beginnend an einem angegebenen Position bis zum Ende des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-148">Creates a new memory region over the portion of the target array starting at a specified position to the end of the array.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-149">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-149">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-150">Gibt `default` zurück, wenn `array` `null`ist.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-150">Returns `default` when `array` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="a7dcd-151"><paramref name="array" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-151"><paramref name="array" /> is covariant, and the array's type is not exactly <see langword="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a7dcd-152"><paramref name="start" />-Index kleiner als 0 oder größer als <see langword="array.Length" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-152"><paramref name="start" /> index less than 0 or greater than <see langword="array.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array, Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array, valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[],System.Range)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (array As T(), range As Range) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array, Range range);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] * Range -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (array, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="range" Type="System.Range" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-153">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-153">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="a7dcd-154">Das zu konvertierende Array.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-154">The array to convert.</span></span></param>
        <param name="range"><span data-ttu-id="a7dcd-155">Der aus dem Array zu konvertierende Bereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-155">The range to convert from the array.</span></span></param>
        <summary><span data-ttu-id="a7dcd-156">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarrays, beginnend mit dem inklusiven Startindex des Bereichs und endend mit dem exklusiven Endindex des Bereichs.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-156">Creates a new memory region over the portion of the target array beginning at inclusive start index of the range and ending at the exclusive end index of the range.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-157">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-157">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this ArraySegment&lt;T&gt; segment, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (segment As ArraySegment(Of T), start As Integer, length As Integer) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(ArraySegment&lt;T&gt; segment, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsMemory : ArraySegment&lt;'T&gt; * int * int -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (segment, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-158">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-158">The type of the array.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="a7dcd-159">Das Zielarraysegment.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-159">The target array segment.</span></span></param>
        <param name="start"><span data-ttu-id="a7dcd-160">Der Index, an dem der Speicher beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-160">The index at which to begin the memory.</span></span></param>
        <param name="length"><span data-ttu-id="a7dcd-161">Die Anzahl der Elemente im Speicher.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-161">The number of items in the memory.</span></span></param>
        <summary><span data-ttu-id="a7dcd-162">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarraysegments, beginnend an einer angegebenen Position mit einer angegebenen Länge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-162">Creates a new memory region over the portion of the target array segment beginning at a specified position with a specified length.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-163">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-163">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-164">Gibt `default` zurück, wenn `segment` `null`ist.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-164">Returns `default` when `segment` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="a7dcd-165"><paramref name="segment" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-165"><paramref name="segment" /> is covariant, and the array's type is not exactly <see langword="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a7dcd-166"><paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="segment" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-166"><paramref name="start" />, <paramref name="length" />, or <paramref name="start" /> + <paramref name="length" /> is not in the range of <paramref name="segment" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (array As T(), start As Integer, length As Integer) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] * int * int -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (array, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-167">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-167">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="a7dcd-168">Das Zielarray.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-168">The target array.</span></span></param>
        <param name="start"><span data-ttu-id="a7dcd-169">Der Index, an dem der Speicherbereich beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-169">The index at which to begin the memory region.</span></span></param>
        <param name="length"><span data-ttu-id="a7dcd-170">Die Anzahl der Elemente im Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-170">The number of items in the memory region.</span></span></param>
        <summary><span data-ttu-id="a7dcd-171">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarrays, beginnend an einer angegebenen Position mit einer angegebenen Länge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-171">Creates a new memory region over the portion of the target array beginning at a specified position with a specified length.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-172">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-172">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-173">Gibt `default` zurück, wenn `array` `null`ist.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-173">Returns `default` when `array` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="a7dcd-174"><paramref name="array" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-174"><paramref name="array" /> is covariant, and the array's type is not exactly <see langword="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a7dcd-175"><paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-175"><paramref name="start" />, <paramref name="length" />, or <paramref name="start" /> + <paramref name="length" /> is not in the range of <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; AsSpan (this string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; AsSpan(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan(System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan (text As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; AsSpan(System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member AsSpan : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.AsSpan text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="a7dcd-176">Die Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-176">The target string.</span></span></param>
        <summary><span data-ttu-id="a7dcd-177">Erstellt eine neue schreibgeschützte Spanne über einen Abschnitt der Zielzeichenfolge von einer angegebenen Position aus für eine angegebene Anzahl von Zeichen.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-177">Creates a new read-only span over a portion of the target string from a specified position for a specified number of characters.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-178">Die schreibgeschützte Spannendarstellung der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-178">The read-only span representation of the string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-179">Gibt `default` zurück, wenn `text` `null`ist.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-179">Returns `default` when `text` is `null`.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; AsSpan (this string text, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; AsSpan(string text, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan (text As String, start As Integer) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; AsSpan(System::String ^ text, int start);" />
      <MemberSignature Language="F#" Value="static member AsSpan : string * int -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.AsSpan (text, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="a7dcd-180">Die Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-180">The target string.</span></span></param>
        <param name="start"><span data-ttu-id="a7dcd-181">Der Index, an dem dieser Slice beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-181">The index at which to begin this slice.</span></span></param>
        <summary><span data-ttu-id="a7dcd-182">Erstellt eine neue schreibgeschützte Spanne über einen Abschnitt der Zielzeichenfolge von einer angegebenen Position aus bis zum Ende der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-182">Creates a new read-only span over a portion of the target string from a specified position to the end of the string.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-183">Die schreibgeschützte Spannendarstellung der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-183">The read-only span representation of the string.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a7dcd-184"><paramref name="text" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="a7dcd-184"><paramref name="text" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a7dcd-185"><paramref name="start" /> ist kleiner als 0 oder größer als <see langword="text.Length" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-185"><paramref name="start" /> is less than 0 or greater than <see langword="text.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; AsSpan (this string text, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; AsSpan(string text, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan (text As String, start As Integer, length As Integer) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; AsSpan(System::String ^ text, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsSpan : string * int * int -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.AsSpan (text, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="a7dcd-186">Die Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-186">The target string.</span></span></param>
        <param name="start"><span data-ttu-id="a7dcd-187">Der Index, an dem dieser Slice beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-187">The index at which to begin this slice.</span></span></param>
        <param name="length"><span data-ttu-id="a7dcd-188">Die gewünschte Länge des Slices.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-188">The desired length for the slice.</span></span></param>
        <summary><span data-ttu-id="a7dcd-189">Erstellt eine neue schreibgeschützte Spanne über eine Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-189">Creates a new read-only span over a string.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-190">Die schreibgeschützte Spannendarstellung der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-190">The read-only span representation of the string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-191">Gibt `default` zurück, wenn `text` `null`ist.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-191">Returns `default` when `text` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a7dcd-192"><paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="text" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-192"><paramref name="start" />, <paramref name="length" />, or <paramref name="start" /> + <paramref name="length" /> is not in the range of <paramref name="text" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (segment As ArraySegment(Of T)) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan segment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-193">Der Typ des Array Segments.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-193">The type of the array segment.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="a7dcd-194">Das zu konvertierende Arraysegment.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-194">The array segment to convert.</span></span></param>
        <summary><span data-ttu-id="a7dcd-195">Erstellt eine neue Spanne über einem Zielarraysegment.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-195">Creates a new span over a target array segment.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-196">Die Spannendarstellung des Arraysegments.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-196">The span representation of the array segment.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (array As T()) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-197">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-197">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="a7dcd-198">Das zu konvertierende Array.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-198">The array to convert.</span></span></param>
        <summary><span data-ttu-id="a7dcd-199">Erstellt eine neue Spanne über einem Zielarray.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-199">Creates a new span over a target array.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-200">Die Spannendarstellung des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-200">The span representation of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment, Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Index)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (segment As ArraySegment(Of T), startIndex As Index) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment, Index startIndex);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; * Index -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (segment, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Index" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-201">Der Typ des Array Segments.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-201">The type of the array segment.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="a7dcd-202">Das Zielarraysegment.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-202">The target array segment.</span></span></param>
        <param name="startIndex"><span data-ttu-id="a7dcd-203">Der Index, an dem die Spanne beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-203">The index at which to begin the Span.</span></span></param>
        <summary><span data-ttu-id="a7dcd-204">Erstellt eine neue Spanne über einem Abschnitt des Zielarraysegments, beginnend mit einem angegebenen Index und endend mit dem Segmentende.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-204">Creates a new span over a portion of the target array segment beginning at a specified index and ending at the end of the segment.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-205">Die Spannendarstellung des Arraysegments.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-205">The span representation of the array segment.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (segment As ArraySegment(Of T), start As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment, int start);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; * int -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (segment, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-206">Der Typ des Array Segments.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-206">The type of the array segment.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="a7dcd-207">Das Zielarraysegment.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-207">The target array segment.</span></span></param>
        <param name="start"><span data-ttu-id="a7dcd-208">Der Index, an dem die Spanne beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-208">The index at which to begin the san.</span></span></param>
        <summary><span data-ttu-id="a7dcd-209">Erstellt eine neue Spanne über einem Abschnitt eines Zielarraysegments von einer bestimmten Position aus bis zum Segmentende.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-209">Creates a new span over a portion of a target array segment from a specified position to the end of the segment.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-210">Die Spannendarstellung des Arraysegments.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-210">The span representation of the array segment.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-211">Gibt `default` zurück, wenn `segment` `null`ist.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-211">Returns `default` when `segment` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="a7dcd-212"><paramref name="segment" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-212"><paramref name="segment" /> is covariant, and the array's type is not exactly <see langword="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a7dcd-213"><paramref name="start" /> ist kleiner als 0 oder größer als <see langword="segment.Count" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-213"><paramref name="start" /> is less than 0 or greater than <see langword="segment.Count" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment, Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Range)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (segment As ArraySegment(Of T), range As Range) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment, Range range);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; * Range -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (segment, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="range" Type="System.Range" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-214">Der Typ des Array Segments.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-214">The type of the array segment.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="a7dcd-215">Das Zielarraysegment.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-215">The target array segment.</span></span></param>
        <param name="range"><span data-ttu-id="a7dcd-216">Der Bereich, der Start- und Endindizes aufweist, die für das Unterteilen des Arrays verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-216">The range which has start and end indexes to use for slicing the array.</span></span></param>
        <summary><span data-ttu-id="a7dcd-217">Erstellt eine neue Spanne über einem Abschnitt eines Zielarraysegments unter Verwendung der Start- und Endindizes des Bereichs.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-217">Creates a new span over a portion of a target array segment using the range start and end indexes.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-218">Die Spannendarstellung des Arraysegments.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-218">The span representation of the array segment.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array, Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array, valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[],System.Index)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (array As T(), startIndex As Index) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array, Index startIndex);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] * Index -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (array, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Index" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-219">Der Arraytyp.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-219">The array type.</span></span></typeparam>
        <param name="array"><span data-ttu-id="a7dcd-220">Das zu konvertierende Array.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-220">The array to convert.</span></span></param>
        <param name="startIndex"><span data-ttu-id="a7dcd-221">Der Startindex.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-221">The starting index.</span></span></param>
        <summary><span data-ttu-id="a7dcd-222">Erstellt eine neue Spanne über dem Abschnitt des Zielarrays, das durch einen <see cref="T:System.Index" />-Wert definiert ist.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-222">Creates a new span over the portion of the target array defined by an <see cref="T:System.Index" /> value.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-223">Die Spannendarstellung des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-223">The span representation of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (array As T(), start As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array, int start);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] * int -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (array, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-224">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-224">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="a7dcd-225">Das zu konvertierende Array.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-225">The array to convert.</span></span></param>
        <param name="start"><span data-ttu-id="a7dcd-226">Der anfängliche Index, aus dem das Array konvertiert wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-226">The initial index from which the array will be converted.</span></span></param>
        <summary><span data-ttu-id="a7dcd-227">Erstellt eine neue Spanne über einem Abschnitt des Zielarrays, beginnend an einer angegebenen Position bis zum Ende des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-227">Creates a new span over a portion of the target array starting at a specified position to the end of the array.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-228">Die Spannendarstellung des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-228">The span representation of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array, Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array, valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[],System.Range)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (array As T(), range As Range) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array, Range range);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] * Range -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (array, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="range" Type="System.Range" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-229">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-229">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="a7dcd-230">Das zu konvertierende Array.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-230">The array to convert.</span></span></param>
        <param name="range"><span data-ttu-id="a7dcd-231">Der Bereich des zu konvertierenden Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-231">The range of the array to convert.</span></span></param>
        <summary><span data-ttu-id="a7dcd-232">Erstellt eine neue Spanne über einem Abschnitt eines Zielarrays, das durch einen <see cref="T:System.Range" />-Wert definiert ist.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-232">Creates a new span over a portion of a target array defined by a <see cref="T:System.Range" /> value.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-233">Die Spannendarstellung des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-233">The span representation of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (segment As ArraySegment(Of T), start As Integer, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; * int * int -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (segment, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-234">Der Typ des Array Segments.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-234">The type of the array segment.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="a7dcd-235">Das Zielarraysegment.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-235">The target array segment.</span></span></param>
        <param name="start"><span data-ttu-id="a7dcd-236">Der Index, an dem die Spanne beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-236">The index at which to begin the span.</span></span></param>
        <param name="length"><span data-ttu-id="a7dcd-237">Die Anzahl der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-237">The number of items in the span.</span></span></param>
        <summary><span data-ttu-id="a7dcd-238">Erstellt eine neue Spanne über einem Abschnitt eines Zielarraysegments von einer bestimmten Position aus für eine angegebene Länge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-238">Creates a new span over a portion of a target array segment from a specified position for a specified length.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-239">Die Spannendarstellung des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-239">The span representation of the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-240">Gibt `default` zurück, wenn `segment` `null`ist.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-240">Returns `default` when `segment` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="a7dcd-241"><paramref name="segment" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-241"><paramref name="segment" /> is covariant, and the array's type is not exactly <see langword="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a7dcd-242"><paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="segment" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-242"><paramref name="start" />, <paramref name="length" />, or <paramref name="start" /> + <paramref name="length" /> is not in the range of <paramref name="segment" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (array As T(), start As Integer, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] * int * int -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (array, start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-243">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-243">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="a7dcd-244">Das Zielarray.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-244">The target array.</span></span></param>
        <param name="start"><span data-ttu-id="a7dcd-245">Der Index, an dem die Spanne beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-245">The index at which to begin the span.</span></span></param>
        <param name="length"><span data-ttu-id="a7dcd-246">Die Anzahl der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-246">The number of items in the span.</span></span></param>
        <summary><span data-ttu-id="a7dcd-247">Erstellt eine neue Spanne über dem Abschnitt des Zielarrays, beginnend an einer angegebenen Position für eine bestimmte Länge.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-247">Creates a new span over the portion of the target array beginning at a specified position for a specified length.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-248">Die Spannendarstellung des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-248">The span representation of the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-249">Gibt `default` zurück, wenn `array` `null`ist.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-249">Returns `default` when `array` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="a7dcd-250"><paramref name="array" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />".</span><span class="sxs-lookup"><span data-stu-id="a7dcd-250"><paramref name="array" /> is covariant, and the array's type is not exactly <see langword="T[]" />".</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a7dcd-251"><paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="text" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-251"><paramref name="start" />, <paramref name="length" />, or <paramref name="start" /> + <paramref name="length" /> is not in the range of <paramref name="text" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, IComparable&lt;T&gt; comparable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, class System.IComparable`1&lt;!!T&gt; comparable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T) (span As ReadOnlySpan(Of T), comparable As IComparable(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(ReadOnlySpan&lt;T&gt; span, IComparable&lt;T&gt; ^ comparable);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : ReadOnlySpan&lt;'T&gt; * IComparable&lt;'T&gt; -&gt; int" Usage="System.MemoryExtensions.BinarySearch (span, comparable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="comparable" Type="System.IComparable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-252">Der Elementtyp der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-252">The element type of the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-253">Das zu durchsuchende sortierte <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-253">The sorted <see cref="T:System.ReadOnlySpan`1" /> to search.</span></span></param>
        <param name="comparable"><span data-ttu-id="a7dcd-254"><see cref="T:System.IComparable`1" />, das beim Vergleich verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-254">The <see cref="T:System.IComparable`1" /> to use when comparing.</span></span></param>
        <summary><span data-ttu-id="a7dcd-255">Durchsucht ein ganzes sortiertes <see cref="T:System.ReadOnlySpan`1" /> mithilfe der angegebenen generischen <see cref="T:System.IComparable`1" />-Schnittstelle nach einem Wert.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-255">Searches an entire sorted <see cref="T:System.ReadOnlySpan`1" /> for a value using the specified <see cref="T:System.IComparable`1" /> generic interface.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-256">Der nullbasierte Index von <paramref name="comparable" /> in der sortierten <paramref name="span" />, sofern <paramref name="comparable" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="comparable" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.ReadOnlySpan`1.Length" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-256">The zero-based index of <paramref name="comparable" /> in the sorted <paramref name="span" />, if <paramref name="comparable" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="comparable" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.ReadOnlySpan`1.Length" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a7dcd-257"><paramref name="comparable" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="a7dcd-257"><paramref name="comparable" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (this Span&lt;T&gt; span, IComparable&lt;T&gt; comparable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span, class System.IComparable`1&lt;!!T&gt; comparable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T) (span As Span(Of T), comparable As IComparable(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(Span&lt;T&gt; span, IComparable&lt;T&gt; ^ comparable);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Span&lt;'T&gt; * IComparable&lt;'T&gt; -&gt; int" Usage="System.MemoryExtensions.BinarySearch (span, comparable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="comparable" Type="System.IComparable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-258">Der Elementtyp der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-258">The element type of the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-259">Das zu durchsuchende sortierte <see cref="T:System.Span`1" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-259">The sorted <see cref="T:System.Span`1" /> to search.</span></span></param>
        <param name="comparable"><span data-ttu-id="a7dcd-260"><see cref="T:System.IComparable`1" />, das beim Vergleich verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-260">The <see cref="T:System.IComparable`1" /> to use when comparing.</span></span></param>
        <summary><span data-ttu-id="a7dcd-261">Durchsucht ein ganzes sortiertes <see cref="T:System.Span`1" /> mithilfe der angegebenen generischen <see cref="T:System.IComparable`1" />-Schnittstelle nach einem Wert.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-261">Searches an entire sorted <see cref="T:System.Span`1" /> for a value using the specified <see cref="T:System.IComparable`1" /> generic interface.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-262">Der nullbasierte Index von <paramref name="comparable" /> in der sortierten <paramref name="span" />, sofern <paramref name="comparable" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="comparable" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Span`1.Length" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-262">The zero-based index of <paramref name="comparable" /> in the sorted <paramref name="span" />, if <paramref name="comparable" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="comparable" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.Span`1.Length" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a7dcd-263"><paramref name="comparable" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="a7dcd-263"><paramref name="comparable" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T,TComparable&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparable&gt; (this ReadOnlySpan&lt;T&gt; span, TComparable comparable) where TComparable : IComparable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T, (class System.IComparable`1&lt;!!T&gt;) TComparable&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!TComparable comparable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T, TComparable) (span As ReadOnlySpan(Of T), comparable As TComparable) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TComparable&gt;&#xA; where TComparable : IComparable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(ReadOnlySpan&lt;T&gt; span, TComparable comparable);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : ReadOnlySpan&lt;'T&gt; * 'Comparable -&gt; int (requires 'Comparable :&gt; IComparable&lt;'T&gt;)" Usage="System.MemoryExtensions.BinarySearch (span, comparable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TComparable">
          <Constraints>
            <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="comparable" Type="TComparable" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-264">Der Elementtyp der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-264">The element type of the span.</span></span></typeparam>
        <typeparam name="TComparable"><span data-ttu-id="a7dcd-265">Der spezifische Typ der <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-265">The specific type of <see cref="T:System.IComparable`1" />.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-266">Das zu durchsuchende sortierte <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-266">The sorted <see cref="T:System.ReadOnlySpan`1" /> to search.</span></span></param>
        <param name="comparable"><span data-ttu-id="a7dcd-267"><typeparamref name="TComparable" />, das beim Vergleich verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-267">The <typeparamref name="TComparable" /> to use when comparing.</span></span></param>
        <summary><span data-ttu-id="a7dcd-268">Durchsucht ein ganzes sortiertes <see cref="T:System.ReadOnlySpan`1" /> mithilfe des angegebenen generischen <typeparamref name="TComparable" />-Typs nach einem Wert.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-268">Searches an entire sorted <see cref="T:System.ReadOnlySpan`1" /> for a value using the specified <typeparamref name="TComparable" /> generic type.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-269">Der nullbasierte Index von <paramref name="comparable" /> in der sortierten <paramref name="span" />, sofern <paramref name="comparable" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="comparable" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.ReadOnlySpan`1.Length" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-269">The zero-based index of <paramref name="comparable" /> in the sorted <paramref name="span" />, if <paramref name="comparable" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="comparable" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.ReadOnlySpan`1.Length" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a7dcd-270"><paramref name="comparable" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="a7dcd-270"><paramref name="comparable" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T,TComparable&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparable&gt; (this Span&lt;T&gt; span, TComparable comparable) where TComparable : IComparable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T, (class System.IComparable`1&lt;!!T&gt;) TComparable&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!TComparable comparable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T, TComparable) (span As Span(Of T), comparable As TComparable) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TComparable&gt;&#xA; where TComparable : IComparable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(Span&lt;T&gt; span, TComparable comparable);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Span&lt;'T&gt; * 'Comparable -&gt; int (requires 'Comparable :&gt; IComparable&lt;'T&gt;)" Usage="System.MemoryExtensions.BinarySearch (span, comparable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TComparable">
          <Constraints>
            <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="comparable" Type="TComparable" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-271">Der Elementtyp der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-271">The element type of the span.</span></span></typeparam>
        <typeparam name="TComparable"><span data-ttu-id="a7dcd-272">Der spezifische Typ der <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-272">The specific type of <see cref="T:System.IComparable`1" />.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-273">Das zu durchsuchende sortierte <see cref="T:System.Span`1" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-273">The sorted <see cref="T:System.Span`1" /> to search.</span></span></param>
        <param name="comparable"><span data-ttu-id="a7dcd-274"><typeparamref name="TComparable" />, das beim Vergleich verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-274">The <typeparamref name="TComparable" /> to use when comparing.</span></span></param>
        <summary><span data-ttu-id="a7dcd-275">Durchsucht ein ganzes sortiertes <see cref="T:System.Span`1" /> mithilfe des angegebenen generischen <typeparamref name="TComparable" />-Typs nach einem Wert.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-275">Searches an entire sorted <see cref="T:System.Span`1" /> for a value using the specified <typeparamref name="TComparable" /> generic type.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-276">Der nullbasierte Index von <paramref name="comparable" /> in der sortierten <paramref name="span" />, sofern <paramref name="comparable" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="comparable" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Span`1.Length" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-276">The zero-based index of <paramref name="comparable" /> in the sorted <paramref name="span" />, if <paramref name="comparable" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="comparable" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.Span`1.Length" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a7dcd-277"><paramref name="comparable" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="a7dcd-277"><paramref name="comparable" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T,TComparer&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparer&gt; (this ReadOnlySpan&lt;T&gt; span, T value, TComparer comparer) where TComparer : System.Collections.Generic.IComparer&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T, (class System.Collections.Generic.IComparer`1&lt;!!T&gt;) TComparer&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value, !!TComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T, TComparer) (span As ReadOnlySpan(Of T), value As T, comparer As TComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TComparer&gt;&#xA; where TComparer : System::Collections::Generic::IComparer&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(ReadOnlySpan&lt;T&gt; span, T value, TComparer comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : ReadOnlySpan&lt;'T&gt; * 'T * 'Comparer -&gt; int (requires 'Comparer :&gt; System.Collections.Generic.IComparer&lt;'T&gt;)" Usage="System.MemoryExtensions.BinarySearch (span, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TComparer">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IComparer&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="TComparer" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-278">Der Elementtyp der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-278">The element type of the span.</span></span></typeparam>
        <typeparam name="TComparer"><span data-ttu-id="a7dcd-279">Der spezifische Typ der <see cref="T:System.Collections.Generic.IComparer`1" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-279">The specific type of <see cref="T:System.Collections.Generic.IComparer`1" />.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-280">Das zu durchsuchende sortierte <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-280">The sorted <see cref="T:System.ReadOnlySpan`1" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-281">Das zu suchende Objekt.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-281">The object to locate.</span></span> <span data-ttu-id="a7dcd-282">Der Wert kann für Verweistypen <see langword="null" /> sein.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-282">The value can be <see langword="null" /> for reference types.</span></span></param>
        <param name="comparer"><span data-ttu-id="a7dcd-283"><typeparamref name="TComparer" />, das beim Vergleich verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-283">The <typeparamref name="TComparer" /> to use when comparing.</span></span></param>
        <summary><span data-ttu-id="a7dcd-284">Durchsucht ein ganzes sortiertes <see cref="T:System.ReadOnlySpan`1" /> mithilfe des angegebenen generischen <typeparamref name="TComparer" />-Typs nach einem angegebenen Wert.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-284">Searches an entire sorted <see cref="T:System.ReadOnlySpan`1" /> for a specified value using the specified <typeparamref name="TComparer" /> generic type.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-285">Der nullbasierte Index von <paramref name="value" /> in der sortierten <paramref name="span" />, sofern <paramref name="value" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="value" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.ReadOnlySpan`1.Length" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-285">The zero-based index of <paramref name="value" /> in the sorted <paramref name="span" />, if <paramref name="value" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="value" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.ReadOnlySpan`1.Length" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a7dcd-286"><paramref name="comparer" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="a7dcd-286"><paramref name="comparer" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T,TComparer&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparer&gt; (this Span&lt;T&gt; span, T value, TComparer comparer) where TComparer : System.Collections.Generic.IComparer&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T, (class System.Collections.Generic.IComparer`1&lt;!!T&gt;) TComparer&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value, !!TComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T, TComparer) (span As Span(Of T), value As T, comparer As TComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TComparer&gt;&#xA; where TComparer : System::Collections::Generic::IComparer&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(Span&lt;T&gt; span, T value, TComparer comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Span&lt;'T&gt; * 'T * 'Comparer -&gt; int (requires 'Comparer :&gt; System.Collections.Generic.IComparer&lt;'T&gt;)" Usage="System.MemoryExtensions.BinarySearch (span, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TComparer">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IComparer&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="TComparer" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-287">Der Elementtyp der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-287">The element type of the span.</span></span></typeparam>
        <typeparam name="TComparer"><span data-ttu-id="a7dcd-288">Der spezifische Typ der <see cref="T:System.Collections.Generic.IComparer`1" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-288">The specific type of <see cref="T:System.Collections.Generic.IComparer`1" />.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-289">Das zu durchsuchende sortierte <see cref="T:System.Span`1" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-289">The sorted <see cref="T:System.Span`1" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-290">Das zu suchende Objekt.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-290">The object to locate.</span></span> <span data-ttu-id="a7dcd-291">Der Wert kann für Verweistypen <see langword="null" /> sein.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-291">The value can be <see langword="null" /> for reference types.</span></span></param>
        <param name="comparer"><span data-ttu-id="a7dcd-292"><typeparamref name="TComparer" />, das beim Vergleich verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-292">The <typeparamref name="TComparer" /> to use when comparing.</span></span></param>
        <summary><span data-ttu-id="a7dcd-293">Durchsucht ein ganzes sortiertes <see cref="T:System.Span`1" /> mithilfe des angegebenen generischen <typeparamref name="TComparer" />-Typs nach einem angegebenen Wert.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-293">Searches an entire sorted <see cref="T:System.Span`1" /> for a specified value using the specified <typeparamref name="TComparer" /> generic type.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-294">Der nullbasierte Index von <paramref name="value" /> in der sortierten <paramref name="span" />, sofern <paramref name="value" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="value" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Span`1.Length" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-294">The zero-based index of <paramref name="value" /> in the sorted <paramref name="span" />, if <paramref name="value" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="value" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.Span`1.Length" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a7dcd-295"><paramref name="comparer" /> ist <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="a7dcd-295"><paramref name="comparer" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public static int CompareTo (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; other, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareTo(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; other, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CompareTo (span As ReadOnlySpan(Of Char), other As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int CompareTo(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; other, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member CompareTo : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.MemoryExtensions.CompareTo (span, other, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-296">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-296">The source span.</span></span></param>
        <param name="other"><span data-ttu-id="a7dcd-297">Der Wert, der mit der Quellspanne verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-297">The value to compare with the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="a7dcd-298">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="other" /> verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-298">An enumeration value that determines how <paramref name="span" /> and <paramref name="other" /> are compared.</span></span></param>
        <summary><span data-ttu-id="a7dcd-299">Vergleicht eine Zeichenspanne mit einer anderen unter Verwendung eines angegebenen Zeichenfolgenvergleichs und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-299">Compares one character span with another using a specified string comparison, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-300">Eine ganze Zahl mit Vorzeichen, die die relative Reihenfolge von <paramref name="span" /> und <paramref name="other" /> angibt:</span><span class="sxs-lookup"><span data-stu-id="a7dcd-300">A signed integer that indicates the relative order of <paramref name="span" /> and <paramref name="other" />:</span></span><br />   <span data-ttu-id="a7dcd-301">– Wenn kleiner als 0, <paramref name="span" /> vor <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-301">- If less than 0, <paramref name="span" /> precedes than <paramref name="other" />.</span></span><br />   <span data-ttu-id="a7dcd-302">– Wenn diese 0 (null) sind, ist <paramref name="span" /> gleich <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-302">- If 0, <paramref name="span" /> equals <paramref name="other" />.</span></span><br />   <span data-ttu-id="a7dcd-303">– Wenn größer als 0, folgt <paramref name="span" /> auf <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-303">- If greater than 0, <paramref name="span" /> follows <paramref name="other" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public static bool Contains (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Contains : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; bool" Usage="System.MemoryExtensions.Contains (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-304">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-304">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-305">Der innerhalb der Quellspanne zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-305">The value to seek within the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="a7dcd-306">Ein Enumerationswert, der bestimmt, wie die Zeichen in <paramref name="span" /> und <paramref name="value" /> verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-306">An enumeration value that determines how the characters in <paramref name="span" /> and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="a7dcd-307">Gibt an, ob ein angegebener Wert innerhalb einer schreibgeschützten Zeichenspanne auftritt.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-307">Indicates whether a specified value occurs within a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-308"><see langword="true" />, wenn <paramref name="value" /> innerhalb der Spanne auftritt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-308"><see langword="true" /> if <paramref name="value" /> occurs within the span, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Contains``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(ReadOnlySpan&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member Contains : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Contains (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-309">Der Typ der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-309">The type of the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-310">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-310">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-311">Der zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-311">The value to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-312">Gibt an, ob ein angegebener Wert in einer schreibgeschützten Spanne gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-312">Indicates whether a specified value is found in a read-only span.</span></span> <span data-ttu-id="a7dcd-313">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-313">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="a7dcd-314"><see langword="true" />, wenn er gefunden wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-314"><see langword="true" /> if found, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;T&gt; (this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Contains``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of T As IEquatable(Of T)) (span As Span(Of T), value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(Span&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member Contains : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Contains (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-315">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-315">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-316">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-316">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-317">Der zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-317">The value to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-318">Gibt an, ob ein angegebener Wert in einer Spanne gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-318">Indicates whether a specified value is found in a span.</span></span> <span data-ttu-id="a7dcd-319">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-319">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="a7dcd-320"><see langword="true" />, wenn er gefunden wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-320"><see langword="true" /> if found, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void CopyTo&lt;T&gt; (this T[] source, Memory&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo&lt;T&gt;(!!T[] source, valuetype System.Memory`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo(Of T) (source As T(), destination As Memory(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(cli::array &lt;T&gt; ^ source, Memory&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="static member CopyTo : 'T[] * Memory&lt;'T&gt; -&gt; unit" Usage="System.MemoryExtensions.CopyTo (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T[]" RefType="this" />
        <Parameter Name="destination" Type="System.Memory&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-321">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-321">The type of the array.</span></span></typeparam>
        <param name="source"><span data-ttu-id="a7dcd-322">Das Array, aus dem Elemente kopiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-322">The array to copy items from.</span></span></param>
        <param name="destination"><span data-ttu-id="a7dcd-323">Das Array, in das die Elemente kopiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-323">The memory to copy items into.</span></span></param>
        <summary><span data-ttu-id="a7dcd-324">Kopiert den Inhalt des Arrays in einen Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-324">Copies the contents of the array into a memory region.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="a7dcd-325">Wenn sich `source` und `destination` überlappen, verhält sich diese Methode so, als ob sich die ursprünglichen Werte an einem temporären Speicherort befinden, bevor das Ziel überschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-325">If `source` and `destination` overlap, this method behaves as if the original values are in a temporary location before the destination is overwritten.</span></span>

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7dcd-326">Das Ziel ist kürzer als das Quellarray.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-326">The destination is shorter than the source array.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void CopyTo&lt;T&gt; (this T[] source, Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo&lt;T&gt;(!!T[] source, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo(Of T) (source As T(), destination As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(cli::array &lt;T&gt; ^ source, Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="static member CopyTo : 'T[] * Span&lt;'T&gt; -&gt; unit" Usage="System.MemoryExtensions.CopyTo (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T[]" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-327">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-327">The type of the array.</span></span></typeparam>
        <param name="source"><span data-ttu-id="a7dcd-328">Das Array, aus dem Elemente kopiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-328">The array to copy items from.</span></span></param>
        <param name="destination"><span data-ttu-id="a7dcd-329">Der Bereich, in den Elemente kopiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-329">The span to copy items into.</span></span></param>
        <summary><span data-ttu-id="a7dcd-330">Kopiert den Inhalt des Arrays in die Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-330">Copies the contents of the array into the span.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="a7dcd-331">Wenn sich `source` und `destination` überlappen, verhält sich diese Methode so, als ob sich die ursprünglichen Werte an einem temporären Speicherort befinden, bevor das Ziel überschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-331">If `source` and `destination` overlap, this method behaves as if the original values are in a temporary location before the destination is overwritten.</span></span>

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a7dcd-332">Die Zielspanne ist kürzer als das Quellarray.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-332">The destination Span is shorter than the source array.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public static bool EndsWith (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsWith(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EndsWith (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool EndsWith(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member EndsWith : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; bool" Usage="System.MemoryExtensions.EndsWith (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-333">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-333">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-334">Die Sequenz, die mit dem Ende der Quellspanne verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-334">The sequence to compare to the end of the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="a7dcd-335">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="value" /> verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-335">An enumeration value that determines how <paramref name="span" /> and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="a7dcd-336">Bestimmt, ob das Ende von <paramref name="span" /> mit dem angegebenen <paramref name="value" /> übereinstimmt, wenn es mit der angegebenen <paramref name="comparisonType" />-Option verglichen wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-336">Determines whether the end of the <paramref name="span" /> matches the specified <paramref name="value" /> when compared using the specified <paramref name="comparisonType" /> option.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-337"><see langword="true" />, wenn <paramref name="value" /> mit dem Ende von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-337"><see langword="true" /> if <paramref name="value" /> matches the end of <paramref name="span" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool EndsWith&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsWith&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EndsWith(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool EndsWith(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member EndsWith : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.EndsWith (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-338">Der Typ der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-338">The type of the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-339">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-339">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-340">Die Sequenz, die mit dem Ende der Quellspanne verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-340">The sequence to compare to the end of the source span.</span></span></param>
        <summary><span data-ttu-id="a7dcd-341">Bestimmt, ob die angegebene Sequenz am Ende einer schreibgeschützten Spanne angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-341">Determines whether the specified sequence appears at the end of a read-only span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-342"><see langword="true" />, wenn <paramref name="value" /> mit dem Ende von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-342"><see langword="true" /> if <paramref name="value" /> matches the end of <paramref name="span" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool EndsWith&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsWith&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EndsWith(Of T As IEquatable(Of T)) (span As Span(Of T), value As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool EndsWith(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member EndsWith : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.EndsWith (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-343">Der Typ der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-343">The type of the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-344">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-344">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-345">Die Sequenz, die mit dem Ende der Quellspanne verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-345">The sequence to compare to the end of the source span.</span></span></param>
        <summary><span data-ttu-id="a7dcd-346">Bestimmt, ob die angegebene Sequenz am Ende einer Spanne angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-346">Determines whether the specified sequence appears at the end of a span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-347"><see langword="true" />, wenn <paramref name="value" /> mit dem Ende von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-347"><see langword="true" /> if <paramref name="value" /> matches the end of <paramref name="span" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public static System.Text.SpanRuneEnumerator EnumerateRunes (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.SpanRuneEnumerator EnumerateRunes(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EnumerateRunes(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EnumerateRunes (span As ReadOnlySpan(Of Char)) As SpanRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Text::SpanRuneEnumerator EnumerateRunes(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member EnumerateRunes : ReadOnlySpan&lt;char&gt; -&gt; System.Text.SpanRuneEnumerator" Usage="System.MemoryExtensions.EnumerateRunes span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.SpanRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-348">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-348">The source span.</span></span></param>
        <summary><span data-ttu-id="a7dcd-349">Gibt eine Enumeration von <see cref="T:System.Text.Rune" /> aus der angegebenen schreibgeschützten Spanne zurück.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-349">Returns an enumeration of <see cref="T:System.Text.Rune" /> from the provided read-only span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-350">Ein rune-Enumerator.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-350">A rune enumerator.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-351">Ungültige Sequenzen werden in der-Enumeration durch <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType>dargestellt.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-351">Invalid sequences will be represented in the enumeration by <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType>.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public static System.Text.SpanRuneEnumerator EnumerateRunes (this Span&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.SpanRuneEnumerator EnumerateRunes(valuetype System.Span`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EnumerateRunes(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EnumerateRunes (span As Span(Of Char)) As SpanRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Text::SpanRuneEnumerator EnumerateRunes(Span&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member EnumerateRunes : Span&lt;char&gt; -&gt; System.Text.SpanRuneEnumerator" Usage="System.MemoryExtensions.EnumerateRunes span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.SpanRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-352">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-352">The source span.</span></span></param>
        <summary><span data-ttu-id="a7dcd-353">Gibt eine Enumeration von <see cref="T:System.Text.Rune" /> aus der angegebenen Spanne zurück.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-353">Returns an enumeration of <see cref="T:System.Text.Rune" /> from the provided span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-354">Ein rune-Enumerator.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-354">A rune enumerator.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-355">Ungültige Sequenzen werden in der-Enumeration durch <xref:System.Text.Rune.ReplacementChar>dargestellt.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-355">Invalid sequences will be represented in the enumeration by <xref:System.Text.Rune.ReplacementChar>.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; other, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; other, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Equals (span As ReadOnlySpan(Of Char), other As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Equals(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; other, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; bool" Usage="System.MemoryExtensions.Equals (span, other, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-356">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-356">The source span.</span></span></param>
        <param name="other"><span data-ttu-id="a7dcd-357">Der Wert, der mit der Quellspanne verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-357">The value to compare with the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="a7dcd-358">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="other" /> verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-358">An enumeration value that determines how <paramref name="span" /> and <paramref name="other" /> are compared.</span></span></param>
        <summary><span data-ttu-id="a7dcd-359">Bestimmt, ob dieser <paramref name="span" /> und die angegebene <paramref name="other" />-Spanne dieselben Zeichen aufweisen, wenn sie mit der angegebenen <paramref name="comparisonType" />-Option verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-359">Determines whether this <paramref name="span" /> and the specified <paramref name="other" /> span have the same characters when compared using the specified <paramref name="comparisonType" /> option.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-360"><see langword="true" />, sofern identisch, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-360"><see langword="true" /> if equal, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member IndexOf : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.MemoryExtensions.IndexOf (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-361">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-361">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-362">Der innerhalb der Quellspanne zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-362">The value to seek within the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="a7dcd-363">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="value" /> verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-363">An enumeration value that determines how <paramref name="span" /> and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="a7dcd-364">Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen <paramref name="value" /> im aktuellen <paramref name="span" /> an.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-364">Reports the zero-based index of the first occurrence of the specified <paramref name="value" /> in the current <paramref name="span" />.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-365">Der Index des Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-365">The index of the occurrence of the value in the span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-366">Der Typ der Spanne und des Werts.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-366">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-367">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-367">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-368">Die zu suchende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-368">The sequence to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-369">Sucht nach der angegebenen Sequenz und gibt den Index des ersten Vorkommens zurück.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-369">Searches for the specified sequence and returns the index of its first occurrence.</span></span> <span data-ttu-id="a7dcd-370">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-370">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="a7dcd-371">Der Index des Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-371">The index of the occurrence of the value in the span.</span></span> <span data-ttu-id="a7dcd-372">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-372">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(ReadOnlySpan&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-373">Der Typ der Spanne und des Werts.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-373">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-374">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-374">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-375">Der zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-375">The value to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-376">Sucht nach dem angegebenen Wert und gibt den Index des ersten Vorkommens zurück.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-376">Searches for the specified value and returns the index of its first occurrence.</span></span> <span data-ttu-id="a7dcd-377">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-377">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="a7dcd-378">Der Index des Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-378">The index of the occurrence of the value in the span.</span></span> <span data-ttu-id="a7dcd-379">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-379">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of T As IEquatable(Of T)) (span As Span(Of T), value As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-380">Der Typ der Spanne und des Werts.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-380">The type of the span and value..</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-381">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-381">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-382">Die zu suchende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-382">The sequence to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-383">Sucht nach der angegebenen Sequenz und gibt den Index des ersten Vorkommens zurück.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-383">Searches for the specified sequence and returns the index of its first occurrence.</span></span> <span data-ttu-id="a7dcd-384">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-384">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="a7dcd-385">Der Index des Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-385">The index of the occurrence of the value in the span.</span></span> <span data-ttu-id="a7dcd-386">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-386">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of T As IEquatable(Of T)) (span As Span(Of T), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(Span&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-387">Der Typ der Spanne und des Werts.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-387">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-388">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-388">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-389">Der zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-389">The value to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-390">Sucht nach dem angegebenen Wert und gibt den Index des ersten Vorkommens zurück.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-390">Searches for the specified value and returns the index of its first occurrence.</span></span> <span data-ttu-id="a7dcd-391">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-391">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="a7dcd-392">Der Index des Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-392">The index of the occurrence of the value in the span.</span></span> <span data-ttu-id="a7dcd-393">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-393">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), values As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-394">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-394">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-395">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-395">The span to search.</span></span></param>
        <param name="values"><span data-ttu-id="a7dcd-396">Der zu suchende Satz von Werten.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-396">The set of values to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-397">Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="a7dcd-397">Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-398">Der erste Index des Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-398">The first index of the occurrence of any of the values in the span.</span></span> <span data-ttu-id="a7dcd-399">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-399">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), values As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-400">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-400">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-401">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-401">The span to search.</span></span></param>
        <param name="values"><span data-ttu-id="a7dcd-402">Der zu suchende Satz von Werten.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-402">The set of values to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-403">Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="a7dcd-403">Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-404">Der erste Index des Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-404">The first index of the occurrence of any of the values in the span.</span></span> <span data-ttu-id="a7dcd-405">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-405">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value0, !!T value1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value0 As T, value1 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(ReadOnlySpan&lt;T&gt; span, T value0, T value1);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, value0, value1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-406">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-406">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-407">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-407">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="a7dcd-408">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-408">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="a7dcd-409">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-409">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-410">Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="a7dcd-410">Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-411">Der erste Index des Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-411">The first index of the occurrence of any of the values in the span.</span></span> <span data-ttu-id="a7dcd-412">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-412">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value0, !!T value1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), value0 As T, value1 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(Span&lt;T&gt; span, T value0, T value1);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, value0, value1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-413">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-413">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-414">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-414">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="a7dcd-415">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-415">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="a7dcd-416">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-416">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-417">Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="a7dcd-417">Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-418">Der erste Index des Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-418">The first index of the occurrence of any of the values in the span.</span></span> <span data-ttu-id="a7dcd-419">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-419">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value0, !!T value1, !!T value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value0 As T, value1 As T, value2 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, value0, value1, value2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
        <Parameter Name="value2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-420">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-420">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-421">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-421">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="a7dcd-422">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-422">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="a7dcd-423">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-423">One of the values to search for.</span></span></param>
        <param name="value2"><span data-ttu-id="a7dcd-424">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-424">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-425">Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="a7dcd-425">Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-426">Der erste Index des Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-426">The first index of the occurrence of any of the values in the span.</span></span> <span data-ttu-id="a7dcd-427">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-427">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value0, !!T value1, !!T value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), value0 As T, value1 As T, value2 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(Span&lt;T&gt; span, T value0, T value1, T value2);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, value0, value1, value2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
        <Parameter Name="value2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-428">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-428">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-429">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-429">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="a7dcd-430">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-430">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="a7dcd-431">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-431">One of the values to search for.</span></span></param>
        <param name="value2"><span data-ttu-id="a7dcd-432">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-432">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-433">Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="a7dcd-433">Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-434">Der erste Index des Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-434">The first index of the occurrence of any of the values in the span.</span></span> <span data-ttu-id="a7dcd-435">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-435">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsWhiteSpace (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsWhiteSpace(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member IsWhiteSpace : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.MemoryExtensions.IsWhiteSpace span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-436">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-436">The source span.</span></span></param>
        <summary><span data-ttu-id="a7dcd-437">Gibt an, ob die angegebene Spanne nur Leerzeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-437">Indicates whether the specified span contains only whitespace characters.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-438"><see langword="true" />, wenn die Spanne nur Leerzeichen enthält, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-438"><see langword="true" /> if the span contains only whitespace characters, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.MemoryExtensions.LastIndexOf (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-439">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-439">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-440">Der innerhalb der Quellspanne zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-440">The value to seek within the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="a7dcd-441">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="value" /> verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-441">An enumeration value that determines how <paramref name="span" /> and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="a7dcd-442">Gibt den NULL-basierten Index des letzten Vorkommens der angegebenen <paramref name="value" /> im aktuellen <paramref name="span" /> an.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-442">Reports the zero-based index of the last occurrence of the specified <paramref name="value" /> in the current <paramref name="span" />.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-443">Der Index des letzten Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-443">The index of the last occurrence of the value in the span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-444">Der Typ der Spanne und des Werts.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-444">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-445">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-445">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-446">Die zu suchende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-446">The sequence to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-447">Sucht nach der angegebenen Sequenz und gibt den Index des letzten Vorkommens zurück.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-447">Searches for the specified sequence and returns the index of its last occurrence.</span></span> <span data-ttu-id="a7dcd-448">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-448">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="a7dcd-449">Der Index des letzten Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-449">The index of the last occurrence of the value in the span.</span></span> <span data-ttu-id="a7dcd-450">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-450">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(ReadOnlySpan&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-451">Der Typ der Spanne und des Werts.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-451">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-452">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-452">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-453">Der zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-453">The value to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-454">Sucht nach dem angegebenen Wert und gibt den Index des letzten Vorkommens zurück.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-454">Searches for the specified value and returns the index of its last occurrence.</span></span> <span data-ttu-id="a7dcd-455">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-455">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="a7dcd-456">Der Index des letzten Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-456">The index of the last occurrence of the value in the span.</span></span> <span data-ttu-id="a7dcd-457">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-457">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf(Of T As IEquatable(Of T)) (span As Span(Of T), value As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-458">Der Typ der Spanne und des Werts.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-458">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-459">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-459">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-460">Die zu suchende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-460">The sequence to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-461">Sucht nach der angegebenen Sequenz und gibt den Index des letzten Vorkommens zurück.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-461">Searches for the specified sequence and returns the index of its last occurrence.</span></span> <span data-ttu-id="a7dcd-462">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-462">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="a7dcd-463">Der Index des letzten Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-463">The index of the last occurrence of the value in the span.</span></span> <span data-ttu-id="a7dcd-464">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-464">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf(Of T As IEquatable(Of T)) (span As Span(Of T), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(Span&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOf (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-465">Der Typ der Spanne und des Werts.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-465">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-466">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-466">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-467">Der zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-467">The value to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-468">Sucht nach dem angegebenen Wert und gibt den Index des letzten Vorkommens zurück.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-468">Searches for the specified value and returns the index of its last occurrence.</span></span> <span data-ttu-id="a7dcd-469">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-469">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="a7dcd-470">Der Index des letzten Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-470">The index of the last occurrence of the value in the span.</span></span> <span data-ttu-id="a7dcd-471">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-471">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), values As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-472">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-472">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-473">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-473">The span to search.</span></span></param>
        <param name="values"><span data-ttu-id="a7dcd-474">Der zu suchende Satz von Werten.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-474">The set of values to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-475">Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="a7dcd-475">Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-476">Der Index des letzten Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-476">The index of the last occurrence of any of the values in the span.</span></span> <span data-ttu-id="a7dcd-477">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-477">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), values As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-478">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-478">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-479">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-479">The span to search.</span></span></param>
        <param name="values"><span data-ttu-id="a7dcd-480">Der zu suchende Satz von Werten.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-480">The set of values to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-481">Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="a7dcd-481">Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-482">Der Index des letzten Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-482">The index of the last occurrence of any of the values in the span.</span></span> <span data-ttu-id="a7dcd-483">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-483">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value0, !!T value1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value0 As T, value1 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(ReadOnlySpan&lt;T&gt; span, T value0, T value1);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, value0, value1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-484">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-484">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-485">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-485">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="a7dcd-486">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-486">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="a7dcd-487">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-487">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-488">Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="a7dcd-488">Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-489">Der Index des letzten Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-489">The index of the last occurrence of any of the values in the span.</span></span> <span data-ttu-id="a7dcd-490">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-490">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value0, !!T value1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), value0 As T, value1 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(Span&lt;T&gt; span, T value0, T value1);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, value0, value1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-491">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-491">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-492">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-492">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="a7dcd-493">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-493">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="a7dcd-494">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-494">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-495">Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="a7dcd-495">Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-496">Der Index des letzten Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-496">The index of the last occurrence of any of the values in the span.</span></span> <span data-ttu-id="a7dcd-497">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-497">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value0, !!T value1, !!T value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value0 As T, value1 As T, value2 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, value0, value1, value2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
        <Parameter Name="value2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-498">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-498">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-499">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-499">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="a7dcd-500">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-500">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="a7dcd-501">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-501">One of the values to search for.</span></span></param>
        <param name="value2"><span data-ttu-id="a7dcd-502">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-502">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-503">Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="a7dcd-503">Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-504">Der Index des letzten Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-504">The index of the last occurrence of any of the values in the span.</span></span> <span data-ttu-id="a7dcd-505">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-505">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value0, !!T value1, !!T value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), value0 As T, value1 As T, value2 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(Span&lt;T&gt; span, T value0, T value1, T value2);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, value0, value1, value2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
        <Parameter Name="value2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-506">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-506">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-507">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-507">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="a7dcd-508">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-508">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="a7dcd-509">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-509">One of the values to search for.</span></span></param>
        <param name="value2"><span data-ttu-id="a7dcd-510">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-510">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="a7dcd-511">Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="a7dcd-511">Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-512">Der Index des letzten Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-512">The index of the last occurrence of any of the values in the span.</span></span> <span data-ttu-id="a7dcd-513">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-513">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Overlaps&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Overlaps(Of T) (span As ReadOnlySpan(Of T), other As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Overlaps(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member Overlaps : ReadOnlySpan&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; -&gt; bool" Usage="System.MemoryExtensions.Overlaps (span, other)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-514">Der Typ der in dem in der schreibgeschützten Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-514">The type of elmeents in the read-only sequence.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-515">Die erste Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-515">The first sequence.</span></span></param>
        <param name="other"><span data-ttu-id="a7dcd-516">Die zweite Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-516">The second sequence.</span></span></param>
        <summary><span data-ttu-id="a7dcd-517">Bestimmt, ob sich zwei schreibgeschützte Sequenzen im Speicher überlappen.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-517">Determines whether two read-only sequences overlap in memory.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-518"><see langword="true" />, wenn sich die beiden Sequenzen überlappen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-518"><see langword="true" /> if the two sequences overlap; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Overlaps&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Overlaps(Of T) (span As Span(Of T), other As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Overlaps(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member Overlaps : Span&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; -&gt; bool" Usage="System.MemoryExtensions.Overlaps (span, other)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-519">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-519">The type of elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-520">Die zu vergleichende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-520">The span to compare.</span></span></param>
        <param name="other"><span data-ttu-id="a7dcd-521">Die zu vergleichende schreibgeschützte Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-521">The read-only span to compare.</span></span></param>
        <summary><span data-ttu-id="a7dcd-522">Bestimmt, ob sich eine Spanne und eine schreibgeschützte Spanne im Speicher überlappen.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-522">Determines whether a span and a read-only span overlap in memory.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-523"><see langword="true" />, wenn sich die beiden Sequenzen überlappen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-523"><see langword="true" /> if the two sequences overlap; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other, out int elementOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Overlaps&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other, [out] int32&amp; elementOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Overlaps(Of T) (span As ReadOnlySpan(Of T), other As ReadOnlySpan(Of T), ByRef elementOffset As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Overlaps(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other, [Runtime::InteropServices::Out] int % elementOffset);" />
      <MemberSignature Language="F#" Value="static member Overlaps : ReadOnlySpan&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; * int -&gt; bool" Usage="System.MemoryExtensions.Overlaps (span, other, elementOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
        <Parameter Name="elementOffset" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-524">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-524">The type of elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-525">Die erste Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-525">The first sequence.</span></span></param>
        <param name="other"><span data-ttu-id="a7dcd-526">Die zweite Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-526">The second sequence.</span></span></param>
        <param name="elementOffset"><span data-ttu-id="a7dcd-527">Wenn die Methode zurückkehrt, enthält sie den Offset zwischen <paramref name="span" /> und <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-527">When the method returns, contains the offset between <paramref name="span" /> and <paramref name="other" />.</span></span></param>
        <summary><span data-ttu-id="a7dcd-528">Bestimmt, ob sich zwei schreibgeschützte Sequenzen im Speicher überlappen, und gibt den Elementoffset aus.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-528">Determines whether two read-only sequences overlap in memory and outputs the element offset.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-529"><see langword="true" />, wenn sich die beiden Sequenzen überlappen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-529"><see langword="true" /> if the two sequences overlap; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other, out int elementOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Overlaps&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other, [out] int32&amp; elementOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Overlaps(Of T) (span As Span(Of T), other As ReadOnlySpan(Of T), ByRef elementOffset As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Overlaps(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other, [Runtime::InteropServices::Out] int % elementOffset);" />
      <MemberSignature Language="F#" Value="static member Overlaps : Span&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; * int -&gt; bool" Usage="System.MemoryExtensions.Overlaps (span, other, elementOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
        <Parameter Name="elementOffset" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-530">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-530">The type of elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-531">Die erste zu vergleichende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-531">The first sequence to compare.</span></span></param>
        <param name="other"><span data-ttu-id="a7dcd-532">Die zweite zu vergleichende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-532">The second sequence to compare.</span></span></param>
        <param name="elementOffset"><span data-ttu-id="a7dcd-533">Wenn die Methode zurückkehrt, enthält sie den Offset zwischen <paramref name="span" /> und <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-533">When the method returns, contains the offset between <paramref name="span" /> and <paramref name="other" />.</span></span></param>
        <summary><span data-ttu-id="a7dcd-534">Bestimmt, ob sich eine Spanne und eine schreibgeschützte Spanne im Speicher überlappen, und gibt den Elementoffset aus.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-534">Determines whether a span and a read-only span overlap in memory and outputs the element offset.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-535"><see langword="true" />, wenn sich die beiden Sequenzen überlappen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-535"><see langword="true" /> if the two sequences overlap; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (this Span&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Reverse``1(System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Reverse(Of T) (span As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Reverse(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member Reverse : Span&lt;'T&gt; -&gt; unit" Usage="System.MemoryExtensions.Reverse span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-536">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-536">The type of elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-537">Die umzukehrende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-537">The span to reverse.</span></span></param>
        <summary><span data-ttu-id="a7dcd-538">Kehrt die Reihenfolge der Elemente in der gesamten Spanne um.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-538">Reverses the sequence of the elements in the entire span.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceCompareTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SequenceCompareTo&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IComparable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SequenceCompareTo&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceCompareTo(Of T As IComparable(Of T)) (span As ReadOnlySpan(Of T), other As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IComparable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int SequenceCompareTo(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member SequenceCompareTo : ReadOnlySpan&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="System.MemoryExtensions.SequenceCompareTo (span, other)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-539">Der Typ der Elemente in der Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-539">The type of elements in the sequence.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-540">Die erste zu vergleichende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-540">The first sequence to compare.</span></span></param>
        <param name="other"><span data-ttu-id="a7dcd-541">Die zweite zu vergleichende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-541">The second sequence to compare.</span></span></param>
        <summary><span data-ttu-id="a7dcd-542">Bestimmt die relative Reihenfolge von zwei schreibgeschützten Sequenzen durch Vergleichen ihrer Elemente mit „IComparable{T}.CompareTo(T)“.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-542">Determines the relative order of two read-only sequences by comparing their elements using IComparable{T}.CompareTo(T).</span></span></summary>
        <returns><span data-ttu-id="a7dcd-543">Eine ganze Zahl mit Vorzeichen, die die relative Reihenfolge von <paramref name="span" /> und <paramref name="other" /> angibt:</span><span class="sxs-lookup"><span data-stu-id="a7dcd-543">A signed integer that indicates the relative order of <paramref name="span" /> and <paramref name="other" />:</span></span><br />   <span data-ttu-id="a7dcd-544">– Wenn kleiner als 0, <paramref name="span" /> vor <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-544">- If less than 0, <paramref name="span" /> precedes than <paramref name="other" />.</span></span><br />   <span data-ttu-id="a7dcd-545">– Wenn diese 0 (null) sind, ist <paramref name="span" /> gleich <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-545">- If 0, <paramref name="span" /> equals <paramref name="other" />.</span></span><br />   <span data-ttu-id="a7dcd-546">– Wenn größer als 0, folgt <paramref name="span" /> auf <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-546">- If greater than 0, <paramref name="span" /> follows <paramref name="other" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceCompareTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SequenceCompareTo&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IComparable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SequenceCompareTo&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceCompareTo(Of T As IComparable(Of T)) (span As Span(Of T), other As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IComparable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int SequenceCompareTo(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member SequenceCompareTo : Span&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="System.MemoryExtensions.SequenceCompareTo (span, other)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-547">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-547">The type of elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-548">Die zu vergleichende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-548">The span to compare.</span></span></param>
        <param name="other"><span data-ttu-id="a7dcd-549">Die zu vergleichende schreibgeschützte Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-549">The read-only span to compare.</span></span></param>
        <summary><span data-ttu-id="a7dcd-550">Bestimmt die relative Reihenfolge von einer Spanne und einer schreibgeschützten Spanne durch Vergleichen der Elemente mit „IComparable{T}.CompareTo(T)“.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-550">Determines the relative order of a span and a read-only span by comparing the elements using IComparable{T}.CompareTo(T).</span></span></summary>
        <returns><span data-ttu-id="a7dcd-551">Eine ganze Zahl mit Vorzeichen, die die relative Reihenfolge von <paramref name="span" /> und <paramref name="other" /> angibt:</span><span class="sxs-lookup"><span data-stu-id="a7dcd-551">A signed integer that indicates the relative order of <paramref name="span" /> and <paramref name="other" />:</span></span><br />   <span data-ttu-id="a7dcd-552">– Wenn kleiner als 0, <paramref name="span" /> vor <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-552">- If less than 0, <paramref name="span" /> precedes than <paramref name="other" />.</span></span><br />   <span data-ttu-id="a7dcd-553">– Wenn diese 0 (null) sind, ist <paramref name="span" /> gleich <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-553">- If 0, <paramref name="span" /> equals <paramref name="other" />.</span></span><br />   <span data-ttu-id="a7dcd-554">– Wenn größer als 0, folgt <paramref name="span" /> auf <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-554">- If greater than 0, <paramref name="span" /> follows <paramref name="other" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), other As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.SequenceEqual (span, other)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-555">Der Typ der Elemente in der Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-555">The type of elements in the sequence.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-556">Die erste zu vergleichende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-556">The first sequence to compare.</span></span></param>
        <param name="other"><span data-ttu-id="a7dcd-557">Die zweite zu vergleichende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-557">The second sequence to compare.</span></span></param>
        <summary><span data-ttu-id="a7dcd-558">Bestimmt, ob zwei schreibgeschützte Sequenzen identisch sind, indem die Elemente mit „IEquatable{T}.Equals(T)“ verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-558">Determines whether two read-only sequences are equal by comparing the elements using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="a7dcd-559"><see langword="true" />, wenn die beiden Sequenzen identisch sind, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-559"><see langword="true" /> if the two sequences are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of T As IEquatable(Of T)) (span As Span(Of T), other As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.SequenceEqual (span, other)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-560">Der Typ der Elemente in der Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-560">The type of elements in the sequence.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-561">Die zu vergleichende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-561">The span to compare.</span></span></param>
        <param name="other"><span data-ttu-id="a7dcd-562">Die zu vergleichende schreibgeschützte Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-562">The read-only span to compare.</span></span></param>
        <summary><span data-ttu-id="a7dcd-563">Bestimmt, ob eine Spanne und eine schreibgeschützte Spanne identisch sind, indem die Elemente mit „IEquatable{T}.Equals(T)“ verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-563">Determines whether a span and a read-only span are equal by comparing the elements using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="a7dcd-564"><see langword="true" />, wenn die beiden Sequenzen identisch sind, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-564"><see langword="true" /> if the two sequences are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (this Span&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Sort``1(System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Sort(Of T) (span As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Sort(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member Sort : Span&lt;'T&gt; -&gt; unit" Usage="System.MemoryExtensions.Sort span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" Index="0" FrameworkAlternate="net-5.0" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="span">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (this Span&lt;T&gt; span, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Sort``1(System.Span{``0},System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Sort(Of T) (span As Span(Of T), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Sort(Span&lt;T&gt; span, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : Span&lt;'T&gt; * Comparison&lt;'T&gt; -&gt; unit" Usage="System.MemoryExtensions.Sort (span, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" Index="0" FrameworkAlternate="net-5.0" RefType="this" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="span">To be added.</param>
        <param name="comparison">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T,TComparer&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T,TComparer&gt; (this Span&lt;T&gt; span, TComparer comparer) where TComparer : System.Collections.Generic.IComparer&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T, (class System.Collections.Generic.IComparer`1&lt;!!T&gt;) TComparer&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!TComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Sort``2(System.Span{``0},``1)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Sort(Of T, TComparer) (span As Span(Of T), comparer As TComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TComparer&gt;&#xA; where TComparer : System::Collections::Generic::IComparer&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static void Sort(Span&lt;T&gt; span, TComparer comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Span&lt;'T&gt; * 'Comparer -&gt; unit (requires 'Comparer :&gt; System.Collections.Generic.IComparer&lt;'T&gt;)" Usage="System.MemoryExtensions.Sort (span, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TComparer">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IComparer&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" Index="0" FrameworkAlternate="net-5.0" RefType="this" />
        <Parameter Name="comparer" Type="TComparer" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TComparer">To be added.</typeparam>
        <param name="span">To be added.</param>
        <param name="comparer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (this Span&lt;TKey&gt; keys, Span&lt;TValue&gt; items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(valuetype System.Span`1&lt;!!TKey&gt; keys, valuetype System.Span`1&lt;!!TValue&gt; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Sort(Of TKey, TValue) (keys As Span(Of TKey), items As Span(Of TValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Sort(Span&lt;TKey&gt; keys, Span&lt;TValue&gt; items);" />
      <MemberSignature Language="F#" Value="static member Sort : Span&lt;'Key&gt; * Span&lt;'Value&gt; -&gt; unit" Usage="System.MemoryExtensions.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="System.Span&lt;TKey&gt;" Index="0" FrameworkAlternate="net-5.0" RefType="this" />
        <Parameter Name="items" Type="System.Span&lt;TValue&gt;" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">To be added.</typeparam>
        <typeparam name="TValue">To be added.</typeparam>
        <param name="keys">To be added.</param>
        <param name="items">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (this Span&lt;TKey&gt; keys, Span&lt;TValue&gt; items, Comparison&lt;TKey&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(valuetype System.Span`1&lt;!!TKey&gt; keys, valuetype System.Span`1&lt;!!TValue&gt; items, class System.Comparison`1&lt;!!TKey&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1},System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Sort(Of TKey, TValue) (keys As Span(Of TKey), items As Span(Of TValue), comparison As Comparison(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Sort(Span&lt;TKey&gt; keys, Span&lt;TValue&gt; items, Comparison&lt;TKey&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : Span&lt;'Key&gt; * Span&lt;'Value&gt; * Comparison&lt;'Key&gt; -&gt; unit" Usage="System.MemoryExtensions.Sort (keys, items, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="System.Span&lt;TKey&gt;" Index="0" FrameworkAlternate="net-5.0" RefType="this" />
        <Parameter Name="items" Type="System.Span&lt;TValue&gt;" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="comparison" Type="System.Comparison&lt;TKey&gt;" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">To be added.</typeparam>
        <typeparam name="TValue">To be added.</typeparam>
        <param name="keys">To be added.</param>
        <param name="items">To be added.</param>
        <param name="comparison">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue,TComparer&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue,TComparer&gt; (this Span&lt;TKey&gt; keys, Span&lt;TValue&gt; items, TComparer comparer) where TComparer : System.Collections.Generic.IComparer&lt;TKey&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue, (class System.Collections.Generic.IComparer`1&lt;!!TKey&gt;) TComparer&gt;(valuetype System.Span`1&lt;!!TKey&gt; keys, valuetype System.Span`1&lt;!!TValue&gt; items, !!TComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Sort``3(System.Span{``0},System.Span{``1},``2)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Sort(Of TKey, TValue, TComparer) (keys As Span(Of TKey), items As Span(Of TValue), comparer As TComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue, typename TComparer&gt;&#xA; where TComparer : System::Collections::Generic::IComparer&lt;TKey&gt;[System::Runtime::CompilerServices::Extension]&#xA; static void Sort(Span&lt;TKey&gt; keys, Span&lt;TValue&gt; items, TComparer comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Span&lt;'Key&gt; * Span&lt;'Value&gt; * 'Comparer -&gt; unit (requires 'Comparer :&gt; System.Collections.Generic.IComparer&lt;'Key&gt;)" Usage="System.MemoryExtensions.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
        <TypeParameter Name="TComparer">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IComparer&lt;TKey&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="System.Span&lt;TKey&gt;" Index="0" FrameworkAlternate="net-5.0" RefType="this" />
        <Parameter Name="items" Type="System.Span&lt;TValue&gt;" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="comparer" Type="TComparer" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">To be added.</typeparam>
        <typeparam name="TValue">To be added.</typeparam>
        <typeparam name="TComparer">To be added.</typeparam>
        <param name="keys">To be added.</param>
        <param name="items">To be added.</param>
        <param name="comparer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public static bool StartsWith (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool StartsWith(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StartsWith (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool StartsWith(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member StartsWith : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; bool" Usage="System.MemoryExtensions.StartsWith (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-565">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-565">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-566">Die Sequenz, die mit dem Anfang der Quellspanne verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-566">The sequence to compare to the beginning of the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="a7dcd-567">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="value" /> verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-567">An enumeration value that determines how <paramref name="span" /> and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="a7dcd-568">Bestimmt, ob eine schreibgeschützte Zeichenspanne mit einem angegebenen Wert beginnt, wenn sie mit einem angegebenen <see cref="T:System.StringComparison" />-Wert verglichen wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-568">Determines whether a read-only character span begins with a specified value when compared using a specified <see cref="T:System.StringComparison" /> value.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-569"><see langword="true" />, wenn <paramref name="value" /> mit dem Anfang von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-569"><see langword="true" /> if <paramref name="value" /> matches the beginning of <paramref name="span" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool StartsWith&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool StartsWith&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StartsWith(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool StartsWith(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member StartsWith : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.StartsWith (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-570">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-570">The type of elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-571">Die zu suchende schreibgeschützte Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-571">The read-only character span to search.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-572">Eine am Anfang von <paramref name="span" /> zu suchende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-572">A sequence to search for at the start of <paramref name="span" />.</span></span></param>
        <summary><span data-ttu-id="a7dcd-573">Bestimmt, ob eine angegebene Sequenz am Anfang einer schreibgeschützten Spanne angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-573">Determines whether a specified sequence appears at the start of a read-only span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-574"><see langword="true" />, wenn <paramref name="value" /> mit dem Anfang von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-574"><see langword="true" /> if <paramref name="value" /> matches the beginning of <paramref name="span" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool StartsWith&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool StartsWith&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StartsWith(Of T As IEquatable(Of T)) (span As Span(Of T), value As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool StartsWith(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member StartsWith : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.StartsWith (span, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-575">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-575">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-576">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-576">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="a7dcd-577">Eine am Anfang von <paramref name="span" /> zu suchende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-577">A sequence to search for at the start of <paramref name="span" />.</span></span></param>
        <summary><span data-ttu-id="a7dcd-578">Bestimmt, ob eine angegebene Sequenz am Anfang einer Spanne angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-578">Determines whether a specified sequence appears at the start of a span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-579"><see langword="true" />, wenn <paramref name="value" /> mit dem Anfang von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-579"><see langword="true" /> if <paramref name="value" /> matches the beginning of <paramref name="span" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static int ToLower (this ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToLower(valuetype System.ReadOnlySpan`1&lt;char&gt; source, valuetype System.Span`1&lt;char&gt; destination, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLower (source As ReadOnlySpan(Of Char), destination As Span(Of Char), culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int ToLower(ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToLower : ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * System.Globalization.CultureInfo -&gt; int" Usage="System.MemoryExtensions.ToLower (source, destination, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a7dcd-580">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-580">The source span.</span></span></param>
        <param name="destination"><span data-ttu-id="a7dcd-581">Die Zielspanne, die die transformierten Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-581">The destination span which contains the transformed characters.</span></span></param>
        <param name="culture"><span data-ttu-id="a7dcd-582">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-582">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="a7dcd-583">Kopiert die Zeichen aus der Quellspanne in das Ziel und konvertiert jedes Zeichen in Kleinbuchstaben, wobei die Regeln für die Groß-/Kleinschreibung der angegebenen Kultur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-583">Copies the characters from the source span into the destination, converting each character to lowercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-584">Die Anzahl der Zeichen, die in die Zielspanne geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-584">The number of characters written into the destination span.</span></span> <span data-ttu-id="a7dcd-585">Wenn das Ziel zu klein ist, wird -1 zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-585">If the destination is too small, returns -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-586">Wenn `culture` `null`ist, wird <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> verwendet.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-586">If `culture` is `null`, <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> will be used.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a7dcd-587">Die Quell- und Zielpuffer überlappen sich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-587">The source and destination buffers overlap.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public static int ToLowerInvariant (this ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToLowerInvariant(valuetype System.ReadOnlySpan`1&lt;char&gt; source, valuetype System.Span`1&lt;char&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLowerInvariant (source As ReadOnlySpan(Of Char), destination As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int ToLowerInvariant(ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination);" />
      <MemberSignature Language="F#" Value="static member ToLowerInvariant : ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; -&gt; int" Usage="System.MemoryExtensions.ToLowerInvariant (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a7dcd-588">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-588">The source span.</span></span></param>
        <param name="destination"><span data-ttu-id="a7dcd-589">Die Zielspanne, die die transformierten Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-589">The destination span which contains the transformed characters.</span></span></param>
        <summary><span data-ttu-id="a7dcd-590">Kopiert die Zeichen aus der Quellspanne in das Ziel und konvertiert jedes Zeichen in Kleinbuchstaben, wobei die Regeln für die Groß-/Kleinschreibung der invarianten Kultur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-590">Copies the characters from the source span into the destination, converting each character to lowercase, using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-591">Die Anzahl der Zeichen, die in die Zielspanne geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-591">The number of characters written into the destination span.</span></span> <span data-ttu-id="a7dcd-592">Wenn das Ziel zu klein ist, wird -1 zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-592">If the destination is too small, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a7dcd-593">Die Quell- und Zielpuffer überlappen sich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-593">The source and destination buffers overlap.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static int ToUpper (this ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToUpper(valuetype System.ReadOnlySpan`1&lt;char&gt; source, valuetype System.Span`1&lt;char&gt; destination, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToUpper (source As ReadOnlySpan(Of Char), destination As Span(Of Char), culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int ToUpper(ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToUpper : ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * System.Globalization.CultureInfo -&gt; int" Usage="System.MemoryExtensions.ToUpper (source, destination, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a7dcd-594">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-594">The source span.</span></span></param>
        <param name="destination"><span data-ttu-id="a7dcd-595">Die Zielspanne, die die transformierten Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-595">The destination span which contains the transformed characters.</span></span></param>
        <param name="culture"><span data-ttu-id="a7dcd-596">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-596">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="a7dcd-597">Kopiert die Zeichen aus der Quellspanne in das Ziel und konvertiert jedes Zeichen in Kleinbuchstaben, wobei die Regeln für die Groß-/Kleinschreibung der angegebenen Kultur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-597">Copies the characters from the source span into the destination, converting each character to uppercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-598">Die Anzahl der Zeichen, die in die Zielspanne geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-598">The number of characters written into the destination span.</span></span> <span data-ttu-id="a7dcd-599">Wenn das Ziel zu klein ist, wird -1 zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-599">If the destination is too small, returns -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-600">Wenn `culture` `null`ist, wird <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> verwendet.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-600">If `culture` is `null`, <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> will be used.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a7dcd-601">Die Quell- und Zielpuffer überlappen sich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-601">The source and destination buffers overlap.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public static int ToUpperInvariant (this ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToUpperInvariant(valuetype System.ReadOnlySpan`1&lt;char&gt; source, valuetype System.Span`1&lt;char&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToUpperInvariant (source As ReadOnlySpan(Of Char), destination As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int ToUpperInvariant(ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination);" />
      <MemberSignature Language="F#" Value="static member ToUpperInvariant : ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; -&gt; int" Usage="System.MemoryExtensions.ToUpperInvariant (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a7dcd-602">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-602">The source span.</span></span></param>
        <param name="destination"><span data-ttu-id="a7dcd-603">Die Zielspanne, die die transformierten Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-603">The destination span which contains the transformed characters.</span></span></param>
        <summary><span data-ttu-id="a7dcd-604">Kopiert die Zeichen aus der Quellspanne in das Ziel und konvertiert jedes Zeichen in Großbuchstaben, wobei die Regeln für die Groß-/Kleinschreibung der angegebenen Kultur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-604">Copies the characters from the source span into the destination, converting each character to uppercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-605">Die Anzahl der Zeichen, die in die Zielspanne geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-605">The number of characters written into the destination span.</span></span> <span data-ttu-id="a7dcd-606">Wenn das Ziel zu klein ist, wird -1 zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-606">If the destination is too small, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a7dcd-607">Die Quell- und Zielpuffer überlappen sich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-607">The source and destination buffers overlap.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static Memory&lt;char&gt; Trim (this Memory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;char&gt; Trim(valuetype System.Memory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.Memory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (memory As Memory(Of Char)) As Memory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;char&gt; Trim(Memory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member Trim : Memory&lt;char&gt; -&gt; Memory&lt;char&gt;" Usage="System.MemoryExtensions.Trim memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="a7dcd-608">Der Quellspeicher, aus dem die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-608">The source memory from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="a7dcd-609">Entfernt alle führenden und nachfolgenden Leerzeichen aus einem Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-609">Removes all leading and trailing whitespace characters from a character memory region.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-610">Der zugeschnittene Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-610">The trimmed character memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; Trim (this ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; Trim(valuetype System.ReadOnlyMemory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (memory As ReadOnlyMemory(Of Char)) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; Trim(ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlyMemory&lt;char&gt; -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.Trim memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="a7dcd-611">Der Quellspeicher, aus dem die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-611">The source memory from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="a7dcd-612">Entfernt alle führenden und nachfolgenden Leerzeichen aus einem schreibgeschützten Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-612">Removes all leading and trailing whitespace characters from a read-only character memory region.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-613">Der zugeschnittene Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-613">The trimmed character memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; Trim (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; Trim(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (span As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; Trim(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.Trim span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-614">Die Quellspanne, aus der die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-614">The source span from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="a7dcd-615">Entfernt alle führenden und nachfolgenden Leerzeichen aus einer schreibgeschützten Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-615">Removes all leading and trailing whitespace characters from a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-616">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-616">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static Span&lt;char&gt; Trim (this Span&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;char&gt; Trim(valuetype System.Span`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (span As Span(Of Char)) As Span(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;char&gt; Trim(Span&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member Trim : Span&lt;char&gt; -&gt; Span&lt;char&gt;" Usage="System.MemoryExtensions.Trim span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-617">Die Quellspanne, aus der die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-617">The source span from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="a7dcd-618">Entfernt alle führenden und nachfolgenden Leerzeichen aus einer Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-618">Removes all leading and trailing whitespace characters from a character span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-619">Der zugeschnittene Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-619">The trimmed character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; Trim (this ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; Trim(valuetype System.ReadOnlySpan`1&lt;char&gt; span, char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (span As ReadOnlySpan(Of Char), trimChar As Char) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; Trim(ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;char&gt; * char -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.Trim (span, trimChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-620">Die Quellspanne, aus der das Zeichen entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-620">The source span from which the character is removed.</span></span></param>
        <param name="trimChar"><span data-ttu-id="a7dcd-621">Das angegebene Zeichen, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-621">The specified character to look for and remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-622">Entfernt alle führenden und nachfolgenden Vorkommen eines bestimmten Zeichens aus einer schreibgeschützten Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-622">Removes all leading and trailing occurrences of a specified character from a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-623">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-623">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; Trim (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; Trim(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (span As ReadOnlySpan(Of Char), trimChars As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; Trim(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.Trim (span, trimChars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-624">Die Quellspanne, aus der die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-624">The source span from which the characters are removed.</span></span></param>
        <param name="trimChars"><span data-ttu-id="a7dcd-625">Die Spanne, die den zu entfernenden Zeichensatz enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-625">The span which contains the set of characters to remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-626">Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Zeichen, die in einer schreibgeschützten Spanne angegeben sind, aus einer schreibgeschützten Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-626">Removes all leading and trailing occurrences of a set of characters specified in a read-only span from a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-627">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-627">The trimmed read-only character span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-628">Wenn `trimChars` leer ist, werden stattdessen Leerzeichen entfernt.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-628">If `trimChars` is empty, whitespace characters are removed instead.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; Trim&lt;T&gt; (this Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.Memory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElements As ReadOnlySpan(Of T)) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; Trim(Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member Trim : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-629">Der Typ der Elemente im Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-629">The type of the elements in the memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="a7dcd-630">Der Quellspeicher, aus dem die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-630">The source memory from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="a7dcd-631">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-631">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-632">Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-632">Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a memory region.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-633">Der zugeschnittene Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-633">The trimmed memory region.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-634">Wenn `trimElements` leer ist, wird der Arbeitsspeicher unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-634">If `trimElements` is empty, the memory is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; Trim&lt;T&gt; (this Memory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.Memory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElement As T) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; Trim(Memory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member Trim : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (memory, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-635">Der Typ der Elemente im Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-635">The type of the elements in the memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="a7dcd-636">Der Quellspeicher, aus dem das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-636">The source memory from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="a7dcd-637">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-637">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-638">Entfernt alle führenden und nachfolgenden Vorkommen eines angegebenen Elements aus einem Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-638">Removes all leading and trailing occurrences of a specified element from a memory region.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-639">Der zugeschnittene Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-639">The trimmed memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt; Trim&lt;T&gt; (this ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; Trim(ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-640">Der Typ der Elemente im schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-640">The type of the elements in the read-only memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="a7dcd-641">Der Quellspeicher, aus dem die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-641">The source memory from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="a7dcd-642">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-642">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-643">Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-643">Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a read-only memory region.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-644">Der zugeschnittene, schreibgeschützte Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-644">The trimmed read-only memory region.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-645">Wenn `trimElements` leer ist, wird der Arbeitsspeicher unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-645">If `trimElements` is empty, the memory is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt; Trim&lt;T&gt; (this ReadOnlyMemory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElement As T) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; Trim(ReadOnlyMemory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (memory, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-646">Der Typ der Elemente im schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-646">The type of the elements in the read-only memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="a7dcd-647">Der Quellspeicher, aus dem das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-647">The source memory from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="a7dcd-648">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-648">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-649">Entfernt alle führenden und nachfolgenden Vorkommen eines angegebenen Elements aus einem schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-649">Removes all leading and trailing occurrences of a specified element from a read-only memory region.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-650">Der zugeschnittene, schreibgeschützte Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-650">The trimmed read-only memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; Trim&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; Trim(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-651">Der Typ der Elemente in der schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-651">The type of the elements in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-652">Die Quellspanne, aus der die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-652">The source span from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="a7dcd-653">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-653">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-654">Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einer schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-654">Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a read-only span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-655">Der zugeschnittene, schreibgeschützte Bereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-655">The trimmed read-only span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-656">Wenn `trimElements` leer ist, wird die Spanne unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-656">If `trimElements` is empty, the span is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; Trim&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElement As T) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; Trim(ReadOnlySpan&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (span, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-657">Der Typ der Elemente in der schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-657">The type of the elements in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-658">Die Quellspanne, aus der das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-658">The source span from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="a7dcd-659">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-659">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-660">Entfernt alle führenden und nachfolgenden Vorkommen eines angegebenen Elements aus einer schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-660">Removes all leading and trailing occurrences of a specified element from a read-only span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-661">Der zugeschnittene, schreibgeschützte Bereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-661">The trimmed read-only span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; Trim&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (span As Span(Of T), trimElements As ReadOnlySpan(Of T)) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; Trim(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member Trim : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-662">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-662">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-663">Die Quellspanne, aus der die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-663">The source span from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="a7dcd-664">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-664">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-665">Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einer Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-665">Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-666">Der zugeschnittene Bereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-666">The trimmed span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-667">Wenn `trimElements` leer ist, wird die Spanne unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-667">If `trimElements` is empty, the span is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; Trim&lt;T&gt; (this Span&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (span As Span(Of T), trimElement As T) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; Trim(Span&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member Trim : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (span, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-668">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-668">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-669">Die Quellspanne, aus der das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-669">The source span from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="a7dcd-670">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-670">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-671">Entfernt alle führenden und nachfolgenden Vorkommen eines angegebenen Elements aus einer Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-671">Removes all leading and trailing occurrences of a specified element from a span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-672">Der zugeschnittene Bereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-672">The trimmed span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static Memory&lt;char&gt; TrimEnd (this Memory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;char&gt; TrimEnd(valuetype System.Memory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.Memory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (memory As Memory(Of Char)) As Memory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;char&gt; TrimEnd(Memory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Memory&lt;char&gt; -&gt; Memory&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="a7dcd-673">Der Quellspeicher, aus dem die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-673">The source memory from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="a7dcd-674">Entfernt alle nachfolgenden Leerzeichen aus einem Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-674">Removes all trailing whitespace characters from a character memory region.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-675">Der zugeschnittene Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-675">The trimmed character memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; TrimEnd (this ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; TrimEnd(valuetype System.ReadOnlyMemory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (memory As ReadOnlyMemory(Of Char)) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; TrimEnd(ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlyMemory&lt;char&gt; -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="a7dcd-676">Der Quellspeicher, aus dem die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-676">The source memory from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="a7dcd-677">Entfernt alle nachfolgenden Leerzeichen aus einem schreibgeschützten Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-677">Removes all trailing whitespace characters from a read-only character memory region.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-678">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-678">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEnd (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEnd(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (span As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimEnd(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-679">Die Quellspanne, aus der die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-679">The source span from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="a7dcd-680">Entfernt alle nachfolgenden Leerzeichen aus einer schreibgeschützten Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-680">Removes all trailing whitespace characters from a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-681">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-681">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static Span&lt;char&gt; TrimEnd (this Span&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;char&gt; TrimEnd(valuetype System.Span`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (span As Span(Of Char)) As Span(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;char&gt; TrimEnd(Span&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Span&lt;char&gt; -&gt; Span&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-682">Die Quellspanne, aus der die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-682">The source span from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="a7dcd-683">Entfernt alle nachfolgenden Leerzeichen aus einer Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-683">Removes all trailing whitespace characters from a character span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-684">Der zugeschnittene Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-684">The trimmed character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEnd (this ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEnd(valuetype System.ReadOnlySpan`1&lt;char&gt; span, char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (span As ReadOnlySpan(Of Char), trimChar As Char) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimEnd(ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;char&gt; * char -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd (span, trimChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-685">Die Quellspanne, aus der das Zeichen entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-685">The source span from which the character is removed.</span></span></param>
        <param name="trimChar"><span data-ttu-id="a7dcd-686">Das angegebene Zeichen, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-686">The specified character to look for and remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-687">Entfernt alle nachfolgenden Vorkommen eines bestimmten Zeichens aus einer schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-687">Removes all trailing occurrences of a specified character from a read-only span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-688">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-688">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEnd (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEnd(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (span As ReadOnlySpan(Of Char), trimChars As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimEnd(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd (span, trimChars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-689">Die Quellspanne, aus der die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-689">The source span from which the characters are removed.</span></span></param>
        <param name="trimChars"><span data-ttu-id="a7dcd-690">Die Spanne, die den zu entfernenden Zeichensatz enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-690">The span which contains the set of characters to remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-691">Entfernt alle nachfolgenden Vorkommen einer Reihe von Zeichen, die in einer schreibgeschützten Spanne angegeben sind, aus einer schreibgeschützten Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-691">Removes all trailing occurrences of a set of characters specified in a read-only span from a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-692">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-692">The trimmed read-only character span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-693">Wenn `trimChars` leer ist, werden stattdessen Leerzeichen entfernt.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-693">If `trimChars` is empty, whitespace characters are removed instead.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; TrimEnd&lt;T&gt; (this Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElements As ReadOnlySpan(Of T)) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; TrimEnd(Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-694">Der Typ der Elemente im Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-694">The type of the elements in the memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="a7dcd-695">Der Quellspeicher, aus dem die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-695">The source memory from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="a7dcd-696">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-696">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-697">Entfernt alle nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-697">Removes all trailing occurrences of a set of elements specified in a read-only span from a memory region.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-698">Der zugeschnittene Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-698">The trimmed memory region.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-699">Wenn `trimElements` leer ist, wird der Arbeitsspeicher unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-699">If `trimElements` is empty, the memory is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; TrimEnd&lt;T&gt; (this Memory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElement As T) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; TrimEnd(Memory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (memory, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-700">Der Typ der Elemente im Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-700">The type of the elements in the memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="a7dcd-701">Der Quellspeicher, aus dem das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-701">The source memory from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="a7dcd-702">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-702">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-703">Entfernt alle nachfolgenden Vorkommen eines angegebenen Elements aus einem Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-703">Removes all trailing occurrences of a specified element from a character memory region.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-704">Der zugeschnittene Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-704">The trimmed memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt; TrimEnd&lt;T&gt; (this ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; TrimEnd(ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-705">Der Typ der Elemente im schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-705">The type of the elements in the read-only memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="a7dcd-706">Der Quellspeicher, aus dem die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-706">The source memory from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="a7dcd-707">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-707">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-708">Entfernt alle nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-708">Removes all trailing occurrences of a set of elements specified in a read-only span from a read-only memory region.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-709">Der zugeschnittene, schreibgeschützte Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-709">The trimmed read-only memory region.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-710">Wenn `trimElements` leer ist, wird der Arbeitsspeicher unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-710">If `trimElements` is empty, the memory is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt; TrimEnd&lt;T&gt; (this ReadOnlyMemory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElement As T) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; TrimEnd(ReadOnlyMemory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (memory, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-711">Der Typ der Elemente im schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-711">The type of the elements in the read-only memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="a7dcd-712">Der Quellspeicher, aus dem das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-712">The source memory from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="a7dcd-713">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-713">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-714">Entfernt alle nachfolgenden Vorkommen eines angegebenen Elements aus einem schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-714">Removes all trailing occurrences of a specified element from a read-only memory region.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-715">Der zugeschnittene, schreibgeschützte Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-715">The trimmed read-only memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; TrimEnd&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; TrimEnd(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-716">Der Typ der Elemente in der schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-716">The type of the elements in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-717">Die Quellspanne, aus der die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-717">The source span from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="a7dcd-718">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-718">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-719">Entfernt alle nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einer schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-719">Removes all trailing occurrences of a set of elements specified in a read-only span from a read-only span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-720">Der zugeschnittene, schreibgeschützte Bereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-720">The trimmed read-only span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-721">Wenn `trimElements` leer ist, wird die Spanne unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-721">If `trimElements` is empty, the span is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; TrimEnd&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElement As T) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; TrimEnd(ReadOnlySpan&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (span, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-722">Der Typ der Elemente in der schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-722">The type of the elements in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-723">Die Quellspanne, aus der das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-723">The source span from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="a7dcd-724">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-724">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-725">Entfernt alle nachfolgenden Vorkommen eines angegebenen Elements aus einer schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-725">Removes all trailing occurrences of a specified element from a read-only span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-726">Der zugeschnittene, schreibgeschützte Bereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-726">The trimmed read-only span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; TrimEnd&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (span As Span(Of T), trimElements As ReadOnlySpan(Of T)) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; TrimEnd(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-727">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-727">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-728">Die Quellspanne, aus der die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-728">The source span from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="a7dcd-729">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-729">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-730">Entfernt alle nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einer Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-730">Removes all trailing occurrences of a set of elements specified in a read-only span from a span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-731">Der zugeschnittene Bereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-731">The trimmed span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-732">Wenn `trimElements` leer ist, wird die Spanne unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-732">If `trimElements` is empty, the span is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; TrimEnd&lt;T&gt; (this Span&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (span As Span(Of T), trimElement As T) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; TrimEnd(Span&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (span, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-733">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-733">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-734">Die Quellspanne, aus der das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-734">The source span from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="a7dcd-735">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-735">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-736">Entfernt alle nachfolgenden Vorkommen eines angegebenen Elements aus einer Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-736">Removes all trailing occurrences of a specified element from a span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-737">Der zugeschnittene Bereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-737">The trimmed span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static Memory&lt;char&gt; TrimStart (this Memory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;char&gt; TrimStart(valuetype System.Memory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.Memory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (memory As Memory(Of Char)) As Memory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;char&gt; TrimStart(Memory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Memory&lt;char&gt; -&gt; Memory&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="a7dcd-738">Der Quellspeicher, aus dem die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-738">The source memory from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="a7dcd-739">Entfernt alle führenden Leerzeichen aus einem Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-739">Removes all leading whitespace characters from a memory region.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-740">Der zugeschnittene Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-740">The trimmed character memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; TrimStart (this ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; TrimStart(valuetype System.ReadOnlyMemory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (memory As ReadOnlyMemory(Of Char)) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; TrimStart(ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlyMemory&lt;char&gt; -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="a7dcd-741">Der Quellspeicher, aus dem die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-741">The source memory from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="a7dcd-742">Entfernt alle führenden Leerzeichen aus einem schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-742">Removes all leading whitespace characters from a read-only memory region.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-743">Der zugeschnittene, schreibgeschützte Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-743">The trimmed read-only character memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimStart (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimStart(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (span As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimStart(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-744">Die Quellspanne, aus der die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-744">The source span from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="a7dcd-745">Entfernt alle führenden Leerzeichen aus einer schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-745">Removes all leading whitespace characters from a read-only span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-746">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-746">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static Span&lt;char&gt; TrimStart (this Span&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;char&gt; TrimStart(valuetype System.Span`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (span As Span(Of Char)) As Span(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;char&gt; TrimStart(Span&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Span&lt;char&gt; -&gt; Span&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-747">Die Quellspanne, aus der die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-747">The source span from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="a7dcd-748">Entfernt alle führenden Leerzeichen aus einer Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-748">Removes all leading whitespace characters from a span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-749">Der zugeschnittene Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-749">The trimmed character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimStart (this ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimStart(valuetype System.ReadOnlySpan`1&lt;char&gt; span, char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (span As ReadOnlySpan(Of Char), trimChar As Char) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimStart(ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;char&gt; * char -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart (span, trimChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-750">Die Quellspanne, aus der das Zeichen entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-750">The source span from which the character is removed.</span></span></param>
        <param name="trimChar"><span data-ttu-id="a7dcd-751">Das angegebene Zeichen, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-751">The specified character to look for and remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-752">Entfernt alle führenden Vorkommen eines bestimmten Zeichens aus der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-752">Removes all leading occurrences of a specified character from the span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-753">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-753">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimStart (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimStart(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (span As ReadOnlySpan(Of Char), trimChars As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimStart(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart (span, trimChars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="a7dcd-754">Die Quellspanne, aus der die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-754">The source span from which the characters are removed.</span></span></param>
        <param name="trimChars"><span data-ttu-id="a7dcd-755">Die Spanne, die den zu entfernenden Zeichensatz enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-755">The span which contains the set of characters to remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-756">Entfernt alle führenden Vorkommen einer Reihe von Zeichen, die in einer schreibgeschützten Spanne angegeben sind, aus der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-756">Removes all leading occurrences of a set of characters specified in a read-only span from the span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-757">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-757">The trimmed read-only character span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-758">Wenn `trimChars` leer ist, werden stattdessen Leerzeichen entfernt.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-758">If `trimChars` is empty, whitespace characters are removed instead.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; TrimStart&lt;T&gt; (this Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElements As ReadOnlySpan(Of T)) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; TrimStart(Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-759">Der Typ der Elemente im Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-759">The type of the elements in the memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="a7dcd-760">Der Quellspeicher, aus dem die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-760">The source memory from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="a7dcd-761">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-761">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-762">Entfernt alle führenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-762">Removes all leading occurrences of a set of elements specified in a read-only span from a memory region.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-763">Der zugeschnittene Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-763">The trimmed memory region.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-764">Wenn `trimElements` leer ist, wird der Arbeitsspeicher unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-764">If `trimElements` is empty, the memory is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; TrimStart&lt;T&gt; (this Memory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElement As T) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; TrimStart(Memory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (memory, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-765">Der Typ der Elemente im Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-765">The type of the elements in the memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="a7dcd-766">Der Quellspeicherbereich, aus dem das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-766">The source memory region from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="a7dcd-767">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-767">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-768">Entfernt alle führenden Vorkommen eines angegebenen Elements aus einem Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-768">Removes all leading occurrences of a specified element from a memory region.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-769">Der zugeschnittene Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-769">The trimmed memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt; TrimStart&lt;T&gt; (this ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; TrimStart(ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-770">Der Typ der Elemente im schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-770">The type of the elements in the read-only memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="a7dcd-771">Der Quellspeicher, aus dem die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-771">The source memory from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="a7dcd-772">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-772">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-773">Entfernt alle führenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-773">Removes all leading occurrences of a set of elements specified in a read-only span from a memory region.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-774">Der zugeschnittene, schreibgeschützte Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-774">The trimmed read-only memory region.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-775">Wenn `trimElements` leer ist, wird der Arbeitsspeicher unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-775">If `trimElements` is empty, the memory is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt; TrimStart&lt;T&gt; (this ReadOnlyMemory&lt;T&gt; memory, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElement As T) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; TrimStart(ReadOnlyMemory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (memory, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-776">Der Typ der Elemente im schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-776">The type of the elements in the read-only memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="a7dcd-777">Der Quellspeicher, aus dem das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-777">The source memory from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="a7dcd-778">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-778">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-779">Entfernt alle führenden Vorkommen eines angegebenen Elements aus einem Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-779">Removes all leading occurrences of a specified element from a memory region.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-780">Der zugeschnittene, schreibgeschützte Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-780">The trimmed read-only memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; TrimStart&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; TrimStart(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-781">Der Typ der Elemente in der schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-781">The type of the elements in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-782">Die Quellspanne, aus der die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-782">The source span from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="a7dcd-783">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-783">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-784">Entfernt alle führenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-784">Removes all leading occurrences of a set of elements specified in a read-only span from the span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-785">Der zugeschnittene, schreibgeschützte Bereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-785">The trimmed read-only span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-786">Wenn `trimElements` leer ist, wird die Spanne unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-786">If `trimElements` is empty, the span is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; TrimStart&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElement As T) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; TrimStart(ReadOnlySpan&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (span, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-787">Der Typ der Elemente in der schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-787">The type of the elements in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-788">Die Quellspanne, aus der das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-788">The source span from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="a7dcd-789">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-789">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-790">Entfernt alle führenden Vorkommen eines bestimmten Elements aus der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-790">Removes all leading occurrences of a specified element from the span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-791">Der zugeschnittene, schreibgeschützte Bereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-791">The trimmed read-only span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; TrimStart&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (span As Span(Of T), trimElements As ReadOnlySpan(Of T)) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; TrimStart(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-792">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-792">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-793">Die Quellspanne, aus der die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-793">The source span from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="a7dcd-794">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-794">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-795">Entfernt alle führenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-795">Removes all leading occurrences of a set of elements specified in a read-only span from the span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-796">Der zugeschnittene Bereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-796">The trimmed span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a7dcd-797">Wenn `trimElements` leer ist, wird die Spanne unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-797">If `trimElements` is empty, the span is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; TrimStart&lt;T&gt; (this Span&lt;T&gt; span, T trimElement) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (span As Span(Of T), trimElement As T) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; TrimStart(Span&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (span, trimElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="a7dcd-798">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-798">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="a7dcd-799">Die Quellspanne, aus der das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-799">The source span from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="a7dcd-800">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-800">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="a7dcd-801">Entfernt alle führenden Vorkommen eines bestimmten Elements aus der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-801">Removes all leading occurrences of a specified element from the span.</span></span></summary>
        <returns><span data-ttu-id="a7dcd-802">Der zugeschnittene Bereich.</span><span class="sxs-lookup"><span data-stu-id="a7dcd-802">The trimmed span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
