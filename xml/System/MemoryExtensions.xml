<Type Name="MemoryExtensions" FullName="System.MemoryExtensions">
  <Metadata><Meta Name="ms.openlocfilehash" Value="732b4247716fb909632051420ea9a0543a05bf7c" /><Meta Name="ms.sourcegitcommit" Value="a372e6accee5099e1c114f8589ca6b4537f1caaa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/20/2020" /><Meta Name="ms.locfileid" Value="88655427" /></Metadata><TypeSignature Language="C#" Value="public static class MemoryExtensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit MemoryExtensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.MemoryExtensions" />
  <TypeSignature Language="VB.NET" Value="Public Module MemoryExtensions" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryExtensions abstract sealed" />
  <TypeSignature Language="F#" Value="type MemoryExtensions = class" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Memory" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="262ba-101">Bietet Erweiterungsmethoden für die Memory- und Span-bezogenen Typen wie <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" /> und <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-101">Provides extension methods for for the memory- and span-related types, such as <see cref="T:System.Memory`1" />, <see cref="T:System.ReadOnlyMemory`1" />, <see cref="T:System.Span`1" />, and <see cref="T:System.ReadOnlySpan`1" />.</span></span></summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string? text);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory (text As String) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory text" />
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="262ba-102">Die Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="262ba-102">The target string.</span></span></param>
        <summary><span data-ttu-id="262ba-103">Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über den Abschnitt der Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="262ba-103">Creates a new <see langword="ReadOnlyMemory&lt;Char&gt;" /> over the portion of the target string.</span></span></summary>
        <returns><span data-ttu-id="262ba-104">Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge oder <see langword="default" />, wenn <paramref name="text" /><see langword="null" /> ist.</span><span class="sxs-lookup"><span data-stu-id="262ba-104">The read-only character memory representation of the string, or <see langword="default" /> if <paramref name="text" /> is <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string? text, Index startIndex);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text, valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String,System.Index)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory (text As String, startIndex As Index) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text, Index startIndex);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string * Index -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory (text, startIndex)" />
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text, Index startIndex);" FrameworkAlternate="netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Index" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="262ba-105">Die Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="262ba-105">The target string.</span></span></param>
        <param name="startIndex"><span data-ttu-id="262ba-106">Der Index, an dem dieser Slice beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-106">The index at which to begin this slice.</span></span></param>
        <summary><span data-ttu-id="262ba-107">Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über einen Abschnitt der Zielzeichenfolge, beginnend bei einem angegebenen Index.</span><span class="sxs-lookup"><span data-stu-id="262ba-107">Creates a new <see langword="ReadOnlyMemory&lt;Char&gt;" /> over a portion of the target string starting at a specified index.</span></span></summary>
        <returns><span data-ttu-id="262ba-108">Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="262ba-108">The read-only character memory representation of the string.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string? text, int start);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory (text As String, start As Integer) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text, int start);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string * int -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory (text, start)" />
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text, int start);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="262ba-109">Die Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="262ba-109">The target string.</span></span></param>
        <param name="start"><span data-ttu-id="262ba-110">Der Index, an dem dieser Slice beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-110">The index at which to begin this slice.</span></span></param>
        <summary><span data-ttu-id="262ba-111">Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über einen Abschnitt der Zielzeichenfolge, beginnend bei einer angegebenen Zeichenposition.</span><span class="sxs-lookup"><span data-stu-id="262ba-111">Creates a new <see langword="ReadOnlyMemory&lt;Char&gt;" /> over a portion of the target string starting at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="262ba-112">Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge oder <see langword="default" />, wenn <paramref name="text" /><see langword="null" /> ist.</span><span class="sxs-lookup"><span data-stu-id="262ba-112">The read-only character memory representation of the string, or <see langword="default" /> if <paramref name="text" /> is <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="262ba-113"><paramref name="start" /> liegt nicht im Bereich von <paramref name="text" />. (<paramref name="start" /> ist &lt; 0 oder &gt; <c>text.Length</c>).</span><span class="sxs-lookup"><span data-stu-id="262ba-113"><paramref name="start" /> is not in the range of <paramref name="text" /> (<paramref name="start" /> is &lt; 0 or &gt; <c>text.Length</c>).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string? text, Range range);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text, valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String,System.Range)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory (text As String, range As Range) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text, Range range);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string * Range -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory (text, range)" />
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text, Range range);" FrameworkAlternate="netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="range" Type="System.Range" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="262ba-114">Die Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="262ba-114">The target string.</span></span></param>
        <param name="range"><span data-ttu-id="262ba-115">Der Bereich, der den Anfang und die Länge der unterteilten Zeichenfolge angibt.</span><span class="sxs-lookup"><span data-stu-id="262ba-115">The range that indicates the start and length of the sliced string.</span></span></param>
        <summary><span data-ttu-id="262ba-116">Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über einen angegebenen Bereich der Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="262ba-116">Creates a new <see langword="ReadOnlyMemory&lt;Char&gt;" /> over a specified range of the target string.</span></span></summary>
        <returns><span data-ttu-id="262ba-117">Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="262ba-117">The read-only character memory representation of the string.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string? text, int start, int length);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; AsMemory(string text, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory (text As String, start As Integer, length As Integer) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; AsMemory(System::String ^ text, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsMemory : string * int * int -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.AsMemory (text, start, length)" />
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; AsMemory (this string text, int start, int length);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="262ba-118">Die Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="262ba-118">The target string.</span></span></param>
        <param name="start"><span data-ttu-id="262ba-119">Der Index, an dem dieser Slice beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-119">The index at which to begin this slice.</span></span></param>
        <param name="length"><span data-ttu-id="262ba-120">Die gewünschte Länge des Slices.</span><span class="sxs-lookup"><span data-stu-id="262ba-120">The desired length for the slice.</span></span></param>
        <summary><span data-ttu-id="262ba-121">Erstellt ein neues <see langword="ReadOnlyMemory&lt;Char&gt;" /> über einen Abschnitt der Zielzeichenfolge, beginnend bei einer angegebenen Position mit einer Länge.</span><span class="sxs-lookup"><span data-stu-id="262ba-121">Creates a new <see langword="ReadOnlyMemory&lt;Char&gt;" /> over a portion of the target string beginning at a specified position with a length.</span></span></summary>
        <returns><span data-ttu-id="262ba-122">Die schreibgeschützte Zeichenspeicherdarstellung der Zeichenfolge oder <see langword="default" />, wenn <paramref name="text" /><see langword="null" /> ist.</span><span class="sxs-lookup"><span data-stu-id="262ba-122">The read-only character memory representation of the string, or <see langword="default" /> if <paramref name="text" /> is <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="262ba-123"><paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="text" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-123"><paramref name="start" />, <paramref name="length" />, or <paramref name="start" /> + <paramref name="length" /> is not in the range of <paramref name="text" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? AsMemory&lt;T&gt; (this ArraySegment&lt;T&gt;? segment);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (segment As ArraySegment(Of T)) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="F#" Value="static member AsMemory : ArraySegment&lt;'T&gt; -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory segment" />
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-124">Der Typ des Segments.</span><span class="sxs-lookup"><span data-stu-id="262ba-124">The type of the segment.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="262ba-125">Das zu konvertierende Segment.</span><span class="sxs-lookup"><span data-stu-id="262ba-125">The segment to convert.</span></span></param>
        <summary><span data-ttu-id="262ba-126">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarraysegments.</span><span class="sxs-lookup"><span data-stu-id="262ba-126">Creates a new memory region over the portion of the target array segment.</span></span></summary>
        <returns><span data-ttu-id="262ba-127">Die Speicherdarstellung des Segments.</span><span class="sxs-lookup"><span data-stu-id="262ba-127">The memory representation of the segment.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? AsMemory&lt;T&gt; (this T[]? array);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (array As T()) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory array" />
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-128">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-128">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="262ba-129">Das zu konvertierende Array.</span><span class="sxs-lookup"><span data-stu-id="262ba-129">The array to convert.</span></span></param>
        <summary><span data-ttu-id="262ba-130">Erstellt einen neuen Speicherbereich über dem Zielarray.</span><span class="sxs-lookup"><span data-stu-id="262ba-130">Creates a new memory region over the target array.</span></span></summary>
        <returns><span data-ttu-id="262ba-131">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-131">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? AsMemory&lt;T&gt; (this ArraySegment&lt;T&gt;? segment, int start);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (segment As ArraySegment(Of T), start As Integer) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(ArraySegment&lt;T&gt; segment, int start);" />
      <MemberSignature Language="F#" Value="static member AsMemory : ArraySegment&lt;'T&gt; * int -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (segment, start)" />
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this ArraySegment&lt;T&gt; segment, int start);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-132">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-132">The type of the array.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="262ba-133">Das Zielarraysegment.</span><span class="sxs-lookup"><span data-stu-id="262ba-133">The target array segment.</span></span></param>
        <param name="start"><span data-ttu-id="262ba-134">Der Index, an dem der Speicher beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-134">The index at which to begin the memory.</span></span></param>
        <summary><span data-ttu-id="262ba-135">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarraysegments, beginnend an einer angegebenen Position bis zum Ende des Segments.</span><span class="sxs-lookup"><span data-stu-id="262ba-135">Creates a new memory region over the portion of the target array segment starting at a specified position to the end of the segment.</span></span></summary>
        <returns><span data-ttu-id="262ba-136">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-136">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-137">Gibt zurück, `default` Wenn `segment` ist `null` .</span><span class="sxs-lookup"><span data-stu-id="262ba-137">Returns `default` when `segment` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="262ba-138"><paramref name="segment" /> ist kovariant, und den Typ von <paramref name="segment" /> ist nicht genau <see langword="T[]" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-138"><paramref name="segment" /> is covariant, and the type of <paramref name="segment" /> is not exactly <see langword="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="262ba-139"><paramref name="start" /> ist kleiner als 0 oder größer als <see langword="segment.Count" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-139"><paramref name="start" /> is less than 0 or greater than <see langword="segment.Count" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? AsMemory&lt;T&gt; (this T[]? array, Index startIndex);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array, valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[],System.Index)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (array As T(), startIndex As Index) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array, Index startIndex);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] * Index -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (array, startIndex)" />
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array, Index startIndex);" FrameworkAlternate="netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Index" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-140">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-140">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="262ba-141">Das zu konvertierende Array.</span><span class="sxs-lookup"><span data-stu-id="262ba-141">The array to convert.</span></span></param>
        <param name="startIndex"><span data-ttu-id="262ba-142">Die erste Position des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-142">The first position of the array.</span></span></param>
        <summary><span data-ttu-id="262ba-143">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarrays, beginnend bei einem angegebenen Index bis zum Ende des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-143">Creates a new memory region over the portion of the target array starting at a specified index to the end of the array.</span></span></summary>
        <returns><span data-ttu-id="262ba-144">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-144">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? AsMemory&lt;T&gt; (this T[]? array, int start);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (array As T(), start As Integer) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array, int start);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] * int -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (array, start)" />
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array, int start);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-145">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-145">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="262ba-146">Das Zielarray.</span><span class="sxs-lookup"><span data-stu-id="262ba-146">The target array.</span></span></param>
        <param name="start"><span data-ttu-id="262ba-147">Der Index, an dem der Speicher beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-147">The index at which to begin the memory.</span></span></param>
        <summary><span data-ttu-id="262ba-148">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarrays, beginnend an einem angegebenen Position bis zum Ende des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-148">Creates a new memory region over the portion of the target array starting at a specified position to the end of the array.</span></span></summary>
        <returns><span data-ttu-id="262ba-149">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-149">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-150">Gibt zurück, `default` Wenn `array` ist `null` .</span><span class="sxs-lookup"><span data-stu-id="262ba-150">Returns `default` when `array` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="262ba-151"><paramref name="array" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-151"><paramref name="array" /> is covariant, and the array's type is not exactly <see langword="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="262ba-152"><paramref name="start" />-Index kleiner als 0 oder größer als <see langword="array.Length" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-152"><paramref name="start" /> index less than 0 or greater than <see langword="array.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? AsMemory&lt;T&gt; (this T[]? array, Range range);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array, valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[],System.Range)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (array As T(), range As Range) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array, Range range);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] * Range -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (array, range)" />
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array, Range range);" FrameworkAlternate="netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="range" Type="System.Range" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-153">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-153">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="262ba-154">Das zu konvertierende Array.</span><span class="sxs-lookup"><span data-stu-id="262ba-154">The array to convert.</span></span></param>
        <param name="range"><span data-ttu-id="262ba-155">Der aus dem Array zu konvertierende Bereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-155">The range to convert from the array.</span></span></param>
        <summary><span data-ttu-id="262ba-156">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarrays, beginnend mit dem inklusiven Startindex des Bereichs und endend mit dem exklusiven Endindex des Bereichs.</span><span class="sxs-lookup"><span data-stu-id="262ba-156">Creates a new memory region over the portion of the target array beginning at inclusive start index of the range and ending at the exclusive end index of the range.</span></span></summary>
        <returns><span data-ttu-id="262ba-157">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-157">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? AsMemory&lt;T&gt; (this ArraySegment&lt;T&gt;? segment, int start, int length);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(System.ArraySegment{``0},System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (segment As ArraySegment(Of T), start As Integer, length As Integer) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(ArraySegment&lt;T&gt; segment, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsMemory : ArraySegment&lt;'T&gt; * int * int -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (segment, start, length)" />
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this ArraySegment&lt;T&gt; segment, int start, int length);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-158">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-158">The type of the array.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="262ba-159">Das Zielarraysegment.</span><span class="sxs-lookup"><span data-stu-id="262ba-159">The target array segment.</span></span></param>
        <param name="start"><span data-ttu-id="262ba-160">Der Index, an dem der Speicher beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-160">The index at which to begin the memory.</span></span></param>
        <param name="length"><span data-ttu-id="262ba-161">Die Anzahl der Elemente im Speicher.</span><span class="sxs-lookup"><span data-stu-id="262ba-161">The number of items in the memory.</span></span></param>
        <summary><span data-ttu-id="262ba-162">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarraysegments, beginnend an einer angegebenen Position mit einer angegebenen Länge.</span><span class="sxs-lookup"><span data-stu-id="262ba-162">Creates a new memory region over the portion of the target array segment beginning at a specified position with a specified length.</span></span></summary>
        <returns><span data-ttu-id="262ba-163">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-163">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-164">Gibt zurück, `default` Wenn `segment` ist `null` .</span><span class="sxs-lookup"><span data-stu-id="262ba-164">Returns `default` when `segment` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="262ba-165"><paramref name="segment" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-165"><paramref name="segment" /> is covariant, and the array's type is not exactly <see langword="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="262ba-166"><paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="segment" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-166"><paramref name="start" />, <paramref name="length" />, or <paramref name="start" /> + <paramref name="length" /> is not in the range of <paramref name="segment" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsMemory&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? AsMemory&lt;T&gt; (this T[]? array, int start, int length);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; AsMemory&lt;T&gt;(!!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsMemory``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsMemory(Of T) (array As T(), start As Integer, length As Integer) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; AsMemory(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsMemory : 'T[] * int * int -&gt; Memory&lt;'T&gt;" Usage="System.MemoryExtensions.AsMemory (array, start, length)" />
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt; AsMemory&lt;T&gt; (this T[] array, int start, int length);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-167">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-167">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="262ba-168">Das Zielarray.</span><span class="sxs-lookup"><span data-stu-id="262ba-168">The target array.</span></span></param>
        <param name="start"><span data-ttu-id="262ba-169">Der Index, an dem der Speicherbereich beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-169">The index at which to begin the memory region.</span></span></param>
        <param name="length"><span data-ttu-id="262ba-170">Die Anzahl der Elemente im Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-170">The number of items in the memory region.</span></span></param>
        <summary><span data-ttu-id="262ba-171">Erstellt einen neuen Speicherbereich über dem Abschnitt des Zielarrays, beginnend an einer angegebenen Position mit einer angegebenen Länge.</span><span class="sxs-lookup"><span data-stu-id="262ba-171">Creates a new memory region over the portion of the target array beginning at a specified position with a specified length.</span></span></summary>
        <returns><span data-ttu-id="262ba-172">Die Speicherdarstellung des gesamten oder eines Teils des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-172">The memory representation of the whole or part of the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-173">Gibt zurück, `default` Wenn `array` ist `null` .</span><span class="sxs-lookup"><span data-stu-id="262ba-173">Returns `default` when `array` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="262ba-174"><paramref name="array" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-174"><paramref name="array" /> is covariant, and the array's type is not exactly <see langword="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="262ba-175"><paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-175"><paramref name="start" />, <paramref name="length" />, or <paramref name="start" /> + <paramref name="length" /> is not in the range of <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; AsSpan (this string? text);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; AsSpan(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan(System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan (text As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; AsSpan(System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member AsSpan : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.AsSpan text" />
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; AsSpan (this string text);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="262ba-176">Die Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="262ba-176">The target string.</span></span></param>
        <summary><span data-ttu-id="262ba-177">Erstellt eine neue schreibgeschützte Spanne über einen Abschnitt der Zielzeichenfolge von einer angegebenen Position aus für eine angegebene Anzahl von Zeichen.</span><span class="sxs-lookup"><span data-stu-id="262ba-177">Creates a new read-only span over a portion of the target string from a specified position for a specified number of characters.</span></span></summary>
        <returns><span data-ttu-id="262ba-178">Die schreibgeschützte Spannendarstellung der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="262ba-178">The read-only span representation of the string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-179">Gibt zurück, `default` Wenn `text` ist `null` .</span><span class="sxs-lookup"><span data-stu-id="262ba-179">Returns `default` when `text` is `null`.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; AsSpan (this string? text, int start);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; AsSpan(string text, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan (text As String, start As Integer) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; AsSpan(System::String ^ text, int start);" />
      <MemberSignature Language="F#" Value="static member AsSpan : string * int -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.AsSpan (text, start)" />
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; AsSpan (this string text, int start);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="262ba-180">Die Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="262ba-180">The target string.</span></span></param>
        <param name="start"><span data-ttu-id="262ba-181">Der Index, an dem dieser Slice beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-181">The index at which to begin this slice.</span></span></param>
        <summary><span data-ttu-id="262ba-182">Erstellt eine neue schreibgeschützte Spanne über einen Abschnitt der Zielzeichenfolge von einer angegebenen Position aus bis zum Ende der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="262ba-182">Creates a new read-only span over a portion of the target string from a specified position to the end of the string.</span></span></summary>
        <returns><span data-ttu-id="262ba-183">Die schreibgeschützte Spannendarstellung der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="262ba-183">The read-only span representation of the string.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="262ba-184"><paramref name="text" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-184"><paramref name="text" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="262ba-185"><paramref name="start" /> ist kleiner als 0 oder größer als <see langword="text.Length" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-185"><paramref name="start" /> is less than 0 or greater than <see langword="text.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; AsSpan (this string? text, int start, int length);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; AsSpan(string text, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan (text As String, start As Integer, length As Integer) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; AsSpan(System::String ^ text, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsSpan : string * int * int -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.AsSpan (text, start, length)" />
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; AsSpan (this string text, int start, int length);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text"><span data-ttu-id="262ba-186">Die Zielzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="262ba-186">The target string.</span></span></param>
        <param name="start"><span data-ttu-id="262ba-187">Der Index, an dem dieser Slice beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-187">The index at which to begin this slice.</span></span></param>
        <param name="length"><span data-ttu-id="262ba-188">Die gewünschte Länge des Slices.</span><span class="sxs-lookup"><span data-stu-id="262ba-188">The desired length for the slice.</span></span></param>
        <summary><span data-ttu-id="262ba-189">Erstellt eine neue schreibgeschützte Spanne über eine Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="262ba-189">Creates a new read-only span over a string.</span></span></summary>
        <returns><span data-ttu-id="262ba-190">Die schreibgeschützte Spannendarstellung der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="262ba-190">The read-only span representation of the string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-191">Gibt zurück, `default` Wenn `text` ist `null` .</span><span class="sxs-lookup"><span data-stu-id="262ba-191">Returns `default` when `text` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="262ba-192"><paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="text" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-192"><paramref name="start" />, <paramref name="length" />, or <paramref name="start" /> + <paramref name="length" /> is not in the range of <paramref name="text" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt;? segment);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (segment As ArraySegment(Of T)) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan segment" />
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-193">Der Typ des Array Segments.</span><span class="sxs-lookup"><span data-stu-id="262ba-193">The type of the array segment.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="262ba-194">Das zu konvertierende Arraysegment.</span><span class="sxs-lookup"><span data-stu-id="262ba-194">The array segment to convert.</span></span></param>
        <summary><span data-ttu-id="262ba-195">Erstellt eine neue Spanne über einem Zielarraysegment.</span><span class="sxs-lookup"><span data-stu-id="262ba-195">Creates a new span over a target array segment.</span></span></summary>
        <returns><span data-ttu-id="262ba-196">Die Spannendarstellung des Arraysegments.</span><span class="sxs-lookup"><span data-stu-id="262ba-196">The span representation of the array segment.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? AsSpan&lt;T&gt; (this T[]? array);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (array As T()) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan array" />
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-197">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-197">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="262ba-198">Das zu konvertierende Array.</span><span class="sxs-lookup"><span data-stu-id="262ba-198">The array to convert.</span></span></param>
        <summary><span data-ttu-id="262ba-199">Erstellt eine neue Spanne über einem Zielarray.</span><span class="sxs-lookup"><span data-stu-id="262ba-199">Creates a new span over a target array.</span></span></summary>
        <returns><span data-ttu-id="262ba-200">Die Spannendarstellung des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-200">The span representation of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt;? segment, Index startIndex);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Index)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (segment As ArraySegment(Of T), startIndex As Index) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment, Index startIndex);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; * Index -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (segment, startIndex)" />
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment, Index startIndex);" FrameworkAlternate="netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Index" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-201">Der Typ des Array Segments.</span><span class="sxs-lookup"><span data-stu-id="262ba-201">The type of the array segment.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="262ba-202">Das Zielarraysegment.</span><span class="sxs-lookup"><span data-stu-id="262ba-202">The target array segment.</span></span></param>
        <param name="startIndex"><span data-ttu-id="262ba-203">Der Index, an dem die Spanne beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-203">The index at which to begin the Span.</span></span></param>
        <summary><span data-ttu-id="262ba-204">Erstellt eine neue Spanne über einem Abschnitt des Zielarraysegments, beginnend mit einem angegebenen Index und endend mit dem Segmentende.</span><span class="sxs-lookup"><span data-stu-id="262ba-204">Creates a new span over a portion of the target array segment beginning at a specified index and ending at the end of the segment.</span></span></summary>
        <returns><span data-ttu-id="262ba-205">Die Spannendarstellung des Arraysegments.</span><span class="sxs-lookup"><span data-stu-id="262ba-205">The span representation of the array segment.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt;? segment, int start);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (segment As ArraySegment(Of T), start As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment, int start);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; * int -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (segment, start)" />
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment, int start);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-206">Der Typ des Array Segments.</span><span class="sxs-lookup"><span data-stu-id="262ba-206">The type of the array segment.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="262ba-207">Das Zielarraysegment.</span><span class="sxs-lookup"><span data-stu-id="262ba-207">The target array segment.</span></span></param>
        <param name="start"><span data-ttu-id="262ba-208">Der Index, an dem die Spanne beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-208">The index at which to begin the san.</span></span></param>
        <summary><span data-ttu-id="262ba-209">Erstellt eine neue Spanne über einem Abschnitt eines Zielarraysegments von einer bestimmten Position aus bis zum Segmentende.</span><span class="sxs-lookup"><span data-stu-id="262ba-209">Creates a new span over a portion of a target array segment from a specified position to the end of the segment.</span></span></summary>
        <returns><span data-ttu-id="262ba-210">Die Spannendarstellung des Arraysegments.</span><span class="sxs-lookup"><span data-stu-id="262ba-210">The span representation of the array segment.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-211">Gibt zurück, `default` Wenn `segment` ist `null` .</span><span class="sxs-lookup"><span data-stu-id="262ba-211">Returns `default` when `segment` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="262ba-212"><paramref name="segment" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-212"><paramref name="segment" /> is covariant, and the array's type is not exactly <see langword="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="262ba-213"><paramref name="start" /> ist kleiner als 0 oder größer als <see langword="segment.Count" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-213"><paramref name="start" /> is less than 0 or greater than <see langword="segment.Count" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt;? segment, Range range);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Range)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (segment As ArraySegment(Of T), range As Range) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment, Range range);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; * Range -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (segment, range)" />
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment, Range range);" FrameworkAlternate="netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="range" Type="System.Range" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-214">Der Typ des Array Segments.</span><span class="sxs-lookup"><span data-stu-id="262ba-214">The type of the array segment.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="262ba-215">Das Zielarraysegment.</span><span class="sxs-lookup"><span data-stu-id="262ba-215">The target array segment.</span></span></param>
        <param name="range"><span data-ttu-id="262ba-216">Der Bereich, der Start- und Endindizes aufweist, die für das Unterteilen des Arrays verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="262ba-216">The range which has start and end indexes to use for slicing the array.</span></span></param>
        <summary><span data-ttu-id="262ba-217">Erstellt eine neue Spanne über einem Abschnitt eines Zielarraysegments unter Verwendung der Start- und Endindizes des Bereichs.</span><span class="sxs-lookup"><span data-stu-id="262ba-217">Creates a new span over a portion of a target array segment using the range start and end indexes.</span></span></summary>
        <returns><span data-ttu-id="262ba-218">Die Spannendarstellung des Arraysegments.</span><span class="sxs-lookup"><span data-stu-id="262ba-218">The span representation of the array segment.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? AsSpan&lt;T&gt; (this T[]? array, Index startIndex);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array, valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[],System.Index)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (array As T(), startIndex As Index) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array, Index startIndex);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] * Index -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (array, startIndex)" />
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array, Index startIndex);" FrameworkAlternate="netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Index" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-219">Der Arraytyp.</span><span class="sxs-lookup"><span data-stu-id="262ba-219">The array type.</span></span></typeparam>
        <param name="array"><span data-ttu-id="262ba-220">Das zu konvertierende Array.</span><span class="sxs-lookup"><span data-stu-id="262ba-220">The array to convert.</span></span></param>
        <param name="startIndex"><span data-ttu-id="262ba-221">Der Startindex.</span><span class="sxs-lookup"><span data-stu-id="262ba-221">The starting index.</span></span></param>
        <summary><span data-ttu-id="262ba-222">Erstellt eine neue Spanne über dem Abschnitt des Zielarrays, das durch einen <see cref="T:System.Index" />-Wert definiert ist.</span><span class="sxs-lookup"><span data-stu-id="262ba-222">Creates a new span over the portion of the target array defined by an <see cref="T:System.Index" /> value.</span></span></summary>
        <returns><span data-ttu-id="262ba-223">Die Spannendarstellung des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-223">The span representation of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? AsSpan&lt;T&gt; (this T[]? array, int start);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (array As T(), start As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array, int start);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] * int -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (array, start)" />
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array, int start);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-224">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-224">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="262ba-225">Das zu konvertierende Array.</span><span class="sxs-lookup"><span data-stu-id="262ba-225">The array to convert.</span></span></param>
        <param name="start"><span data-ttu-id="262ba-226">Der anfängliche Index, aus dem das Array konvertiert wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-226">The initial index from which the array will be converted.</span></span></param>
        <summary><span data-ttu-id="262ba-227">Erstellt eine neue Spanne über einem Abschnitt des Zielarrays, beginnend an einer angegebenen Position bis zum Ende des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-227">Creates a new span over a portion of the target array starting at a specified position to the end of the array.</span></span></summary>
        <returns><span data-ttu-id="262ba-228">Die Spannendarstellung des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-228">The span representation of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? AsSpan&lt;T&gt; (this T[]? array, Range range);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array, valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[],System.Range)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (array As T(), range As Range) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array, Range range);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] * Range -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (array, range)" />
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array, Range range);" FrameworkAlternate="netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="range" Type="System.Range" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-229">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-229">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="262ba-230">Das zu konvertierende Array.</span><span class="sxs-lookup"><span data-stu-id="262ba-230">The array to convert.</span></span></param>
        <param name="range"><span data-ttu-id="262ba-231">Der Bereich des zu konvertierenden Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-231">The range of the array to convert.</span></span></param>
        <summary><span data-ttu-id="262ba-232">Erstellt eine neue Spanne über einem Abschnitt eines Zielarrays, das durch einen <see cref="T:System.Range" />-Wert definiert ist.</span><span class="sxs-lookup"><span data-stu-id="262ba-232">Creates a new span over a portion of a target array defined by a <see cref="T:System.Range" /> value.</span></span></summary>
        <returns><span data-ttu-id="262ba-233">Die Spannendarstellung des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-233">The span representation of the array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt;? segment, int start, int length);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(valuetype System.ArraySegment`1&lt;!!T&gt; segment, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(System.ArraySegment{``0},System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (segment As ArraySegment(Of T), start As Integer, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(ArraySegment&lt;T&gt; segment, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsSpan : ArraySegment&lt;'T&gt; * int * int -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (segment, start, length)" />
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this ArraySegment&lt;T&gt; segment, int start, int length);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-234">Der Typ des Array Segments.</span><span class="sxs-lookup"><span data-stu-id="262ba-234">The type of the array segment.</span></span></typeparam>
        <param name="segment"><span data-ttu-id="262ba-235">Das Zielarraysegment.</span><span class="sxs-lookup"><span data-stu-id="262ba-235">The target array segment.</span></span></param>
        <param name="start"><span data-ttu-id="262ba-236">Der Index, an dem die Spanne beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-236">The index at which to begin the span.</span></span></param>
        <param name="length"><span data-ttu-id="262ba-237">Die Anzahl der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-237">The number of items in the span.</span></span></param>
        <summary><span data-ttu-id="262ba-238">Erstellt eine neue Spanne über einem Abschnitt eines Zielarraysegments von einer bestimmten Position aus für eine angegebene Länge.</span><span class="sxs-lookup"><span data-stu-id="262ba-238">Creates a new span over a portion of a target array segment from a specified position for a specified length.</span></span></summary>
        <returns><span data-ttu-id="262ba-239">Die Spannendarstellung des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-239">The span representation of the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-240">Gibt zurück, `default` Wenn `segment` ist `null` .</span><span class="sxs-lookup"><span data-stu-id="262ba-240">Returns `default` when `segment` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="262ba-241"><paramref name="segment" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-241"><paramref name="segment" /> is covariant, and the array's type is not exactly <see langword="T[]" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="262ba-242"><paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="segment" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-242"><paramref name="start" />, <paramref name="length" />, or <paramref name="start" /> + <paramref name="length" /> is not in the range of <paramref name="segment" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? AsSpan&lt;T&gt; (this T[]? array, int start, int length);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; AsSpan&lt;T&gt;(!!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.AsSpan``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSpan(Of T) (array As T(), start As Integer, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; AsSpan(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="static member AsSpan : 'T[] * int * int -&gt; Span&lt;'T&gt;" Usage="System.MemoryExtensions.AsSpan (array, start, length)" />
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; AsSpan&lt;T&gt; (this T[] array, int start, int length);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-243">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-243">The type of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="262ba-244">Das Zielarray.</span><span class="sxs-lookup"><span data-stu-id="262ba-244">The target array.</span></span></param>
        <param name="start"><span data-ttu-id="262ba-245">Der Index, an dem die Spanne beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-245">The index at which to begin the span.</span></span></param>
        <param name="length"><span data-ttu-id="262ba-246">Die Anzahl der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-246">The number of items in the span.</span></span></param>
        <summary><span data-ttu-id="262ba-247">Erstellt eine neue Spanne über dem Abschnitt des Zielarrays, beginnend an einer angegebenen Position für eine bestimmte Länge.</span><span class="sxs-lookup"><span data-stu-id="262ba-247">Creates a new span over the portion of the target array beginning at a specified position for a specified length.</span></span></summary>
        <returns><span data-ttu-id="262ba-248">Die Spannendarstellung des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-248">The span representation of the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-249">Gibt zurück, `default` Wenn `array` ist `null` .</span><span class="sxs-lookup"><span data-stu-id="262ba-249">Returns `default` when `array` is `null`.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="262ba-250"><paramref name="array" /> ist kovariant, und der Typ des Arrays ist nicht genau <see langword="T[]" />".</span><span class="sxs-lookup"><span data-stu-id="262ba-250"><paramref name="array" /> is covariant, and the array's type is not exactly <see langword="T[]" />".</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="262ba-251"><paramref name="start" />, <paramref name="length" /> oder <paramref name="start" /> + <paramref name="length" /> liegt nicht im Bereich von <paramref name="text" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-251"><paramref name="start" />, <paramref name="length" />, or <paramref name="start" /> + <paramref name="length" /> is not in the range of <paramref name="text" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, IComparable&lt;T&gt; comparable);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, class System.IComparable`1&lt;!!T&gt; comparable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``1(System.ReadOnlySpan{``0},System.IComparable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T) (span As ReadOnlySpan(Of T), comparable As IComparable(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(ReadOnlySpan&lt;T&gt; span, IComparable&lt;T&gt; ^ comparable);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : ReadOnlySpan&lt;'T&gt; * IComparable&lt;'T&gt; -&gt; int" Usage="System.MemoryExtensions.BinarySearch (span, comparable)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, IComparable&lt;T&gt; comparable);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="comparable" Type="System.IComparable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-252">Der Elementtyp der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-252">The element type of the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-253">Das zu durchsuchende sortierte <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-253">The sorted <see cref="T:System.ReadOnlySpan`1" /> to search.</span></span></param>
        <param name="comparable"><span data-ttu-id="262ba-254"><see cref="T:System.IComparable`1" />, das beim Vergleich verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-254">The <see cref="T:System.IComparable`1" /> to use when comparing.</span></span></param>
        <summary><span data-ttu-id="262ba-255">Durchsucht ein ganzes sortiertes <see cref="T:System.ReadOnlySpan`1" /> mithilfe der angegebenen generischen <see cref="T:System.IComparable`1" />-Schnittstelle nach einem Wert.</span><span class="sxs-lookup"><span data-stu-id="262ba-255">Searches an entire sorted <see cref="T:System.ReadOnlySpan`1" /> for a value using the specified <see cref="T:System.IComparable`1" /> generic interface.</span></span></summary>
        <returns><span data-ttu-id="262ba-256">Der nullbasierte Index von <paramref name="comparable" /> in der sortierten <paramref name="span" />, sofern <paramref name="comparable" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="comparable" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.ReadOnlySpan`1.Length" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-256">The zero-based index of <paramref name="comparable" /> in the sorted <paramref name="span" />, if <paramref name="comparable" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="comparable" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.ReadOnlySpan`1.Length" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="262ba-257"><paramref name="comparable" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-257"><paramref name="comparable" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (this Span&lt;T&gt;? span, IComparable&lt;T&gt; comparable);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span, class System.IComparable`1&lt;!!T&gt; comparable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``1(System.Span{``0},System.IComparable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T) (span As Span(Of T), comparable As IComparable(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(Span&lt;T&gt; span, IComparable&lt;T&gt; ^ comparable);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Span&lt;'T&gt; * IComparable&lt;'T&gt; -&gt; int" Usage="System.MemoryExtensions.BinarySearch (span, comparable)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (this Span&lt;T&gt; span, IComparable&lt;T&gt; comparable);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="comparable" Type="System.IComparable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-258">Der Elementtyp der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-258">The element type of the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-259">Das zu durchsuchende sortierte <see cref="T:System.Span`1" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-259">The sorted <see cref="T:System.Span`1" /> to search.</span></span></param>
        <param name="comparable"><span data-ttu-id="262ba-260"><see cref="T:System.IComparable`1" />, das beim Vergleich verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-260">The <see cref="T:System.IComparable`1" /> to use when comparing.</span></span></param>
        <summary><span data-ttu-id="262ba-261">Durchsucht ein ganzes sortiertes <see cref="T:System.Span`1" /> mithilfe der angegebenen generischen <see cref="T:System.IComparable`1" />-Schnittstelle nach einem Wert.</span><span class="sxs-lookup"><span data-stu-id="262ba-261">Searches an entire sorted <see cref="T:System.Span`1" /> for a value using the specified <see cref="T:System.IComparable`1" /> generic interface.</span></span></summary>
        <returns><span data-ttu-id="262ba-262">Der nullbasierte Index von <paramref name="comparable" /> in der sortierten <paramref name="span" />, sofern <paramref name="comparable" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="comparable" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Span`1.Length" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-262">The zero-based index of <paramref name="comparable" /> in the sorted <paramref name="span" />, if <paramref name="comparable" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="comparable" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.Span`1.Length" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="262ba-263"><paramref name="comparable" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-263"><paramref name="comparable" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T,TComparable&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparable&gt; (this ReadOnlySpan&lt;T&gt;? span, TComparable comparable) where TComparable : IComparable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T, (class System.IComparable`1&lt;!!T&gt;) TComparable&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!TComparable comparable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``1)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T, TComparable) (span As ReadOnlySpan(Of T), comparable As TComparable) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TComparable&gt;&#xA; where TComparable : IComparable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(ReadOnlySpan&lt;T&gt; span, TComparable comparable);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : ReadOnlySpan&lt;'T&gt; * 'Comparable -&gt; int (requires 'Comparable :&gt; IComparable&lt;'T&gt;)" Usage="System.MemoryExtensions.BinarySearch (span, comparable)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparable&gt; (this ReadOnlySpan&lt;T&gt; span, TComparable comparable) where TComparable : IComparable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TComparable">
          <Constraints>
            <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="comparable" Type="TComparable" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-264">Der Elementtyp der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-264">The element type of the span.</span></span></typeparam>
        <typeparam name="TComparable"><span data-ttu-id="262ba-265">Der spezifische Typ von <see cref="T:System.IComparable`1" /> .</span><span class="sxs-lookup"><span data-stu-id="262ba-265">The specific type of <see cref="T:System.IComparable`1" />.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-266">Das zu durchsuchende sortierte <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-266">The sorted <see cref="T:System.ReadOnlySpan`1" /> to search.</span></span></param>
        <param name="comparable"><span data-ttu-id="262ba-267"><typeparamref name="TComparable" />, das beim Vergleich verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-267">The <typeparamref name="TComparable" /> to use when comparing.</span></span></param>
        <summary><span data-ttu-id="262ba-268">Durchsucht ein ganzes sortiertes <see cref="T:System.ReadOnlySpan`1" /> mithilfe des angegebenen generischen <typeparamref name="TComparable" />-Typs nach einem Wert.</span><span class="sxs-lookup"><span data-stu-id="262ba-268">Searches an entire sorted <see cref="T:System.ReadOnlySpan`1" /> for a value using the specified <typeparamref name="TComparable" /> generic type.</span></span></summary>
        <returns><span data-ttu-id="262ba-269">Der nullbasierte Index von <paramref name="comparable" /> in der sortierten <paramref name="span" />, sofern <paramref name="comparable" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="comparable" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.ReadOnlySpan`1.Length" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-269">The zero-based index of <paramref name="comparable" /> in the sorted <paramref name="span" />, if <paramref name="comparable" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="comparable" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.ReadOnlySpan`1.Length" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="262ba-270"><paramref name="comparable" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-270"><paramref name="comparable" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T,TComparable&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparable&gt; (this Span&lt;T&gt;? span, TComparable comparable) where TComparable : IComparable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T, (class System.IComparable`1&lt;!!T&gt;) TComparable&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!TComparable comparable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``1)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T, TComparable) (span As Span(Of T), comparable As TComparable) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TComparable&gt;&#xA; where TComparable : IComparable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(Span&lt;T&gt; span, TComparable comparable);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Span&lt;'T&gt; * 'Comparable -&gt; int (requires 'Comparable :&gt; IComparable&lt;'T&gt;)" Usage="System.MemoryExtensions.BinarySearch (span, comparable)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparable&gt; (this Span&lt;T&gt; span, TComparable comparable) where TComparable : IComparable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TComparable">
          <Constraints>
            <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="comparable" Type="TComparable" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-271">Der Elementtyp der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-271">The element type of the span.</span></span></typeparam>
        <typeparam name="TComparable"><span data-ttu-id="262ba-272">Der spezifische Typ von <see cref="T:System.IComparable`1" /> .</span><span class="sxs-lookup"><span data-stu-id="262ba-272">The specific type of <see cref="T:System.IComparable`1" />.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-273">Das zu durchsuchende sortierte <see cref="T:System.Span`1" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-273">The sorted <see cref="T:System.Span`1" /> to search.</span></span></param>
        <param name="comparable"><span data-ttu-id="262ba-274"><typeparamref name="TComparable" />, das beim Vergleich verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-274">The <typeparamref name="TComparable" /> to use when comparing.</span></span></param>
        <summary><span data-ttu-id="262ba-275">Durchsucht ein ganzes sortiertes <see cref="T:System.Span`1" /> mithilfe des angegebenen generischen <typeparamref name="TComparable" />-Typs nach einem Wert.</span><span class="sxs-lookup"><span data-stu-id="262ba-275">Searches an entire sorted <see cref="T:System.Span`1" /> for a value using the specified <typeparamref name="TComparable" /> generic type.</span></span></summary>
        <returns><span data-ttu-id="262ba-276">Der nullbasierte Index von <paramref name="comparable" /> in der sortierten <paramref name="span" />, sofern <paramref name="comparable" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="comparable" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Span`1.Length" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-276">The zero-based index of <paramref name="comparable" /> in the sorted <paramref name="span" />, if <paramref name="comparable" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="comparable" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.Span`1.Length" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="262ba-277"><paramref name="comparable" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-277"><paramref name="comparable" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T,TComparer&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparer&gt; (this ReadOnlySpan&lt;T&gt;? span, T value, TComparer comparer) where TComparer : System.Collections.Generic.IComparer&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T, (class System.Collections.Generic.IComparer`1&lt;!!T&gt;) TComparer&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value, !!TComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``2(System.ReadOnlySpan{``0},``0,``1)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T, TComparer) (span As ReadOnlySpan(Of T), value As T, comparer As TComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TComparer&gt;&#xA; where TComparer : System::Collections::Generic::IComparer&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(ReadOnlySpan&lt;T&gt; span, T value, TComparer comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : ReadOnlySpan&lt;'T&gt; * 'T * 'Comparer -&gt; int (requires 'Comparer :&gt; System.Collections.Generic.IComparer&lt;'T&gt;)" Usage="System.MemoryExtensions.BinarySearch (span, value, comparer)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparer&gt; (this ReadOnlySpan&lt;T&gt; span, T value, TComparer comparer) where TComparer : System.Collections.Generic.IComparer&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TComparer">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IComparer&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="TComparer" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-278">Der Elementtyp der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-278">The element type of the span.</span></span></typeparam>
        <typeparam name="TComparer"><span data-ttu-id="262ba-279">Der spezifische Typ von <see cref="T:System.Collections.Generic.IComparer`1" /> .</span><span class="sxs-lookup"><span data-stu-id="262ba-279">The specific type of <see cref="T:System.Collections.Generic.IComparer`1" />.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-280">Das zu durchsuchende sortierte <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-280">The sorted <see cref="T:System.ReadOnlySpan`1" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-281">Das zu suchende Objekt.</span><span class="sxs-lookup"><span data-stu-id="262ba-281">The object to locate.</span></span> <span data-ttu-id="262ba-282">Der Wert kann für Verweistypen <see langword="null" /> sein.</span><span class="sxs-lookup"><span data-stu-id="262ba-282">The value can be <see langword="null" /> for reference types.</span></span></param>
        <param name="comparer"><span data-ttu-id="262ba-283"><typeparamref name="TComparer" />, das beim Vergleich verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-283">The <typeparamref name="TComparer" /> to use when comparing.</span></span></param>
        <summary><span data-ttu-id="262ba-284">Durchsucht ein ganzes sortiertes <see cref="T:System.ReadOnlySpan`1" /> mithilfe des angegebenen generischen <typeparamref name="TComparer" />-Typs nach einem angegebenen Wert.</span><span class="sxs-lookup"><span data-stu-id="262ba-284">Searches an entire sorted <see cref="T:System.ReadOnlySpan`1" /> for a specified value using the specified <typeparamref name="TComparer" /> generic type.</span></span></summary>
        <returns><span data-ttu-id="262ba-285">Der nullbasierte Index von <paramref name="value" /> in der sortierten <paramref name="span" />, sofern <paramref name="value" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="value" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.ReadOnlySpan`1.Length" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-285">The zero-based index of <paramref name="value" /> in the sorted <paramref name="span" />, if <paramref name="value" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="value" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.ReadOnlySpan`1.Length" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="262ba-286"><paramref name="comparer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-286"><paramref name="comparer" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T,TComparer&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparer&gt; (this Span&lt;T&gt;? span, T value, TComparer comparer) where TComparer : System.Collections.Generic.IComparer&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T, (class System.Collections.Generic.IComparer`1&lt;!!T&gt;) TComparer&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value, !!TComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.BinarySearch``2(System.Span{``0},``0,``1)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function BinarySearch(Of T, TComparer) (span As Span(Of T), value As T, comparer As TComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TComparer&gt;&#xA; where TComparer : System::Collections::Generic::IComparer&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int BinarySearch(Span&lt;T&gt; span, T value, TComparer comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Span&lt;'T&gt; * 'T * 'Comparer -&gt; int (requires 'Comparer :&gt; System.Collections.Generic.IComparer&lt;'T&gt;)" Usage="System.MemoryExtensions.BinarySearch (span, value, comparer)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T,TComparer&gt; (this Span&lt;T&gt; span, T value, TComparer comparer) where TComparer : System.Collections.Generic.IComparer&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TComparer">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IComparer&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="TComparer" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-287">Der Elementtyp der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-287">The element type of the span.</span></span></typeparam>
        <typeparam name="TComparer"><span data-ttu-id="262ba-288">Der spezifische Typ von <see cref="T:System.Collections.Generic.IComparer`1" /> .</span><span class="sxs-lookup"><span data-stu-id="262ba-288">The specific type of <see cref="T:System.Collections.Generic.IComparer`1" />.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-289">Das zu durchsuchende sortierte <see cref="T:System.Span`1" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-289">The sorted <see cref="T:System.Span`1" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-290">Das zu suchende Objekt.</span><span class="sxs-lookup"><span data-stu-id="262ba-290">The object to locate.</span></span> <span data-ttu-id="262ba-291">Der Wert kann für Verweistypen <see langword="null" /> sein.</span><span class="sxs-lookup"><span data-stu-id="262ba-291">The value can be <see langword="null" /> for reference types.</span></span></param>
        <param name="comparer"><span data-ttu-id="262ba-292"><typeparamref name="TComparer" />, das beim Vergleich verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-292">The <typeparamref name="TComparer" /> to use when comparing.</span></span></param>
        <summary><span data-ttu-id="262ba-293">Durchsucht ein ganzes sortiertes <see cref="T:System.Span`1" /> mithilfe des angegebenen generischen <typeparamref name="TComparer" />-Typs nach einem angegebenen Wert.</span><span class="sxs-lookup"><span data-stu-id="262ba-293">Searches an entire sorted <see cref="T:System.Span`1" /> for a specified value using the specified <typeparamref name="TComparer" /> generic type.</span></span></summary>
        <returns><span data-ttu-id="262ba-294">Der nullbasierte Index von <paramref name="value" /> in der sortierten <paramref name="span" />, sofern <paramref name="value" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="value" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Span`1.Length" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-294">The zero-based index of <paramref name="value" /> in the sorted <paramref name="span" />, if <paramref name="value" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="value" /> or, if there is no larger element, the bitwise complement of <see cref="P:System.Span`1.Length" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="262ba-295"><paramref name="comparer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-295"><paramref name="comparer" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public static int CompareTo (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; other, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareTo(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; other, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.CompareTo(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CompareTo (span As ReadOnlySpan(Of Char), other As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int CompareTo(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; other, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member CompareTo : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.MemoryExtensions.CompareTo (span, other, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-296">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-296">The source span.</span></span></param>
        <param name="other"><span data-ttu-id="262ba-297">Der Wert, der mit der Quellspanne verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-297">The value to compare with the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="262ba-298">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="other" /> verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-298">An enumeration value that determines how <paramref name="span" /> and <paramref name="other" /> are compared.</span></span></param>
        <summary><span data-ttu-id="262ba-299">Vergleicht eine Zeichenspanne mit einer anderen unter Verwendung eines angegebenen Zeichenfolgenvergleichs und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</span><span class="sxs-lookup"><span data-stu-id="262ba-299">Compares one character span with another using a specified string comparison, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="262ba-300">Eine ganze Zahl mit Vorzeichen, die die relative Reihenfolge von <paramref name="span" /> und <paramref name="other" /> angibt:</span><span class="sxs-lookup"><span data-stu-id="262ba-300">A signed integer that indicates the relative order of <paramref name="span" /> and <paramref name="other" />:</span></span><br />   <span data-ttu-id="262ba-301">– Wenn kleiner als 0, <paramref name="span" /> vor <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-301">- If less than 0, <paramref name="span" /> precedes than <paramref name="other" />.</span></span><br />   <span data-ttu-id="262ba-302">– Wenn diese 0 (null) sind, ist <paramref name="span" /> gleich <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-302">- If 0, <paramref name="span" /> equals <paramref name="other" />.</span></span><br />   <span data-ttu-id="262ba-303">– Wenn größer als 0, folgt <paramref name="span" /> auf <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-303">- If greater than 0, <paramref name="span" /> follows <paramref name="other" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public static bool Contains (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Contains(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Contains : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; bool" Usage="System.MemoryExtensions.Contains (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-304">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-304">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-305">Der innerhalb der Quellspanne zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="262ba-305">The value to seek within the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="262ba-306">Ein Enumerationswert, der bestimmt, wie die Zeichen in <paramref name="span" /> und <paramref name="value" /> verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-306">An enumeration value that determines how the characters in <paramref name="span" /> and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="262ba-307">Gibt an, ob ein angegebener Wert innerhalb einer schreibgeschützten Zeichenspanne auftritt.</span><span class="sxs-lookup"><span data-stu-id="262ba-307">Indicates whether a specified value occurs within a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="262ba-308"><see langword="true" />, wenn <paramref name="value" /> innerhalb der Spanne auftritt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-308"><see langword="true" /> if <paramref name="value" /> occurs within the span, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, T value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Contains``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(ReadOnlySpan&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member Contains : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Contains (span, value)" />
      <MemberSignature Language="C#" Value="public static bool Contains&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, T? value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-309">Der Typ der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-309">The type of the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-310">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-310">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-311">Der zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="262ba-311">The value to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-312">Gibt an, ob ein angegebener Wert in einer schreibgeschützten Spanne gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-312">Indicates whether a specified value is found in a read-only span.</span></span> <span data-ttu-id="262ba-313">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="262ba-313">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="262ba-314"><see langword="true" />, wenn er gefunden wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-314"><see langword="true" /> if found, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;T&gt; (this Span&lt;T&gt;? span, T value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Contains``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of T As IEquatable(Of T)) (span As Span(Of T), value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(Span&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member Contains : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Contains (span, value)" />
      <MemberSignature Language="C#" Value="public static bool Contains&lt;T&gt; (this Span&lt;T&gt;? span, T? value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-315">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-315">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-316">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-316">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-317">Der zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="262ba-317">The value to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-318">Gibt an, ob ein angegebener Wert in einer Spanne gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-318">Indicates whether a specified value is found in a span.</span></span> <span data-ttu-id="262ba-319">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="262ba-319">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="262ba-320"><see langword="true" />, wenn er gefunden wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-320"><see langword="true" /> if found, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void CopyTo&lt;T&gt; (this T[]? source, Memory&lt;T&gt;? destination);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo&lt;T&gt;(!!T[] source, valuetype System.Memory`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.CopyTo``1(``0[],System.Memory{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo(Of T) (source As T(), destination As Memory(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(cli::array &lt;T&gt; ^ source, Memory&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="static member CopyTo : 'T[] * Memory&lt;'T&gt; -&gt; unit" Usage="System.MemoryExtensions.CopyTo (source, destination)" />
      <MemberSignature Language="C#" Value="public static void CopyTo&lt;T&gt; (this T[] source, Memory&lt;T&gt; destination);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T[]" RefType="this" />
        <Parameter Name="destination" Type="System.Memory&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-321">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-321">The type of the array.</span></span></typeparam>
        <param name="source"><span data-ttu-id="262ba-322">Das Array, aus dem Elemente kopiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="262ba-322">The array to copy items from.</span></span></param>
        <param name="destination"><span data-ttu-id="262ba-323">Das Array, in das die Elemente kopiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="262ba-323">The memory to copy items into.</span></span></param>
        <summary><span data-ttu-id="262ba-324">Kopiert den Inhalt des Arrays in einen Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-324">Copies the contents of the array into a memory region.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="262ba-325">Wenn `source` und `destination` sich überlappen, verhält sich diese Methode so, als ob sich die ursprünglichen Werte an einem temporären Speicherort befinden, bevor das Ziel überschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-325">If `source` and `destination` overlap, this method behaves as if the original values are in a temporary location before the destination is overwritten.</span></span>

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="262ba-326">Das Ziel ist kürzer als das Quellarray.</span><span class="sxs-lookup"><span data-stu-id="262ba-326">The destination is shorter than the source array.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void CopyTo&lt;T&gt; (this T[]? source, Span&lt;T&gt;? destination);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo&lt;T&gt;(!!T[] source, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.CopyTo``1(``0[],System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo(Of T) (source As T(), destination As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(cli::array &lt;T&gt; ^ source, Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="static member CopyTo : 'T[] * Span&lt;'T&gt; -&gt; unit" Usage="System.MemoryExtensions.CopyTo (source, destination)" />
      <MemberSignature Language="C#" Value="public static void CopyTo&lt;T&gt; (this T[] source, Span&lt;T&gt; destination);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T[]" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-327">Der Typ des Arrays.</span><span class="sxs-lookup"><span data-stu-id="262ba-327">The type of the array.</span></span></typeparam>
        <param name="source"><span data-ttu-id="262ba-328">Das Array, aus dem Elemente kopiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="262ba-328">The array to copy items from.</span></span></param>
        <param name="destination"><span data-ttu-id="262ba-329">Der Bereich, in den Elemente kopiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="262ba-329">The span to copy items into.</span></span></param>
        <summary><span data-ttu-id="262ba-330">Kopiert den Inhalt des Arrays in die Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-330">Copies the contents of the array into the span.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="262ba-331">Wenn `source` und `destination` sich überlappen, verhält sich diese Methode so, als ob sich die ursprünglichen Werte an einem temporären Speicherort befinden, bevor das Ziel überschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-331">If `source` and `destination` overlap, this method behaves as if the original values are in a temporary location before the destination is overwritten.</span></span>

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="262ba-332">Die Zielspanne ist kürzer als das Quellarray.</span><span class="sxs-lookup"><span data-stu-id="262ba-332">The destination Span is shorter than the source array.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public static bool EndsWith (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsWith(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EndsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EndsWith (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool EndsWith(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member EndsWith : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; bool" Usage="System.MemoryExtensions.EndsWith (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-333">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-333">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-334">Die Sequenz, die mit dem Ende der Quellspanne verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-334">The sequence to compare to the end of the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="262ba-335">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="value" /> verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-335">An enumeration value that determines how <paramref name="span" /> and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="262ba-336">Bestimmt, ob das Ende von <paramref name="span" /> mit dem angegebenen <paramref name="value" /> übereinstimmt, wenn es mit der angegebenen <paramref name="comparisonType" />-Option verglichen wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-336">Determines whether the end of the <paramref name="span" /> matches the specified <paramref name="value" /> when compared using the specified <paramref name="comparisonType" /> option.</span></span></summary>
        <returns><span data-ttu-id="262ba-337"><see langword="true" />, wenn <paramref name="value" /> mit dem Ende von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-337"><see langword="true" /> if <paramref name="value" /> matches the end of <paramref name="span" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool EndsWith&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsWith&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EndsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EndsWith(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool EndsWith(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member EndsWith : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.EndsWith (span, value)" />
      <MemberSignature Language="C#" Value="public static bool EndsWith&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-338">Der Typ der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-338">The type of the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-339">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-339">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-340">Die Sequenz, die mit dem Ende der Quellspanne verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-340">The sequence to compare to the end of the source span.</span></span></param>
        <summary><span data-ttu-id="262ba-341">Bestimmt, ob die angegebene Sequenz am Ende einer schreibgeschützten Spanne angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-341">Determines whether the specified sequence appears at the end of a read-only span.</span></span></summary>
        <returns><span data-ttu-id="262ba-342"><see langword="true" />, wenn <paramref name="value" /> mit dem Ende von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-342"><see langword="true" /> if <paramref name="value" /> matches the end of <paramref name="span" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool EndsWith&lt;T&gt; (this Span&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsWith&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EndsWith``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EndsWith(Of T As IEquatable(Of T)) (span As Span(Of T), value As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool EndsWith(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member EndsWith : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.EndsWith (span, value)" />
      <MemberSignature Language="C#" Value="public static bool EndsWith&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-343">Der Typ der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-343">The type of the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-344">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-344">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-345">Die Sequenz, die mit dem Ende der Quellspanne verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-345">The sequence to compare to the end of the source span.</span></span></param>
        <summary><span data-ttu-id="262ba-346">Bestimmt, ob die angegebene Sequenz am Ende einer Spanne angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-346">Determines whether the specified sequence appears at the end of a span.</span></span></summary>
        <returns><span data-ttu-id="262ba-347"><see langword="true" />, wenn <paramref name="value" /> mit dem Ende von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-347"><see langword="true" /> if <paramref name="value" /> matches the end of <paramref name="span" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public static System.Text.SpanRuneEnumerator EnumerateRunes (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.SpanRuneEnumerator EnumerateRunes(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EnumerateRunes(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EnumerateRunes (span As ReadOnlySpan(Of Char)) As SpanRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Text::SpanRuneEnumerator EnumerateRunes(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member EnumerateRunes : ReadOnlySpan&lt;char&gt; -&gt; System.Text.SpanRuneEnumerator" Usage="System.MemoryExtensions.EnumerateRunes span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.SpanRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-348">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-348">The source span.</span></span></param>
        <summary><span data-ttu-id="262ba-349">Gibt eine Enumeration von <see cref="T:System.Text.Rune" /> aus der angegebenen schreibgeschützten Spanne zurück.</span><span class="sxs-lookup"><span data-stu-id="262ba-349">Returns an enumeration of <see cref="T:System.Text.Rune" /> from the provided read-only span.</span></span></summary>
        <returns><span data-ttu-id="262ba-350">Ein rune-Enumerator.</span><span class="sxs-lookup"><span data-stu-id="262ba-350">A rune enumerator.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-351">Ungültige Sequenzen werden in der-Enumeration durch dargestellt <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="262ba-351">Invalid sequences will be represented in the enumeration by <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType>.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public static System.Text.SpanRuneEnumerator EnumerateRunes (this Span&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.SpanRuneEnumerator EnumerateRunes(valuetype System.Span`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.EnumerateRunes(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function EnumerateRunes (span As Span(Of Char)) As SpanRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Text::SpanRuneEnumerator EnumerateRunes(Span&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member EnumerateRunes : Span&lt;char&gt; -&gt; System.Text.SpanRuneEnumerator" Usage="System.MemoryExtensions.EnumerateRunes span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.SpanRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-352">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-352">The source span.</span></span></param>
        <summary><span data-ttu-id="262ba-353">Gibt eine Enumeration von <see cref="T:System.Text.Rune" /> aus der angegebenen Spanne zurück.</span><span class="sxs-lookup"><span data-stu-id="262ba-353">Returns an enumeration of <see cref="T:System.Text.Rune" /> from the provided span.</span></span></summary>
        <returns><span data-ttu-id="262ba-354">Ein rune-Enumerator.</span><span class="sxs-lookup"><span data-stu-id="262ba-354">A rune enumerator.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-355">Ungültige Sequenzen werden in der-Enumeration durch dargestellt <xref:System.Text.Rune.ReplacementChar> .</span><span class="sxs-lookup"><span data-stu-id="262ba-355">Invalid sequences will be represented in the enumeration by <xref:System.Text.Rune.ReplacementChar>.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; other, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; other, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Equals(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Equals (span As ReadOnlySpan(Of Char), other As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Equals(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; other, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; bool" Usage="System.MemoryExtensions.Equals (span, other, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-356">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-356">The source span.</span></span></param>
        <param name="other"><span data-ttu-id="262ba-357">Der Wert, der mit der Quellspanne verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-357">The value to compare with the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="262ba-358">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="other" /> verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-358">An enumeration value that determines how <paramref name="span" /> and <paramref name="other" /> are compared.</span></span></param>
        <summary><span data-ttu-id="262ba-359">Bestimmt, ob dieser <paramref name="span" /> und die angegebene <paramref name="other" />-Spanne dieselben Zeichen aufweisen, wenn sie mit der angegebenen <paramref name="comparisonType" />-Option verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-359">Determines whether this <paramref name="span" /> and the specified <paramref name="other" /> span have the same characters when compared using the specified <paramref name="comparisonType" /> option.</span></span></summary>
        <returns><span data-ttu-id="262ba-360"><see langword="true" />, sofern identisch, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-360"><see langword="true" /> if equal, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member IndexOf : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.MemoryExtensions.IndexOf (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-361">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-361">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-362">Der innerhalb der Quellspanne zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="262ba-362">The value to seek within the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="262ba-363">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="value" /> verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-363">An enumeration value that determines how <paramref name="span" /> and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="262ba-364">Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen <paramref name="value" /> im aktuellen <paramref name="span" /> an.</span><span class="sxs-lookup"><span data-stu-id="262ba-364">Reports the zero-based index of the first occurrence of the specified <paramref name="value" /> in the current <paramref name="span" />.</span></span></summary>
        <returns><span data-ttu-id="262ba-365">Der Index des Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-365">The index of the occurrence of the value in the span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOf (span, value)" />
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-366">Der Typ der Spanne und des Werts.</span><span class="sxs-lookup"><span data-stu-id="262ba-366">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-367">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-367">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-368">Die zu suchende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-368">The sequence to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-369">Sucht nach der angegebenen Sequenz und gibt den Index des ersten Vorkommens zurück.</span><span class="sxs-lookup"><span data-stu-id="262ba-369">Searches for the specified sequence and returns the index of its first occurrence.</span></span> <span data-ttu-id="262ba-370">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="262ba-370">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="262ba-371">Der Index des Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-371">The index of the occurrence of the value in the span.</span></span> <span data-ttu-id="262ba-372">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-372">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, T value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(ReadOnlySpan&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOf (span, value)" />
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, T? value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-373">Der Typ der Spanne und des Werts.</span><span class="sxs-lookup"><span data-stu-id="262ba-373">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-374">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-374">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-375">Der zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="262ba-375">The value to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-376">Sucht nach dem angegebenen Wert und gibt den Index des ersten Vorkommens zurück.</span><span class="sxs-lookup"><span data-stu-id="262ba-376">Searches for the specified value and returns the index of its first occurrence.</span></span> <span data-ttu-id="262ba-377">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="262ba-377">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="262ba-378">Der Index des Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-378">The index of the occurrence of the value in the span.</span></span> <span data-ttu-id="262ba-379">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-379">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this Span&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of T As IEquatable(Of T)) (span As Span(Of T), value As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOf (span, value)" />
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-380">Der Typ der Spanne und des Werts.</span><span class="sxs-lookup"><span data-stu-id="262ba-380">The type of the span and value..</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-381">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-381">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-382">Die zu suchende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-382">The sequence to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-383">Sucht nach der angegebenen Sequenz und gibt den Index des ersten Vorkommens zurück.</span><span class="sxs-lookup"><span data-stu-id="262ba-383">Searches for the specified sequence and returns the index of its first occurrence.</span></span> <span data-ttu-id="262ba-384">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="262ba-384">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="262ba-385">Der Index des Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-385">The index of the occurrence of the value in the span.</span></span> <span data-ttu-id="262ba-386">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-386">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this Span&lt;T&gt;? span, T value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOf``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOf(Of T As IEquatable(Of T)) (span As Span(Of T), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOf(Span&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOf (span, value)" />
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (this Span&lt;T&gt;? span, T? value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-387">Der Typ der Spanne und des Werts.</span><span class="sxs-lookup"><span data-stu-id="262ba-387">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-388">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-388">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-389">Der zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="262ba-389">The value to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-390">Sucht nach dem angegebenen Wert und gibt den Index des ersten Vorkommens zurück.</span><span class="sxs-lookup"><span data-stu-id="262ba-390">Searches for the specified value and returns the index of its first occurrence.</span></span> <span data-ttu-id="262ba-391">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="262ba-391">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="262ba-392">Der Index des Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-392">The index of the occurrence of the value in the span.</span></span> <span data-ttu-id="262ba-393">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-393">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? values) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), values As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, values)" />
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-394">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-394">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-395">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-395">The span to search.</span></span></param>
        <param name="values"><span data-ttu-id="262ba-396">Der zu suchende Satz von Werten.</span><span class="sxs-lookup"><span data-stu-id="262ba-396">The set of values to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-397">Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="262ba-397">Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="262ba-398">Der erste Index des Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-398">The first index of the occurrence of any of the values in the span.</span></span> <span data-ttu-id="262ba-399">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-399">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this Span&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? values) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), values As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, values)" />
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-400">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-400">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-401">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-401">The span to search.</span></span></param>
        <param name="values"><span data-ttu-id="262ba-402">Der zu suchende Satz von Werten.</span><span class="sxs-lookup"><span data-stu-id="262ba-402">The set of values to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-403">Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="262ba-403">Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="262ba-404">Der erste Index des Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-404">The first index of the occurrence of any of the values in the span.</span></span> <span data-ttu-id="262ba-405">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-405">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, T value0, T value1) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value0, !!T value1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value0 As T, value1 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(ReadOnlySpan&lt;T&gt; span, T value0, T value1);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, value0, value1)" />
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, T? value0, T? value1) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-406">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-406">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-407">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-407">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="262ba-408">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-408">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="262ba-409">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-409">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-410">Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="262ba-410">Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="262ba-411">Der erste Index des Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-411">The first index of the occurrence of any of the values in the span.</span></span> <span data-ttu-id="262ba-412">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-412">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this Span&lt;T&gt;? span, T value0, T value1) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value0, !!T value1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), value0 As T, value1 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(Span&lt;T&gt; span, T value0, T value1);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, value0, value1)" />
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this Span&lt;T&gt;? span, T? value0, T? value1) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-413">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-413">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-414">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-414">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="262ba-415">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-415">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="262ba-416">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-416">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-417">Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="262ba-417">Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="262ba-418">Der erste Index des Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-418">The first index of the occurrence of any of the values in the span.</span></span> <span data-ttu-id="262ba-419">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-419">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value0, !!T value1, !!T value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value0 As T, value1 As T, value2 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, value0, value1, value2)" />
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
        <Parameter Name="value2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-420">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-420">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-421">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-421">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="262ba-422">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-422">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="262ba-423">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-423">One of the values to search for.</span></span></param>
        <param name="value2"><span data-ttu-id="262ba-424">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-424">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-425">Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="262ba-425">Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="262ba-426">Der erste Index des Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-426">The first index of the occurrence of any of the values in the span.</span></span> <span data-ttu-id="262ba-427">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-427">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this Span&lt;T&gt;? span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value0, !!T value1, !!T value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IndexOfAny``1(System.Span{``0},``0,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), value0 As T, value1 As T, value2 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int IndexOfAny(Span&lt;T&gt; span, T value0, T value1, T value2);" />
      <MemberSignature Language="F#" Value="static member IndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.IndexOfAny (span, value0, value1, value2)" />
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
        <Parameter Name="value2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-428">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-428">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-429">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-429">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="262ba-430">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-430">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="262ba-431">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-431">One of the values to search for.</span></span></param>
        <param name="value2"><span data-ttu-id="262ba-432">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-432">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-433">Sucht nach dem ersten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von IndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="262ba-433">Searches for the first index of any of the specified values similar to calling IndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="262ba-434">Der erste Index des Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-434">The first index of the occurrence of any of the values in the span.</span></span> <span data-ttu-id="262ba-435">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-435">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.IsWhiteSpace(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsWhiteSpace (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsWhiteSpace(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member IsWhiteSpace : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.MemoryExtensions.IsWhiteSpace span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-436">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-436">The source span.</span></span></param>
        <summary><span data-ttu-id="262ba-437">Gibt an, ob die angegebene Spanne nur Leerzeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-437">Indicates whether the specified span contains only whitespace characters.</span></span></summary>
        <returns><span data-ttu-id="262ba-438"><see langword="true" />, wenn die Spanne nur Leerzeichen enthält, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-438"><see langword="true" /> if the span contains only whitespace characters, <see langword="false" /> otherwise.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.MemoryExtensions.LastIndexOf (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-439">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-439">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-440">Der innerhalb der Quellspanne zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="262ba-440">The value to seek within the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="262ba-441">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="value" /> verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-441">An enumeration value that determines how <paramref name="span" /> and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="262ba-442">Gibt den NULL-basierten Index des letzten Vorkommens der angegebenen <paramref name="value" /> im aktuellen <paramref name="span" /> an.</span><span class="sxs-lookup"><span data-stu-id="262ba-442">Reports the zero-based index of the last occurrence of the specified <paramref name="value" /> in the current <paramref name="span" />.</span></span></summary>
        <returns><span data-ttu-id="262ba-443">Der Index des letzten Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-443">The index of the last occurrence of the value in the span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOf (span, value)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-444">Der Typ der Spanne und des Werts.</span><span class="sxs-lookup"><span data-stu-id="262ba-444">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-445">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-445">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-446">Die zu suchende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-446">The sequence to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-447">Sucht nach der angegebenen Sequenz und gibt den Index des letzten Vorkommens zurück.</span><span class="sxs-lookup"><span data-stu-id="262ba-447">Searches for the specified sequence and returns the index of its last occurrence.</span></span> <span data-ttu-id="262ba-448">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="262ba-448">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="262ba-449">Der Index des letzten Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-449">The index of the last occurrence of the value in the span.</span></span> <span data-ttu-id="262ba-450">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-450">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, T value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(ReadOnlySpan&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOf (span, value)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, T? value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-451">Der Typ der Spanne und des Werts.</span><span class="sxs-lookup"><span data-stu-id="262ba-451">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-452">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-452">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-453">Der zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="262ba-453">The value to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-454">Sucht nach dem angegebenen Wert und gibt den Index des letzten Vorkommens zurück.</span><span class="sxs-lookup"><span data-stu-id="262ba-454">Searches for the specified value and returns the index of its last occurrence.</span></span> <span data-ttu-id="262ba-455">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="262ba-455">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="262ba-456">Der Index des letzten Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-456">The index of the last occurrence of the value in the span.</span></span> <span data-ttu-id="262ba-457">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-457">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this Span&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf(Of T As IEquatable(Of T)) (span As Span(Of T), value As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOf (span, value)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-458">Der Typ der Spanne und des Werts.</span><span class="sxs-lookup"><span data-stu-id="262ba-458">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-459">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-459">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-460">Die zu suchende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-460">The sequence to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-461">Sucht nach der angegebenen Sequenz und gibt den Index des letzten Vorkommens zurück.</span><span class="sxs-lookup"><span data-stu-id="262ba-461">Searches for the specified sequence and returns the index of its last occurrence.</span></span> <span data-ttu-id="262ba-462">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="262ba-462">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="262ba-463">Der Index des letzten Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-463">The index of the last occurrence of the value in the span.</span></span> <span data-ttu-id="262ba-464">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-464">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this Span&lt;T&gt;? span, T value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOf``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOf(Of T As IEquatable(Of T)) (span As Span(Of T), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOf(Span&lt;T&gt; span, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOf (span, value)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this Span&lt;T&gt; span, T value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (this Span&lt;T&gt;? span, T? value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-465">Der Typ der Spanne und des Werts.</span><span class="sxs-lookup"><span data-stu-id="262ba-465">The type of the span and value.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-466">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-466">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-467">Der zu suchende Wert.</span><span class="sxs-lookup"><span data-stu-id="262ba-467">The value to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-468">Sucht nach dem angegebenen Wert und gibt den Index des letzten Vorkommens zurück.</span><span class="sxs-lookup"><span data-stu-id="262ba-468">Searches for the specified value and returns the index of its last occurrence.</span></span> <span data-ttu-id="262ba-469">Werte werden mit „IEquatable{T}.Equals(T)“ verglichen.</span><span class="sxs-lookup"><span data-stu-id="262ba-469">Values are compared using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="262ba-470">Der Index des letzten Vorkommens des Werts in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-470">The index of the last occurrence of the value in the span.</span></span> <span data-ttu-id="262ba-471">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-471">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? values) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), values As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, values)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-472">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-472">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-473">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-473">The span to search.</span></span></param>
        <param name="values"><span data-ttu-id="262ba-474">Der zu suchende Satz von Werten.</span><span class="sxs-lookup"><span data-stu-id="262ba-474">The set of values to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-475">Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="262ba-475">Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="262ba-476">Der Index des letzten Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-476">The index of the last occurrence of any of the values in the span.</span></span> <span data-ttu-id="262ba-477">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-477">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this Span&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? values) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), values As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, values)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; values) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-478">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-478">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-479">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-479">The span to search.</span></span></param>
        <param name="values"><span data-ttu-id="262ba-480">Der zu suchende Satz von Werten.</span><span class="sxs-lookup"><span data-stu-id="262ba-480">The set of values to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-481">Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="262ba-481">Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="262ba-482">Der Index des letzten Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-482">The index of the last occurrence of any of the values in the span.</span></span> <span data-ttu-id="262ba-483">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-483">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, T value0, T value1) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value0, !!T value1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value0 As T, value1 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(ReadOnlySpan&lt;T&gt; span, T value0, T value1);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, value0, value1)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, T? value0, T? value1) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-484">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-484">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-485">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-485">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="262ba-486">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-486">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="262ba-487">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-487">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-488">Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="262ba-488">Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="262ba-489">Der Index des letzten Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-489">The index of the last occurrence of any of the values in the span.</span></span> <span data-ttu-id="262ba-490">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-490">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this Span&lt;T&gt;? span, T value0, T value1) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value0, !!T value1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), value0 As T, value1 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(Span&lt;T&gt; span, T value0, T value1);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, value0, value1)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, T value0, T value1) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this Span&lt;T&gt;? span, T? value0, T? value1) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-491">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-491">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-492">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-492">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="262ba-493">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-493">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="262ba-494">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-494">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-495">Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="262ba-495">Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="262ba-496">Der Index des letzten Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-496">The index of the last occurrence of any of the values in the span.</span></span> <span data-ttu-id="262ba-497">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-497">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T value0, !!T value1, !!T value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},``0,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value0 As T, value1 As T, value2 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, value0, value1, value2)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
        <Parameter Name="value2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-498">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-498">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-499">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-499">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="262ba-500">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-500">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="262ba-501">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-501">One of the values to search for.</span></span></param>
        <param name="value2"><span data-ttu-id="262ba-502">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-502">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-503">Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="262ba-503">Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="262ba-504">Der Index des letzten Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-504">The index of the last occurrence of any of the values in the span.</span></span> <span data-ttu-id="262ba-505">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-505">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this Span&lt;T&gt;? span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOfAny&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T value0, !!T value1, !!T value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.LastIndexOfAny``1(System.Span{``0},``0,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastIndexOfAny(Of T As IEquatable(Of T)) (span As Span(Of T), value0 As T, value1 As T, value2 As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int LastIndexOfAny(Span&lt;T&gt; span, T value0, T value1, T value2);" />
      <MemberSignature Language="F#" Value="static member LastIndexOfAny : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T * 'T * 'T -&gt; int (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.LastIndexOfAny (span, value0, value1, value2)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOfAny&lt;T&gt; (this Span&lt;T&gt; span, T value0, T value1, T value2) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value0" Type="T" />
        <Parameter Name="value1" Type="T" />
        <Parameter Name="value2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-506">Der Typ der Spanne und der Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-506">The type of the span and values.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-507">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-507">The span to search.</span></span></param>
        <param name="value0"><span data-ttu-id="262ba-508">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-508">One of the values to search for.</span></span></param>
        <param name="value1"><span data-ttu-id="262ba-509">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-509">One of the values to search for.</span></span></param>
        <param name="value2"><span data-ttu-id="262ba-510">Einer der zu suchenden Werte.</span><span class="sxs-lookup"><span data-stu-id="262ba-510">One of the values to search for.</span></span></param>
        <summary><span data-ttu-id="262ba-511">Sucht nach dem letzten Index eines der angegebenen Werte, ähnlich dem mehrmaligen Aufruf von LastIndexOf mit dem logischen OR-Operator (ODER).</span><span class="sxs-lookup"><span data-stu-id="262ba-511">Searches for the last index of any of the specified values similar to calling LastIndexOf several times with the logical OR operator.</span></span></summary>
        <returns><span data-ttu-id="262ba-512">Der Index des letzten Vorkommens eines der Werte in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-512">The index of the last occurrence of any of the values in the span.</span></span> <span data-ttu-id="262ba-513">Gibt -1 zurück, wenn die Suche nicht erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="262ba-513">If not found, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? other);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Overlaps&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Overlaps(Of T) (span As ReadOnlySpan(Of T), other As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Overlaps(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member Overlaps : ReadOnlySpan&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; -&gt; bool" Usage="System.MemoryExtensions.Overlaps (span, other)" />
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-514">Der Typ der Elemente in der schreibgeschützten Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-514">The type of elements in the read-only sequence.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-515">Die erste Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-515">The first sequence.</span></span></param>
        <param name="other"><span data-ttu-id="262ba-516">Die zweite Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-516">The second sequence.</span></span></param>
        <summary><span data-ttu-id="262ba-517">Bestimmt, ob sich zwei schreibgeschützte Sequenzen im Speicher überlappen.</span><span class="sxs-lookup"><span data-stu-id="262ba-517">Determines whether two read-only sequences overlap in memory.</span></span></summary>
        <returns><span data-ttu-id="262ba-518"><see langword="true" />, wenn sich die beiden Sequenzen überlappen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-518"><see langword="true" /> if the two sequences overlap; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this Span&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? other);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Overlaps&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Overlaps(Of T) (span As Span(Of T), other As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Overlaps(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member Overlaps : Span&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; -&gt; bool" Usage="System.MemoryExtensions.Overlaps (span, other)" />
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-519">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-519">The type of elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-520">Die zu vergleichende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-520">The span to compare.</span></span></param>
        <param name="other"><span data-ttu-id="262ba-521">Die zu vergleichende schreibgeschützte Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-521">The read-only span to compare.</span></span></param>
        <summary><span data-ttu-id="262ba-522">Bestimmt, ob sich eine Spanne und eine schreibgeschützte Spanne im Speicher überlappen.</span><span class="sxs-lookup"><span data-stu-id="262ba-522">Determines whether a span and a read-only span overlap in memory.</span></span></summary>
        <returns><span data-ttu-id="262ba-523"><see langword="true" />, wenn sich die beiden Sequenzen überlappen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-523"><see langword="true" /> if the two sequences overlap; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? other, out int elementOffset);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Overlaps&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other, [out] int32&amp; elementOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Overlaps``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Overlaps(Of T) (span As ReadOnlySpan(Of T), other As ReadOnlySpan(Of T), ByRef elementOffset As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Overlaps(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other, [Runtime::InteropServices::Out] int % elementOffset);" />
      <MemberSignature Language="F#" Value="static member Overlaps : ReadOnlySpan&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; * int -&gt; bool" Usage="System.MemoryExtensions.Overlaps (span, other, elementOffset)" />
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other, out int elementOffset);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
        <Parameter Name="elementOffset" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-524">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-524">The type of elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-525">Die erste Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-525">The first sequence.</span></span></param>
        <param name="other"><span data-ttu-id="262ba-526">Die zweite Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-526">The second sequence.</span></span></param>
        <param name="elementOffset"><span data-ttu-id="262ba-527">Wenn die Methode zurückkehrt, enthält sie den Offset zwischen <paramref name="span" /> und <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-527">When the method returns, contains the offset between <paramref name="span" /> and <paramref name="other" />.</span></span></param>
        <summary><span data-ttu-id="262ba-528">Bestimmt, ob sich zwei schreibgeschützte Sequenzen im Speicher überlappen, und gibt den Elementoffset aus.</span><span class="sxs-lookup"><span data-stu-id="262ba-528">Determines whether two read-only sequences overlap in memory and outputs the element offset.</span></span></summary>
        <returns><span data-ttu-id="262ba-529"><see langword="true" />, wenn sich die beiden Sequenzen überlappen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-529"><see langword="true" /> if the two sequences overlap; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this Span&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? other, out int elementOffset);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Overlaps&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other, [out] int32&amp; elementOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Overlaps``1(System.Span{``0},System.ReadOnlySpan{``0},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Overlaps(Of T) (span As Span(Of T), other As ReadOnlySpan(Of T), ByRef elementOffset As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Overlaps(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other, [Runtime::InteropServices::Out] int % elementOffset);" />
      <MemberSignature Language="F#" Value="static member Overlaps : Span&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; * int -&gt; bool" Usage="System.MemoryExtensions.Overlaps (span, other, elementOffset)" />
      <MemberSignature Language="C#" Value="public static bool Overlaps&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other, out int elementOffset);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
        <Parameter Name="elementOffset" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-530">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-530">The type of elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-531">Die erste zu vergleichende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-531">The first sequence to compare.</span></span></param>
        <param name="other"><span data-ttu-id="262ba-532">Die zweite zu vergleichende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-532">The second sequence to compare.</span></span></param>
        <param name="elementOffset"><span data-ttu-id="262ba-533">Wenn die Methode zurückkehrt, enthält sie den Offset zwischen <paramref name="span" /> und <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-533">When the method returns, contains the offset between <paramref name="span" /> and <paramref name="other" />.</span></span></param>
        <summary><span data-ttu-id="262ba-534">Bestimmt, ob sich eine Spanne und eine schreibgeschützte Spanne im Speicher überlappen, und gibt den Elementoffset aus.</span><span class="sxs-lookup"><span data-stu-id="262ba-534">Determines whether a span and a read-only span overlap in memory and outputs the element offset.</span></span></summary>
        <returns><span data-ttu-id="262ba-535"><see langword="true" />, wenn sich die beiden Sequenzen überlappen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-535"><see langword="true" /> if the two sequences overlap; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (this Span&lt;T&gt;? span);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Reverse``1(System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Reverse(Of T) (span As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Reverse(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member Reverse : Span&lt;'T&gt; -&gt; unit" Usage="System.MemoryExtensions.Reverse span" />
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (this Span&lt;T&gt; span);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-536">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-536">The type of elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-537">Die umzukehrende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-537">The span to reverse.</span></span></param>
        <summary><span data-ttu-id="262ba-538">Kehrt die Reihenfolge der Elemente in der gesamten Spanne um.</span><span class="sxs-lookup"><span data-stu-id="262ba-538">Reverses the sequence of the elements in the entire span.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceCompareTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SequenceCompareTo&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? other) where T : IComparable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SequenceCompareTo&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.SequenceCompareTo``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceCompareTo(Of T As IComparable(Of T)) (span As ReadOnlySpan(Of T), other As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IComparable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int SequenceCompareTo(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member SequenceCompareTo : ReadOnlySpan&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="System.MemoryExtensions.SequenceCompareTo (span, other)" />
      <MemberSignature Language="C#" Value="public static int SequenceCompareTo&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IComparable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-539">Der Typ der Elemente in der Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-539">The type of elements in the sequence.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-540">Die erste zu vergleichende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-540">The first sequence to compare.</span></span></param>
        <param name="other"><span data-ttu-id="262ba-541">Die zweite zu vergleichende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-541">The second sequence to compare.</span></span></param>
        <summary><span data-ttu-id="262ba-542">Bestimmt die relative Reihenfolge von zwei schreibgeschützten Sequenzen durch Vergleichen ihrer Elemente mit „IComparable{T}.CompareTo(T)“.</span><span class="sxs-lookup"><span data-stu-id="262ba-542">Determines the relative order of two read-only sequences by comparing their elements using IComparable{T}.CompareTo(T).</span></span></summary>
        <returns><span data-ttu-id="262ba-543">Eine ganze Zahl mit Vorzeichen, die die relative Reihenfolge von <paramref name="span" /> und <paramref name="other" /> angibt:</span><span class="sxs-lookup"><span data-stu-id="262ba-543">A signed integer that indicates the relative order of <paramref name="span" /> and <paramref name="other" />:</span></span><br />   <span data-ttu-id="262ba-544">– Wenn kleiner als 0, <paramref name="span" /> vor <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-544">- If less than 0, <paramref name="span" /> precedes than <paramref name="other" />.</span></span><br />   <span data-ttu-id="262ba-545">– Wenn diese 0 (null) sind, ist <paramref name="span" /> gleich <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-545">- If 0, <paramref name="span" /> equals <paramref name="other" />.</span></span><br />   <span data-ttu-id="262ba-546">– Wenn größer als 0, folgt <paramref name="span" /> auf <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-546">- If greater than 0, <paramref name="span" /> follows <paramref name="other" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceCompareTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SequenceCompareTo&lt;T&gt; (this Span&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? other) where T : IComparable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SequenceCompareTo&lt;(class System.IComparable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.SequenceCompareTo``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceCompareTo(Of T As IComparable(Of T)) (span As Span(Of T), other As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IComparable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static int SequenceCompareTo(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member SequenceCompareTo : Span&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IComparable&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; IComparable&lt;'T&gt;)" Usage="System.MemoryExtensions.SequenceCompareTo (span, other)" />
      <MemberSignature Language="C#" Value="public static int SequenceCompareTo&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IComparable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IComparable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-547">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-547">The type of elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-548">Die zu vergleichende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-548">The span to compare.</span></span></param>
        <param name="other"><span data-ttu-id="262ba-549">Die zu vergleichende schreibgeschützte Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-549">The read-only span to compare.</span></span></param>
        <summary><span data-ttu-id="262ba-550">Bestimmt die relative Reihenfolge von einer Spanne und einer schreibgeschützten Spanne durch Vergleichen der Elemente mit „IComparable{T}.CompareTo(T)“.</span><span class="sxs-lookup"><span data-stu-id="262ba-550">Determines the relative order of a span and a read-only span by comparing the elements using IComparable{T}.CompareTo(T).</span></span></summary>
        <returns><span data-ttu-id="262ba-551">Eine ganze Zahl mit Vorzeichen, die die relative Reihenfolge von <paramref name="span" /> und <paramref name="other" /> angibt:</span><span class="sxs-lookup"><span data-stu-id="262ba-551">A signed integer that indicates the relative order of <paramref name="span" /> and <paramref name="other" />:</span></span><br />   <span data-ttu-id="262ba-552">– Wenn kleiner als 0, <paramref name="span" /> vor <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-552">- If less than 0, <paramref name="span" /> precedes than <paramref name="other" />.</span></span><br />   <span data-ttu-id="262ba-553">– Wenn diese 0 (null) sind, ist <paramref name="span" /> gleich <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-553">- If 0, <paramref name="span" /> equals <paramref name="other" />.</span></span><br />   <span data-ttu-id="262ba-554">– Wenn größer als 0, folgt <paramref name="span" /> auf <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-554">- If greater than 0, <paramref name="span" /> follows <paramref name="other" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? other) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.SequenceEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), other As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.SequenceEqual (span, other)" />
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-555">Der Typ der Elemente in der Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-555">The type of elements in the sequence.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-556">Die erste zu vergleichende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-556">The first sequence to compare.</span></span></param>
        <param name="other"><span data-ttu-id="262ba-557">Die zweite zu vergleichende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-557">The second sequence to compare.</span></span></param>
        <summary><span data-ttu-id="262ba-558">Bestimmt, ob zwei schreibgeschützte Sequenzen identisch sind, indem die Elemente mit „IEquatable{T}.Equals(T)“ verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-558">Determines whether two read-only sequences are equal by comparing the elements using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="262ba-559"><see langword="true" />, wenn die beiden Sequenzen identisch sind, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-559"><see langword="true" /> if the two sequences are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;T&gt; (this Span&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? other) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.SequenceEqual``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of T As IEquatable(Of T)) (span As Span(Of T), other As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.SequenceEqual (span, other)" />
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; other) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="other" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-560">Der Typ der Elemente in der Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-560">The type of elements in the sequence.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-561">Die zu vergleichende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-561">The span to compare.</span></span></param>
        <param name="other"><span data-ttu-id="262ba-562">Die zu vergleichende schreibgeschützte Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-562">The read-only span to compare.</span></span></param>
        <summary><span data-ttu-id="262ba-563">Bestimmt, ob eine Spanne und eine schreibgeschützte Spanne identisch sind, indem die Elemente mit „IEquatable{T}.Equals(T)“ verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-563">Determines whether a span and a read-only span are equal by comparing the elements using IEquatable{T}.Equals(T).</span></span></summary>
        <returns><span data-ttu-id="262ba-564"><see langword="true" />, wenn die beiden Sequenzen identisch sind, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-564"><see langword="true" /> if the two sequences are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (this Span&lt;T&gt;? span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Sort``1(System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Sort(Of T) (span As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Sort(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member Sort : Span&lt;'T&gt; -&gt; unit" Usage="System.MemoryExtensions.Sort span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" Index="0" FrameworkAlternate="net-5.0" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-565">Der Typ der Elemente der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-565">The type of the elements of the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-566">Der Umfang des zu sortierenden Speichers.</span><span class="sxs-lookup"><span data-stu-id="262ba-566">The span of memory to sort.</span></span></param>
        <summary><span data-ttu-id="262ba-567">Sortiert die Elemente innerhalb von <see cref="T:System.Span`1" /> mithilfe der <see cref="T:System.IComparable`1" />-Implementierung jedes Elements von <see cref="T:System.Span`1" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-567">Sorts the elements in the entire <see cref="T:System.Span`1" /> using the <see cref="T:System.IComparable`1" /> implementation of each element of the <see cref="T:System.Span`1" /></span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="262ba-568">In einem oder mehreren Elementen in <paramref name="span" /> ist die <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</span><span class="sxs-lookup"><span data-stu-id="262ba-568">One or more elements in <paramref name="span" /> do not implement the <see cref="T:System.IComparable`1" /> interface.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (this Span&lt;T&gt;? span, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(valuetype System.Span`1&lt;!!T&gt; span, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Sort``1(System.Span{``0},System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Sort(Of T) (span As Span(Of T), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Sort(Span&lt;T&gt; span, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : Span&lt;'T&gt; * Comparison&lt;'T&gt; -&gt; unit" Usage="System.MemoryExtensions.Sort (span, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" Index="0" FrameworkAlternate="net-5.0" RefType="this" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-569">Der Typ der Elemente der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-569">The type of the elements of the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-570">Der Umfang des zu sortierenden Speichers.</span><span class="sxs-lookup"><span data-stu-id="262ba-570">The span of memory to sort.</span></span></param>
        <param name="comparison"><span data-ttu-id="262ba-571">Die Methode, die beim Vergleichen von Elementen verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-571">The method to use when comparing elements.</span></span></param>
        <summary><span data-ttu-id="262ba-572">Sortiert die Elemente in der gesamten <see cref="T:System.Span`1" /> mithilfe des angegebenen <see cref="T:System.Comparison`1" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-572">Sorts the elements in the entire <see cref="T:System.Span`1" /> using the specified <see cref="T:System.Comparison`1" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="262ba-573"><paramref name="comparison" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-573"><paramref name="comparison" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T,TComparer&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T,TComparer&gt; (this Span&lt;T&gt;? span, TComparer? comparer) where TComparer : System.Collections.Generic.IComparer&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T, (class System.Collections.Generic.IComparer`1&lt;!!T&gt;) TComparer&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!TComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Sort``2(System.Span{``0},``1)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Sort(Of T, TComparer) (span As Span(Of T), comparer As TComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TComparer&gt;&#xA; where TComparer : System::Collections::Generic::IComparer&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static void Sort(Span&lt;T&gt; span, TComparer comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Span&lt;'T&gt; * 'Comparer -&gt; unit (requires 'Comparer :&gt; System.Collections.Generic.IComparer&lt;'T&gt;)" Usage="System.MemoryExtensions.Sort (span, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TComparer">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IComparer&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" Index="0" FrameworkAlternate="net-5.0" RefType="this" />
        <Parameter Name="comparer" Type="TComparer" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-574">Der Typ der Elemente der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-574">The type of the elements of the span.</span></span></typeparam>
        <typeparam name="TComparer"><span data-ttu-id="262ba-575">Der Typ des Vergleichs, der zum Vergleichen von Elementen verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-575">The type of the comparer to use to compare elements.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-576">Der Umfang des zu sortierenden Speichers.</span><span class="sxs-lookup"><span data-stu-id="262ba-576">The span of memory to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="262ba-577">Die Methode, die beim Vergleichen von Elementen verwendet werden soll, oder <see langword="null" />, um die <see cref="T:System.IComparable`1" />-Schnittstellenimplementierung jedes Elements zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="262ba-577">The method to use when comparing elements, or <see langword="null" /> to use each element's <see cref="T:System.IComparable`1" /> interface implementation.</span></span></param>
        <summary><span data-ttu-id="262ba-578">Sortiert die Elemente innerhalb von <see cref="T:System.Span`1" /> mithilfe von <typeparamref name="TComparer" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-578">Sorts the elements in the entire <see cref="T:System.Span`1" /> using the <typeparamref name="TComparer" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="262ba-579"><paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen in <paramref name="span" /> ist die <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</span><span class="sxs-lookup"><span data-stu-id="262ba-579"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="span" /> do not implement the <see cref="T:System.IComparable`1" /> interface.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="262ba-580">Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht.</span><span class="sxs-lookup"><span data-stu-id="262ba-580">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (this Span&lt;TKey&gt;? keys, Span&lt;TValue&gt;? items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(valuetype System.Span`1&lt;!!TKey&gt; keys, valuetype System.Span`1&lt;!!TValue&gt; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Sort(Of TKey, TValue) (keys As Span(Of TKey), items As Span(Of TValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Sort(Span&lt;TKey&gt; keys, Span&lt;TValue&gt; items);" />
      <MemberSignature Language="F#" Value="static member Sort : Span&lt;'Key&gt; * Span&lt;'Value&gt; -&gt; unit" Usage="System.MemoryExtensions.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="System.Span&lt;TKey&gt;" Index="0" FrameworkAlternate="net-5.0" RefType="this" />
        <Parameter Name="items" Type="System.Span&lt;TValue&gt;" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="262ba-581">Der Typ der Elemente der Schlüssel Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-581">The type of the elements of the key span.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="262ba-582">Der Typ der Elemente der Element Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-582">The type of the elements of the items span.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="262ba-583">Die Spanne, die die zu sortierenden Schlüssel enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-583">The span that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="262ba-584">Die Spanne, die die Elemente enthält, die den Schlüsseln in <paramref name="keys" /> entsprechen.</span><span class="sxs-lookup"><span data-stu-id="262ba-584">The span that contains the items that correspond to the keys in <paramref name="keys" />.</span></span></param>
        <summary><span data-ttu-id="262ba-585">Sortiert ein Paar von Spannen (eine enthält die Schlüssel und die andere die entsprechenden Elemente) auf Basis der Schlüssel in der ersten Schnittstelle <see cref="T:System.Span`1" /> und mithilfe der <see cref="T:System.IComparable`1" />-Implementierung der einzelnen Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="262ba-585">Sorts a pair of spans (one containing the keys and the other containing the corresponding items) based on the keys in the first <see cref="T:System.Span`1" /> using the <see cref="T:System.IComparable`1" /> implementation of each key.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="262ba-586">Die Länge von <paramref name="keys" /> entspricht nicht der Länge von <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-586">The length of <paramref name="keys" /> isn't equal to the length of <paramref name="items" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="262ba-587">In einem oder mehreren Elementen in <paramref name="keys" /> ist die <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</span><span class="sxs-lookup"><span data-stu-id="262ba-587">One or more elements in <paramref name="keys" /> do not implement the <see cref="T:System.IComparable`1" /> interface.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (this Span&lt;TKey&gt;? keys, Span&lt;TValue&gt;? items, Comparison&lt;TKey&gt;? comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(valuetype System.Span`1&lt;!!TKey&gt; keys, valuetype System.Span`1&lt;!!TValue&gt; items, class System.Comparison`1&lt;!!TKey&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Sort``2(System.Span{``0},System.Span{``1},System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Sort(Of TKey, TValue) (keys As Span(Of TKey), items As Span(Of TValue), comparison As Comparison(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Sort(Span&lt;TKey&gt; keys, Span&lt;TValue&gt; items, Comparison&lt;TKey&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : Span&lt;'Key&gt; * Span&lt;'Value&gt; * Comparison&lt;'Key&gt; -&gt; unit" Usage="System.MemoryExtensions.Sort (keys, items, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="System.Span&lt;TKey&gt;" Index="0" FrameworkAlternate="net-5.0" RefType="this" />
        <Parameter Name="items" Type="System.Span&lt;TValue&gt;" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="comparison" Type="System.Comparison&lt;TKey&gt;" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="262ba-588">Der Typ der Elemente der Schlüssel Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-588">The type of the elements of the key span.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="262ba-589">Der Typ der Elemente der Element Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-589">The type of the elements of the items span.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="262ba-590">Die Spanne, die die zu sortierenden Schlüssel enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-590">The span that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="262ba-591">Die Spanne, die die Elemente enthält, die den Schlüsseln in <paramref name="keys" /> entsprechen.</span><span class="sxs-lookup"><span data-stu-id="262ba-591">The span that contains the items that correspond to the keys in <paramref name="keys" />.</span></span></param>
        <param name="comparison"><span data-ttu-id="262ba-592">Die <see cref="T:System.Comparison`1" />, die beim Vergleich von Elementen verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-592">The <see cref="T:System.Comparison`1" /> to use when comparing elements.</span></span></param>
        <summary><span data-ttu-id="262ba-593">Sortiert ein Paar von Spannen (eine enthält die Schlüssel und die andere die entsprechenden Elemente) auf Basis der Schlüssel in der ersten Schnittstelle <see cref="T:System.Span`1" /> und mithilfe des angegebenen Vergleichs.</span><span class="sxs-lookup"><span data-stu-id="262ba-593">Sorts a pair of spans (one containing the keys and the other containing the corresponding items) based on the keys in the first <see cref="T:System.Span`1" /> using the specified comparison.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="262ba-594"><paramref name="comparison" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-594"><paramref name="comparison" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="262ba-595">Die Länge von <paramref name="keys" /> entspricht nicht der Länge von <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-595">The length of <paramref name="keys" /> isn't equal to the length of <paramref name="items" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue,TComparer&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue,TComparer&gt; (this Span&lt;TKey&gt;? keys, Span&lt;TValue&gt;? items, TComparer? comparer) where TComparer : System.Collections.Generic.IComparer&lt;TKey&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue, (class System.Collections.Generic.IComparer`1&lt;!!TKey&gt;) TComparer&gt;(valuetype System.Span`1&lt;!!TKey&gt; keys, valuetype System.Span`1&lt;!!TValue&gt; items, !!TComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Sort``3(System.Span{``0},System.Span{``1},``2)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Sort(Of TKey, TValue, TComparer) (keys As Span(Of TKey), items As Span(Of TValue), comparer As TComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue, typename TComparer&gt;&#xA; where TComparer : System::Collections::Generic::IComparer&lt;TKey&gt;[System::Runtime::CompilerServices::Extension]&#xA; static void Sort(Span&lt;TKey&gt; keys, Span&lt;TValue&gt; items, TComparer comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Span&lt;'Key&gt; * Span&lt;'Value&gt; * 'Comparer -&gt; unit (requires 'Comparer :&gt; System.Collections.Generic.IComparer&lt;'Key&gt;)" Usage="System.MemoryExtensions.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
        <TypeParameter Name="TComparer">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IComparer&lt;TKey&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="System.Span&lt;TKey&gt;" Index="0" FrameworkAlternate="net-5.0" RefType="this" />
        <Parameter Name="items" Type="System.Span&lt;TValue&gt;" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="comparer" Type="TComparer" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="262ba-596">Der Typ der Elemente der Schlüssel Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-596">The type of the elements of the key span.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="262ba-597">Der Typ der Elemente der Element Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-597">The type of the elements of the items span.</span></span></typeparam>
        <typeparam name="TComparer"><span data-ttu-id="262ba-598">Der Typ des Vergleichs, der zum Vergleichen von Elementen verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-598">The type of the comparer to use to compare elements.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="262ba-599">Die Spanne, die die zu sortierenden Schlüssel enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-599">The span that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="262ba-600">Die Spanne, die die Elemente enthält, die den Schlüsseln in <paramref name="keys" /> entsprechen.</span><span class="sxs-lookup"><span data-stu-id="262ba-600">The span that contains the items that correspond to the keys in <paramref name="keys" />.</span></span></param>
        <param name="comparer"><span data-ttu-id="262ba-601">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleichen von Elementen verwendet werden soll, oder <see langword="null" />, um die <see cref="T:System.IComparable`1" />-Schnittstellenimplementierung der einzelnen Elemente zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="262ba-601">The <see cref="T:System.Collections.Generic.IComparer`1" /> implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> interface implementation of each element.</span></span></param>
        <summary><span data-ttu-id="262ba-602">Sortiert ein Paar von Spannen (eine enthält die Schlüssel und die andere die entsprechenden Elemente) auf Basis der Schlüssel in der ersten Schnittstelle <see cref="T:System.Span`1" /> und mithilfe der angegebenen Vergleichsfunktion.</span><span class="sxs-lookup"><span data-stu-id="262ba-602">Sorts a pair of spans (one containing the keys and the other containing the corresponding items) based on the keys in the first <see cref="T:System.Span`1" /> using the specified comparer.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="262ba-603">Die Länge von <paramref name="keys" /> entspricht nicht der Länge von <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-603">The length of <paramref name="keys" /> isn't equal to the length of <paramref name="items" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="262ba-604"><paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen in <paramref name="keys" /> ist die <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</span><span class="sxs-lookup"><span data-stu-id="262ba-604"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="keys" /> do not implement the <see cref="T:System.IComparable`1" /> interface.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public static bool StartsWith (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool StartsWith(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.StartsWith(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StartsWith (span As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool StartsWith(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member StartsWith : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * StringComparison -&gt; bool" Usage="System.MemoryExtensions.StartsWith (span, value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-605">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-605">The source span.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-606">Die Sequenz, die mit dem Anfang der Quellspanne verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-606">The sequence to compare to the beginning of the source span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="262ba-607">Ein Enumerationswert, der bestimmt, wie <paramref name="span" /> und <paramref name="value" /> verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-607">An enumeration value that determines how <paramref name="span" /> and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="262ba-608">Bestimmt, ob eine schreibgeschützte Zeichenspanne mit einem angegebenen Wert beginnt, wenn sie mit einem angegebenen <see cref="T:System.StringComparison" />-Wert verglichen wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-608">Determines whether a read-only character span begins with a specified value when compared using a specified <see cref="T:System.StringComparison" /> value.</span></span></summary>
        <returns><span data-ttu-id="262ba-609"><see langword="true" />, wenn <paramref name="value" /> mit dem Anfang von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-609"><see langword="true" /> if <paramref name="value" /> matches the beginning of <paramref name="span" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool StartsWith&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool StartsWith&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.StartsWith``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StartsWith(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), value As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool StartsWith(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member StartsWith : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.StartsWith (span, value)" />
      <MemberSignature Language="C#" Value="public static bool StartsWith&lt;T&gt; (this ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-610">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-610">The type of elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-611">Die zu suchende schreibgeschützte Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-611">The read-only character span to search.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-612">Eine am Anfang von <paramref name="span" /> zu suchende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-612">A sequence to search for at the start of <paramref name="span" />.</span></span></param>
        <summary><span data-ttu-id="262ba-613">Bestimmt, ob eine angegebene Sequenz am Anfang einer schreibgeschützten Spanne angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-613">Determines whether a specified sequence appears at the start of a read-only span.</span></span></summary>
        <returns><span data-ttu-id="262ba-614"><see langword="true" />, wenn <paramref name="value" /> mit dem Anfang von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-614"><see langword="true" /> if <paramref name="value" /> matches the beginning of <paramref name="span" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool StartsWith&lt;T&gt; (this Span&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool StartsWith&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.StartsWith``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function StartsWith(Of T As IEquatable(Of T)) (span As Span(Of T), value As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool StartsWith(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value);" />
      <MemberSignature Language="F#" Value="static member StartsWith : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.StartsWith (span, value)" />
      <MemberSignature Language="C#" Value="public static bool StartsWith&lt;T&gt; (this Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; value) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-615">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-615">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-616">Die zu suchende Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-616">The span to search.</span></span></param>
        <param name="value"><span data-ttu-id="262ba-617">Eine am Anfang von <paramref name="span" /> zu suchende Sequenz.</span><span class="sxs-lookup"><span data-stu-id="262ba-617">A sequence to search for at the start of <paramref name="span" />.</span></span></param>
        <summary><span data-ttu-id="262ba-618">Bestimmt, ob eine angegebene Sequenz am Anfang einer Spanne angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-618">Determines whether a specified sequence appears at the start of a span.</span></span></summary>
        <returns><span data-ttu-id="262ba-619"><see langword="true" />, wenn <paramref name="value" /> mit dem Anfang von <paramref name="span" /> übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="262ba-619"><see langword="true" /> if <paramref name="value" /> matches the beginning of <paramref name="span" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static int ToLower (this ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, System.Globalization.CultureInfo? culture);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToLower(valuetype System.ReadOnlySpan`1&lt;char&gt; source, valuetype System.Span`1&lt;char&gt; destination, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.ToLower(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLower (source As ReadOnlySpan(Of Char), destination As Span(Of Char), culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int ToLower(ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToLower : ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * System.Globalization.CultureInfo -&gt; int" Usage="System.MemoryExtensions.ToLower (source, destination, culture)" />
      <MemberSignature Language="C#" Value="public static int ToLower (this ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, System.Globalization.CultureInfo culture);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="262ba-620">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-620">The source span.</span></span></param>
        <param name="destination"><span data-ttu-id="262ba-621">Die Zielspanne, die die transformierten Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-621">The destination span which contains the transformed characters.</span></span></param>
        <param name="culture"><span data-ttu-id="262ba-622">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="262ba-622">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="262ba-623">Kopiert die Zeichen aus der Quellspanne in das Ziel und konvertiert jedes Zeichen in Kleinbuchstaben, wobei die Regeln für die Groß-/Kleinschreibung der angegebenen Kultur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-623">Copies the characters from the source span into the destination, converting each character to lowercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="262ba-624">Die Anzahl der Zeichen, die in die Zielspanne geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-624">The number of characters written into the destination span.</span></span> <span data-ttu-id="262ba-625">Wenn das Ziel zu klein ist, wird -1 zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="262ba-625">If the destination is too small, returns -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-626">Wenn den Wert `culture` `null` hat, <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> wird verwendet.</span><span class="sxs-lookup"><span data-stu-id="262ba-626">If `culture` is `null`, <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> will be used.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="262ba-627">Die Quell- und Zielpuffer überlappen sich.</span><span class="sxs-lookup"><span data-stu-id="262ba-627">The source and destination buffers overlap.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public static int ToLowerInvariant (this ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToLowerInvariant(valuetype System.ReadOnlySpan`1&lt;char&gt; source, valuetype System.Span`1&lt;char&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.ToLowerInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLowerInvariant (source As ReadOnlySpan(Of Char), destination As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int ToLowerInvariant(ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination);" />
      <MemberSignature Language="F#" Value="static member ToLowerInvariant : ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; -&gt; int" Usage="System.MemoryExtensions.ToLowerInvariant (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="262ba-628">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-628">The source span.</span></span></param>
        <param name="destination"><span data-ttu-id="262ba-629">Die Zielspanne, die die transformierten Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-629">The destination span which contains the transformed characters.</span></span></param>
        <summary><span data-ttu-id="262ba-630">Kopiert die Zeichen aus der Quellspanne in das Ziel und konvertiert jedes Zeichen in Kleinbuchstaben, wobei die Regeln für die Groß-/Kleinschreibung der invarianten Kultur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-630">Copies the characters from the source span into the destination, converting each character to lowercase, using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="262ba-631">Die Anzahl der Zeichen, die in die Zielspanne geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-631">The number of characters written into the destination span.</span></span> <span data-ttu-id="262ba-632">Wenn das Ziel zu klein ist, wird -1 zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="262ba-632">If the destination is too small, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="262ba-633">Die Quell- und Zielpuffer überlappen sich.</span><span class="sxs-lookup"><span data-stu-id="262ba-633">The source and destination buffers overlap.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static int ToUpper (this ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, System.Globalization.CultureInfo? culture);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToUpper(valuetype System.ReadOnlySpan`1&lt;char&gt; source, valuetype System.Span`1&lt;char&gt; destination, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.ToUpper(System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToUpper (source As ReadOnlySpan(Of Char), destination As Span(Of Char), culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int ToUpper(ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToUpper : ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * System.Globalization.CultureInfo -&gt; int" Usage="System.MemoryExtensions.ToUpper (source, destination, culture)" />
      <MemberSignature Language="C#" Value="public static int ToUpper (this ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination, System.Globalization.CultureInfo culture);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="262ba-634">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-634">The source span.</span></span></param>
        <param name="destination"><span data-ttu-id="262ba-635">Die Zielspanne, die die transformierten Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-635">The destination span which contains the transformed characters.</span></span></param>
        <param name="culture"><span data-ttu-id="262ba-636">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="262ba-636">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="262ba-637">Kopiert die Zeichen aus der Quellspanne in das Ziel und konvertiert jedes Zeichen in Kleinbuchstaben, wobei die Regeln für die Groß-/Kleinschreibung der angegebenen Kultur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-637">Copies the characters from the source span into the destination, converting each character to uppercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="262ba-638">Die Anzahl der Zeichen, die in die Zielspanne geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-638">The number of characters written into the destination span.</span></span> <span data-ttu-id="262ba-639">Wenn das Ziel zu klein ist, wird -1 zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="262ba-639">If the destination is too small, returns -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-640">Wenn den Wert `culture` `null` hat, <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> wird verwendet.</span><span class="sxs-lookup"><span data-stu-id="262ba-640">If `culture` is `null`, <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> will be used.</span></span>

            ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="262ba-641">Die Quell- und Zielpuffer überlappen sich.</span><span class="sxs-lookup"><span data-stu-id="262ba-641">The source and destination buffers overlap.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public static int ToUpperInvariant (this ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToUpperInvariant(valuetype System.ReadOnlySpan`1&lt;char&gt; source, valuetype System.Span`1&lt;char&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.ToUpperInvariant(System.ReadOnlySpan{System.Char},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToUpperInvariant (source As ReadOnlySpan(Of Char), destination As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int ToUpperInvariant(ReadOnlySpan&lt;char&gt; source, Span&lt;char&gt; destination);" />
      <MemberSignature Language="F#" Value="static member ToUpperInvariant : ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; -&gt; int" Usage="System.MemoryExtensions.ToUpperInvariant (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="262ba-642">Die Quellspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-642">The source span.</span></span></param>
        <param name="destination"><span data-ttu-id="262ba-643">Die Zielspanne, die die transformierten Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-643">The destination span which contains the transformed characters.</span></span></param>
        <summary><span data-ttu-id="262ba-644">Kopiert die Zeichen aus der Quellspanne in das Ziel und konvertiert jedes Zeichen in Großbuchstaben, wobei die Regeln für die Groß-/Kleinschreibung der angegebenen Kultur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-644">Copies the characters from the source span into the destination, converting each character to uppercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="262ba-645">Die Anzahl der Zeichen, die in die Zielspanne geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-645">The number of characters written into the destination span.</span></span> <span data-ttu-id="262ba-646">Wenn das Ziel zu klein ist, wird -1 zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="262ba-646">If the destination is too small, returns -1.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="262ba-647">Die Quell- und Zielpuffer überlappen sich.</span><span class="sxs-lookup"><span data-stu-id="262ba-647">The source and destination buffers overlap.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static Memory&lt;char&gt; Trim (this Memory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;char&gt; Trim(valuetype System.Memory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.Memory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (memory As Memory(Of Char)) As Memory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;char&gt; Trim(Memory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member Trim : Memory&lt;char&gt; -&gt; Memory&lt;char&gt;" Usage="System.MemoryExtensions.Trim memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="262ba-648">Der Quellspeicher, aus dem die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-648">The source memory from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="262ba-649">Entfernt alle führenden und nachfolgenden Leerzeichen aus einem Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-649">Removes all leading and trailing whitespace characters from a character memory region.</span></span></summary>
        <returns><span data-ttu-id="262ba-650">Der zugeschnittene Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-650">The trimmed character memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; Trim (this ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; Trim(valuetype System.ReadOnlyMemory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (memory As ReadOnlyMemory(Of Char)) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; Trim(ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlyMemory&lt;char&gt; -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.Trim memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="262ba-651">Der Quellspeicher, aus dem die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-651">The source memory from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="262ba-652">Entfernt alle führenden und nachfolgenden Leerzeichen aus einem schreibgeschützten Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-652">Removes all leading and trailing whitespace characters from a read-only character memory region.</span></span></summary>
        <returns><span data-ttu-id="262ba-653">Der zugeschnittene Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-653">The trimmed character memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; Trim (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; Trim(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (span As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; Trim(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.Trim span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-654">Die Quellspanne, aus der die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-654">The source span from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="262ba-655">Entfernt alle führenden und nachfolgenden Leerzeichen aus einer schreibgeschützten Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-655">Removes all leading and trailing whitespace characters from a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="262ba-656">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-656">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static Span&lt;char&gt; Trim (this Span&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;char&gt; Trim(valuetype System.Span`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (span As Span(Of Char)) As Span(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;char&gt; Trim(Span&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member Trim : Span&lt;char&gt; -&gt; Span&lt;char&gt;" Usage="System.MemoryExtensions.Trim span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-657">Die Quellspanne, aus der die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-657">The source span from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="262ba-658">Entfernt alle führenden und nachfolgenden Leerzeichen aus einer Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-658">Removes all leading and trailing whitespace characters from a character span.</span></span></summary>
        <returns><span data-ttu-id="262ba-659">Der zugeschnittene Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-659">The trimmed character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; Trim (this ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; Trim(valuetype System.ReadOnlySpan`1&lt;char&gt; span, char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.Char)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (span As ReadOnlySpan(Of Char), trimChar As Char) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; Trim(ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;char&gt; * char -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.Trim (span, trimChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-660">Die Quellspanne, aus der das Zeichen entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-660">The source span from which the character is removed.</span></span></param>
        <param name="trimChar"><span data-ttu-id="262ba-661">Das angegebene Zeichen, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-661">The specified character to look for and remove.</span></span></param>
        <summary><span data-ttu-id="262ba-662">Entfernt alle führenden und nachfolgenden Vorkommen eines bestimmten Zeichens aus einer schreibgeschützten Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-662">Removes all leading and trailing occurrences of a specified character from a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="262ba-663">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-663">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; Trim (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; Trim(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim (span As ReadOnlySpan(Of Char), trimChars As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; Trim(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.Trim (span, trimChars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-664">Die Quellspanne, aus der die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-664">The source span from which the characters are removed.</span></span></param>
        <param name="trimChars"><span data-ttu-id="262ba-665">Die Spanne, die den zu entfernenden Zeichensatz enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-665">The span which contains the set of characters to remove.</span></span></param>
        <summary><span data-ttu-id="262ba-666">Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Zeichen, die in einer schreibgeschützten Spanne angegeben sind, aus einer schreibgeschützten Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-666">Removes all leading and trailing occurrences of a set of characters specified in a read-only span from a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="262ba-667">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-667">The trimmed read-only character span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-668">Wenn `trimChars` leer ist, werden stattdessen Leerzeichen entfernt.</span><span class="sxs-lookup"><span data-stu-id="262ba-668">If `trimChars` is empty, whitespace characters are removed instead.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? Trim&lt;T&gt; (this Memory&lt;T&gt;? memory, ReadOnlySpan&lt;T&gt;? trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.Memory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElements As ReadOnlySpan(Of T)) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; Trim(Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member Trim : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-669">Der Typ der Elemente im Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-669">The type of the elements in the memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="262ba-670">Der Quellspeicher, aus dem die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-670">The source memory from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="262ba-671">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-671">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="262ba-672">Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-672">Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a memory region.</span></span></summary>
        <returns><span data-ttu-id="262ba-673">Der zugeschnittene Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-673">The trimmed memory region.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-674">Wenn `trimElements` leer ist, wird der Arbeitsspeicher unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="262ba-674">If `trimElements` is empty, the memory is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? Trim&lt;T&gt; (this Memory&lt;T&gt;? memory, T trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.Memory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElement As T) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; Trim(Memory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member Trim : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (memory, trimElement)" />
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? Trim&lt;T&gt; (this Memory&lt;T&gt;? memory, T? trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-675">Der Typ der Elemente im Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-675">The type of the elements in the memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="262ba-676">Der Quellspeicher, aus dem das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-676">The source memory from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="262ba-677">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-677">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="262ba-678">Entfernt alle führenden und nachfolgenden Vorkommen eines angegebenen Elements aus einem Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-678">Removes all leading and trailing occurrences of a specified element from a memory region.</span></span></summary>
        <returns><span data-ttu-id="262ba-679">Der zugeschnittene Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-679">The trimmed memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt;? Trim&lt;T&gt; (this ReadOnlyMemory&lt;T&gt;? memory, ReadOnlySpan&lt;T&gt;? trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; Trim(ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-680">Der Typ der Elemente im schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-680">The type of the elements in the read-only memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="262ba-681">Der Quellspeicher, aus dem die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-681">The source memory from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="262ba-682">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-682">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="262ba-683">Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-683">Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a read-only memory region.</span></span></summary>
        <returns><span data-ttu-id="262ba-684">Der zugeschnittene, schreibgeschützte Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-684">The trimmed read-only memory region.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-685">Wenn `trimElements` leer ist, wird der Arbeitsspeicher unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="262ba-685">If `trimElements` is empty, the memory is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt;? Trim&lt;T&gt; (this ReadOnlyMemory&lt;T&gt;? memory, T trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.ReadOnlyMemory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElement As T) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; Trim(ReadOnlyMemory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (memory, trimElement)" />
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt;? Trim&lt;T&gt; (this ReadOnlyMemory&lt;T&gt;? memory, T? trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-686">Der Typ der Elemente im schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-686">The type of the elements in the read-only memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="262ba-687">Der Quellspeicher, aus dem das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-687">The source memory from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="262ba-688">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-688">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="262ba-689">Entfernt alle führenden und nachfolgenden Vorkommen eines angegebenen Elements aus einem schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-689">Removes all leading and trailing occurrences of a specified element from a read-only memory region.</span></span></summary>
        <returns><span data-ttu-id="262ba-690">Der zugeschnittene, schreibgeschützte Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-690">The trimmed read-only memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt;? Trim&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; Trim(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-691">Der Typ der Elemente in der schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-691">The type of the elements in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-692">Die Quellspanne, aus der die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-692">The source span from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="262ba-693">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-693">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="262ba-694">Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einer schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-694">Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a read-only span.</span></span></summary>
        <returns><span data-ttu-id="262ba-695">Der zugeschnittene, schreibgeschützte Bereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-695">The trimmed read-only span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-696">Wenn `trimElements` leer ist, wird die Spanne unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="262ba-696">If `trimElements` is empty, the span is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt;? Trim&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, T trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElement As T) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; Trim(ReadOnlySpan&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member Trim : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (span, trimElement)" />
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt;? Trim&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, T? trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-697">Der Typ der Elemente in der schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-697">The type of the elements in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-698">Die Quellspanne, aus der das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-698">The source span from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="262ba-699">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-699">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="262ba-700">Entfernt alle führenden und nachfolgenden Vorkommen eines angegebenen Elements aus einer schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-700">Removes all leading and trailing occurrences of a specified element from a read-only span.</span></span></summary>
        <returns><span data-ttu-id="262ba-701">Der zugeschnittene, schreibgeschützte Bereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-701">The trimmed read-only span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? Trim&lt;T&gt; (this Span&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (span As Span(Of T), trimElements As ReadOnlySpan(Of T)) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; Trim(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member Trim : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-702">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-702">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-703">Die Quellspanne, aus der die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-703">The source span from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="262ba-704">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-704">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="262ba-705">Entfernt alle führenden und nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einer Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-705">Removes all leading and trailing occurrences of a set of elements specified in a read-only span from a span.</span></span></summary>
        <returns><span data-ttu-id="262ba-706">Der zugeschnittene Bereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-706">The trimmed span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-707">Wenn `trimElements` leer ist, wird die Spanne unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="262ba-707">If `trimElements` is empty, the span is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? Trim&lt;T&gt; (this Span&lt;T&gt;? span, T trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; Trim&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.Trim``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Trim(Of T As IEquatable(Of T)) (span As Span(Of T), trimElement As T) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; Trim(Span&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member Trim : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.Trim (span, trimElement)" />
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? Trim&lt;T&gt; (this Span&lt;T&gt;? span, T? trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-708">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-708">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-709">Die Quellspanne, aus der das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-709">The source span from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="262ba-710">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-710">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="262ba-711">Entfernt alle führenden und nachfolgenden Vorkommen eines angegebenen Elements aus einer Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-711">Removes all leading and trailing occurrences of a specified element from a span.</span></span></summary>
        <returns><span data-ttu-id="262ba-712">Der zugeschnittene Bereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-712">The trimmed span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static Memory&lt;char&gt; TrimEnd (this Memory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;char&gt; TrimEnd(valuetype System.Memory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.Memory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (memory As Memory(Of Char)) As Memory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;char&gt; TrimEnd(Memory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Memory&lt;char&gt; -&gt; Memory&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="262ba-713">Der Quellspeicher, aus dem die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-713">The source memory from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="262ba-714">Entfernt alle nachfolgenden Leerzeichen aus einem Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-714">Removes all trailing whitespace characters from a character memory region.</span></span></summary>
        <returns><span data-ttu-id="262ba-715">Der zugeschnittene Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-715">The trimmed character memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; TrimEnd (this ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; TrimEnd(valuetype System.ReadOnlyMemory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (memory As ReadOnlyMemory(Of Char)) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; TrimEnd(ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlyMemory&lt;char&gt; -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="262ba-716">Der Quellspeicher, aus dem die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-716">The source memory from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="262ba-717">Entfernt alle nachfolgenden Leerzeichen aus einem schreibgeschützten Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-717">Removes all trailing whitespace characters from a read-only character memory region.</span></span></summary>
        <returns><span data-ttu-id="262ba-718">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-718">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEnd (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEnd(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (span As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimEnd(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-719">Die Quellspanne, aus der die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-719">The source span from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="262ba-720">Entfernt alle nachfolgenden Leerzeichen aus einer schreibgeschützten Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-720">Removes all trailing whitespace characters from a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="262ba-721">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-721">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static Span&lt;char&gt; TrimEnd (this Span&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;char&gt; TrimEnd(valuetype System.Span`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (span As Span(Of Char)) As Span(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;char&gt; TrimEnd(Span&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Span&lt;char&gt; -&gt; Span&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-722">Die Quellspanne, aus der die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-722">The source span from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="262ba-723">Entfernt alle nachfolgenden Leerzeichen aus einer Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-723">Removes all trailing whitespace characters from a character span.</span></span></summary>
        <returns><span data-ttu-id="262ba-724">Der zugeschnittene Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-724">The trimmed character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEnd (this ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEnd(valuetype System.ReadOnlySpan`1&lt;char&gt; span, char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.Char)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (span As ReadOnlySpan(Of Char), trimChar As Char) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimEnd(ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;char&gt; * char -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd (span, trimChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-725">Die Quellspanne, aus der das Zeichen entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-725">The source span from which the character is removed.</span></span></param>
        <param name="trimChar"><span data-ttu-id="262ba-726">Das angegebene Zeichen, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-726">The specified character to look for and remove.</span></span></param>
        <summary><span data-ttu-id="262ba-727">Entfernt alle nachfolgenden Vorkommen eines bestimmten Zeichens aus einer schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-727">Removes all trailing occurrences of a specified character from a read-only span.</span></span></summary>
        <returns><span data-ttu-id="262ba-728">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-728">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEnd (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEnd(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd (span As ReadOnlySpan(Of Char), trimChars As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimEnd(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimEnd (span, trimChars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-729">Die Quellspanne, aus der die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-729">The source span from which the characters are removed.</span></span></param>
        <param name="trimChars"><span data-ttu-id="262ba-730">Die Spanne, die den zu entfernenden Zeichensatz enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-730">The span which contains the set of characters to remove.</span></span></param>
        <summary><span data-ttu-id="262ba-731">Entfernt alle nachfolgenden Vorkommen einer Reihe von Zeichen, die in einer schreibgeschützten Spanne angegeben sind, aus einer schreibgeschützten Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-731">Removes all trailing occurrences of a set of characters specified in a read-only span from a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="262ba-732">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-732">The trimmed read-only character span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-733">Wenn `trimChars` leer ist, werden stattdessen Leerzeichen entfernt.</span><span class="sxs-lookup"><span data-stu-id="262ba-733">If `trimChars` is empty, whitespace characters are removed instead.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? TrimEnd&lt;T&gt; (this Memory&lt;T&gt;? memory, ReadOnlySpan&lt;T&gt;? trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElements As ReadOnlySpan(Of T)) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; TrimEnd(Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-734">Der Typ der Elemente im Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-734">The type of the elements in the memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="262ba-735">Der Quellspeicher, aus dem die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-735">The source memory from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="262ba-736">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-736">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="262ba-737">Entfernt alle nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-737">Removes all trailing occurrences of a set of elements specified in a read-only span from a memory region.</span></span></summary>
        <returns><span data-ttu-id="262ba-738">Der zugeschnittene Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-738">The trimmed memory region.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-739">Wenn `trimElements` leer ist, wird der Arbeitsspeicher unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="262ba-739">If `trimElements` is empty, the memory is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? TrimEnd&lt;T&gt; (this Memory&lt;T&gt;? memory, T trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.Memory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElement As T) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; TrimEnd(Memory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (memory, trimElement)" />
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? TrimEnd&lt;T&gt; (this Memory&lt;T&gt;? memory, T? trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-740">Der Typ der Elemente im Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-740">The type of the elements in the memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="262ba-741">Der Quellspeicher, aus dem das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-741">The source memory from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="262ba-742">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-742">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="262ba-743">Entfernt alle nachfolgenden Vorkommen eines angegebenen Elements aus einem Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-743">Removes all trailing occurrences of a specified element from a character memory region.</span></span></summary>
        <returns><span data-ttu-id="262ba-744">Der zugeschnittene Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-744">The trimmed memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt;? TrimEnd&lt;T&gt; (this ReadOnlyMemory&lt;T&gt;? memory, ReadOnlySpan&lt;T&gt;? trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; TrimEnd(ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-745">Der Typ der Elemente im schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-745">The type of the elements in the read-only memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="262ba-746">Der Quellspeicher, aus dem die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-746">The source memory from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="262ba-747">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-747">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="262ba-748">Entfernt alle nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-748">Removes all trailing occurrences of a set of elements specified in a read-only span from a read-only memory region.</span></span></summary>
        <returns><span data-ttu-id="262ba-749">Der zugeschnittene, schreibgeschützte Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-749">The trimmed read-only memory region.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-750">Wenn `trimElements` leer ist, wird der Arbeitsspeicher unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="262ba-750">If `trimElements` is empty, the memory is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt;? TrimEnd&lt;T&gt; (this ReadOnlyMemory&lt;T&gt;? memory, T trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlyMemory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElement As T) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; TrimEnd(ReadOnlyMemory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (memory, trimElement)" />
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt;? TrimEnd&lt;T&gt; (this ReadOnlyMemory&lt;T&gt;? memory, T? trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-751">Der Typ der Elemente im schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-751">The type of the elements in the read-only memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="262ba-752">Der Quellspeicher, aus dem das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-752">The source memory from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="262ba-753">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-753">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="262ba-754">Entfernt alle nachfolgenden Vorkommen eines angegebenen Elements aus einem schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-754">Removes all trailing occurrences of a specified element from a read-only memory region.</span></span></summary>
        <returns><span data-ttu-id="262ba-755">Der zugeschnittene, schreibgeschützte Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-755">The trimmed read-only memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt;? TrimEnd&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; TrimEnd(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-756">Der Typ der Elemente in der schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-756">The type of the elements in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-757">Die Quellspanne, aus der die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-757">The source span from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="262ba-758">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-758">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="262ba-759">Entfernt alle nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einer schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-759">Removes all trailing occurrences of a set of elements specified in a read-only span from a read-only span.</span></span></summary>
        <returns><span data-ttu-id="262ba-760">Der zugeschnittene, schreibgeschützte Bereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-760">The trimmed read-only span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-761">Wenn `trimElements` leer ist, wird die Spanne unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="262ba-761">If `trimElements` is empty, the span is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt;? TrimEnd&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, T trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElement As T) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; TrimEnd(ReadOnlySpan&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (span, trimElement)" />
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt;? TrimEnd&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, T? trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-762">Der Typ der Elemente in der schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-762">The type of the elements in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-763">Die Quellspanne, aus der das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-763">The source span from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="262ba-764">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-764">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="262ba-765">Entfernt alle nachfolgenden Vorkommen eines angegebenen Elements aus einer schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-765">Removes all trailing occurrences of a specified element from a read-only span.</span></span></summary>
        <returns><span data-ttu-id="262ba-766">Der zugeschnittene, schreibgeschützte Bereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-766">The trimmed read-only span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? TrimEnd&lt;T&gt; (this Span&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (span As Span(Of T), trimElements As ReadOnlySpan(Of T)) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; TrimEnd(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-767">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-767">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-768">Die Quellspanne, aus der die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-768">The source span from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="262ba-769">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-769">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="262ba-770">Entfernt alle nachfolgenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einer Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-770">Removes all trailing occurrences of a set of elements specified in a read-only span from a span.</span></span></summary>
        <returns><span data-ttu-id="262ba-771">Der zugeschnittene Bereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-771">The trimmed span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-772">Wenn `trimElements` leer ist, wird die Spanne unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="262ba-772">If `trimElements` is empty, the span is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? TrimEnd&lt;T&gt; (this Span&lt;T&gt;? span, T trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; TrimEnd&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimEnd``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimEnd(Of T As IEquatable(Of T)) (span As Span(Of T), trimElement As T) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; TrimEnd(Span&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimEnd : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimEnd (span, trimElement)" />
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? TrimEnd&lt;T&gt; (this Span&lt;T&gt;? span, T? trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-773">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-773">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-774">Die Quellspanne, aus der das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-774">The source span from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="262ba-775">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-775">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="262ba-776">Entfernt alle nachfolgenden Vorkommen eines angegebenen Elements aus einer Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-776">Removes all trailing occurrences of a specified element from a span.</span></span></summary>
        <returns><span data-ttu-id="262ba-777">Der zugeschnittene Bereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-777">The trimmed span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static Memory&lt;char&gt; TrimStart (this Memory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;char&gt; TrimStart(valuetype System.Memory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.Memory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (memory As Memory(Of Char)) As Memory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;char&gt; TrimStart(Memory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Memory&lt;char&gt; -&gt; Memory&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="262ba-778">Der Quellspeicher, aus dem die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-778">The source memory from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="262ba-779">Entfernt alle führenden Leerzeichen aus einem Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-779">Removes all leading whitespace characters from a memory region.</span></span></summary>
        <returns><span data-ttu-id="262ba-780">Der zugeschnittene Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-780">The trimmed character memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;char&gt; TrimStart (this ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;char&gt; TrimStart(valuetype System.ReadOnlyMemory`1&lt;char&gt; memory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (memory As ReadOnlyMemory(Of Char)) As ReadOnlyMemory(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;char&gt; TrimStart(ReadOnlyMemory&lt;char&gt; memory);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlyMemory&lt;char&gt; -&gt; ReadOnlyMemory&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart memory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="memory"><span data-ttu-id="262ba-781">Der Quellspeicher, aus dem die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-781">The source memory from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="262ba-782">Entfernt alle führenden Leerzeichen aus einem schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-782">Removes all leading whitespace characters from a read-only memory region.</span></span></summary>
        <returns><span data-ttu-id="262ba-783">Der zugeschnittene, schreibgeschützte Zeichenspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-783">The trimmed read-only character memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimStart (this ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimStart(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (span As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimStart(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-784">Die Quellspanne, aus der die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-784">The source span from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="262ba-785">Entfernt alle führenden Leerzeichen aus einer schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-785">Removes all leading whitespace characters from a read-only span.</span></span></summary>
        <returns><span data-ttu-id="262ba-786">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-786">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static Span&lt;char&gt; TrimStart (this Span&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;char&gt; TrimStart(valuetype System.Span`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (span As Span(Of Char)) As Span(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;char&gt; TrimStart(Span&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Span&lt;char&gt; -&gt; Span&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;System.Char&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-787">Die Quellspanne, aus der die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-787">The source span from which the characters are removed.</span></span></param>
        <summary><span data-ttu-id="262ba-788">Entfernt alle führenden Leerzeichen aus einer Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-788">Removes all leading whitespace characters from a span.</span></span></summary>
        <returns><span data-ttu-id="262ba-789">Der zugeschnittene Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-789">The trimmed character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimStart (this ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimStart(valuetype System.ReadOnlySpan`1&lt;char&gt; span, char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.Char)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (span As ReadOnlySpan(Of Char), trimChar As Char) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimStart(ReadOnlySpan&lt;char&gt; span, char trimChar);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;char&gt; * char -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart (span, trimChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-790">Die Quellspanne, aus der das Zeichen entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-790">The source span from which the character is removed.</span></span></param>
        <param name="trimChar"><span data-ttu-id="262ba-791">Das angegebene Zeichen, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-791">The specified character to look for and remove.</span></span></param>
        <summary><span data-ttu-id="262ba-792">Entfernt alle führenden Vorkommen eines bestimmten Zeichens aus der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-792">Removes all leading occurrences of a specified character from the span.</span></span></summary>
        <returns><span data-ttu-id="262ba-793">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-793">The trimmed read-only character span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimStart (this ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimStart(valuetype System.ReadOnlySpan`1&lt;char&gt; span, valuetype System.ReadOnlySpan`1&lt;char&gt; trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart (span As ReadOnlySpan(Of Char), trimChars As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;char&gt; TrimStart(ReadOnlySpan&lt;char&gt; span, ReadOnlySpan&lt;char&gt; trimChars);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.MemoryExtensions.TrimStart (span, trimChars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" RefType="this" />
        <Parameter Name="trimChars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span"><span data-ttu-id="262ba-794">Die Quellspanne, aus der die Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-794">The source span from which the characters are removed.</span></span></param>
        <param name="trimChars"><span data-ttu-id="262ba-795">Die Spanne, die den zu entfernenden Zeichensatz enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-795">The span which contains the set of characters to remove.</span></span></param>
        <summary><span data-ttu-id="262ba-796">Entfernt alle führenden Vorkommen einer Reihe von Zeichen, die in einer schreibgeschützten Spanne angegeben sind, aus der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-796">Removes all leading occurrences of a set of characters specified in a read-only span from the span.</span></span></summary>
        <returns><span data-ttu-id="262ba-797">Der zugeschnittene, schreibgeschützte Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-797">The trimmed read-only character span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-798">Wenn `trimChars` leer ist, werden stattdessen Leerzeichen entfernt.</span><span class="sxs-lookup"><span data-stu-id="262ba-798">If `trimChars` is empty, whitespace characters are removed instead.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? TrimStart&lt;T&gt; (this Memory&lt;T&gt;? memory, ReadOnlySpan&lt;T&gt;? trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElements As ReadOnlySpan(Of T)) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; TrimStart(Memory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-799">Der Typ der Elemente im Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-799">The type of the elements in the memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="262ba-800">Der Quellspeicher, aus dem die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-800">The source memory from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="262ba-801">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-801">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="262ba-802">Entfernt alle führenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-802">Removes all leading occurrences of a set of elements specified in a read-only span from a memory region.</span></span></summary>
        <returns><span data-ttu-id="262ba-803">Der zugeschnittene Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-803">The trimmed memory region.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-804">Wenn `trimElements` leer ist, wird der Arbeitsspeicher unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="262ba-804">If `trimElements` is empty, the memory is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? TrimStart&lt;T&gt; (this Memory&lt;T&gt;? memory, T trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Memory`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Memory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.Memory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (memory As Memory(Of T), trimElement As T) As Memory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Memory&lt;T&gt; TrimStart(Memory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Memory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (memory, trimElement)" />
      <MemberSignature Language="C#" Value="public static Memory&lt;T&gt;? TrimStart&lt;T&gt; (this Memory&lt;T&gt;? memory, T? trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.Memory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-805">Der Typ der Elemente im Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-805">The type of the elements in the memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="262ba-806">Der Quellspeicherbereich, aus dem das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-806">The source memory region from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="262ba-807">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-807">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="262ba-808">Entfernt alle führenden Vorkommen eines angegebenen Elements aus einem Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-808">Removes all leading occurrences of a specified element from a memory region.</span></span></summary>
        <returns><span data-ttu-id="262ba-809">Der zugeschnittene Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-809">The trimmed memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt;? TrimStart&lt;T&gt; (this ReadOnlyMemory&lt;T&gt;? memory, ReadOnlySpan&lt;T&gt;? trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; TrimStart(ReadOnlyMemory&lt;T&gt; memory, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (memory, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-810">Der Typ der Elemente im schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-810">The type of the elements in the read-only memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="262ba-811">Der Quellspeicher, aus dem die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-811">The source memory from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="262ba-812">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-812">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="262ba-813">Entfernt alle führenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus einem Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-813">Removes all leading occurrences of a set of elements specified in a read-only span from a memory region.</span></span></summary>
        <returns><span data-ttu-id="262ba-814">Der zugeschnittene, schreibgeschützte Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-814">The trimmed read-only memory region.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-815">Wenn `trimElements` leer ist, wird der Arbeitsspeicher unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="262ba-815">If `trimElements` is empty, the memory is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt;? TrimStart&lt;T&gt; (this ReadOnlyMemory&lt;T&gt;? memory, T trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlyMemory`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlyMemory`1&lt;!!T&gt; memory, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlyMemory{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (memory As ReadOnlyMemory(Of T), trimElement As T) As ReadOnlyMemory(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlyMemory&lt;T&gt; TrimStart(ReadOnlyMemory&lt;T&gt; memory, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlyMemory&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (memory, trimElement)" />
      <MemberSignature Language="C#" Value="public static ReadOnlyMemory&lt;T&gt;? TrimStart&lt;T&gt; (this ReadOnlyMemory&lt;T&gt;? memory, T? trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="memory" Type="System.ReadOnlyMemory&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-816">Der Typ der Elemente im schreibgeschützten Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-816">The type of the elements in the read-only memory region.</span></span></typeparam>
        <param name="memory"><span data-ttu-id="262ba-817">Der Quellspeicher, aus dem das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-817">The source memory from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="262ba-818">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-818">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="262ba-819">Entfernt alle führenden Vorkommen eines angegebenen Elements aus einem Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-819">Removes all leading occurrences of a specified element from a memory region.</span></span></summary>
        <returns><span data-ttu-id="262ba-820">Der zugeschnittene, schreibgeschützte Speicherbereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-820">The trimmed read-only memory region.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt;? TrimStart&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElements As ReadOnlySpan(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; TrimStart(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-821">Der Typ der Elemente in der schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-821">The type of the elements in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-822">Die Quellspanne, aus der die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-822">The source span from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="262ba-823">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-823">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="262ba-824">Entfernt alle führenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-824">Removes all leading occurrences of a set of elements specified in a read-only span from the span.</span></span></summary>
        <returns><span data-ttu-id="262ba-825">Der zugeschnittene, schreibgeschützte Bereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-825">The trimmed read-only span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-826">Wenn `trimElements` leer ist, wird die Spanne unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="262ba-826">If `trimElements` is empty, the span is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt;? TrimStart&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, T trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.ReadOnlySpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (span As ReadOnlySpan(Of T), trimElement As T) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static ReadOnlySpan&lt;T&gt; TrimStart(ReadOnlySpan&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimStart : ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (span, trimElement)" />
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt;? TrimStart&lt;T&gt; (this ReadOnlySpan&lt;T&gt;? span, T? trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-827">Der Typ der Elemente in der schreibgeschützten Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-827">The type of the elements in the read-only span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-828">Die Quellspanne, aus der das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-828">The source span from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="262ba-829">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-829">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="262ba-830">Entfernt alle führenden Vorkommen eines bestimmten Elements aus der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-830">Removes all leading occurrences of a specified element from the span.</span></span></summary>
        <returns><span data-ttu-id="262ba-831">Der zugeschnittene, schreibgeschützte Bereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-831">The trimmed read-only span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? TrimStart&lt;T&gt; (this Span&lt;T&gt;? span, ReadOnlySpan&lt;T&gt;? trimElements) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;!!T&gt; trimElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (span As Span(Of T), trimElements As ReadOnlySpan(Of T)) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; TrimStart(Span&lt;T&gt; span, ReadOnlySpan&lt;T&gt; trimElements);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (span, trimElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElements" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-832">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-832">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-833">Die Quellspanne, aus der die Elemente entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="262ba-833">The source span from which the elements are removed.</span></span></param>
        <param name="trimElements"><span data-ttu-id="262ba-834">Die Spanne, die den Satz der zu entfernenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="262ba-834">The span which contains the set of elements to remove.</span></span></param>
        <summary><span data-ttu-id="262ba-835">Entfernt alle führenden Vorkommen einer Reihe von Elementen, die in einer schreibgeschützten Spanne angegeben sind, aus der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-835">Removes all leading occurrences of a set of elements specified in a read-only span from the span.</span></span></summary>
        <returns><span data-ttu-id="262ba-836">Der zugeschnittene Bereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-836">The trimmed span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="262ba-837">Wenn `trimElements` leer ist, wird die Spanne unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="262ba-837">If `trimElements` is empty, the span is returned unaltered.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? TrimStart&lt;T&gt; (this Span&lt;T&gt;? span, T trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!!T&gt; TrimStart&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.Span`1&lt;!!T&gt; span, !!T trimElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MemoryExtensions.TrimStart``1(System.Span{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TrimStart(Of T As IEquatable(Of T)) (span As Span(Of T), trimElement As T) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static Span&lt;T&gt; TrimStart(Span&lt;T&gt; span, T trimElement);" />
      <MemberSignature Language="F#" Value="static member TrimStart : Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; * 'T -&gt; Span&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.MemoryExtensions.TrimStart (span, trimElement)" />
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt;? TrimStart&lt;T&gt; (this Span&lt;T&gt;? span, T? trimElement) where T : IEquatable&lt;T&gt;;" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" RefType="this" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="trimElement" Type="T" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="262ba-838">Der Typ der Elemente in der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-838">The type of the elements in the span.</span></span></typeparam>
        <param name="span"><span data-ttu-id="262ba-839">Die Quellspanne, aus der das Element entfernt wird.</span><span class="sxs-lookup"><span data-stu-id="262ba-839">The source span from which the element is removed.</span></span></param>
        <param name="trimElement"><span data-ttu-id="262ba-840">Das angegebene Element, das gesucht und entfernt werden soll.</span><span class="sxs-lookup"><span data-stu-id="262ba-840">The specified element to look for and remove.</span></span></param>
        <summary><span data-ttu-id="262ba-841">Entfernt alle führenden Vorkommen eines bestimmten Elements aus der Spanne.</span><span class="sxs-lookup"><span data-stu-id="262ba-841">Removes all leading occurrences of a specified element from the span.</span></span></summary>
        <returns><span data-ttu-id="262ba-842">Der zugeschnittene Bereich.</span><span class="sxs-lookup"><span data-stu-id="262ba-842">The trimmed span.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
