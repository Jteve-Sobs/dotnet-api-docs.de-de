<Type Name="Object" FullName="System.Object">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="544711ea8218218b56f4211efd46b56984ab2498" />
    <Meta Name="ms.sourcegitcommit" Value="22c9818dc4a11ae279d13a36bc98a3c6852e9316" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/20/2018" />
    <Meta Name="ms.locfileid" Value="39169404" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="931e4-101">Unterstützt sämtliche Klassen in der Hierarchie von .NET Framework-Klassen und stellt abgeleiteten Klassen Low-Level-Dienste zur Verfügung.</span>
      <span class="sxs-lookup">
        <span data-stu-id="931e4-101">Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes.</span>
      </span>
      <span data-ttu-id="931e4-102">Dies ist die allen Klassen von .NET Framework übergeordnete Basisklasse und stellt den Stamm der Typhierarchie dar.</span>
      <span class="sxs-lookup">
        <span data-stu-id="931e4-102">This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="931e4-103">Sprachen erfordern in der Regel keine Klasse zur Deklaration der Vererbung von <xref:System.Object> , da die Vererbung implizit ist.</span><span class="sxs-lookup"><span data-stu-id="931e4-103">Languages typically do not require a class to declare inheritance from <xref:System.Object> because the inheritance is implicit.</span></span>  
  
 <span data-ttu-id="931e4-104">Da alle Klassen in .NET Framework abgeleitet sind <xref:System.Object>, jede Methode, die definiert, der <xref:System.Object> Klasse steht in alle Objekte im System.</span><span class="sxs-lookup"><span data-stu-id="931e4-104">Because all classes in the .NET Framework are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system.</span></span> <span data-ttu-id="931e4-105">Abgeleitete Klassen, und führen Sie einige dieser Methoden, einschließlich überschreiben:</span><span class="sxs-lookup"><span data-stu-id="931e4-105">Derived classes can and do override some of these methods, including:</span></span>  
  
-   <span data-ttu-id="931e4-106"><xref:System.Object.Equals%2A> -Unterstützt Vergleiche zwischen Objekten.</span><span class="sxs-lookup"><span data-stu-id="931e4-106"><xref:System.Object.Equals%2A> - Supports comparisons between objects.</span></span>  
  
-   <span data-ttu-id="931e4-107"><xref:System.Object.Finalize%2A> -Führt Bereinigungsvorgänge durch, bevor ein Objekt automatisch freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="931e4-107"><xref:System.Object.Finalize%2A> - Performs cleanup operations before an object is automatically reclaimed.</span></span>  
  
-   <span data-ttu-id="931e4-108"><xref:System.Object.GetHashCode%2A> -Generiert eine Zahl, die entsprechend dem Wert des Objekts, um die Verwendung einer Hashtabelle zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="931e4-108"><xref:System.Object.GetHashCode%2A> - Generates a number corresponding to the value of the object to support the use of a hash table.</span></span>  
  
-   <span data-ttu-id="931e4-109"><xref:System.Object.ToString%2A> -Stellt eine lesbare Zeichenfolge, die eine Instanz der Klasse beschreibt.</span><span class="sxs-lookup"><span data-stu-id="931e4-109"><xref:System.Object.ToString%2A> - Manufactures a human-readable text string that describes an instance of the class.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="931e4-110">Überlegungen zur Leistung</span><span class="sxs-lookup"><span data-stu-id="931e4-110">Performance Considerations</span></span>  
 <span data-ttu-id="931e4-111">Wenn Sie eine Klasse, z. B. eine Auflistung, entwerfen, die alle Arten von Objekten behandelt werden müssen, erstellen Sie-Klasse, Elemente, die Instanzen akzeptieren die <xref:System.Object> Klasse.</span><span class="sxs-lookup"><span data-stu-id="931e4-111">If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class.</span></span> <span data-ttu-id="931e4-112">Der Prozess von Boxing und unboxing eines Typs trägt jedoch Kosten der Leistung.</span><span class="sxs-lookup"><span data-stu-id="931e4-112">However, the process of boxing and unboxing a type carries a performance cost.</span></span> <span data-ttu-id="931e4-113">Wenn Sie wissen, dass die neue Klasse häufig bestimmte Werttypen behandelt können eine der beiden Taktiken Sie die Kosten von Boxing zu minimieren.</span><span class="sxs-lookup"><span data-stu-id="931e4-113">If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</span></span>  
  
-   <span data-ttu-id="931e4-114">Erstellen Sie eine allgemeine Methode, die akzeptiert eine <xref:System.Object> Typ und einen Satz von typspezifische methodenüberladungen, die jeden Typ Sie erwarten, die Klasse akzeptieren dass, um häufig behandeln.</span><span class="sxs-lookup"><span data-stu-id="931e4-114">Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</span></span> <span data-ttu-id="931e4-115">Wenn eine typspezifische-Methode vorhanden, der den Parametertyp des aufrufenden akzeptiert ist, keine Boxing-Konvertierung tritt ein, und die typspezifischen Methode wird aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="931e4-115">If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</span></span> <span data-ttu-id="931e4-116">Ist keine Methodenargument, das dem aufrufenden Parametertyp übereinstimmt, wird der Parameter geschachtelt und die allgemeine Methode wird aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="931e4-116">If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</span></span>  
  
-   <span data-ttu-id="931e4-117">Entwerfen Sie den Typ und ihre Member zum Verwenden von Generika.</span><span class="sxs-lookup"><span data-stu-id="931e4-117">Design your type and its members to use generics.</span></span> <span data-ttu-id="931e4-118">Die common Language Runtime erstellt einen geschlossenen generischen Typ, wenn Sie eine Instanz der Klasse erstellen, und geben Sie ein generisches Typargument.</span><span class="sxs-lookup"><span data-stu-id="931e4-118">The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</span></span> <span data-ttu-id="931e4-119">Die generische Methode ist typenspezifisch und ohne boxing von des aufrufenden Parameters aufgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="931e4-119">The generic method is type-specific and can be invoked without boxing the calling parameter.</span></span>  
  
 <span data-ttu-id="931e4-120">Obwohl es manchmal erforderlich, um allgemeine Klassen entwickeln, die akzeptiert und zurückgegeben ist <xref:System.Object> Typen können Sie die Leistung verbessern, durch die Bereitstellung einer typspezifische-Klasse, um eine häufig verwendete Typ verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="931e4-120">Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</span></span> <span data-ttu-id="931e4-121">Z. B. bereitstellen eine Klasse, die spezifisch für festlegen und Abrufen von booleschen Werten ist, werden die Kosten von Boxing und unboxing booleschen Werten entfällt.</span><span class="sxs-lookup"><span data-stu-id="931e4-121">For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="931e4-122">Das folgende Beispiel definiert einen Point-Typ abgeleitet der <xref:System.Object> -Klasse und überschreibt Sie viele virtuelle Methoden von der <xref:System.Object> Klasse.</span><span class="sxs-lookup"><span data-stu-id="931e4-122">The following example defines a Point type derived from the <xref:System.Object> class and overrides many of the virtual methods of the <xref:System.Object> class.</span></span> <span data-ttu-id="931e4-123">Darüber hinaus gezeigt, wie viele der statischen aufrufen und Instanzenmethoden von der <xref:System.Object> Klasse.</span><span class="sxs-lookup"><span data-stu-id="931e4-123">In addition, the example shows how to call many of the static and instance methods of the <xref:System.Object> class.</span></span>  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="931e4-124">Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind threadsicher.</span>
      <span class="sxs-lookup">
        <span data-stu-id="931e4-124">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span>
      </span>
      <span data-ttu-id="931e4-125">Instanzmember sind nicht unbedingt threadsicher sein.</span>
      <span class="sxs-lookup">
        <span data-stu-id="931e4-125">Instance members are not guaranteed to be thread-safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="931e4-126">Initialisiert eine neue Instanz der <see cref="T:System.Object" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-126">Initializes a new instance of the <see cref="T:System.Object" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="931e4-127">Dieser Konstruktor wird von Konstruktoren in abgeleiteten Klassen aufgerufen, aber es kann auch verwendet, direkt zu eine Instanz von erstellen die <xref:System.Object> Klasse.</span><span class="sxs-lookup"><span data-stu-id="931e4-127">This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref:System.Object> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="931e4-128">Stellt fest, ob zwei Objektinstanzen gleich sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-128">Determines whether two object instances are equal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="931e4-129">Das Objekt, das mit dem aktuellen Objekt verglichen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-129">The object to compare with the current object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="931e4-130">Bestimmt, ob das angegebene Objekt mit dem aktuellen Objekt identisch ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-130">Determines whether the specified object is equal to the current object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="931e4-131">
            <see langword="true" />, wenn das angegebene Objekt und das aktuelle Objekt gleich sind, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-131">
              <see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="931e4-132">Der Typ des Vergleichs zwischen der aktuellen Instanz und die `obj` Parameter, hängt davon ab, ob die aktuelle Instanz ein Verweistyp oder ein Werttyp ist.</span><span class="sxs-lookup"><span data-stu-id="931e4-132">The type of comparison between the current instance and the `obj` parameter depends on whether the current instance is a reference type or a value type.</span></span>  
  
-   <span data-ttu-id="931e4-133">Wenn die aktuelle Instanz einen Verweistyp handelt, ist die <xref:System.Object.Equals%28System.Object%29> Methode Tests hinsichtlich ihrer Verweisgleichheit und einem Aufruf von der <xref:System.Object.Equals%28System.Object%29> Methode ist gleichwertig mit einem Aufruf von der <xref:System.Object.ReferenceEquals%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-133">If the current instance is a reference type, the <xref:System.Object.Equals%28System.Object%29> method tests for reference equality, and a call to the <xref:System.Object.Equals%28System.Object%29> method is equivalent to a call to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="931e4-134">Verweisgleichheit ist gegeben, dass der Objektvariablen, die verglichen werden auf das gleiche Objekt verweisen.</span><span class="sxs-lookup"><span data-stu-id="931e4-134">Reference equality means that the object variables that are compared refer to the same object.</span></span> <span data-ttu-id="931e4-135">Das folgende Beispiel veranschaulicht das Ergebnis von einem solchen Vergleich.</span><span class="sxs-lookup"><span data-stu-id="931e4-135">The following example illustrates the result of such a comparison.</span></span> <span data-ttu-id="931e4-136">Definiert eine `Person` -Klasse, die ein Verweistyp ist, und ruft die `Person` Klassenkonstruktor, um zwei neue instanziieren `Person` Objekte `person1a` und `person2`, die den gleichen Wert aufweisen.</span><span class="sxs-lookup"><span data-stu-id="931e4-136">It defines a `Person` class, which is a reference type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1a` and `person2`, which have the same value.</span></span> <span data-ttu-id="931e4-137">Er weist auch `person1a` auf einem anderen Objektvariablen `person1b`.</span><span class="sxs-lookup"><span data-stu-id="931e4-137">It also assigns `person1a` to another object variable, `person1b`.</span></span> <span data-ttu-id="931e4-138">Wie die Ausgabe des Beispiels zeigt `person1a` und `person1b` gleich sind, da sie das gleiche Objekt verweisen.</span><span class="sxs-lookup"><span data-stu-id="931e4-138">As the output from the example shows, `person1a` and `person1b` are equal because they reference the same object.</span></span> <span data-ttu-id="931e4-139">Allerdings `person1a` und `person2` ungleich sind, obwohl sie den gleichen Wert haben.</span><span class="sxs-lookup"><span data-stu-id="931e4-139">However, `person1a` and `person2` are not equal, although they have the same value.</span></span>  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   <span data-ttu-id="931e4-140">Wenn die aktuelle Instanz eines Werttyps, ist die <xref:System.Object.Equals%28System.Object%29> Methode Wertgleichheit.</span><span class="sxs-lookup"><span data-stu-id="931e4-140">If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality.</span></span> <span data-ttu-id="931e4-141">Wertgleichheit bedeutet Folgendes:</span><span class="sxs-lookup"><span data-stu-id="931e4-141">Value equality means the following:</span></span>  
  
    -   <span data-ttu-id="931e4-142">Die beiden Objekte sind vom gleichen Typ.</span><span class="sxs-lookup"><span data-stu-id="931e4-142">The two objects are of the same type.</span></span> <span data-ttu-id="931e4-143">Wie im folgenden Beispiel wird gezeigt, eine <xref:System.Byte> -Objekt, das den Wert 12 hat entspricht keinem <xref:System.Int32> -Objekt, das den Wert 12, aufweist, da die beiden Objekte unterschiedliche Run-Time-Typen aufweisen.</span><span class="sxs-lookup"><span data-stu-id="931e4-143">As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types.</span></span>  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   <span data-ttu-id="931e4-144">Die Werte der öffentlichen und privaten Felder der beiden Objekte sind gleich.</span><span class="sxs-lookup"><span data-stu-id="931e4-144">The values of the public and private fields of the two objects are equal.</span></span> <span data-ttu-id="931e4-145">Das folgende Beispiel testet Wertgleichheit.</span><span class="sxs-lookup"><span data-stu-id="931e4-145">The following example tests for value equality.</span></span> <span data-ttu-id="931e4-146">Definiert eine `Person` -Struktur, die ein Werttyp ist, und ruft die `Person` Klassenkonstruktor, um zwei neue instanziieren `Person` Objekte `person1` und `person2`, die den gleichen Wert aufweisen.</span><span class="sxs-lookup"><span data-stu-id="931e4-146">It defines a `Person` structure, which is a value type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1` and `person2`, which have the same value.</span></span> <span data-ttu-id="931e4-147">Die Ausgabe aus dem Beispiel zeigt auch die zwei Objektvariablen auf verschiedene Objekte verweisen, `person1` und `person2` sind gleich, da sie den gleichen Wert für die Private aufweisen `personName` Feld.</span><span class="sxs-lookup"><span data-stu-id="931e4-147">As the output from the example shows, although the two object variables refer to different objects, `person1` and `person2` are equal because they have the same value for the private `personName` field.</span></span>  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 <span data-ttu-id="931e4-148">Da die <xref:System.Object> Klasse ist die Basisklasse für alle Typen in .NET Framework, die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Methode bietet die Standard-gleichheitsprüfung für alle anderen Datentypen.</span><span class="sxs-lookup"><span data-stu-id="931e4-148">Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method provides the default equality comparison for all other types.</span></span> <span data-ttu-id="931e4-149">Typen jedoch häufig überschreiben die <xref:System.Object.Equals%2A> Methode zum Implementieren der Wertgleichheit.</span><span class="sxs-lookup"><span data-stu-id="931e4-149">However, types often override the <xref:System.Object.Equals%2A> method to implement value equality.</span></span> <span data-ttu-id="931e4-150">Weitere Informationen finden Sie unter die Anmerkungen zu dieser Version für Aufrufer und Hinweise für Vererber Abschnitte.</span><span class="sxs-lookup"><span data-stu-id="931e4-150">For more information, see the Notes for Callers and Notes for Inheritors sections.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="931e4-151">Anmerkungen zu dieser von der [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="931e4-151">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="931e4-152">Beim Aufrufen der <xref:System.Object.Equals%28System.Object%29> methodenüberladung für eine Klasse in der [!INCLUDE[wrt](~/includes/wrt-md.md)], es ist das Standardverhalten für Klassen, die nicht außer Kraft setzen <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="931e4-152">When you call the <xref:System.Object.Equals%28System.Object%29> method overload on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="931e4-153">Dies ist Teil der Unterstützung von .NET Framework für die [!INCLUDE[wrt](~/includes/wrt-md.md)] (finden Sie unter [.NET Framework Unterstützung für Windows Store-Apps und Windows-Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="931e4-153">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="931e4-154">Klassen in der [!INCLUDE[wrt](~/includes/wrt-md.md)] nicht erben <xref:System.Object>, und derzeit nicht implementiert eine <xref:System.Object.Equals%28System.Object%29> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-154">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and currently don’t implement an <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="931e4-155">Allerdings haben sie anscheinend <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, und <xref:System.Object.GetHashCode%2A> Methoden ein, wenn Sie diese in Ihrem C#- oder Visual Basic-Code verwenden und .NET Framework das Standardverhalten für diese Methoden ist.</span><span class="sxs-lookup"><span data-stu-id="931e4-155">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]<span data-ttu-id="931e4-156"> Klassen, die in c# oder Visual Basic geschrieben sind, können außer Kraft setzen der <xref:System.Object.Equals%28System.Object%29> -methodenüberladung.</span><span class="sxs-lookup"><span data-stu-id="931e4-156"> classes that are written in C# or Visual Basic can override the <xref:System.Object.Equals%28System.Object%29> method overload.</span></span>  
  
## <a name="notes-for-callers"></a><span data-ttu-id="931e4-157">Hinweise für Aufrufer</span><span class="sxs-lookup"><span data-stu-id="931e4-157">Notes for Callers</span></span>  
 <span data-ttu-id="931e4-158">Abgeleitete Klassen überschreiben, die häufig den <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Methode zum Implementieren der Wertgleichheit.</span><span class="sxs-lookup"><span data-stu-id="931e4-158">Derived classes frequently override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to implement value equality.</span></span> <span data-ttu-id="931e4-159">Darüber hinaus bieten Typen häufig auch eine zusätzliche stark typisierte Überladung für die `Equals` Methode, in der Regel durch die Implementierung der <xref:System.IEquatable%601> Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="931e4-159">In addition, types also frequently provide an additional strongly typed overload to the `Equals` method, typically by implementing the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="931e4-160">Beim Aufrufen der `Equals` Methode zum Testen auf Gleichheit, sollten Sie wissen, ob die aktuelle Instanz überschreibt <xref:System.Object.Equals%2A?displayProperty=nameWithType> und zu verstehen, wie ein bestimmter Aufruf einer `Equals` Methode wird aufgelöst.</span><span class="sxs-lookup"><span data-stu-id="931e4-160">When you call the `Equals` method to test for equality, you should know whether the current instance overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType> and understand how a particular call to an `Equals` method is resolved.</span></span> <span data-ttu-id="931e4-161">Andernfalls, Sie werden einen Test durchführen, Gleichheit, die von Ihnen gewünschte unterscheidet, und die Methode gibt möglicherweise einen unerwarteten Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="931e4-161">Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</span></span>  
  
 <span data-ttu-id="931e4-162">Dies wird im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="931e4-162">The following example provides an illustration.</span></span> <span data-ttu-id="931e4-163">Es instanziiert drei <xref:System.Text.StringBuilder> Objekte mit identischer Zeichenfolgen und anschließend vier Aufrufe zu `Equals` Methoden.</span><span class="sxs-lookup"><span data-stu-id="931e4-163">It instantiates three <xref:System.Text.StringBuilder> objects with identical strings, and then makes four calls to `Equals` methods.</span></span> <span data-ttu-id="931e4-164">Der erste Methodenaufruf gibt `true`, und die verbleibenden drei Rückgabe `false`.</span><span class="sxs-lookup"><span data-stu-id="931e4-164">The first method call returns `true`, and the remaining three return `false`.</span></span>  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 <span data-ttu-id="931e4-165">Im ersten Fall, den stark typisierten <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> methodenüberladung der Wertgleichheit getestet wird, wird aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="931e4-165">In the first case, the strongly typed <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> method overload, which tests for value equality, is called.</span></span> <span data-ttu-id="931e4-166">Da die beiden Zeichenfolgen zugewiesen <xref:System.Text.StringBuilder> Objekte gleich sind, gibt die Methode zurück `true`.</span><span class="sxs-lookup"><span data-stu-id="931e4-166">Because the strings assigned to the two <xref:System.Text.StringBuilder> objects are equal, the method returns `true`.</span></span> <span data-ttu-id="931e4-167">Allerdings <xref:System.Text.StringBuilder> überschreibt nicht die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="931e4-167">However, <xref:System.Text.StringBuilder> does not override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="931e4-168">Aus diesem Grund bei der <xref:System.Text.StringBuilder> Objekt umgewandelt wird ein <xref:System.Object>, wenn eine <xref:System.Text.StringBuilder> Instanz einer Variablen des Typs zugewiesen <xref:System.Object>, und wann die <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> -Methode übergeben zwei <xref:System.Text.StringBuilder> Objekte, die Standardeinstellung <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>Methode wird aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="931e4-168">Because of this, when the <xref:System.Text.StringBuilder> object is cast to an <xref:System.Object>, when a <xref:System.Text.StringBuilder> instance is assigned to a variable of type <xref:System.Object>, and when the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> method is passed two <xref:System.Text.StringBuilder> objects, the default <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="931e4-169">Da <xref:System.Text.StringBuilder> ein Verweistyp ist, dies entspricht dem Übergeben der beiden <xref:System.Text.StringBuilder> Objekte die <xref:System.Object.ReferenceEquals%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-169">Because <xref:System.Text.StringBuilder> is a reference type, this is equivalent to passing the two <xref:System.Text.StringBuilder> objects to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="931e4-170">Obwohl alle drei <xref:System.Text.StringBuilder> Objekte enthalten identische Zeichenfolgen, die sie auf drei unterschiedliche Objekte verweisen.</span><span class="sxs-lookup"><span data-stu-id="931e4-170">Although all three <xref:System.Text.StringBuilder> objects contain identical strings, they refer to three distinct objects.</span></span> <span data-ttu-id="931e4-171">Daher diese drei Methodenaufrufe return `false`.</span><span class="sxs-lookup"><span data-stu-id="931e4-171">As a result, these three method calls return `false`.</span></span>  
  
 <span data-ttu-id="931e4-172">Sie können das aktuelle Objekt in ein anderes Objekt hinsichtlich ihrer Verweisgleichheit vergleichen, durch den Aufruf der <xref:System.Object.ReferenceEquals%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-172">You can compare the current object to another object for reference equality by calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="931e4-173">In Visual Basic können Sie auch die `is` Schlüsselwort (z. B. `If Me Is otherObject Then ...`).</span><span class="sxs-lookup"><span data-stu-id="931e4-173">In Visual Basic, you can also use the `is` keyword (for example, `If Me Is otherObject Then ...`).</span></span>  
  
## <a name="notes-for-inheritors"></a><span data-ttu-id="931e4-174">Hinweise für Vererber</span><span class="sxs-lookup"><span data-stu-id="931e4-174">Notes for Inheritors</span></span>  
 <span data-ttu-id="931e4-175">Wenn Sie einen eigenen Typ definieren, erbt dieses Typs Funktionen, die definiert die `Equals` Methode des Basistyps.</span><span class="sxs-lookup"><span data-stu-id="931e4-175">When you define your own type, that type inherits the functionality defined by the `Equals` method of its base type.</span></span> <span data-ttu-id="931e4-176">Die folgende Tabelle enthält die standardmäßige Implementierung der `Equals` -Methode für die Hauptkategorien der Typen in .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="931e4-176">The following table lists the default implementation of the `Equals` method for the major categories of types in the .NET Framework.</span></span>  
  
|<span data-ttu-id="931e4-177">Typkategorie</span><span class="sxs-lookup"><span data-stu-id="931e4-177">Type category</span></span>|<span data-ttu-id="931e4-178">Vom definierten Gleichheit</span><span class="sxs-lookup"><span data-stu-id="931e4-178">Equality defined by</span></span>|<span data-ttu-id="931e4-179">Kommentare</span><span class="sxs-lookup"><span data-stu-id="931e4-179">Comments</span></span>|  
|-------------------|-------------------------|--------------|  
|<span data-ttu-id="931e4-180">Direkt von abgeleiteten Klasse <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="931e4-180">Class derived directly from <xref:System.Object></span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="931e4-181">Verweisgleichheit; entspricht dem Aufruf von <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="931e4-181">Reference equality; equivalent to calling <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span></span>|  
|<span data-ttu-id="931e4-182">Struktur</span><span class="sxs-lookup"><span data-stu-id="931e4-182">Structure</span></span>|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="931e4-183">Wertgleichheit; direkte Byte-pro-Byte-Vergleich oder Feld-nach-Feld-Vergleich mithilfe von Reflektion.</span><span class="sxs-lookup"><span data-stu-id="931e4-183">Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</span></span>|  
|<span data-ttu-id="931e4-184">Enumeration</span><span class="sxs-lookup"><span data-stu-id="931e4-184">Enumeration</span></span>|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="931e4-185">Werte müssen den gleichen Enumerationstyp und den gleichen zugrunde liegenden Wert.</span><span class="sxs-lookup"><span data-stu-id="931e4-185">Values must have the same enumeration type and the same underlying value.</span></span>|  
|<span data-ttu-id="931e4-186">delegate</span><span class="sxs-lookup"><span data-stu-id="931e4-186">Delegate</span></span>|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="931e4-187">Delegaten müssen den gleichen Typ mit identischen Aufruflisten.</span><span class="sxs-lookup"><span data-stu-id="931e4-187">Delegates must have the same type with identical invocation lists.</span></span>|  
|<span data-ttu-id="931e4-188">Interface</span><span class="sxs-lookup"><span data-stu-id="931e4-188">Interface</span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="931e4-189">Verweisgleichheit.</span><span class="sxs-lookup"><span data-stu-id="931e4-189">Reference equality.</span></span>|  
  
 <span data-ttu-id="931e4-190">Für einen Werttyp handelt, sollten Sie immer überschreiben <xref:System.Object.Equals%2A>, da prüft auf Gleichheit, die auf Reflektion beruhen auf eine schlechte Leistung bieten.</span><span class="sxs-lookup"><span data-stu-id="931e4-190">For a value type, you should always override <xref:System.Object.Equals%2A>, because tests for equality that rely on reflection offer poor performance.</span></span> <span data-ttu-id="931e4-191">Sie können auch die standardmäßige Implementierung des überschreiben <xref:System.Object.Equals%2A> für Verweistypen statt auf Verweisgleichheit Wertgleichheit prüfen und die genaue Bedeutung der Wertgleichheit definieren.</span><span class="sxs-lookup"><span data-stu-id="931e4-191">You can also override the default implementation of <xref:System.Object.Equals%2A> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</span></span> <span data-ttu-id="931e4-192">Solche Implementierungen von <xref:System.Object.Equals%2A> zurückgeben `true` , wenn die beiden Objekte den gleichen Wert verfügen, auch wenn sie sich nicht um dieselbe Instanz sind.</span><span class="sxs-lookup"><span data-stu-id="931e4-192">Such implementations of <xref:System.Object.Equals%2A> return `true` if the two objects have the same value, even if they are not the same instance.</span></span> <span data-ttu-id="931e4-193">Der Implementierung des Typs entscheidet, was den Wert eines Objekts ist, aber es ist in der Regel einige oder alle der in Instanzvariablen gespeicherten Daten der des Objekts.</span><span class="sxs-lookup"><span data-stu-id="931e4-193">The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</span></span> <span data-ttu-id="931e4-194">Z. B. den Wert der ein <xref:System.String> Objekt basiert darauf, dass die Zeichen der Zeichenfolge die <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> methodenüberschreibungen der <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> -Methode zur Rückgabe `true` für eine beliebige Zeichenfolge zwei Instanzen, die dieselben Zeichen in der gleichen Reihenfolge enthalten.</span><span class="sxs-lookup"><span data-stu-id="931e4-194">For example, the value of a <xref:System.String> object is based on the characters of the string; the <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> method overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to return `true` for any two string instances that contain the same characters in the same order.</span></span>  
  
 <span data-ttu-id="931e4-195">Das folgende Beispiel veranschaulicht das Überschreiben der <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Methode auf Wertgleichheit prüfen.</span><span class="sxs-lookup"><span data-stu-id="931e4-195">The following example shows how to override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to test for value equality.</span></span> <span data-ttu-id="931e4-196">Es überschreibt die <xref:System.Object.Equals%2A> -Methode für die `Person` Klasse.</span><span class="sxs-lookup"><span data-stu-id="931e4-196">It overrides the <xref:System.Object.Equals%2A> method for the `Person` class.</span></span> <span data-ttu-id="931e4-197">Wenn `Person` akzeptiert die basisklassenimplementierung von Gleichheit, zwei `Person` Objekte wäre nur gleich, wenn sie ein einzelnes Objekt, auf die verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="931e4-197">If `Person` accepted its base class implementation of equality, two `Person` objects would be equal only if they referenced a single object.</span></span> <span data-ttu-id="931e4-198">In diesem Fall jedoch zwei `Person` Objekte sind gleich, wenn sie den gleichen Wert für die `Person.Id` Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="931e4-198">However, in this case, two `Person` objects are equal if they have the same value for the `Person.Id` property.</span></span>  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 <span data-ttu-id="931e4-199">Neben dem Außerkraftsetzen von <xref:System.Object.Equals%2A>, können Sie implementieren die <xref:System.IEquatable%601> Schnittstelle, um eine stark typisierte Test auf Gleichheit bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="931e4-199">In addition to overriding <xref:System.Object.Equals%2A>, you can implement the <xref:System.IEquatable%601> interface to provide a strongly typed test for equality.</span></span>  
  
 <span data-ttu-id="931e4-200">Die folgenden Anweisungen müssen für alle Implementierungen von "true" werden die <xref:System.Object.Equals%28System.Object%29> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-200">The following statements must be true for all implementations of the <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="931e4-201">In der Liste der `x`, `y`, und `z` darstellen von Objektverweisen, die nicht **null**.</span><span class="sxs-lookup"><span data-stu-id="931e4-201">In the list, `x`, `y`, and `z` represent object references that are not **null**.</span></span>  
  
-   <span data-ttu-id="931e4-202">`x.Equals(x)` Gibt `true`, außer in Fällen, bei denen Gleitkomma-Datentypen.</span><span class="sxs-lookup"><span data-stu-id="931e4-202">`x.Equals(x)` returns `true`, except in cases that involve floating-point types.</span></span> <span data-ttu-id="931e4-203">ISO/IEC/IEEE 60559:2011, Information Technology--Mikroprozessor Systeme Gleitkommaoperatoren wird angezeigt.</span><span class="sxs-lookup"><span data-stu-id="931e4-203">See ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic.</span></span>  
  
-   <span data-ttu-id="931e4-204">`x.Equals(y)` Gibt den gleichen Wert wie `y.Equals(x)`.</span><span class="sxs-lookup"><span data-stu-id="931e4-204">`x.Equals(y)` returns the same value as `y.Equals(x)`.</span></span>  
  
-   <span data-ttu-id="931e4-205">`x.Equals(y)` Gibt `true` sowohl `x` und `y` sind `NaN`.</span><span class="sxs-lookup"><span data-stu-id="931e4-205">`x.Equals(y)` returns `true` if both `x` and `y` are `NaN`.</span></span>  
  
-   <span data-ttu-id="931e4-206">Wenn `(x.Equals(y) && y.Equals(z))` gibt `true`, klicken Sie dann `x.Equals(z)` gibt `true`.</span><span class="sxs-lookup"><span data-stu-id="931e4-206">If `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`.</span></span>  
  
-   <span data-ttu-id="931e4-207">Aufeinander folgende Aufrufe von `x.Equals(y)` zurück, der gleiche Wert, solange die Objekte verweist `x` und `y` werden nicht geändert.</span><span class="sxs-lookup"><span data-stu-id="931e4-207">Successive calls to `x.Equals(y)` return the same value as long as the objects referenced by `x` and `y` are not modified.</span></span>  
  
-   <span data-ttu-id="931e4-208">`x.Equals(null)` gibt `false` zurück.</span><span class="sxs-lookup"><span data-stu-id="931e4-208">`x.Equals(null)` returns `false`.</span></span>  
  
 <span data-ttu-id="931e4-209">Implementierungen von <xref:System.Object.Equals%2A> darf keine Ausnahmen auslösen, sollten sie immer einen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="931e4-209">Implementations of <xref:System.Object.Equals%2A> must not throw exceptions; they should always return a value.</span></span> <span data-ttu-id="931e4-210">Z. B. wenn `obj` ist `null`, <xref:System.Object.Equals%2A> Methode zurückgeben soll `false` statt einer <xref:System.ArgumentNullException>.</span><span class="sxs-lookup"><span data-stu-id="931e4-210">For example, if `obj` is `null`, the <xref:System.Object.Equals%2A> method should return `false` instead of throwing an <xref:System.ArgumentNullException>.</span></span>  
  
 <span data-ttu-id="931e4-211">Beachten Sie Folgendes, wenn überschreiben <xref:System.Object.Equals%28System.Object%29>:</span><span class="sxs-lookup"><span data-stu-id="931e4-211">Follow these guidelines when overriding <xref:System.Object.Equals%28System.Object%29>:</span></span>  
  
-   <span data-ttu-id="931e4-212">Typen implementiert <xref:System.IComparable> müssen überschreiben <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="931e4-212">Types that implement <xref:System.IComparable> must override <xref:System.Object.Equals%28System.Object%29>.</span></span>  
  
-   <span data-ttu-id="931e4-213">Die Überschreibung Typen <xref:System.Object.Equals%28System.Object%29> müssen auch überschreiben <xref:System.Object.GetHashCode%2A>ist, andernfalls Hashtabellen funktionieren möglicherweise nicht korrekt.</span><span class="sxs-lookup"><span data-stu-id="931e4-213">Types that override <xref:System.Object.Equals%28System.Object%29> must also override <xref:System.Object.GetHashCode%2A>; otherwise, hash tables  might not work correctly.</span></span>  
  
-   <span data-ttu-id="931e4-214">Sie sollten erwägen, implementieren die <xref:System.IEquatable%601> -Schnittstelle zur Unterstützung stark typisierte prüft auf Gleichheit.</span><span class="sxs-lookup"><span data-stu-id="931e4-214">You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality.</span></span> <span data-ttu-id="931e4-215">Ihre <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> Implementierung sollten Ergebnisse zurück, die konsistent mit sind <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="931e4-215">Your <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementation should return results that are consistent with <xref:System.Object.Equals%2A>.</span></span>  
  
-   <span data-ttu-id="931e4-216">Wenn Ihre bevorzugte Programmiersprache unterstützt die Überladung von Operatoren und Überladen Sie den Gleichheitsoperator für einen bestimmten Typ, müssen Sie auch überschreiben die <xref:System.Object.Equals%28System.Object%29> Methode, um das gleiche Ergebnis wie der Gleichheitsoperator zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="931e4-216">If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator.</span></span> <span data-ttu-id="931e4-217">Dies trägt dazu bei, Klassenbibliothekscode, die verwendet <xref:System.Object.Equals%2A> (z. B. <xref:System.Collections.ArrayList> und <xref:System.Collections.Hashtable>) verhält sich in einer Weise, mit der Funktionsweise entspricht der Equality-Operator wird vom Anwendungscode verwendet.</span><span class="sxs-lookup"><span data-stu-id="931e4-217">This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code.</span></span>  
  
### <a name="guidelines-for-reference-types"></a><span data-ttu-id="931e4-218">Richtlinien für Referenztypen</span><span class="sxs-lookup"><span data-stu-id="931e4-218">Guidelines for Reference Types</span></span>  
 <span data-ttu-id="931e4-219">Die folgenden Richtlinien gelten für das Überschreiben <xref:System.Object.Equals%28System.Object%29> für einen Verweistyp handelt:</span><span class="sxs-lookup"><span data-stu-id="931e4-219">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a reference type:</span></span>  
  
-   <span data-ttu-id="931e4-220">Ziehen Sie das Überschreiben <xref:System.Object.Equals%2A> Wenn die Semantik des Typs basiert auf der Tatsache, dass der Typ einige Werte darstellt.</span><span class="sxs-lookup"><span data-stu-id="931e4-220">Consider overriding <xref:System.Object.Equals%2A> if the semantics of the type are based on the fact that the type represents some value(s).</span></span>  
  
-   <span data-ttu-id="931e4-221">Die meisten Referenztypen müssen nicht den Equality-Operator überladen, auch wenn sie außer Kraft setzen <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="931e4-221">Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="931e4-222">Wenn Sie einen Verweistyp implementieren, der über Wertsemantik, z. B. eine komplexe Zahl-Typ verfügen soll müssen Sie jedoch den Gleichheitsoperator überschreiben.</span><span class="sxs-lookup"><span data-stu-id="931e4-222">However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</span></span>  
  
-   <span data-ttu-id="931e4-223">Sie sollten nicht überschreiben <xref:System.Object.Equals%2A> auf einen änderbaren Referenztyp.</span><span class="sxs-lookup"><span data-stu-id="931e4-223">You should not override <xref:System.Object.Equals%2A> on a mutable reference type.</span></span> <span data-ttu-id="931e4-224">Dies ist daran, dass überschrieben <xref:System.Object.Equals%2A> erfordert, dass Sie auch überschreiben, die <xref:System.Object.GetHashCode%2A> -Methode, wie im vorherigen Abschnitt erläutert.</span><span class="sxs-lookup"><span data-stu-id="931e4-224">This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section.</span></span> <span data-ttu-id="931e4-225">Dies bedeutet, dass der Hashcode einer Instanz von einen änderbaren Referenztyp während seiner Lebensdauer ändern kann, die das Objekt, das verloren gehen, die in einer Hashtabelle führen kann.</span><span class="sxs-lookup"><span data-stu-id="931e4-225">This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</span></span>  
  
### <a name="guidelines-for-value-types"></a><span data-ttu-id="931e4-226">Richtlinien für Werttypen</span><span class="sxs-lookup"><span data-stu-id="931e4-226">Guidelines for Value Types</span></span>  
 <span data-ttu-id="931e4-227">Die folgenden Richtlinien gelten für das Überschreiben <xref:System.Object.Equals%28System.Object%29> für einen Werttyp darstellt:</span><span class="sxs-lookup"><span data-stu-id="931e4-227">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a value type:</span></span>  
  
-   <span data-ttu-id="931e4-228">Wenn Sie einen Werttyp definieren, die eine oder mehrere Felder enthält, deren Werte Verweistypen sind, sollten Sie überschreiben <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="931e4-228">If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="931e4-229">Die <xref:System.Object.Equals%28System.Object%29> -Implementierung von <xref:System.ValueType> führt Sie einen Byte-pro-Byte-Vergleich aus, für, deren Werttypen Felder sind alle Werttypen, aber er verwendet Reflektion, einen Feld-nach-Feld-Vergleich von Werttypen durchgeführt, deren Felder Verweistypen sind.</span><span class="sxs-lookup"><span data-stu-id="931e4-229">The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</span></span>  
  
-   <span data-ttu-id="931e4-230">Wenn Sie außer Kraft setzen <xref:System.Object.Equals%2A> und Ihre bevorzugte Programmiersprache unterstützt überladen werden, müssen Sie den Equality-Operator überladen.</span><span class="sxs-lookup"><span data-stu-id="931e4-230">If you override <xref:System.Object.Equals%2A> and your development language supports operator overloading, you must overload the equality operator.</span></span>  
  
-   <span data-ttu-id="931e4-231">Implementieren Sie die <xref:System.IEquatable%601> Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="931e4-231">You should implement the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="931e4-232">Aufrufen von stark typisierten <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> Methode verhindert das Konvertieren der `obj` Argument.</span><span class="sxs-lookup"><span data-stu-id="931e4-232">Calling the strongly typed <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> method avoids boxing the `obj` argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="931e4-233">Das folgende Beispiel zeigt eine `Point` -Klasse, überschreibt die <xref:System.Object.Equals%2A> Methode zum Bereitstellen der Wertgleichheit, und ein `Point3D` abgeleitete ist `Point`.</span><span class="sxs-lookup"><span data-stu-id="931e4-233">The following example shows a `Point` class that overrides the <xref:System.Object.Equals%2A> method to provide value equality, and a `Point3D` class that is derived from `Point`.</span></span> <span data-ttu-id="931e4-234">Da `Point` überschreibt <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> zum Prüfen auf Wertgleichheit, die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Methode wird nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="931e4-234">Because `Point` overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to test for value equality, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is not called.</span></span> <span data-ttu-id="931e4-235">Allerdings `Point3D.Equals` Aufrufe `Point.Equals` da `Point` implementiert <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in einer Weise, die Wertgleichheit bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="931e4-235">However, `Point3D.Equals` calls `Point.Equals` because `Point` implements <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in a manner that provides value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 <span data-ttu-id="931e4-236">Die `Point.Equals` Methode überprüft, um sicherzustellen, dass die `obj` Argument ist kein **null** und eine Instanz des gleichen Typs wie dieses Objekt verweist.</span><span class="sxs-lookup"><span data-stu-id="931e4-236">The `Point.Equals` method checks to make sure that the `obj` argument is not **null** and that it references an instance of the same type as this object.</span></span> <span data-ttu-id="931e4-237">Wenn bei entweder ein Fehler auftritt, wird der Methodenrückgabe `false`.</span><span class="sxs-lookup"><span data-stu-id="931e4-237">If either check fails, the method returns `false`.</span></span>  
  
 <span data-ttu-id="931e4-238">Die `Point.Equals` Methodenaufrufe der <xref:System.Object.GetType%2A> Methode, um zu bestimmen, ob die Runtime-Typen der beiden Objekte identisch sind.</span><span class="sxs-lookup"><span data-stu-id="931e4-238">The `Point.Equals` method calls the <xref:System.Object.GetType%2A> method to determine whether the run-time types of the two objects are identical.</span></span> <span data-ttu-id="931e4-239">Wenn die Methode eine Überprüfung des Formulars verwendet `obj is Point` in c# oder `TryCast(obj, Point)` in Visual Basic die Überprüfung zurückgeben würde `true` in Fällen, in denen `obj` ist eine Instanz einer abgeleiteten Klasse der `Point`, auch wenn `obj` und der aktuelle Instanz sind nicht vom gleichen Typ zur Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="931e4-239">If the method used a check of the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic, the check would return `true` in cases where `obj` is an instance of a derived class of `Point`, even though `obj` and the current instance are not of the same run-time type.</span></span> <span data-ttu-id="931e4-240">Wenn Sie überprüft haben, dass beide Objekte desselben Typs, die Methode Umwandlungen sind `obj` eingeben `Point` und das Ergebnis des Vergleichs die Instanzfelder der beiden Objekte zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="931e4-240">Having verified that both objects are of the same type, the method casts `obj` to type `Point` and returns the result of comparing the instance fields of the two objects.</span></span>  
  
 <span data-ttu-id="931e4-241">In `Point3D.Equals`, die geerbte `Point.Equals` -Methode, die überschreibt <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, wird aufgerufen, bevor alles abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="931e4-241">In `Point3D.Equals`, the inherited `Point.Equals` method, which overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, is invoked before anything else is done.</span></span> <span data-ttu-id="931e4-242">Da `Point3D` ist eine versiegelte Klasse (`NotInheritable` in Visual Basic), eine Überprüfung in der Form `obj is Point` in c# oder `TryCast(obj, Point)` in Visual Basic ist ausreichend, um sicherzustellen, dass `obj` ist eine `Point3D` Objekt.</span><span class="sxs-lookup"><span data-stu-id="931e4-242">Because `Point3D` is a sealed class (`NotInheritable` in Visual Basic), a check in the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic is adequate to ensure that `obj` is a `Point3D` object.</span></span> <span data-ttu-id="931e4-243">Ist dies ein `Point3D` Objekt, der Umwandlung in einen `Point` -Objekt und übergeben Sie die basisklassenimplementierung von <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="931e4-243">If it is a `Point3D` object, it is cast to a `Point` object and passed to the base class implementation of <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="931e4-244">Nur, wenn die geerbte `Point.Equals` Methodenrückgabe `true` ist die Methode vergleichen die `z` Instanzfelder, die in der abgeleiteten Klasse eingeführt.</span><span class="sxs-lookup"><span data-stu-id="931e4-244">Only when the inherited `Point.Equals` method returns `true` does the method compare the `z` instance fields introduced in the derived class.</span></span>  
  
 <span data-ttu-id="931e4-245">Das folgende Beispiel definiert eine `Rectangle` Klasse, die ein Rechteck als zwei intern implementiert `Point` Objekte.</span><span class="sxs-lookup"><span data-stu-id="931e4-245">The following example defines a `Rectangle` class that internally implements a rectangle as two `Point` objects.</span></span> <span data-ttu-id="931e4-246">Die `Rectangle` -Klasse auch überschreibt <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Wertgleichheit bereit.</span><span class="sxs-lookup"><span data-stu-id="931e4-246">The `Rectangle` class also overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to provide for value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 <span data-ttu-id="931e4-247">Einige Sprachen wie c# und Visual Basic unterstützen das überladen.</span><span class="sxs-lookup"><span data-stu-id="931e4-247">Some languages such as C# and Visual Basic support operator overloading.</span></span> <span data-ttu-id="931e4-248">Wenn ein Typ, den Equality-Operator überlädt, muss er auch überschreiben die <xref:System.Object.Equals%28System.Object%29> Methode, um die gleiche Funktionalität bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="931e4-248">When a type overloads the equality operator, it must also override the <xref:System.Object.Equals%28System.Object%29> method to provide the same functionality.</span></span> <span data-ttu-id="931e4-249">Dies erfolgt in der Regel durch Schreiben der <xref:System.Object.Equals%28System.Object%29> Methode hinsichtlich des überladenen Gleichheitsoperators, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="931e4-249">This is typically accomplished by writing the <xref:System.Object.Equals%28System.Object%29> method in terms of the overloaded equality operator, as in the following example.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 <span data-ttu-id="931e4-250">Da `Complex` ein Werttyp ist, es kann nicht abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="931e4-250">Because `Complex` is a value type, it cannot be derived from.</span></span>  <span data-ttu-id="931e4-251">Aus diesem Grund die Außerkraftsetzung, mit <xref:System.Object.Equals%28System.Object%29> Methodenaufruf müssen nicht <xref:System.Object.GetType%2A> um zu bestimmen, die genaue Laufzeittyp der einzelnen Objekte, kann aber stattdessen verwenden die `is` -Operator in c# oder der `TypeOf` -Operator in Visual Basic zum Überprüfen des Typs, der die `obj` Parameter.</span><span class="sxs-lookup"><span data-stu-id="931e4-251">Therefore, the override to <xref:System.Object.Equals%28System.Object%29> method need not call <xref:System.Object.GetType%2A> to determine the precise run-time type of each object, but can instead use the `is` operator in C# or the `TypeOf` operator in Visual Basic to check the type of the `obj` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">
          <span data-ttu-id="931e4-252">Das erste zu vergleichende Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-252">The first object to compare.</span>
          </span>
        </param>
        <param name="objB">
          <span data-ttu-id="931e4-253">Das zweite zu vergleichende Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-253">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="931e4-254">Stellt fest, ob die angegebenen Objektinstanzen als gleich betrachtet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-254">Determines whether the specified object instances are considered equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="931e4-255">
            <see langword="true" />, wenn die Objekte als gleich betrachtet werden, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-255">
              <see langword="true" /> if the objects are considered equal; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="931e4-256">Wenn sowohl <paramref name="objA" />, als auch <paramref name="objB" /> **NULL** sind, gibt diese Methode <see langword="true" /> zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-256">If both <paramref name="objA" /> and <paramref name="objB" /> are **null**, the method returns <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="931e4-257">Die statische <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> angibt, ob zwei Objekte, `objA` und `objB`, gleich sind.</span><span class="sxs-lookup"><span data-stu-id="931e4-257">The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, `objA` and  `objB`, are equal.</span></span> <span data-ttu-id="931e4-258">Außerdem können Sie Objekte zu testen, deren Wert **null** hinsichtlich ihrer Gleichheit.</span><span class="sxs-lookup"><span data-stu-id="931e4-258">It also enables you to test objects whose value is **null** for equality.</span></span> <span data-ttu-id="931e4-259">Es vergleicht `objA` und `objB` Gleichheit wie folgt:</span><span class="sxs-lookup"><span data-stu-id="931e4-259">It compares `objA` and `objB` for equality as follows:</span></span>  
  
-   <span data-ttu-id="931e4-260">Es bestimmt, ob die beiden Objekte auf den gleichen Objektverweis darstellen.</span><span class="sxs-lookup"><span data-stu-id="931e4-260">It determines whether the two objects represent the same object reference.</span></span> <span data-ttu-id="931e4-261">Wenn dies der Fall ist, wird der Methodenrückgabe `true`.</span><span class="sxs-lookup"><span data-stu-id="931e4-261">If they do, the method returns `true`.</span></span> <span data-ttu-id="931e4-262">Dieser Test entspricht dem Aufrufen der <xref:System.Object.ReferenceEquals%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-262">This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="931e4-263">Darüber hinaus, wenn beide `objA` und `objB` sind **null**, gibt die Methode zurück `true`.</span><span class="sxs-lookup"><span data-stu-id="931e4-263">In addition, if both `objA` and `objB` are **null**, the method returns `true`.</span></span>  
  
-   <span data-ttu-id="931e4-264">Bestimmt, ob entweder `objA` oder `objB` ist **null**.</span><span class="sxs-lookup"><span data-stu-id="931e4-264">It determines whether either `objA` or `objB` is **null**.</span></span> <span data-ttu-id="931e4-265">Wenn also zurückgegeben `false`.</span><span class="sxs-lookup"><span data-stu-id="931e4-265">If so, it returns `false`.</span></span>  
  
-   <span data-ttu-id="931e4-266">Wenn die beiden Objekte nicht den gleichen Objektverweis darstellen und keine ist **null**, ruft `objA`.`Equals` (`objB`) und das Ergebnis zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="931e4-266">If the two objects do not represent the same object reference and neither is **null**, it calls `objA`.`Equals`(`objB`) and returns the result.</span></span> <span data-ttu-id="931e4-267">Dies bedeutet, dass bei `objA` überschreibt die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Methode, diese Außerkraftsetzung wird aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="931e4-267">This means that if `objA` overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, this override is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="931e4-268">Das folgende Beispiel veranschaulicht die <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> Methode, und vergleicht ihn mit der <xref:System.Object.ReferenceEquals%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-268">The following example illustrates the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method and compares it with the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="931e4-269">Gibt einem Objekt Gelegenheit zu dem Versuch, Ressourcen freizugeben und andere Bereinigungen durchzuführen, bevor es von der Garbage Collection freigegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-269">Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="931e4-270">Die <xref:System.Object.Finalize%2A> Methode wird verwendet, um Bereinigungsvorgänge für nicht verwaltete Ressourcen, die vom aktuellen Objekt gehalten werden, bevor das Objekt zerstört wird.</span><span class="sxs-lookup"><span data-stu-id="931e4-270">The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</span></span> <span data-ttu-id="931e4-271">Die Methode ist geschützt und daher nur über diese Klasse oder durch eine abgeleitete Klasse zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="931e4-271">The method is protected and therefore is accessible only through this class or through a derived class.</span></span>  
  
 <span data-ttu-id="931e4-272">In diesem Abschnitt</span><span class="sxs-lookup"><span data-stu-id="931e4-272">In this section:</span></span>  
  
-   [<span data-ttu-id="931e4-273">Funktionsweise der Finalisierung</span><span class="sxs-lookup"><span data-stu-id="931e4-273">How finalization works</span></span>](#How)  
  
-   [<span data-ttu-id="931e4-274">Hinweise für Implementierer</span><span class="sxs-lookup"><span data-stu-id="931e4-274">Notes for implementers</span></span>](#Notes)  
  
-   [<span data-ttu-id="931e4-275">Die SafeHandle-alternative</span><span class="sxs-lookup"><span data-stu-id="931e4-275">The SafeHandle alternative</span></span>](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a><span data-ttu-id="931e4-276">Funktionsweise der Finalisierung</span><span class="sxs-lookup"><span data-stu-id="931e4-276">How finalization works</span></span>  
 <span data-ttu-id="931e4-277">Die <xref:System.Object> Klasse stellt keine Implementierung für die <xref:System.Object.Finalize%2A> -Methode, und der Garbage Collector von abgeleitete Typen nicht markiert <xref:System.Object> auf einen Abschluss warten, wenn sie außer Kraft setzen der <xref:System.Object.Finalize%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-277">The <xref:System.Object> class provides no implementation for the <xref:System.Object.Finalize%2A> method, and the garbage collector does not mark types derived from <xref:System.Object> for finalization unless they override the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 <span data-ttu-id="931e4-278">Wenn ein Typ überschreibt die <xref:System.Object.Finalize%2A> -Methode der Garbage Collector Fügt einen Eintrag für jede Instanz des Typs internen Struktur einer Finalisierungswarteschlange.</span><span class="sxs-lookup"><span data-stu-id="931e4-278">If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</span></span> <span data-ttu-id="931e4-279">Die Finalisierungswarteschlange enthält Einträge für alle Objekte im verwalteten Heap, deren Finalisierungscode ausgeführt werden muss, bevor der Garbage Collector deren Speicher freigeben kann.</span><span class="sxs-lookup"><span data-stu-id="931e4-279">The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</span></span> <span data-ttu-id="931e4-280">Anschließend ruft der Garbage Collector die <xref:System.Object.Finalize%2A> Methode automatisch in den folgenden Situationen:</span><span class="sxs-lookup"><span data-stu-id="931e4-280">The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:</span></span>  
  
-   <span data-ttu-id="931e4-281">Nachdem der Garbage Collector ermittelt hat, dass ein Objekt kann nicht zugegriffen werden, es sei denn, das Objekt durch einen Aufruf, von der Finalisierung ausgenommen wurden die <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-281">After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="931e4-282">**In .NET Framework nur**, während des Herunterfahrens einer Anwendungsdomäne, es sei denn, das Objekt von der Finalisierung ausgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="931e4-282">**On .NET Framework only**, during shutdown of an application domain, unless the object is exempt from finalization.</span></span> <span data-ttu-id="931e4-283">Während des Herunterfahrens sind auch Objekte, die immer noch zugänglich sind abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="931e4-283">During shutdown, even objects that are still accessible are finalized.</span></span>  
  
 <span data-ttu-id="931e4-284"><xref:System.Object.Finalize%2A> automatisch nur einmal aufgerufen wird für eine bestimmte Instanz, es sei denn, das Objekt erneut registriert wird, wie z. B. mit einem Mechanismus <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> und <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> Methode nicht anschließend aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="931e4-284"><xref:System.Object.Finalize%2A> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> and the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method has not been subsequently called.</span></span>  
  
 <span data-ttu-id="931e4-285"><xref:System.Object.Finalize%2A> Vorgänge weisen die folgenden Einschränkungen:</span><span class="sxs-lookup"><span data-stu-id="931e4-285"><xref:System.Object.Finalize%2A> operations have the following limitations:</span></span>  
  
-   <span data-ttu-id="931e4-286">Die genaue Zeit, wann der Finalizer ausgeführt wird, ist nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="931e4-286">The exact time when the finalizer executes is undefined.</span></span> <span data-ttu-id="931e4-287">Um deterministische Freigabe von Ressourcen sicherzustellen, dass für Instanzen von Ihrer Klasse implementieren eine `Close` Methode, oder geben Sie einen <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> Implementierung.</span><span class="sxs-lookup"><span data-stu-id="931e4-287">To ensure deterministic release of resources for instances of your class, implement a `Close` method or provide a <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
-   <span data-ttu-id="931e4-288">Der Finalizer von zwei Objekten sind Ausführung nicht garantiert in einer bestimmten Reihenfolge, selbst wenn ein Objekt in die andere verweist.</span><span class="sxs-lookup"><span data-stu-id="931e4-288">The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</span></span> <span data-ttu-id="931e4-289">D. h. wenn Objekt A verfügt über einen Verweis auf das Objekt B, und beide verfügen über Finalizer, Objekt B möglicherweise bereits beendet wurde zu Beginn der Finalizer des Objekts ein.</span><span class="sxs-lookup"><span data-stu-id="931e4-289">That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</span></span>  
  
-   <span data-ttu-id="931e4-290">Der Thread, der auf dem der Finalizer ausgeführt wird, ist nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="931e4-290">The thread on which the finalizer runs is unspecified.</span></span>  
  
 <span data-ttu-id="931e4-291">Die <xref:System.Object.Finalize%2A> Methode möglicherweise nicht bis zum Abschluss ausgeführt, oder möglicherweise nicht alle in den folgenden außergewöhnlichen Situationen ausgeführt:</span><span class="sxs-lookup"><span data-stu-id="931e4-291">The <xref:System.Object.Finalize%2A> method might not run to completion or might not run at all under the following exceptional circumstances:</span></span>  
  
-   <span data-ttu-id="931e4-292">Wenn eine andere Finalizer auf unbestimmte Zeit blockiert (wird auf eine unendliche Schleife, versucht, eine Sperre kann nie zu erhalten und so weiter).</span><span class="sxs-lookup"><span data-stu-id="931e4-292">If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</span></span> <span data-ttu-id="931e4-293">Da die Runtime versucht, die Finalizer vollständig ausgeführt werden, möglicherweise andere Finalizer nicht wenn ein Finalizer blockiert auf unbestimmte Zeit aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="931e4-293">Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</span></span>  
  
-   <span data-ttu-id="931e4-294">Wenn der Prozess beendet wird, ohne dass die Laufzeit eine Gelegenheit zum Bereinigen von.</span><span class="sxs-lookup"><span data-stu-id="931e4-294">If the process terminates without giving the runtime a chance to clean up.</span></span> <span data-ttu-id="931e4-295">In diesem Fall ist die erste Benachrichtigung von der Runtime für Beendigung des Prozesses eine DLL_PROZESS_DETACH-Benachrichtigung.</span><span class="sxs-lookup"><span data-stu-id="931e4-295">In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</span></span>  
  
 <span data-ttu-id="931e4-296">Die Laufzeit weiterhin Threadobjekte während des Herunterfahrens, nur, während die Anzahl der finalisierbare Objekte weiter verringern.</span><span class="sxs-lookup"><span data-stu-id="931e4-296">The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</span></span>  
  
 <span data-ttu-id="931e4-297">Wenn <xref:System.Object.Finalize%2A> oder eine Überschreibung von <xref:System.Object.Finalize%2A> löst eine Ausnahme aus, und die Runtime nicht von einer Anwendung, die die Standardrichtlinie überschreibt gehostet wird, die Runtime beendet den Prozess und keine aktiven `try` / `finally` Blöcke oder Finalizer werden ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="931e4-297">If <xref:System.Object.Finalize%2A> or an override of <xref:System.Object.Finalize%2A> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active `try`/`finally` blocks or finalizers are executed.</span></span> <span data-ttu-id="931e4-298">Dadurch wird die Prozessintegrität sichergestellt, wenn der Finalizer nicht freigeben kann, oder Löschen von Ressourcen.</span><span class="sxs-lookup"><span data-stu-id="931e4-298">This behavior ensures process integrity if the finalizer cannot free or destroy resources.</span></span>  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a><span data-ttu-id="931e4-299">Überschreiben der Finalize-Methode</span><span class="sxs-lookup"><span data-stu-id="931e4-299">Overriding the Finalize method</span></span> 
 <span data-ttu-id="931e4-300">Sie sollten überschreiben <xref:System.Object.Finalize%2A> für eine Klasse, die nicht verwaltete Ressourcen wie Dateihandles oder Verbindungen mit der Datenbank, die freigegeben werden müssen, wenn das verwaltete Objekt, das sie verwendet, während der Garbagecollection verworfen wird verwendet.</span><span class="sxs-lookup"><span data-stu-id="931e4-300">You should override <xref:System.Object.Finalize%2A> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</span></span> <span data-ttu-id="931e4-301">Sie sollten nicht implementieren, eine <xref:System.Object.Finalize%2A> -Methode für verwaltete Objekte auf, da der Garbage Collector verwaltete Ressourcen automatisch freigibt.</span><span class="sxs-lookup"><span data-stu-id="931e4-301">You shouldn't implement a <xref:System.Object.Finalize%2A> method for managed objects because the garbage collector releases managed resources automatically.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="931e4-302">Wenn eine <xref:System.Runtime.InteropServices.SafeHandle> Objekt steht, die nicht verwaltete Ressource einschließt, die empfohlene Alternative ist das Implementieren des Dispose-Musters mit einem sicheren Handle und überschreiben Sie nicht <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="931e4-302">If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="931e4-303">Weitere Informationen finden Sie unter [die SafeHandle-Alternative](#SafeHandle) Abschnitt.</span><span class="sxs-lookup"><span data-stu-id="931e4-303">For more information, see [The SafeHandle alternative](#SafeHandle) section.</span></span>  
  
 <span data-ttu-id="931e4-304">Die <xref:System.Object.Finalize%2A?displayProperty=nameWithType> Methode führt keine Aktion standardmäßig, jedoch sollten Sie überschreiben <xref:System.Object.Finalize%2A> nur dann, wenn erforderlich, und nur auf nicht verwaltete Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="931e4-304">The <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources.</span></span> <span data-ttu-id="931e4-305">Freigeben von Arbeitsspeicher eher zu viel länger, wenn ein Vorgang für die Beendigung ausgeführt wird, da er mindestens zwei Garbage Collections erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="931e4-305">Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</span></span> <span data-ttu-id="931e4-306">Darüber hinaus sollten Sie überschreiben die <xref:System.Object.Finalize%2A> -Methode für den Verweis nur Typen.</span><span class="sxs-lookup"><span data-stu-id="931e4-306">In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only.</span></span> <span data-ttu-id="931e4-307">Die common Language Runtime finalisiert nur Verweistypen.</span><span class="sxs-lookup"><span data-stu-id="931e4-307">The common language runtime only finalizes reference types.</span></span> <span data-ttu-id="931e4-308">Finalizer für Werttypen werden dabei ignoriert.</span><span class="sxs-lookup"><span data-stu-id="931e4-308">It ignores finalizers on value types.</span></span>  

<span data-ttu-id="931e4-309">Im Rahmen der <xref:System.Object.Finalize%2A?displayProperty=nameWithType> Methode `protected`.</span><span class="sxs-lookup"><span data-stu-id="931e4-309">The scope of the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method is `protected`.</span></span> <span data-ttu-id="931e4-310">Sie sollten diesen eingeschränkten Gültigkeitsbereich beibehalten, wenn Sie die Methode in der Klasse überschreiben.</span><span class="sxs-lookup"><span data-stu-id="931e4-310">You should maintain this limited scope when you override the method in your class.</span></span> <span data-ttu-id="931e4-311">Durch aufbewahren einer <xref:System.Object.Finalize%2A> -Methode geschützt ist, können Benutzer der Anwendung Aufrufen eines Objekts <xref:System.Object.Finalize%2A> -Methode direkt.</span><span class="sxs-lookup"><span data-stu-id="931e4-311">By keeping a <xref:System.Object.Finalize%2A> method protected, you prevent users of your application from calling an object's <xref:System.Object.Finalize%2A> method directly.</span></span>
  
 <span data-ttu-id="931e4-312">Jede Implementierung von <xref:System.Object.Finalize%2A> in einem abgeleiteten Typ muss den Basistyp-Implementierung von Aufrufen <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="931e4-312">Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="931e4-313">Dies ist der einzige Fall, bei denen Code aufrufen, darf <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="931e4-313">This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="931e4-314">Ein Objekt des <xref:System.Object.Finalize%2A> Methode darf keine Methode für alle Objekte, die von der Basisklasse aufrufen.</span><span class="sxs-lookup"><span data-stu-id="931e4-314">An object's <xref:System.Object.Finalize%2A> method shouldn't call a method on any objects other than that of its base class.</span></span> <span data-ttu-id="931e4-315">Der Grund hierfür ist, dass das aufrufende Objekt möglicherweise zur gleichen Zeit an die Garbage Collection übergeben wird wie die anderen aufgerufenen Objekte, z. B. wenn eine Common Language Runtime beendet wird.</span><span class="sxs-lookup"><span data-stu-id="931e4-315">This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</span></span> 
  
> [!NOTE]
>  <span data-ttu-id="931e4-316">Der C#-Compiler lässt nicht zu überschreiben, die <xref:System.Object.Finalize%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-316">The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="931e4-317">Stattdessen Sie einen Finalizer bereitstellen, durch die Implementierung einer [Destruktor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) für die Klasse.</span><span class="sxs-lookup"><span data-stu-id="931e4-317">Instead, you provide a finalizer by implementing a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) for your class.</span></span> <span data-ttu-id="931e4-318">Ein C#-Destruktor ruft automatisch den Destruktor der Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="931e4-318">A C# destructor automatically calls the destructor of its base class.</span></span>  
>   
>  <span data-ttu-id="931e4-319">Visual C++ stellt auch eine eigene Syntax bereit, für die Implementierung der <xref:System.Object.Finalize%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-319">Visual C++ also provides its own syntax for implementing the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="931e4-320">Weitere Informationen finden Sie im Abschnitt "Destruktoren und Finalizer" [wie: definieren und Verarbeiten von Klassen und Strukturen (C++ / CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span><span class="sxs-lookup"><span data-stu-id="931e4-320">For more information, see the "Destructors and finalizers" section of [How to: Define and Consume Classes and Structs (C++/CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span></span>  
  
 <span data-ttu-id="931e4-321">Da der Garbagecollection nicht deterministisch ist, wissen Sie nicht genau, wann der Garbage Collector Beendigung führt.</span><span class="sxs-lookup"><span data-stu-id="931e4-321">Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</span></span> <span data-ttu-id="931e4-322">Um Ressourcen freizugeben sofort, Sie können auch zum Implementieren der [dispose-Muster](~/docs/standard/design-guidelines/dispose-pattern.md) und <xref:System.IDisposable> Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="931e4-322">To release resources immediately, you can also choose to implement the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) and the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="931e4-323">Die <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> Implementierung aufgerufen werden kann, durch die Benutzer Ihrer Klasse, die nicht verwaltete Ressourcen freizugeben, und können Sie die <xref:System.Object.Finalize%2A> Methode, um nicht verwaltete Ressourcen freizugeben, die <xref:System.IDisposable.Dispose%2A> Methode wird nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="931e4-323">The <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <xref:System.Object.Finalize%2A> method to free unmanaged resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called.</span></span>  
  
 <span data-ttu-id="931e4-324"><xref:System.Object.Finalize%2A> dauert nahezu jede Aktion, z. B. kann zugänglich ein-Objekt (das das Objekt wieder zugänglich gemacht werden,) aus, nachdem es während der Garbagecollection bereinigt wurden.</span><span class="sxs-lookup"><span data-stu-id="931e4-324"><xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</span></span> <span data-ttu-id="931e4-325">Allerdings kann das Objekt nur einmal wieder zugänglich gemacht werden; <xref:System.Object.Finalize%2A> kann nicht während der Garbagecollection wieder zugänglich gemachte Objekte aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="931e4-325">However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection.</span></span> <span data-ttu-id="931e4-326">Es gibt eine Aktion, die Ihre Implementierung von <xref:System.Object.Finalize%2A> nie dauert: sollten sie nie eine Ausnahme auslösen.</span><span class="sxs-lookup"><span data-stu-id="931e4-326">There is one action that your implementation of <xref:System.Object.Finalize%2A> should never take: it should never throw an exception.</span></span> <span data-ttu-id="931e4-327">Bei Aufruf von Methoden ausgelösten Ausnahmen aus der <xref:System.Object.Finalize%2A> Methode werden nicht behandelt, durch die <xref:System.Object.Finalize%2A> -Methode, die Laufzeit geht davon aus, die die <xref:System.Object.Finalize%2A> Methode zurückgegeben, und rufen Sie weiterhin die <xref:System.Object.Finalize%2A> Methoden anderer Objekte.</span><span class="sxs-lookup"><span data-stu-id="931e4-327">If any exceptions thrown by methods called from the <xref:System.Object.Finalize%2A> method are unhandled by the <xref:System.Object.Finalize%2A> method, the runtime assumes that the <xref:System.Object.Finalize%2A> method returned and continues to call the <xref:System.Object.Finalize%2A> methods of other objects.</span></span> 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a><span data-ttu-id="931e4-328">Die SafeHandle-Alternative</span><span class="sxs-lookup"><span data-stu-id="931e4-328">The SafeHandle alternative</span></span>  
 <span data-ttu-id="931e4-329">Zuverlässige Finalizer ist oft schwierig, da Sie keine Annahmen über den Zustand Ihrer Anwendung vornehmen können, und Systemausnahmen wie z. B. nicht behandelte <xref:System.OutOfMemoryException> und <xref:System.StackOverflowException> den Finalizer zu beenden.</span><span class="sxs-lookup"><span data-stu-id="931e4-329">Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer.</span></span> <span data-ttu-id="931e4-330">Anstatt einen Finalizer für die Klasse zum Freigeben von nicht verwalteter Ressourcen zu implementieren, können Sie ein Objekt, das von abgeleitet ist die <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> Klasse, um die nicht verwalteten Ressourcen zu umschließen, und klicken Sie dann das Dispose-Muster ohne einen Finalizer zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="931e4-330">Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</span></span> <span data-ttu-id="931e4-331">.NET Framework bietet die folgenden Klassen in der <xref:Microsoft.Win32?displayProperty=nameWithType> Namespace, der von abgeleitet werden <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="931e4-331">The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=nameWithType> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span></span>  
  
-   <span data-ttu-id="931e4-332"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> ist eine Wrapperklasse für ein Dateihandle.</span><span class="sxs-lookup"><span data-stu-id="931e4-332"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> is a wrapper class for a file handle.</span></span>  
  
-   <span data-ttu-id="931e4-333"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> ist eine Wrapperklasse für Handles der Datei mit zugewiesenem Speicher.</span><span class="sxs-lookup"><span data-stu-id="931e4-333"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> is a wrapper class for memory-mapped file handles.</span></span>  
  
-   <span data-ttu-id="931e4-334"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> ist eine Wrapperklasse für ein Zeiger auf einen nicht verwalteten Speicherblock.</span><span class="sxs-lookup"><span data-stu-id="931e4-334"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> is a wrapper class for a pointer to a block of unmanaged memory.</span></span>  
  
-   <span data-ttu-id="931e4-335"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, und <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> Wrapperklassen für kryptografische verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="931e4-335"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> are wrapper classes for cryptographic handles.</span></span>  
  
-   <span data-ttu-id="931e4-336"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> ist eine Wrapperklasse für Pipehandles.</span><span class="sxs-lookup"><span data-stu-id="931e4-336"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> is a wrapper class for pipe handles.</span></span>  
  
-   <span data-ttu-id="931e4-337"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> ist eine Wrapperklasse für ein Handle für einen Registrierungsschlüssel an.</span><span class="sxs-lookup"><span data-stu-id="931e4-337"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> is a wrapper class for a handle to a registry key.</span></span>  
  
-   <span data-ttu-id="931e4-338"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> ist eine Wrapperklasse für ein Wait-Handle.</span><span class="sxs-lookup"><span data-stu-id="931e4-338"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> is a wrapper class for a wait handle.</span></span>  
  
 <span data-ttu-id="931e4-339">Im folgenden Beispiel wird die [dispose-Muster](~/docs/standard/design-guidelines/dispose-pattern.md) mit SafeHandles anstelle von der <xref:System.Object.Finalize%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-339">The following example uses the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) with safe handles instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="931e4-340">Definiert eine `FileAssociation` -Klasse, die Informationen in der Registrierung über die Anwendung einschließt, die Dateien mit einer bestimmten Dateierweiterung behandelt.</span><span class="sxs-lookup"><span data-stu-id="931e4-340">It defines a `FileAssociation` class that wraps registry information about the application that handles files with a particular file extension.</span></span> <span data-ttu-id="931e4-341">Die beiden Registrierungsschlüssel Handles als `out` Parameter nach Windows ["RegOpenKeyEx"](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) an Funktionsaufrufe übergeben werden die <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="931e4-341">The two registry handles returned as `out` parameters by Windows [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) function calls are passed to the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor.</span></span> <span data-ttu-id="931e4-342">Der Typ der geschützte `Dispose` -Methode ruft dann die `SafeRegistryHandle.Dispose` Methode, um diese zwei Handles freizugeben.</span><span class="sxs-lookup"><span data-stu-id="931e4-342">The type's protected `Dispose` method then calls the `SafeRegistryHandle.Dispose` method  to free these two handles.</span></span>  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="931e4-343">Im folgenden Beispiel wird überprüft, ob die <xref:System.Object.Finalize%2A> Methode wird aufgerufen, wenn ein Objekt, das überschreibt <xref:System.Object.Finalize%2A> zerstört wird.</span><span class="sxs-lookup"><span data-stu-id="931e4-343">The following example verifies that the <xref:System.Object.Finalize%2A> method is called when an object that overrides <xref:System.Object.Finalize%2A> is destroyed.</span></span> <span data-ttu-id="931e4-344">Beachten Sie, dass in einer produktionsanwendung die <xref:System.Object.Finalize%2A> Methode zum Freigeben von nicht verwalteter Ressourcen frei, die das Objekt überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="931e4-344">Note that, in a production application, the <xref:System.Object.Finalize%2A> method would be overridden to release unmanaged resources held by the object.</span></span> <span data-ttu-id="931e4-345">Beachten Sie, dass der C#-Beispiel wird einen Destruktor anstelle von bietet die <xref:System.Object.Finalize%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-345">Also note that the C# example provides a destructor instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 <span data-ttu-id="931e4-346">Ein weiteres Beispiel, das überschreibt die <xref:System.Object.Finalize%2A> -Methode finden Sie unter den <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-346">For an additional example that overrides the <xref:System.Object.Finalize%2A> method, see the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="931e4-347">Fungiert als die Standardhashfunktion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-347">Serves as the default hash function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="931e4-348">Ein Hashcode für das aktuelle Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-348">A hash code for the current object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="931e4-349">Ein Hashcode ist ein numerischer Wert, der zum Einfügen und identifizieren ein Objekt in einer Auflistung hashbasierten wie z. B. die <xref:System.Collections.Generic.Dictionary%602> -Klasse, die <xref:System.Collections.Hashtable> Klasse oder von abgeleiteten Typs der <xref:System.Collections.DictionaryBase> Klasse.</span><span class="sxs-lookup"><span data-stu-id="931e4-349">A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class.</span></span> <span data-ttu-id="931e4-350">Die <xref:System.Object.GetHashCode%2A> Methode enthält dieser Hashcode für Algorithmen, die schnelle Überprüfungen Objektgleichheit benötigen.</span><span class="sxs-lookup"><span data-stu-id="931e4-350">The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="931e4-351">Informationen zur Verwendung von Hashcodes in Hashtabellen und einige zusätzliche Code Hashalgorithmen, finden Sie unter den [Hashfunktion](https://en.wikipedia.org/wiki/Hash_function) Eintrag in Wikipedia.</span><span class="sxs-lookup"><span data-stu-id="931e4-351">For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the [Hash Function](https://en.wikipedia.org/wiki/Hash_function) entry in Wikipedia.</span></span>  
  
 <span data-ttu-id="931e4-352">Zwei Objekte gleich return Hashcodes, die gleich sind.</span><span class="sxs-lookup"><span data-stu-id="931e4-352">Two objects that are equal return hash codes that are equal.</span></span> <span data-ttu-id="931e4-353">Das Gegenteil ist jedoch nicht "true": gleich Hashcodes implizieren keine Objektgleichheit, da verschiedene (ungleich) Objekte identische Hashcodes verfügen können.</span><span class="sxs-lookup"><span data-stu-id="931e4-353">However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</span></span> <span data-ttu-id="931e4-354">Darüber hinaus ist .NET Framework nicht die standardmäßige Implementierung des garantiert die <xref:System.Object.GetHashCode%2A> -Methode, und der Wert, der diese Methode gibt unterscheiden zwischen .NET Framework-Versionen und Plattformen wie 32-Bit- und 64-Bit-Plattformen.</span><span class="sxs-lookup"><span data-stu-id="931e4-354">Furthermore, the .NET Framework does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms.</span></span> <span data-ttu-id="931e4-355">Aus diesen Gründen verwenden Sie nicht die Standardimplementierung dieser Methode als eine eindeutige Objekt-ID für hashing zu.</span><span class="sxs-lookup"><span data-stu-id="931e4-355">For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</span></span> <span data-ttu-id="931e4-356">Führen Sie die beiden aus diesem:</span><span class="sxs-lookup"><span data-stu-id="931e4-356">Two consequences follow from this:</span></span>  
  
-   <span data-ttu-id="931e4-357">Sie sollten nicht davon ausgehen, dass gleich Hashcodes Objektgleichheit implizieren.</span><span class="sxs-lookup"><span data-stu-id="931e4-357">You should not assume that equal hash codes imply object equality.</span></span>  
  
-   <span data-ttu-id="931e4-358">Sie sollten nie beibehalten oder einen Hashcode außerhalb der Anwendungsdomäne, in der es erstellt wurde, verwenden, da das gleiche Objekt über Anwendungsdomänen, Prozessen und Plattformen hash kann.</span><span class="sxs-lookup"><span data-stu-id="931e4-358">You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="931e4-359">Ein Hashcode ist vorgesehen, für das effiziente Einfügen und Suche in Auflistungen, die auf eine Hash-Tabelle basieren.</span><span class="sxs-lookup"><span data-stu-id="931e4-359">A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</span></span> <span data-ttu-id="931e4-360">Ein Hashcode ist kein permanente Wert.</span><span class="sxs-lookup"><span data-stu-id="931e4-360">A hash code is not a permanent value.</span></span> <span data-ttu-id="931e4-361">Aus diesem Grund:</span><span class="sxs-lookup"><span data-stu-id="931e4-361">For this reason:</span></span>  
>   
> -   <span data-ttu-id="931e4-362">Serialisieren Sie Hashwerte für Code zu und speichern Sie sie in Datenbanken nicht.</span><span class="sxs-lookup"><span data-stu-id="931e4-362">Do not serialize hash code values or store them in databases.</span></span>  
> -   <span data-ttu-id="931e4-363">Verwenden Sie nicht den Hashcode als Schlüssel an, um ein Objekt über eine schlüsselgebundene Sammlung abzurufen.</span><span class="sxs-lookup"><span data-stu-id="931e4-363">Do not use the hash code as the key to retrieve an object from a keyed collection.</span></span>  
> -   <span data-ttu-id="931e4-364">Hashcodes werden nicht über Anwendungsdomänen oder Prozessen gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="931e4-364">Do not send hash codes across application domains or processes.</span></span> <span data-ttu-id="931e4-365">In einigen Fällen können der Hashcodes pro Domäne pro Prozess oder pro Anwendung berechnet werden.</span><span class="sxs-lookup"><span data-stu-id="931e4-365">In some cases, hash codes may be computed on a per-process or per-application domain basis.</span></span>  
> -   <span data-ttu-id="931e4-366">Verwenden Sie den Hash nicht anstelle eines Werts von einer kryptografischen Hashfunktion zurückgegeben wird, wenn Sie einen kryptographisch starken Hashwert benötigen.</span><span class="sxs-lookup"><span data-stu-id="931e4-366">Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="931e4-367">Für kryptografische Hashes, verwenden Sie eine von abgeleitete Klasse die <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> oder <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> Klasse.</span><span class="sxs-lookup"><span data-stu-id="931e4-367">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
> -   <span data-ttu-id="931e4-368">Testen Sie nicht auf Gleichheit Hashcodes zu bestimmen, ob zwei Objekte gleich sind.</span><span class="sxs-lookup"><span data-stu-id="931e4-368">Do not test for equality of hash codes to determine whether two objects are equal.</span></span> <span data-ttu-id="931e4-369">(Ungleich Objekte können identische Hashcodes haben.) Um auf Gleichheit zu testen, rufen Sie die <xref:System.Object.ReferenceEquals%2A> oder <xref:System.Object.Equals%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-369">(Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="931e4-370">Die <xref:System.Object.GetHashCode%2A> Methode kann von einem abgeleiteten Typ überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="931e4-370">The <xref:System.Object.GetHashCode%2A> method can be overridden by a derived type.</span></span> <span data-ttu-id="931e4-371">Wenn <xref:System.Object.GetHashCode%2A> wird nicht überschrieben, Hashcodes für Verweistypen berechnet werden, durch den Aufruf der <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> -Methode der Basisklasse, die berechnet einen Hashcode basierend auf ein Objekt in der Referenz; Weitere Informationen, finden Sie unter <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="931e4-371">If <xref:System.Object.GetHashCode%2A> is not overridden, hash codes for reference types are computed by calling the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="931e4-372">Das heißt, zwei Objekte auf dem die <xref:System.Object.ReferenceEquals%2A> Methodenrückgabe `true` haben identische Hashcodes.</span><span class="sxs-lookup"><span data-stu-id="931e4-372">In other words, two objects for which the <xref:System.Object.ReferenceEquals%2A> method returns `true` have identical hash codes.</span></span> <span data-ttu-id="931e4-373">Wenn Sie Werttypen nicht außer Kraft setzen <xref:System.Object.GetHashCode%2A>, <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> Methode der Basisklasse verwendet Reflektion, um den Hashcode anhand der Werte der Felder des Typs zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="931e4-373">If value types do not override <xref:System.Object.GetHashCode%2A>, the <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</span></span> <span data-ttu-id="931e4-374">Mit anderen Worten, müssen die Typen mit Werten, deren Felder gleiche Werte haben, gleich Hashcodes.</span><span class="sxs-lookup"><span data-stu-id="931e4-374">In other words, value types whose fields have equal values have equal hash codes.</span></span> <span data-ttu-id="931e4-375">Weitere Informationen zum Überschreiben der <xref:System.Object.GetHashCode%2A>, finden Sie im Abschnitt "Hinweise zur Vererbung".</span><span class="sxs-lookup"><span data-stu-id="931e4-375">For more information about overriding <xref:System.Object.GetHashCode%2A>, see the "Notes to Inheritors" section.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="931e4-376">Wenn Sie außer Kraft setzen der <xref:System.Object.GetHashCode%2A> -Methode, Sie sollten auch überschreiben <xref:System.Object.Equals%2A>, und umgekehrt.</span><span class="sxs-lookup"><span data-stu-id="931e4-376">If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa.</span></span> <span data-ttu-id="931e4-377">Wenn die überschriebene <xref:System.Object.Equals%2A> Methodenrückgabe `true` beim sind zwei Objekte hinsichtlich ihrer Gleichheit, die überschriebene testen <xref:System.Object.GetHashCode%2A> Methode muss den gleichen Wert für die beiden Objekte zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="931e4-377">If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects.</span></span>  
  
 <span data-ttu-id="931e4-378">Wenn ein Objekt, das in einer Hashtabelle als Schlüssel verwendet wird, keine geeignete Implementierung von bietet <xref:System.Object.GetHashCode%2A>, Sie können einen Hashcode-Standardanbieter angeben, durch Angabe einer <xref:System.Collections.IEqualityComparer> Implementierung, die eine der Überladungen der der <xref:System.Collections.Hashtable> Klassenkonstruktor.</span><span class="sxs-lookup"><span data-stu-id="931e4-378">If an object that is used as a key in a hash table does not provide a useful implementation of <xref:System.Object.GetHashCode%2A>, you can specify a hash code provider by supplying an <xref:System.Collections.IEqualityComparer> implementation to one of the overloads of the <xref:System.Collections.Hashtable> class constructor.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="931e4-379">Anmerkungen zu dieser von der [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="931e4-379">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="931e4-380">Beim Aufrufen der <xref:System.Object.GetHashCode%2A> Methode einer Klasse in der [!INCLUDE[wrt](~/includes/wrt-md.md)], es ist das Standardverhalten für Klassen, die nicht außer Kraft setzen <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="931e4-380">When you call the <xref:System.Object.GetHashCode%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="931e4-381">Dies ist Teil der Unterstützung von .NET Framework für die [!INCLUDE[wrt](~/includes/wrt-md.md)] (finden Sie unter [.NET Framework Unterstützung für Windows Store-Apps und Windows-Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="931e4-381">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="931e4-382">Klassen in der [!INCLUDE[wrt](~/includes/wrt-md.md)] nicht erben <xref:System.Object>, und derzeit nicht implementiert eine <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="931e4-382">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and currently don’t implement a <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="931e4-383">Allerdings haben sie anscheinend <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, und <xref:System.Object.GetHashCode%2A> Methoden ein, wenn Sie diese in Ihrem C#- oder Visual Basic-Code verwenden und .NET Framework das Standardverhalten für diese Methoden ist.</span><span class="sxs-lookup"><span data-stu-id="931e4-383">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]<span data-ttu-id="931e4-384"> Klassen, die in c# oder Visual Basic geschrieben sind, können außer Kraft setzen der <xref:System.Object.GetHashCode%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-384"> classes that are written in C# or Visual Basic can override the <xref:System.Object.GetHashCode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="931e4-385">Eine der einfachsten Möglichkeiten, um einen Hashcode für einen numerischen Wert zu berechnen, die den gleichen oder einen kleineren Bereich als hat die <xref:System.Int32> Typ ist, einfach diesen Wert zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="931e4-385">One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <xref:System.Int32> type is to simply return that value.</span></span> <span data-ttu-id="931e4-386">Das folgende Beispiel zeigt eine solche Implementierung für eine `Number` Struktur.</span><span class="sxs-lookup"><span data-stu-id="931e4-386">The following example shows such an implementation for a `Number` structure.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 <span data-ttu-id="931e4-387">In vielen Fällen hat einen Typ mehrere Datenfelder, die beim Generieren des Hashcodes teilnehmen kann.</span><span class="sxs-lookup"><span data-stu-id="931e4-387">Frequently, a type has multiple data fields that can participate in generating the hash code.</span></span> <span data-ttu-id="931e4-388">Eine Möglichkeit, einen Hashcode zu generieren, kombinieren diese Felder mit wird ein `XOR (eXclusive OR)` -Operation, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="931e4-388">One way to generate a hash code is to combine these fields using an `XOR (eXclusive OR)` operation, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 <span data-ttu-id="931e4-389">Das vorherige Beispiel gibt den gleichen Hashcode für (n1, n2) und (n2, n1), und um weitere Konflikte als wünschenswert sind, generieren kann.</span><span class="sxs-lookup"><span data-stu-id="931e4-389">The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</span></span> <span data-ttu-id="931e4-390">Eine Reihe von Lösungen sind verfügbar, sodass Hashcodes in diesen Fällen nicht identisch sind.</span><span class="sxs-lookup"><span data-stu-id="931e4-390">A number of solutions are available so that hash codes in these cases are not identical.</span></span> <span data-ttu-id="931e4-391">Eine besteht darin, den Hashcode des Zurückgeben einer `Tuple` -Objekt, das die Reihenfolge der einzelnen Felder entspricht.</span><span class="sxs-lookup"><span data-stu-id="931e4-391">One is to return the hash code of a `Tuple` object that reflects the order of each field.</span></span> <span data-ttu-id="931e4-392">Das folgende Beispiel zeigt eine mögliche Implementierung, die verwendet die <xref:System.Tuple%602> Klasse.</span><span class="sxs-lookup"><span data-stu-id="931e4-392">The following example shows a possible implementation that uses the <xref:System.Tuple%602> class.</span></span> <span data-ttu-id="931e4-393">Beachten Sie jedoch, die den Leistungsaufwand von Instanziieren einer `Tuple` Objekt kann erhebliche Auswirkungen auf die gesamtleistung einer Anwendung, die große Anzahl von Objekten in Hashtabellen speichert.</span><span class="sxs-lookup"><span data-stu-id="931e4-393">Note, though, that the performance overhead of instantiating a `Tuple` object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 <span data-ttu-id="931e4-394">Eine zweite alternative Lösung umfasst die Gewichtung der Hashcodes für die einzelnen durch die Links-Umstellung der Hashcodes von aufeinander folgenden Feldern von zwei oder mehr Bits.</span><span class="sxs-lookup"><span data-stu-id="931e4-394">A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</span></span> <span data-ttu-id="931e4-395">Optimal, anstatt verworfen wird, verschoben nach Bit 31 Bits umschließen soll, anstatt verworfen werden.</span><span class="sxs-lookup"><span data-stu-id="931e4-395">Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded.</span></span> <span data-ttu-id="931e4-396">Da von der Left Shift-Operatoren in c# und Visual Basic Bits verworfen werden, dies ist erforderlich, erstellen eine linke UMSCHALT-Wrap-Methode wie folgt:</span><span class="sxs-lookup"><span data-stu-id="931e4-396">Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 <span data-ttu-id="931e4-397">Im folgenden Beispiel wird dann diese UMSCHALT-Wrap-Methode berechnet den Hashcode der `Point` Struktur, die in den vorherigen Beispielen verwendet.</span><span class="sxs-lookup"><span data-stu-id="931e4-397">The following example then uses this shift-and-wrap method to compute the hash code of the `Point` structure used in the previous examples.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="931e4-398">
            <para>Eine Hashfunktion wird verwendet, um eine Zahl (Hashcode) schnell zu generieren, die den Wert eines Objekts entspricht. Hash-Funktionen sind für jeden Typ in der Regel spezifisch und Eindeutigkeit, müssen mindestens eines der Instanzfelder als Eingabe verwenden. Hashcodes sollten nicht mit den Werten von statischen Feldern berechnet werden.  Für die abgeleitete Klassen von <see cref="T:System.Object" />, <see langword="GetHashCode" /> Delegatmethode können auf die Basisklasse <see cref="M:System.Object.GetHashCode" /> Implementierung nur dann, wenn die abgeleitete Klasse auf Gleichheit als Verweisgleichheit definiert. Die standardmäßige Implementierung des <see cref="M:System.Object.GetHashCode" /> zu Referenzzwecken Typen zurückgibt einen Hashcode, der zurückgegeben werden, indem Sie entspricht der <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> Methode. Sie können außer Kraft setzen <see cref="M:System.Object.GetHashCode" /> für unveränderliche Verweistypen. Im Allgemeinen für änderbare Referenztypen, Sie sollten eine Überschreibung <see cref="M:System.Object.GetHashCode" /> nur, wenn: – Sie können den Hashcode aus Feldern, die nicht änderbare; berechnen oder - können Sie sicherstellen, dass es sich bei der Hashcode des ein änderbares Objekt nicht geändert wird, während das Objekt in einem Collecti enthalten ist auf dieser basiert auf dessen Hashcode.  Andernfalls könnte man denken, dass die änderbare Objekt in der Hashtabelle verloren geht. Wenn Sie außer Kraft setzen möchten, führen Sie <see cref="M:System.Object.GetHashCode" /> für einen änderbaren Referenztyp, der Dokumentation sollte es machen, klar, dass Benutzer des Typs Objektwerte nicht ändern sollten, während das Objekt in einer Hashtabelle gespeichert ist.  Bei Werttypen <see cref="M:System.ValueType.GetHashCode" /> Hash-Code stellt eine Standardimplementierung bereit, der Reflektion verwendet. Sie sollten erwägen, überschreiben sie für eine bessere Leistung.  <block subset="none" type="note"><para> Weitere Informationen und Beispiele, die Hashcodes in einer Vielzahl von Möglichkeiten zu berechnen, finden Sie unter dem Abschnitt "Beispiele".  </para></block>  Eine Hashfunktion muss die folgenden Eigenschaften aufweisen:: Wenn zwei Objekte als gleich verglichen werden soll. die <see cref="M:System.Object.GetHashCode" /> Methode für jedes Objekt muss den gleichen Wert zurückgeben. Jedoch, wenn zwei Objekte nicht als gleich verglichen werden die <see cref="M:System.Object.GetHashCode" /> Methoden für die beiden Objekte keine unterschiedliche Werte zurückgeben.  – Die <see cref="M:System.Object.GetHashCode" /> -Methode für ein Objekt muss immer zurückgeben, die gleichen hash-Code so lange keine Änderung des Objektzustands, der den Rückgabewert des Objekts bestimmt [System.Object.Equals](xref:System.Object.Equals*) Methode. Beachten Sie, dass es sich bei "true" nur für die aktuelle Ausführung einer Anwendung und ein anderen Hash-Code zurückgegeben werden kann, wenn die Anwendung erneut ausgeführt wird.  – Für die optimale Leistung sollte eine Hash-Funktion generieren eine gleichmäßige Verteilung für alle Eingaben, einschließlich Eingabe, die stark gruppiert ist. Ein Folge ist, dass kleinere Änderungen an den Objektstatus zu große Änderungen an der resultierende Hashcode für eine optimale Leistung der Hash-Tabelle führen soll.  -Hashfunktionen sollte wenig Aufwand zu berechnen.  – Die <see cref="M:System.Object.GetHashCode" /> Methode sollte keine Ausnahmen auslösen.  Z. B. die Implementierung von der <see cref="M:System.String.GetHashCode" /> Methode bereitgestellt wird, durch die <see cref="T:System.String" /> -Klasse gibt identische Hashcodes für identische Zeichenfolgenwerte zurück. Aus diesem Grund zwei <see cref="T:System.String" /> Objekte den gleichen Hashcode zurückgeben, wenn sie den gleichen Zeichenfolgenwert darstellt. Die Methode verwendet außerdem alle Zeichen in der Zeichenfolge um verhältnismäßig zufällig verteilte Ausgabe zu generieren, selbst wenn die Eingabe in bestimmten Bereichen gruppiert ist (z. B. möglicherweise viele Benutzer Zeichenfolgen, die nur die unteren 128 ASCII-Zeichen, obwohl enthalten ein Zeichenfolge kann die 65.535 Unicode-Zeichen enthalten).  Bereitstellen einer guten Hashfunktion für eine Klasse kann sich erheblich auf die Leistung des Hinzufügens von diesen Objekten in eine Hashtabelle beeinträchtigen. In einer Hashtabelle mit Schlüsseln, die einer guten einer Hashfunktion Implementierung, dauert sucht nach einem Element Konstanten Zeit (z. B. eine o(1)-Operation) aus. In einer Hashtabelle mit einer schlechten Implementierung einer Hashfunktion, die Leistung einer Suche hängt die Anzahl der Elemente in der Hashtabelle (z. B. eine O (`n`)-Vorgang, in denen `n` ist die Anzahl der Elemente in der Hashtabelle). Geben Sie ein böswilliger Benutzer kann Daten, die die Anzahl der Konflikte, erhöht sich die erheblich die Leistung der Anwendung beeinträchtigen können, die abhängig von Hashtabellen, unter den folgenden Bedingungen: - Hashfunktionen häufig Konflikte erzeugt.  – Wenn ein Großteil der Objekte in einer Hashtabelle zum Erstellen der Hashcodes, die gleich sind oder anderen ungefähr gleich.  – Wenn Benutzer die Daten eingeben, anhand, die derer der Hashcode berechnet wird.  Abgeleitete Klassen, die außer Kraft setzen <see cref="M:System.Object.GetHashCode" /> müssen auch überschreiben <see cref="M:System.Object.Equals(System.Object)" /> um sicherzustellen, dass zwei Objekte als gleich betrachtet, die den gleichen Hashcode haben, andernfalls die <see cref="T:System.Collections.Hashtable" /> Typ funktioniert möglicherweise nicht ordnungsgemäß.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-398">
              <para>A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object. Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input. Hash codes should not be computed by using the values of static fields.  For classes derived from <see cref="T:System.Object" />, the <see langword="GetHashCode" /> method can delegate to the base class <see cref="M:System.Object.GetHashCode" /> implementation only if the derived class defines equality to be reference equality. The default implementation of <see cref="M:System.Object.GetHashCode" /> for reference types returns a hash code that is equivalent to the one returned by the <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> method. You can override <see cref="M:System.Object.GetHashCode" /> for immutable reference types. In general, for mutable reference types, you should override <see cref="M:System.Object.GetHashCode" /> only if:  -   You can compute the hash code from fields that are not mutable; or  -   You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.  Otherwise, you might think that the mutable object is lost in the hash table. If you do choose to override <see cref="M:System.Object.GetHashCode" /> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.  For value types, <see cref="M:System.ValueType.GetHashCode" /> provides a default hash code implementation that uses reflection. You should consider overriding it for better performance.  <block subset="none" type="note"><para> For more information and examples that compute hash codes in a variety of ways, see the Examples section.  </para></block>  A hash function must have the following properties:  -   If two objects compare as equal, the <see cref="M:System.Object.GetHashCode" /> method for each object must return the same value. However, if two objects do not compare as equal, the <see cref="M:System.Object.GetHashCode" /> methods for the two objects do not have to return different values.  -   The <see cref="M:System.Object.GetHashCode" /> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's [System.Object.Equals](xref:System.Object.Equals*) method. Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.  -   For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered. An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.  -   Hash functions should be inexpensive to compute.  -   The <see cref="M:System.Object.GetHashCode" /> method should not throw exceptions.  For example, the implementation of the <see cref="M:System.String.GetHashCode" /> method provided by the <see cref="T:System.String" /> class returns identical hash codes for identical string values. Therefore, two <see cref="T:System.String" /> objects return the same hash code if they represent the same string value. Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).  Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table. In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation). In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(`n`) operation, where `n` is the number of items in the hash table). A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:  -   When hash functions produce frequent collisions.  -   When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.  -   When users input the data from which the hash code is computed.  Derived classes that override <see cref="M:System.Object.GetHashCode" /> must also override <see cref="M:System.Object.Equals(System.Object)" /> to guarantee that two objects considered equal have the same hash code; otherwise, the <see cref="T:System.Collections.Hashtable" /> type might not work correctly.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="931e4-399">Ruft den <see cref="T:System.Type" /> der aktuellen Instanz ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-399">Gets the <see cref="T:System.Type" /> of the current instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="931e4-400">Der genaue Laufzeittyp der aktuellen Instanz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-400">The exact runtime type of the current instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="931e4-401">Da <xref:System.Object?displayProperty=nameWithType> ist die Basisklasse für alle Typen im .NET Framework-Typsystem, das <xref:System.Object.GetType%2A> Methode kann verwendet werden, um zurückgeben <xref:System.Type> Objekte, die alle .NET Framework-Typen darstellen.</span><span class="sxs-lookup"><span data-stu-id="931e4-401">Because <xref:System.Object?displayProperty=nameWithType> is the base class for all types in the .NET Framework type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET Framework types.</span></span> <span data-ttu-id="931e4-402">.NET Framework erkennt die folgenden fünf Typkategorien:</span><span class="sxs-lookup"><span data-stu-id="931e4-402">The .NET Framework recognizes the following five categories of types:</span></span>  
  
-   <span data-ttu-id="931e4-403">Klassen, die von abgeleiteten <xref:System.Object?displayProperty=nameWithType>,</span><span class="sxs-lookup"><span data-stu-id="931e4-403">Classes, which are derived from <xref:System.Object?displayProperty=nameWithType>,</span></span>  
  
-   <span data-ttu-id="931e4-404">Werttypen, die abgeleitet sind <xref:System.ValueType?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="931e4-404">Value types, which are derived from <xref:System.ValueType?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="931e4-405">Schnittstellen, die von abgeleiteten <xref:System.Object?displayProperty=nameWithType> beginnend mit .NET Framework 2.0.</span><span class="sxs-lookup"><span data-stu-id="931e4-405">Interfaces, which are derived from <xref:System.Object?displayProperty=nameWithType> starting with the .NET Framework 2.0.</span></span>  
  
-   <span data-ttu-id="931e4-406">Enumerationen abgeleitet sind <xref:System.Enum?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="931e4-406">Enumerations, which are derived from <xref:System.Enum?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="931e4-407">Delegaten, die von abgeleiteten <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="931e4-407">Delegates, which are derived from <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="931e4-408">Für zwei Objekte `x` und `y` identische-Runtime-Typen, deren `Object.ReferenceEquals(x.GetType(),y.GetType())` gibt `true`.</span><span class="sxs-lookup"><span data-stu-id="931e4-408">For two objects `x` and `y` that have identical runtime types, `Object.ReferenceEquals(x.GetType(),y.GetType())` returns `true`.</span></span> <span data-ttu-id="931e4-409">Im folgenden Beispiel wird die <xref:System.Object.GetType%2A> -Methode mit dem <xref:System.Object.ReferenceEquals%2A> Methode, um zu bestimmen, ob einen numerischer Wert der gleiche Typ wie die anderen zwei numerische Werte.</span><span class="sxs-lookup"><span data-stu-id="931e4-409">The following example uses the <xref:System.Object.GetType%2A> method with the <xref:System.Object.ReferenceEquals%2A> method to determine whether one numeric value is the same type as two other numeric values.</span></span>  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  <span data-ttu-id="931e4-410">Um zu bestimmen, ob ein Objekt eines bestimmten Typs ist, verwenden Sie Ihre Sprache die Typ-Vergleich-Schlüsselwort oder zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="931e4-410">To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</span></span> <span data-ttu-id="931e4-411">Beispielsweise können Sie die `TypeOf…Is` -Konstrukts in Visual Basic oder `is` -Schlüsselwort in c#.</span><span class="sxs-lookup"><span data-stu-id="931e4-411">For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#.</span></span>  
  
 <span data-ttu-id="931e4-412">Die <xref:System.Object.GetType%2A> Methode wird von allen Typen, die abgeleitet geerbt <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="931e4-412">The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>.</span></span> <span data-ttu-id="931e4-413">Dies bedeutet, dass zusätzlich zur Verwendung Ihrer eigenen Sprache des Vergleichs-Schlüsselwort, das Sie verwenden können die <xref:System.Object.GetType%2A> Methode, um den Typ eines bestimmten Objekts, zu bestimmen, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="931e4-413">This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <span data-ttu-id="931e4-414">Die <xref:System.Type> Objekt verfügbar macht, die die Klasse des aktuellen zugeordnete Metadaten <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="931e4-414">The <xref:System.Type> object exposes the metadata associated with the class of the current <xref:System.Object>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="931e4-415">Im folgenden Codebeispiel wird veranschaulicht, dass <xref:System.Object.GetType%2A> gibt den Laufzeittyp der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="931e4-415">The following code example demonstrates that <xref:System.Object.GetType%2A> returns the runtime type of the current instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="931e4-416">Erstellt eine flache Kopie des aktuellen <see cref="T:System.Object" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-416">Creates a shallow copy of the current <see cref="T:System.Object" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="931e4-417">Eine flache Kopie des aktuellen <see cref="T:System.Object" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-417">A shallow copy of the current <see cref="T:System.Object" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="931e4-418">Die <xref:System.Object.MemberwiseClone%2A> Methode erstellt eine flache Kopie durch ein neues Objekt erstellt und anschließend die nicht statische Felder des aktuellen Objekts auf das neue Objekt kopiert.</span><span class="sxs-lookup"><span data-stu-id="931e4-418">The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</span></span> <span data-ttu-id="931e4-419">Wenn ein Feld eines Werttyps ist, erfolgt eine Bit für Bit-Kopie des Felds.</span><span class="sxs-lookup"><span data-stu-id="931e4-419">If a field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="931e4-420">Wenn ein Feld ein Verweistyp ist, wird der Verweis kopiert, aber das Objekt verwiesen wird, ist nicht; aus diesem Grund beziehen sich das ursprüngliche Objekt und dessen Klon auf dasselbe Objekt ein.</span><span class="sxs-lookup"><span data-stu-id="931e4-420">If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</span></span>  
  
 <span data-ttu-id="931e4-421">Betrachten Sie beispielsweise ein Objekt namens X dienen, die Objekte A und B, verweist wiederum auf verweist. Eine flache Kopie des X erstellt neues Objekt X2, das auch Objekte A und b verweist Im Gegensatz dazu eine tiefe Kopie des X-erstellt ein neues Objekt X2, die verweist auf die neuen Objekte A2 und B2, die Kopien von A und b B2, verweist wiederum auf das neue Objekt C2, wird eine Kopie des c Das Beispiel veranschaulicht den Unterschied zwischen einer flache und eine tiefe Kopie-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="931e4-421">For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</span></span>  
  
 <span data-ttu-id="931e4-422">Es gibt zahlreiche Möglichkeiten, einen tiefe Kopie-Vorgang zu implementieren, wenn die flache Kopie-durch Vorgangs die <xref:System.Object.MemberwiseClone%2A> Methode Ihren Anforderungen nicht erfüllt.</span><span class="sxs-lookup"><span data-stu-id="931e4-422">There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs.</span></span> <span data-ttu-id="931e4-423">Hierzu gehört Folgendes:</span><span class="sxs-lookup"><span data-stu-id="931e4-423">These include the following:</span></span>  
  
-   <span data-ttu-id="931e4-424">Rufen Sie den Konstruktor einer Klasse des Objekts, das kopiert werden, um ein zweites Objekt mit Eigenschaftswerten, die das erste Objekt entnommen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="931e4-424">Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</span></span> <span data-ttu-id="931e4-425">Dies setzt voraus, dass die Werte eines Objekts durch den Klassenkonstruktor vollständig definiert sind.</span><span class="sxs-lookup"><span data-stu-id="931e4-425">This assumes that the values of an object are entirely defined by its class constructor.</span></span>  
  
-   <span data-ttu-id="931e4-426">Rufen Sie die <xref:System.Object.MemberwiseClone%2A> Methode, um eine flache Kopie eines Objekts zu erstellen, und weisen Sie dann auf neue Objekte, deren Werte identisch mit das ursprüngliche Objekt, um alle Eigenschaften oder Felder sind, deren Werte Verweistypen sind.</span><span class="sxs-lookup"><span data-stu-id="931e4-426">Call the <xref:System.Object.MemberwiseClone%2A> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</span></span> <span data-ttu-id="931e4-427">Die `DeepCopy` -Methode in der das Beispiel veranschaulicht diese Vorgehensweise.</span><span class="sxs-lookup"><span data-stu-id="931e4-427">The `DeepCopy` method in the example illustrates this approach.</span></span>  
  
-   <span data-ttu-id="931e4-428">Serialisiert das Objekt, um Tiefe kopiert, und die serialisierten Daten in einer anderen Variable wiederhergestellt werden.</span><span class="sxs-lookup"><span data-stu-id="931e4-428">Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</span></span>  
  
-   <span data-ttu-id="931e4-429">Mithilfe von Reflektion mit Rekursion zum Ausführen des Vorgangs tiefe Kopie.</span><span class="sxs-lookup"><span data-stu-id="931e4-429">Use reflection with recursion to perform the deep copy operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="931e4-430">Das folgende Beispiel veranschaulicht die <xref:System.Object.MemberwiseClone%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-430">The following example illustrates the <xref:System.Object.MemberwiseClone%2A> method.</span></span> <span data-ttu-id="931e4-431">Definiert eine `ShallowCopy` Methode, die aufgerufen der <xref:System.Object.MemberwiseClone%2A> Methode, um eine flache Kopie-Vorgang ausgeführt eine `Person` Objekt.</span><span class="sxs-lookup"><span data-stu-id="931e4-431">It defines a `ShallowCopy` method that calls the <xref:System.Object.MemberwiseClone%2A> method to perform a shallow copy operation on a `Person` object.</span></span> <span data-ttu-id="931e4-432">Sie definiert außerdem eine `DeepCopy` Methode, einen tiefe Kopie-Vorgang ausführt, auf, eine `Person` Objekt.</span><span class="sxs-lookup"><span data-stu-id="931e4-432">It also defines a `DeepCopy` method that performs a deep copy operation on a `Person` object.</span></span>  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 <span data-ttu-id="931e4-433">In diesem Beispiel die `Person.IdInfo` -Eigenschaft gibt ein `IdInfo` Objekt.</span><span class="sxs-lookup"><span data-stu-id="931e4-433">In this example, the `Person.IdInfo` property returns an `IdInfo` object.</span></span> <span data-ttu-id="931e4-434">Wie die Ausgabe des Beispiels zeigt Wenn eine `Person` -Objekt geklont wird durch Aufrufen der <xref:System.Object.MemberwiseClone%2A> -Methode, die geklonte `Person` Objekt ist eine unabhängige Kopie des ursprünglichen Objekts, mit dem Unterschied, dass sie dieselbe `Person.IdInfo` Objektverweis.</span><span class="sxs-lookup"><span data-stu-id="931e4-434">As the output from the example shows, when a `Person` object is cloned by calling the <xref:System.Object.MemberwiseClone%2A> method, the cloned `Person` object is an independent copy of the original object, except that they share the same `Person.IdInfo` object reference.</span></span> <span data-ttu-id="931e4-435">Daher ändern des Klons `Person.IdInfo` eigenschaftsänderungen des ursprünglichen Objekts `Person.IdInfo` Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="931e4-435">As a result, modifying the clone's `Person.IdInfo` property changes the original object's `Person.IdInfo` property.</span></span> <span data-ttu-id="931e4-436">Wenn auf der anderen Seite ein tiefe Kopie-Vorgang ausgeführt wird, die geklonte `Person` Objekts, einschließlich der `Person.IdInfo` -Eigenschaft kann ohne Auswirkungen auf das ursprüngliche Objekt geändert werden.</span><span class="sxs-lookup"><span data-stu-id="931e4-436">On the other hand, when a deep copy operation is performed, the cloned `Person` object, including its `Person.IdInfo` property, can be modified without affecting the original object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">
          <span data-ttu-id="931e4-437">Das erste zu vergleichende Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-437">The first object to compare.</span>
          </span>
        </param>
        <param name="objB">
          <span data-ttu-id="931e4-438">Das zweite zu vergleichende Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-438">The second object  to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="931e4-439">Stellt fest, ob die angegebenen <see cref="T:System.Object" />-Instanzen dieselbe Instanz sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-439">Determines whether the specified <see cref="T:System.Object" /> instances are the same instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="931e4-440">
            <see langword="true" />, wenn <paramref name="objA" /> dieselbe Instanz wie <paramref name="objB" /> ist oder beide **NULL** sind, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-440">
              <see langword="true" /> if <paramref name="objA" /> is the same instance as <paramref name="objB" /> or if both are **null**; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="931e4-441">Im Gegensatz zu den <xref:System.Object.Equals%2A> -Methode und den Equality-Operator, der <xref:System.Object.ReferenceEquals%2A> Methode kann nicht überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="931e4-441">Unlike the <xref:System.Object.Equals%2A> method and the equality operator, the <xref:System.Object.ReferenceEquals%2A> method cannot be overridden.</span></span> <span data-ttu-id="931e4-442">Aus diesem Grund sollten Sie testen, zwei Objektverweise auf Gleichheit, und Sie sind nicht sicher sind, die Implementierung von der `Equals` -Methode, die Sie aufrufen können die <xref:System.Object.ReferenceEquals%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-442">Because of this, if you want to test two object references for equality and you are unsure about the implementation of the `Equals` method, you can call the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 <span data-ttu-id="931e4-443">Allerdings den Rückgabewert der <xref:System.Object.ReferenceEquals%2A> Methode scheint in diesen beiden Szenarien als anomal eingestuft haben:</span><span class="sxs-lookup"><span data-stu-id="931e4-443">However, the return value of the <xref:System.Object.ReferenceEquals%2A> method may appear to be anomalous in these two scenarios:</span></span>  
  
-   <span data-ttu-id="931e4-444">Wenn Sie Werttypen vergleichen zu können.</span><span class="sxs-lookup"><span data-stu-id="931e4-444">When comparing value types.</span></span> <span data-ttu-id="931e4-445">Wenn `objA` und `objB` Werttypen sind, werden mittels Boxing gepackte vor der Übergabe an die <xref:System.Object.ReferenceEquals%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-445">If `objA` and `objB` are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="931e4-446">Dies bedeutet, dass, wenn beide `objA` und `objB` darstellen derselben Instanz eines Werttyps, der <xref:System.Object.ReferenceEquals%2A> dennoch Methodenrückgabe `false`, wie im folgende Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="931e4-446">This means that if both `objA` and `objB` represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns `false`, as the following example shows.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     <span data-ttu-id="931e4-447">Weitere Informationen zu Boxing-Werttypen, finden Sie unter [Boxing und Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span><span class="sxs-lookup"><span data-stu-id="931e4-447">For information on boxing value types, see [Boxing and Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span></span>  
  
-   <span data-ttu-id="931e4-448">Beim Vergleichen von Zeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="931e4-448">When comparing strings.</span></span> <span data-ttu-id="931e4-449">Wenn `objA` und `objB` sind Zeichenfolgen, die <xref:System.Object.ReferenceEquals%2A> Methodenrückgabe `true` , wenn die Zeichenfolge internalisiert ist.</span><span class="sxs-lookup"><span data-stu-id="931e4-449">If `objA` and `objB` are strings, the <xref:System.Object.ReferenceEquals%2A> method returns `true` if the string is interned.</span></span> <span data-ttu-id="931e4-450">Er führt einen Test keine Wertgleichheit.</span><span class="sxs-lookup"><span data-stu-id="931e4-450">It does not perform a test for value equality.</span></span>  <span data-ttu-id="931e4-451">Im folgenden Beispiel `s1` und `s2` gleich sind, da sie zwei Instanzen von einer einzelnen Zeichenfolge für die im Internpool vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="931e4-451">In the following example, `s1` and `s2` are equal because they are two instances of a single interned string.</span></span> <span data-ttu-id="931e4-452">Allerdings `s3` und `s4` ungleich sind, da auch sie werden identische Werte aufweisen, die diese Zeichenfolge nicht internalisiert ist.</span><span class="sxs-lookup"><span data-stu-id="931e4-452">However, `s3` and `s4` are not equal, because although they are have identical string values, that string is not interned.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     <span data-ttu-id="931e4-453">Weitere Informationen zum Internalisieren von Zeichenfolgen finden Sie unter <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="931e4-453">For more information about string interning, see <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="931e4-454">Im folgenden Beispiel wird <xref:System.Object.ReferenceEquals%2A> zu bestimmen, ob zwei Objekte dieselbe Instanz sind.</span><span class="sxs-lookup"><span data-stu-id="931e4-454">The following example uses <xref:System.Object.ReferenceEquals%2A> to determine if two objects are the same instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="931e4-455">Gibt eine Zeichenfolge zurück, die das aktuelle Objekt darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-455">Returns a string that represents the current object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="931e4-456">Eine Zeichenfolge, die das aktuelle Objekt darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-456">A string that represents the current object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="931e4-457"><xref:System.Object.ToString%2A?displayProperty=nameWithType> ist die wichtigsten-Methode in der .NET Framework formatieren.</span><span class="sxs-lookup"><span data-stu-id="931e4-457"><xref:System.Object.ToString%2A?displayProperty=nameWithType> is the major formatting method in the .NET Framework.</span></span> <span data-ttu-id="931e4-458">Konvertiert ein Objekt in seine Zeichenfolgendarstellung, damit es für die Anzeige geeignet ist.</span><span class="sxs-lookup"><span data-stu-id="931e4-458">It converts an object to its string representation so that it is suitable for display.</span></span> <span data-ttu-id="931e4-459">(Weitere Informationen zur Formatierung-Unterstützung in .NET Framework finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).) Standardimplementierungen der der <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode zurück, der vollqualifizierte Name, der den Typ des Objekts.</span><span class="sxs-lookup"><span data-stu-id="931e4-459">(For information about formatting support in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Default implementations of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method return the fully qualified name of the object's type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="931e4-460">Sie können diese Seite erreicht, über den Link aus der Memberliste eines anderen Typs.</span><span class="sxs-lookup"><span data-stu-id="931e4-460">You may have reached this page by following the link from the member list of another type.</span></span> <span data-ttu-id="931e4-461">Dies liegt daran dieses Typs nicht überschreibt <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="931e4-461">That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="931e4-462">Stattdessen erbt es die Funktionalität der <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-462">Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="931e4-463">Typen, die häufig überschreiben die <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode, um ein geeigneter Zeichenfolgendarstellung eines bestimmten Typs bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="931e4-463">Types frequently override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide a more suitable string representation of a particular type.</span></span> <span data-ttu-id="931e4-464">Typen auch häufig überladen der <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode, um die Formatzeichenfolgen oder kulturabhängige Formatierung zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="931e4-464">Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide support for format strings or culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="931e4-465">In diesem Abschnitt</span><span class="sxs-lookup"><span data-stu-id="931e4-465">In this section:</span></span>  
  
 <span data-ttu-id="931e4-466">[Die Standardmethode für die Object.ToString()](#Default) </span><span class="sxs-lookup"><span data-stu-id="931e4-466">[The default Object.ToString() method](#Default) </span></span>  
 <span data-ttu-id="931e4-467">[Überschreiben der Object.ToString()-Methode](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="931e4-467">[Overriding the Object.ToString() method](#Overriding) </span></span>  
 <span data-ttu-id="931e4-468">[Überladen die ToString-Methode](#Overloading) </span><span class="sxs-lookup"><span data-stu-id="931e4-468">[Overloading the ToString method](#Overloading) </span></span>  
 <span data-ttu-id="931e4-469">[Erweitern Sie die Object.ToString-Methode](#Extending) </span><span class="sxs-lookup"><span data-stu-id="931e4-469">[Extending the Object.ToString method](#Extending) </span></span>  
 [<span data-ttu-id="931e4-470">Anmerkungen zu dieser Version für die Windows-Runtime</span><span class="sxs-lookup"><span data-stu-id="931e4-470">Notes for the Windows Runtime</span></span>](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a><span data-ttu-id="931e4-471">Die Standardmethode für die Object.ToString()</span><span class="sxs-lookup"><span data-stu-id="931e4-471">The default Object.ToString() method</span></span>  
 <span data-ttu-id="931e4-472">Die standardmäßige Implementierung des der <xref:System.Object.ToString%2A> Methode gibt den vollqualifizierten Namen des Typs von der <xref:System.Object>, wie im folgende Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="931e4-472">The default implementation of the <xref:System.Object.ToString%2A> method returns the fully qualified name of the type of the <xref:System.Object>, as the following example shows.</span></span>  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 <span data-ttu-id="931e4-473">Da <xref:System.Object> ist die Basisklasse aller Verweistypen in .NET Framework wird dieses Verhalten von Verweistypen, die nicht außer Kraft setzen geerbt der <xref:System.Object.ToString%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-473">Because <xref:System.Object> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <xref:System.Object.ToString%2A> method.</span></span> <span data-ttu-id="931e4-474">Dies wird anhand des folgenden Beispiels veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="931e4-474">The following example illustrates this.</span></span> <span data-ttu-id="931e4-475">Es definiert eine Klasse namens `Object1` , akzeptiert die standardmäßige Implementierung aller <xref:System.Object> Member.</span><span class="sxs-lookup"><span data-stu-id="931e4-475">It defines a class named `Object1` that accepts the default implementation of all <xref:System.Object> members.</span></span> <span data-ttu-id="931e4-476">Die <xref:System.Object.ToString%2A> Methode gibt den vollqualifizierten Typnamen des Objekts zurück.</span><span class="sxs-lookup"><span data-stu-id="931e4-476">Its <xref:System.Object.ToString%2A> method returns the object's fully qualified type name.</span></span>  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a><span data-ttu-id="931e4-477">Überschreiben der Object.ToString()-Methode</span><span class="sxs-lookup"><span data-stu-id="931e4-477">Overriding the Object.ToString() method</span></span>  
 <span data-ttu-id="931e4-478">Überschreiben Sie die Typen im Allgemeinen die <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode, um eine Zeichenfolge zurückzugeben, die die Objektinstanz darstellt.</span><span class="sxs-lookup"><span data-stu-id="931e4-478">Types commonly override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return a string that represents the object instance.</span></span> <span data-ttu-id="931e4-479">Beispielsweise Basistypen wie z. B. <xref:System.Char>, <xref:System.Int32>, und <xref:System.String> bieten <xref:System.Object.ToString%2A> Implementierungen, die die Zeichenfolgendarstellung des Werts zurückzugeben, die das Objekt darstellt.</span><span class="sxs-lookup"><span data-stu-id="931e4-479">For example, the base types such as <xref:System.Char>, <xref:System.Int32>, and <xref:System.String> provide <xref:System.Object.ToString%2A> implementations that return the string form of the value that the object represents.</span></span> <span data-ttu-id="931e4-480">Das folgende Beispiel definiert eine Klasse, `Object2`, überschreibt die <xref:System.Object.ToString%2A> Methode, um den Typnamen zusammen mit seinem Wert zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="931e4-480">The following example defines a class, `Object2`, that overrides the <xref:System.Object.ToString%2A> method to return the type name along with its value.</span></span>  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 <span data-ttu-id="931e4-481">Die folgende Tabelle listet die Kategorien in .NET Framework und gibt an, und zwar unabhängig davon, ob sie überschreiben die <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-481">The following table lists the type categories in the .NET Framework and indicates whether or not they override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
|<span data-ttu-id="931e4-482">Typkategorie</span><span class="sxs-lookup"><span data-stu-id="931e4-482">Type category</span></span>|<span data-ttu-id="931e4-483">Außerkraftsetzungen Object.ToString()</span><span class="sxs-lookup"><span data-stu-id="931e4-483">Overrides Object.ToString()</span></span>|<span data-ttu-id="931e4-484">Verhalten</span><span class="sxs-lookup"><span data-stu-id="931e4-484">Behavior</span></span>|  
|-------------------|-----------------------------------|--------------|  
|<span data-ttu-id="931e4-485">Klasse</span><span class="sxs-lookup"><span data-stu-id="931e4-485">Class</span></span>|<span data-ttu-id="931e4-486">n/v</span><span class="sxs-lookup"><span data-stu-id="931e4-486">n/a</span></span>|<span data-ttu-id="931e4-487">n/v</span><span class="sxs-lookup"><span data-stu-id="931e4-487">n/a</span></span>|  
|<span data-ttu-id="931e4-488">Struktur</span><span class="sxs-lookup"><span data-stu-id="931e4-488">Structure</span></span>|<span data-ttu-id="931e4-489">Ja (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="931e4-489">Yes (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="931e4-490">Identisch mit Object.ToString()</span><span class="sxs-lookup"><span data-stu-id="931e4-490">Same as Object.ToString()</span></span>|  
|<span data-ttu-id="931e4-491">Enumeration</span><span class="sxs-lookup"><span data-stu-id="931e4-491">Enumeration</span></span>|<span data-ttu-id="931e4-492">Ja (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="931e4-492">Yes (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="931e4-493">Den Namen des Members</span><span class="sxs-lookup"><span data-stu-id="931e4-493">The member name</span></span>|  
|<span data-ttu-id="931e4-494">Interface</span><span class="sxs-lookup"><span data-stu-id="931e4-494">Interface</span></span>|<span data-ttu-id="931e4-495">Nein</span><span class="sxs-lookup"><span data-stu-id="931e4-495">No</span></span>|<span data-ttu-id="931e4-496">n/v</span><span class="sxs-lookup"><span data-stu-id="931e4-496">n/a</span></span>|  
|<span data-ttu-id="931e4-497">delegate</span><span class="sxs-lookup"><span data-stu-id="931e4-497">Delegate</span></span>|<span data-ttu-id="931e4-498">Nein</span><span class="sxs-lookup"><span data-stu-id="931e4-498">No</span></span>|<span data-ttu-id="931e4-499">n/v</span><span class="sxs-lookup"><span data-stu-id="931e4-499">n/a</span></span>|  
  
 <span data-ttu-id="931e4-500">Finden Sie die Hinweise für Vererber-Abschnitt, um weitere Informationen zum Überschreiben <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="931e4-500">See the Notes to Inheritors section for additional information on overriding <xref:System.Object.ToString%2A>.</span></span>  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a><span data-ttu-id="931e4-501">Überladen die ToString-Methode</span><span class="sxs-lookup"><span data-stu-id="931e4-501">Overloading the ToString method</span></span>  
 <span data-ttu-id="931e4-502">Zusätzlich zum Überschreiben der parameterlosen <xref:System.Object.ToString?displayProperty=nameWithType> Methode überladen, viele Arten der `ToString` Methode, um Versionen der-Methode bereitzustellen, die Parameter akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="931e4-502">In addition to overriding the parameterless <xref:System.Object.ToString?displayProperty=nameWithType> method, many types overload the `ToString` method to provide versions of the method that accept parameters.</span></span> <span data-ttu-id="931e4-503">Dies erfolgt in den meisten Fällen um für die Variable Formatierung und kulturabhängige Formatierung zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="931e4-503">Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="931e4-504">Das folgende Beispiel überlädt die `ToString` Methode, um eine Ergebniszeichenfolge zurückzugeben, die den Wert verschiedener Felder dieses enthält ein `Automobile` Klasse.</span><span class="sxs-lookup"><span data-stu-id="931e4-504">The following example overloads the `ToString` method to return a result string that includes the value of various fields of an `Automobile` class.</span></span> <span data-ttu-id="931e4-505">Er definiert vier Formatzeichenfolgen: G, die den Modellnamen und Jahr zurückgibt. D, die den Modellnamen, Jahr und Anzahl von Türen zurückgibt; C, die den Modellnamen, Jahr und Anzahl der Zylinder zurückgibt; und ein, die eine Zeichenfolge mit allen vier Feldwerten zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="931e4-505">It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</span></span>  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 <span data-ttu-id="931e4-506">Im folgenden Beispiel wird die überladene <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode, um anzuzeigen, kulturabhängige Formatierung, der einen Währungswert.</span><span class="sxs-lookup"><span data-stu-id="931e4-506">The following example calls the overloaded <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method to display culture-sensitive formatting of a currency value.</span></span>  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 <span data-ttu-id="931e4-507">Weitere Informationen zu Formatzeichenfolgen und kulturabhängige Formatierung, finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="931e4-507">For more information on format strings and culture-sensitive formatting, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span> <span data-ttu-id="931e4-508">Die Formatzeichenfolgen, die von numerischen Werten unterstützt, finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="931e4-508">For the format strings supported by numeric values, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="931e4-509">Die Formatzeichenfolgen, die von Datums-und Uhrzeitwerte unterstützt werden, finden Sie unter [Standardformatzeichenfolgen für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="931e4-509">For the format strings supported by date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a><span data-ttu-id="931e4-510">Erweitern Sie die Object.ToString-Methode</span><span class="sxs-lookup"><span data-stu-id="931e4-510">Extending the Object.ToString method</span></span>  
 <span data-ttu-id="931e4-511">Da der Standardwert erbt <xref:System.Object.ToString%2A?displayProperty=nameWithType> -Methode, Sie können finden Sie das Verhalten nicht erwünscht und ihn ändern möchten.</span><span class="sxs-lookup"><span data-stu-id="931e4-511">Because a type inherits the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, you may find its behavior undesirable and want to change it.</span></span> <span data-ttu-id="931e4-512">Dies gilt insbesondere für Arrays und Auflistungsklassen.</span><span class="sxs-lookup"><span data-stu-id="931e4-512">This is particularly true of arrays and collection classes.</span></span> <span data-ttu-id="931e4-513">Während Sie erwarten, dass möglicherweise die `ToString` Methode ein Array oder eine Auflistung der Klasse zur Anzeige der Werte von Membern, stattdessen wird der vollqualifizierte Typname, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="931e4-513">While you may expect the `ToString` method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 <span data-ttu-id="931e4-514">Sie haben mehrere Optionen für die resultierende Zeichenfolge zu erzeugen, die Sie möchten.</span><span class="sxs-lookup"><span data-stu-id="931e4-514">You have several options to produce the result string that you'd like.</span></span>  
  
-   <span data-ttu-id="931e4-515">Wenn der Typ ist ein Array, ein Auflistungsobjekt oder ein Objekt, das implementiert der <xref:System.Collections.IEnumerable> oder <xref:System.Collections.Generic.IEnumerable%601> Schnittstellen, Sie können die Elemente auflisten, mit der `foreach` -Anweisung in c# oder die `For Each...Next` in Visual Basic erstellen.</span><span class="sxs-lookup"><span data-stu-id="931e4-515">If the type is an array, a collection object, or an object that implements the <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> interfaces, you can enumerate its elements by using the `foreach` statement in C# or the `For Each...Next` construct in Visual Basic.</span></span>  
  
-   <span data-ttu-id="931e4-516">Wenn die Klasse nicht `sealed` (in c#) oder `NotInheritable` (in Visual Basic), können Sie eine Wrapperklasse, die von der Basisklasse, deren erbt entwickeln <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode, die Sie anpassen möchten.</span><span class="sxs-lookup"><span data-stu-id="931e4-516">If the class is not `sealed` (in C#) or `NotInheritable` (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <xref:System.Object.ToString%2A?displayProperty=nameWithType> method you want to customize.</span></span> <span data-ttu-id="931e4-517">Mindestens erfordert dies, dass Sie die folgenden Schritte ausführen:</span><span class="sxs-lookup"><span data-stu-id="931e4-517">At a minimum, this requires that you do the following:</span></span>  
  
    1.  <span data-ttu-id="931e4-518">Implementieren Sie alle erforderlichen Konstruktoren.</span><span class="sxs-lookup"><span data-stu-id="931e4-518">Implement any necessary constructors.</span></span> <span data-ttu-id="931e4-519">Abgeleitete Klassen erben nicht die Konstruktoren ihrer Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="931e4-519">Derived classes do not inherit their base class constructors.</span></span>  
  
    2.  <span data-ttu-id="931e4-520">Überschreiben der <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode, um die Ergebniszeichenfolge zurückzugeben, die Sie möchten.</span><span class="sxs-lookup"><span data-stu-id="931e4-520">Override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the result string that you'd like.</span></span>  
  
     <span data-ttu-id="931e4-521">Das folgende Beispiel definiert eine Wrapperklasse für die <xref:System.Collections.Generic.List%601> Klasse.</span><span class="sxs-lookup"><span data-stu-id="931e4-521">The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class.</span></span> <span data-ttu-id="931e4-522">Es überschreibt die <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode, um den Wert der einzelnen Methoden von der Sammlung anstelle der vollqualifizierte Typname anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="931e4-522">It overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to display the value of each method of the collection rather than the fully qualified type name.</span></span>  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   <span data-ttu-id="931e4-523">Entwickeln einer [Erweiterungsmethode](~/docs/standard/design-guidelines/extension-methods.md) , die die Ergebniszeichenfolge, die Sie möchten zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="931e4-523">Develop an [extension method](~/docs/standard/design-guidelines/extension-methods.md) that returns the result string that you want.</span></span> <span data-ttu-id="931e4-524">Beachten Sie, dass Sie die Standardeinstellung außer Kraft setzen können nicht <xref:System.Object.ToString%2A?displayProperty=nameWithType> -Methode in der auf diese Weise (d. h. der Erweiterungsklasse (in c#) oder dem Modul (in Visual Basic) sind keine parameterlose Methode namens `ToString` , der anstelle des ursprünglichen Typs aufgerufen `ToString` Methode .</span><span class="sxs-lookup"><span data-stu-id="931e4-524">Note that you can't override the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named `ToString` that is called in place of the original type's `ToString` method.</span></span> <span data-ttu-id="931e4-525">Sie müssen einen anderen Namen für Ihre parameterlosen bieten `ToString` Ersatz.</span><span class="sxs-lookup"><span data-stu-id="931e4-525">You'll have to provide some other name for your parameterless `ToString` replacement.</span></span>  
  
     <span data-ttu-id="931e4-526">Das folgende Beispiel definiert zwei Methoden, die erweitert die <xref:System.Collections.Generic.List%601> Klasse: eine parameterlose `ToString2` -Methode, und ein `ToString` -Methode mit einer <xref:System.String> Parameter, der eine Formatzeichenfolge darstellt.</span><span class="sxs-lookup"><span data-stu-id="931e4-526">The following example defines two methods that extend the <xref:System.Collections.Generic.List%601> class: a parameterless `ToString2` method, and a `ToString` method with a <xref:System.String> parameter that represents a format string.</span></span>  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="931e4-527">Anmerkungen zu dieser von der [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="931e4-527">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="931e4-528">Beim Aufrufen der <xref:System.Object.ToString%2A> Methode einer Klasse in der [!INCLUDE[wrt](~/includes/wrt-md.md)], es ist das Standardverhalten für Klassen, die nicht außer Kraft setzen <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="931e4-528">When you call the <xref:System.Object.ToString%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="931e4-529">Dies ist Teil der Unterstützung von .NET Framework für die [!INCLUDE[wrt](~/includes/wrt-md.md)] (finden Sie unter [.NET Framework Unterstützung für Windows Store-Apps und Windows-Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="931e4-529">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="931e4-530">Klassen in der [!INCLUDE[wrt](~/includes/wrt-md.md)] nicht erben <xref:System.Object>, und implementieren nicht immer eine <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="931e4-530">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and don’t always implement a <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="931e4-531">Allerdings sie immer anscheinend <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, und <xref:System.Object.GetHashCode%2A> Methoden ein, wenn Sie diese in Ihrem C#- oder Visual Basic-Code verwenden und .NET Framework ein Standardverhalten für diese Methoden bietet.</span><span class="sxs-lookup"><span data-stu-id="931e4-531">However, they always appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</span></span>  
  
 <span data-ttu-id="931e4-532">Beginnend mit der [!INCLUDE[net_v451](~/includes/net-v451-md.md)], verwendet die common Language Runtime [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) auf eine [!INCLUDE[wrt](~/includes/wrt-md.md)] Objekt vor dem Fallback auf die standardmäßige Implementierung des <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="931e4-532">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], the common language runtime will use [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) on a [!INCLUDE[wrt](~/includes/wrt-md.md)] object before falling back to the default implementation of <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]<span data-ttu-id="931e4-533"> Klassen, die in c# oder Visual Basic geschrieben sind, können außer Kraft setzen der <xref:System.Object.ToString%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="931e4-533"> classes that are written in C# or Visual Basic can override the <xref:System.Object.ToString%2A> method.</span></span>  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a><span data-ttu-id="931e4-534">Die [!INCLUDE[wrt](~/includes/wrt-md.md)] und die IStringable-Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="931e4-534">The [!INCLUDE[wrt](~/includes/wrt-md.md)] and the IStringable Interface</span></span>  
 <span data-ttu-id="931e4-535">Beginnend mit [!INCLUDE[win81](~/includes/win81-md.md)], [!INCLUDE[wrt](~/includes/wrt-md.md)] enthält ein [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) Schnittstelle, deren einzige Methode, [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), eine grundlegende formatierungsunterstützung vergleichbar mit der bietet von bereitgestellten <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="931e4-535">Starting with [!INCLUDE[win81](~/includes/win81-md.md)], the [!INCLUDE[wrt](~/includes/wrt-md.md)] includes an [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface whose single method, [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), provides basic formatting support comparable to that provided by <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="931e4-536">Sie sollten nicht implementieren, um Mehrdeutigkeit zu vermeiden, [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) für verwaltete Typen.</span><span class="sxs-lookup"><span data-stu-id="931e4-536">To prevent ambiguity, you should not implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on managed types.</span></span>  
  
 <span data-ttu-id="931e4-537">Wenn verwaltete Objekte heißen durch systemeigenen Code oder durch Code in Sprachen wie JavaScript oder C++ / CX können sie sich wie implementieren [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span><span class="sxs-lookup"><span data-stu-id="931e4-537">When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span> <span data-ttu-id="931e4-538">Die common Language Runtime leitet automatisch Aufrufe von [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) zu <xref:System.Object.ToString%2A?displayProperty=nameWithType> im [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) ist für das verwaltete Objekt nicht implementiert.</span><span class="sxs-lookup"><span data-stu-id="931e4-538">The common language runtime will automatically route calls from [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) to <xref:System.Object.ToString%2A?displayProperty=nameWithType> in the event [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) is not implemented on the managed object.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="931e4-539">Da die common Language Runtime automatisch-implementiert [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) für alle verwalteten Typen im [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] -apps, es wird empfohlen, dass Sie keine eigene haben [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) Implementierung.</span><span class="sxs-lookup"><span data-stu-id="931e4-539">Because the common language runtime auto-implements [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation.</span></span> <span data-ttu-id="931e4-540">Implementieren von [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) strafbar unerwartetem Verhalten beim Aufrufen von `ToString` aus der [!INCLUDE[wrt](~/includes/wrt-md.md)], C++ / CX oder JavaScript.</span><span class="sxs-lookup"><span data-stu-id="931e4-540">Implementing [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript.</span></span>  
  
 <span data-ttu-id="931e4-541">Wenn Sie sich entschließen, implementieren Sie [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in einem öffentlich verwalteten Typ, der im exportiert wird eine [!INCLUDE[wrt](~/includes/wrt-md.md)] -Komponente, die folgenden Einschränkungen gelten:</span><span class="sxs-lookup"><span data-stu-id="931e4-541">If you do choose to implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in a public managed type that is exported in a [!INCLUDE[wrt](~/includes/wrt-md.md)] component, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="931e4-542">Sie können definieren, die [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) -Schnittstelle nur in einer "class Implements"-Beziehung, z. B.</span><span class="sxs-lookup"><span data-stu-id="931e4-542">You can define the [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface only in a "class implements" relationship, such as</span></span>  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     <span data-ttu-id="931e4-543">in C# oder</span><span class="sxs-lookup"><span data-stu-id="931e4-543">in C#, or</span></span>  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     <span data-ttu-id="931e4-544">in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="931e4-544">in Visual Basic.</span></span>  
  
-   <span data-ttu-id="931e4-545">Sie können nicht implementieren [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) auf einer Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="931e4-545">You cannot implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on an interface.</span></span>  
  
-   <span data-ttu-id="931e4-546">Sie können einen Parameter vom Typ nicht deklarieren [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span><span class="sxs-lookup"><span data-stu-id="931e4-546">You cannot declare a parameter to be of type [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span>  
  
-   <span data-ttu-id="931e4-547">[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) darf nicht der Rückgabetyp einer Methode, eine Eigenschaft oder ein Feld sein.</span><span class="sxs-lookup"><span data-stu-id="931e4-547">[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cannot be the return type of a method, property, or field.</span></span>  
  
-   <span data-ttu-id="931e4-548">Sie können nicht ausgeblendet werden Ihre [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) Implementierung von Basisklassen mithilfe eine Methodendefinition wie die folgende:</span><span class="sxs-lookup"><span data-stu-id="931e4-548">You cannot hide your [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation from base classes by using a method definition such as the following:</span></span>  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     <span data-ttu-id="931e4-549">Stattdessen die [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) Implementierung muss die basisklassenimplementierung immer überschreiben.</span><span class="sxs-lookup"><span data-stu-id="931e4-549">Instead, the [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation must always override the base class implementation.</span></span> <span data-ttu-id="931e4-550">Sie können eine `ToString`-Implementierung nur ausblenden, indem Sie sie auf einer stark typisierten Klasseninstanz aufrufen.</span><span class="sxs-lookup"><span data-stu-id="931e4-550">You can hide a `ToString` implementation only by invoking it on a strongly typed class instance.</span></span>  
  
 <span data-ttu-id="931e4-551">Beachten Sie, die unter einer Vielzahl von Bedingungen Aufrufe von nativem Code zu einem verwalteten Typ, der implementiert [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) oder blendet Sie aus der [ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) Implementierung kann zu unerwartetem Verhalten führen.</span><span class="sxs-lookup"><span data-stu-id="931e4-551">Note that under a variety of conditions, calls from native code to a managed type that implements [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) or hides its [ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation can produce unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="931e4-552">
            <para>Wenn Sie Ihre eigenen Typen implementieren, sollten Sie Sie überschreiben die <see cref="M:System.Object.ToString" /> Methode zum Zurückgeben von Werten, die für diese Typen von Bedeutung sind. Abgeleitete Klassen, die mehr Kontrolle über die Formatierung als erfordern <see cref="M:System.Object.ToString" /> bietet können implementieren die <see cref="T:System.IFormattable" /> Schnittstelle. Die <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> Methode ermöglicht es Ihnen, die Formatzeichenfolgen zu definieren, die die Formatierung steuern und Verwenden einer <see cref="T:System.IFormatProvider" /> -Objekt, das für die kulturabhängige Formatierung bereitstellen kann.  Der überschreibt die <see cref="M:System.Object.ToString" /> Methode sollte die folgenden Richtlinien:-die zurückgegebene Zeichenfolge sollte sein, benutzerfreundliche und von Menschen gelesen werden.  -Die zurückgegebene Zeichenfolge sollte den Wert der Objektinstanz eindeutig identifizieren.  -Die zurückgegebene Zeichenfolge sollte so kurz wie möglich sein, damit es für die Anzeige von einem Debugger geeignet ist.  -Für Ihre <see cref="M:System.Object.ToString" /> außer Kraft setzen sollten keine zurückgeben <see cref="F:System.String.Empty" /> oder ein null-Zeichenfolge.  -Für Ihre <see cref="M:System.Object.ToString" /> außer Kraft setzen sollte keine Ausnahme ausgelöst.  – Wenn die angegebene Zeichenfolgendarstellung einer Instanz kulturabhängig ist oder auf verschiedene Weise formatiert werden kann, implementieren die <see cref="T:System.IFormattable" /> Schnittstelle.  – Wenn die zurückgegebene Zeichenfolge vertrauliche Informationen enthält, sollten Sie zunächst eine entsprechende Berechtigung anfordern. Wenn die Anforderung erfolgreich ist, können Sie die vertrauliche Informationen zurückgegeben wird. Andernfalls sollten Sie eine Zeichenfolge zurückgeben, die vertrauliche Informationen ausschließt.  -Für Ihre <see cref="M:System.Object.ToString" /> außer Kraft setzen müssen keine wahrnehmbaren Nebeneffekte zu schwierigkeiten beim Debuggen zu vermeiden. Z. B. einen Aufruf der <see cref="M:System.Object.ToString" /> Methode sollte den Wert der Instanzfelder nicht ändern.  – Wenn der Typ eine Analysemethode implementiert (oder <see langword="Parse" /> oder <see langword="TryParse" /> -Methode, einen Konstruktor oder eine andere statische Methode, die eine Instanz des Typs aus einer Zeichenfolge instanziiert), Sie sollten sicherstellen, dass die zurückgegebene Zeichenfolge den <see cref="M:System.Object.ToString" /> Methode kann sein, Konvertiert eine Objektinstanz.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="931e4-552">
              <para>When you implement your own types, you should override the <see cref="M:System.Object.ToString" /> method to return values that are meaningful for those types. Derived classes that require more control over formatting than <see cref="M:System.Object.ToString" /> provides can implement the <see cref="T:System.IFormattable" /> interface. Its <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> method enables you to define format strings that control formatting and to use an <see cref="T:System.IFormatProvider" /> object that can provide for culture-specific formatting.  Overrides of the <see cref="M:System.Object.ToString" /> method should follow these guidelines:  -   The returned string should be friendly and readable by humans.  -   The returned string should uniquely identify the value of the object instance.  -   The returned string should be as short as possible so that it is suitable for display by a debugger.  -   Your <see cref="M:System.Object.ToString" /> override should not return <see cref="F:System.String.Empty" /> or a null string.  -   Your <see cref="M:System.Object.ToString" /> override should not throw an exception.  -   If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <see cref="T:System.IFormattable" /> interface.  -   If the returned string includes sensitive information, you should first demand an appropriate permission. If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.  -   Your <see cref="M:System.Object.ToString" /> override should have no observable side effects to avoid complications in debugging. For example, a call to the <see cref="M:System.Object.ToString" /> method should not change the value of instance fields.  -   If your type implements a parsing method (or <see langword="Parse" /> or <see langword="TryParse" /> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <see cref="M:System.Object.ToString" /> method can be converted to an object instance.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>