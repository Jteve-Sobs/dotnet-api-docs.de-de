<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1712c4257543163b0bf3c5ed7c94aa080d7b45b8" /><Meta Name="ms.sourcegitcommit" Value="97dd2e4ee16a6215aef37f928d45e872fc816c6f" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="01/02/2020" /><Meta Name="ms.locfileid" Value="75615222" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="3df45-101">Unterstützt alle Klassen in der .NET-Klassenhierarchie und stellt abgeleiteten Klassen Low-Level-Dienste zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="3df45-101">Supports all classes in the .NET class hierarchy and provides low-level services to derived classes.</span></span> <span data-ttu-id="3df45-102">Dies ist die ultimative Basisklasse aller .NET-Klassen und stellt den Stamm der Typhierarchie dar.</span><span class="sxs-lookup"><span data-stu-id="3df45-102">This is the ultimate base class of all .NET classes; it is the root of the type hierarchy.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3df45-103">In der Regel ist es nicht erforderlich, dass eine Klasse die Vererbung aus <xref:System.Object> deklariert, da die Vererbung implizit ist.</span><span class="sxs-lookup"><span data-stu-id="3df45-103">Languages typically do not require a class to declare inheritance from <xref:System.Object> because the inheritance is implicit.</span></span>  
  
 <span data-ttu-id="3df45-104">Da alle Klassen in .net von <xref:System.Object>abgeleitet sind, ist jede Methode, die in der <xref:System.Object>-Klasse definiert ist, in allen Objekten im System verfügbar.</span><span class="sxs-lookup"><span data-stu-id="3df45-104">Because all classes in .NET are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system.</span></span> <span data-ttu-id="3df45-105">Abgeleitete Klassen können einige dieser Methoden außer Kraft setzen und überschreiben, einschließlich:</span><span class="sxs-lookup"><span data-stu-id="3df45-105">Derived classes can and do override some of these methods, including:</span></span>  
  
-   <span data-ttu-id="3df45-106"><xref:System.Object.Equals%2A>: unterstützt Vergleiche zwischen Objekten.</span><span class="sxs-lookup"><span data-stu-id="3df45-106"><xref:System.Object.Equals%2A> - Supports comparisons between objects.</span></span>  
  
-   <span data-ttu-id="3df45-107"><xref:System.Object.Finalize%2A>: führt Bereinigungs Vorgänge aus, bevor ein Objekt automatisch freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-107"><xref:System.Object.Finalize%2A> - Performs cleanup operations before an object is automatically reclaimed.</span></span>  
  
-   <span data-ttu-id="3df45-108"><xref:System.Object.GetHashCode%2A>-generiert eine Zahl, die dem Wert des-Objekts entspricht, um die Verwendung einer Hash Tabelle zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="3df45-108"><xref:System.Object.GetHashCode%2A> - Generates a number corresponding to the value of the object to support the use of a hash table.</span></span>  
  
-   <span data-ttu-id="3df45-109"><xref:System.Object.ToString%2A>: stellt eine lesbare Text Zeichenfolge her, die eine Instanz der-Klasse beschreibt.</span><span class="sxs-lookup"><span data-stu-id="3df45-109"><xref:System.Object.ToString%2A> - Manufactures a human-readable text string that describes an instance of the class.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="3df45-110">Überlegungen zur Leistung</span><span class="sxs-lookup"><span data-stu-id="3df45-110">Performance Considerations</span></span>  
 <span data-ttu-id="3df45-111">Wenn Sie eine Klasse entwerfen, z. b. eine Auflistung, die einen beliebigen Objekttyp verarbeiten muss, können Sie Klassenmember erstellen, die Instanzen der <xref:System.Object> Klasse akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="3df45-111">If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class.</span></span> <span data-ttu-id="3df45-112">Der Vorgang zum Boxing und Unboxing eines Typs führt jedoch zu Leistungseinbußen.</span><span class="sxs-lookup"><span data-stu-id="3df45-112">However, the process of boxing and unboxing a type carries a performance cost.</span></span> <span data-ttu-id="3df45-113">Wenn Sie wissen, dass Ihre neue Klasse häufig bestimmte Werttypen behandelt, können Sie eine von zwei Taktiken verwenden, um die Kosten des Boxens zu minimieren.</span><span class="sxs-lookup"><span data-stu-id="3df45-113">If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</span></span>  
  
-   <span data-ttu-id="3df45-114">Erstellen Sie eine allgemeine Methode, die einen <xref:System.Object> Typ akzeptiert, und einen Satz von typspezifischen Methoden Überladungen, die jeden Werttyp akzeptieren, der von der Klasse häufig verarbeitet wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-114">Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</span></span> <span data-ttu-id="3df45-115">Wenn eine typspezifische Methode vorhanden ist, die den aufrufenden Parametertyp akzeptiert, erfolgt kein Boxing, und die typspezifische Methode wird aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="3df45-115">If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</span></span> <span data-ttu-id="3df45-116">Wenn kein Methoden Argument vorhanden ist, das mit dem aufrufenden Parametertyp übereinstimmt, wird der-Parameter geachtelt, und die allgemeine-Methode wird aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="3df45-116">If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</span></span>  
  
-   <span data-ttu-id="3df45-117">Entwerfen Sie Ihren Typ und seine Member, um Generika zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="3df45-117">Design your type and its members to use generics.</span></span> <span data-ttu-id="3df45-118">Der Common Language Runtime erstellt einen geschlossenen generischen Typ, wenn Sie eine Instanz der Klasse erstellen und ein generisches Typargument angeben.</span><span class="sxs-lookup"><span data-stu-id="3df45-118">The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</span></span> <span data-ttu-id="3df45-119">Die generische Methode ist typspezifisch und kann aufgerufen werden, ohne den aufrufenden Parameter zu Boxing.</span><span class="sxs-lookup"><span data-stu-id="3df45-119">The generic method is type-specific and can be invoked without boxing the calling parameter.</span></span>  
  
 <span data-ttu-id="3df45-120">Obwohl es manchmal notwendig ist, allgemeine Klassen zu entwickeln, die <xref:System.Object> Typen akzeptieren und zurückgeben, können Sie die Leistung verbessern, indem Sie auch eine typspezifische Klasse zum Verarbeiten eines häufig verwendeten Typs bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="3df45-120">Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</span></span> <span data-ttu-id="3df45-121">Wenn Sie beispielsweise eine Klasse angeben, die für das Festlegen und das erhalten von booleschen Werten spezifisch ist, werden die Kosten für das Boxing und das Unboxing von booleschen Werten vermieden.</span><span class="sxs-lookup"><span data-stu-id="3df45-121">For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3df45-122">Im folgenden Beispiel wird ein von der <xref:System.Object>-Klasse abgeleiteter Punkttyp definiert, der viele der virtuellen Methoden der <xref:System.Object>-Klasse überschreibt.</span><span class="sxs-lookup"><span data-stu-id="3df45-122">The following example defines a Point type derived from the <xref:System.Object> class and overrides many of the virtual methods of the <xref:System.Object> class.</span></span> <span data-ttu-id="3df45-123">Außerdem wird im Beispiel gezeigt, wie viele der statischen Methoden und Instanzmethoden der <xref:System.Object> Klasse aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-123">In addition, the example shows how to call many of the static and instance methods of the <xref:System.Object> class.</span></span>  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="3df45-124">Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind Thread sicher.</span><span class="sxs-lookup"><span data-stu-id="3df45-124">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span></span> <span data-ttu-id="3df45-125">Instanzmember sind nicht garantiert Thread sicher.</span><span class="sxs-lookup"><span data-stu-id="3df45-125">Instance members are not guaranteed to be thread-safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3df45-126">Initialisiert eine neue Instanz der <see cref="T:System.Object" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="3df45-126">Initializes a new instance of the <see cref="T:System.Object" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3df45-127">Dieser Konstruktor wird von Konstruktoren in abgeleiteten Klassen aufgerufen, kann aber auch verwendet werden, um direkt eine Instanz der <xref:System.Object>-Klasse zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="3df45-127">This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref:System.Object> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3df45-128">Stellt fest, ob zwei Objektinstanzen gleich sind.</span><span class="sxs-lookup"><span data-stu-id="3df45-128">Determines whether two object instances are equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="3df45-129">Das Objekt, das mit dem aktuellen Objekt verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="3df45-129">The object to compare with the current object.</span></span></param>
        <summary><span data-ttu-id="3df45-130">Ermittelt, ob das angegebene Objekt und das aktuelle Objekt gleich sind.</span><span class="sxs-lookup"><span data-stu-id="3df45-130">Determines whether the specified object is equal to the current object.</span></span></summary>
        <returns><span data-ttu-id="3df45-131"><see langword="true" />, wenn das angegebene Objekt und das aktuelle Objekt gleich sind, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3df45-131"><see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3df45-132">Der Typ des Vergleichs zwischen der aktuellen Instanz und dem `obj`-Parameter hängt davon ab, ob es sich bei der aktuellen Instanz um einen Verweistyp oder einen Werttyp handelt.</span><span class="sxs-lookup"><span data-stu-id="3df45-132">The type of comparison between the current instance and the `obj` parameter depends on whether the current instance is a reference type or a value type.</span></span>  

-   <span data-ttu-id="3df45-133">Wenn es sich bei der aktuellen Instanz um einen Verweistyp handelt, testet die <xref:System.Object.Equals%28System.Object%29>-Methode auf Verweis Gleichheit, und ein aufzurufende <xref:System.Object.Equals%28System.Object%29>-Methode entspricht einem-Rückruf der <xref:System.Object.ReferenceEquals%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="3df45-133">If the current instance is a reference type, the <xref:System.Object.Equals%28System.Object%29> method tests for reference equality, and a call to the <xref:System.Object.Equals%28System.Object%29> method is equivalent to a call to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="3df45-134">Verweis Gleichheit bedeutet, dass die zu vergleichenden Objektvariablen auf das gleiche Objekt verweisen.</span><span class="sxs-lookup"><span data-stu-id="3df45-134">Reference equality means that the object variables that are compared refer to the same object.</span></span> <span data-ttu-id="3df45-135">Das folgende Beispiel veranschaulicht das Ergebnis eines solchen Vergleichs.</span><span class="sxs-lookup"><span data-stu-id="3df45-135">The following example illustrates the result of such a comparison.</span></span> <span data-ttu-id="3df45-136">Es definiert eine `Person`-Klasse, die ein Verweistyp ist, und ruft den `Person`-Klassenkonstruktor auf, um zwei neue `Person`-Objekte zu instanziieren, `person1a` und `person2`, die denselben Wert aufweisen.</span><span class="sxs-lookup"><span data-stu-id="3df45-136">It defines a `Person` class, which is a reference type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1a` and `person2`, which have the same value.</span></span> <span data-ttu-id="3df45-137">Außerdem wird `person1a` einer anderen Objektvariablen zugewiesen, `person1b`.</span><span class="sxs-lookup"><span data-stu-id="3df45-137">It also assigns `person1a` to another object variable, `person1b`.</span></span> <span data-ttu-id="3df45-138">Wie die Ausgabe des Beispiels zeigt, sind `person1a` und `person1b` gleich, da Sie auf dasselbe Objekt verweisen.</span><span class="sxs-lookup"><span data-stu-id="3df45-138">As the output from the example shows, `person1a` and `person1b` are equal because they reference the same object.</span></span> <span data-ttu-id="3df45-139">Allerdings sind `person1a` und `person2` nicht gleich, obwohl Sie denselben Wert aufweisen.</span><span class="sxs-lookup"><span data-stu-id="3df45-139">However, `person1a` and `person2` are not equal, although they have the same value.</span></span>  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   <span data-ttu-id="3df45-140">Wenn die aktuelle Instanz ein Werttyp ist, testet die <xref:System.Object.Equals%28System.Object%29>-Methode auf Wert Gleichheit.</span><span class="sxs-lookup"><span data-stu-id="3df45-140">If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality.</span></span> <span data-ttu-id="3df45-141">Wert Gleichheit bedeutet Folgendes:</span><span class="sxs-lookup"><span data-stu-id="3df45-141">Value equality means the following:</span></span>  
  
    -   <span data-ttu-id="3df45-142">Die beiden Objekte weisen denselben Typ auf.</span><span class="sxs-lookup"><span data-stu-id="3df45-142">The two objects are of the same type.</span></span> <span data-ttu-id="3df45-143">Wie im folgenden Beispiel gezeigt, entspricht ein <xref:System.Byte> Objekt mit dem Wert 12 nicht einem <xref:System.Int32> Objekt mit dem Wert 12, da die beiden-Objekte unterschiedliche Lauf Zeit Typen aufweisen.</span><span class="sxs-lookup"><span data-stu-id="3df45-143">As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types.</span></span>  
  
         [!code-csharp-interactive[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   <span data-ttu-id="3df45-144">Die Werte der öffentlichen und privaten Felder der beiden Objekte sind gleich.</span><span class="sxs-lookup"><span data-stu-id="3df45-144">The values of the public and private fields of the two objects are equal.</span></span> <span data-ttu-id="3df45-145">Im folgenden Beispiel wird auf Wert Gleichheit getestet.</span><span class="sxs-lookup"><span data-stu-id="3df45-145">The following example tests for value equality.</span></span> <span data-ttu-id="3df45-146">Er definiert eine `Person` Struktur, bei der es sich um einen Werttyp handelt, und ruft den `Person`-Klassenkonstruktor auf, um zwei neue `Person` Objekte zu instanziieren, `person1` und `person2`, die denselben Wert aufweisen.</span><span class="sxs-lookup"><span data-stu-id="3df45-146">It defines a `Person` structure, which is a value type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1` and `person2`, which have the same value.</span></span> <span data-ttu-id="3df45-147">Wie die Ausgabe des Beispiels zeigt, obwohl die beiden Objektvariablen auf verschiedene Objekte verweisen, `person1` und `person2` gleich sind, da Sie den gleichen Wert für das Feld private `personName` haben.</span><span class="sxs-lookup"><span data-stu-id="3df45-147">As the output from the example shows, although the two object variables refer to different objects, `person1` and `person2` are equal because they have the same value for the private `personName` field.</span></span>  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 <span data-ttu-id="3df45-148">Da die <xref:System.Object>-Klasse die Basisklasse für alle Typen in der .NET Framework ist, stellt die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>-Methode den Standard Gleichheits Vergleich für alle anderen Typen bereit.</span><span class="sxs-lookup"><span data-stu-id="3df45-148">Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method provides the default equality comparison for all other types.</span></span> <span data-ttu-id="3df45-149">Typen überschreiben jedoch oft die <xref:System.Object.Equals%2A>-Methode, um Wert Gleichheit zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="3df45-149">However, types often override the <xref:System.Object.Equals%2A> method to implement value equality.</span></span> <span data-ttu-id="3df45-150">Weitere Informationen finden Sie in den Abschnitten "Hinweise zu Aufrufern und Notizen für Vererbung".</span><span class="sxs-lookup"><span data-stu-id="3df45-150">For more information, see the Notes for Callers and Notes for Inheritors sections.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="3df45-151">Hinweise für den [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="3df45-151">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="3df45-152">Wenn Sie die <xref:System.Object.Equals%28System.Object%29>-Methoden Überladung für eine Klasse im [!INCLUDE[wrt](~/includes/wrt-md.md)]aufrufen, stellt Sie das Standardverhalten für Klassen bereit, die <xref:System.Object.Equals%28System.Object%29>nicht überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-152">When you call the <xref:System.Object.Equals%28System.Object%29> method overload on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="3df45-153">Dies ist ein Teil der Unterstützung, die der .NET Framework für die [!INCLUDE[wrt](~/includes/wrt-md.md)] bietet (siehe [.NET Framework Support für Windows Store-Apps und Windows-Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="3df45-153">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="3df45-154">Klassen im [!INCLUDE[wrt](~/includes/wrt-md.md)] erben <xref:System.Object>nicht und implementieren derzeit keine <xref:System.Object.Equals%28System.Object%29>-Methode.</span><span class="sxs-lookup"><span data-stu-id="3df45-154">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement an <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="3df45-155">Sie scheinen jedoch <xref:System.Object.ToString%2A>-, <xref:System.Object.Equals%28System.Object%29>-und <xref:System.Object.GetHashCode%2A>-Methoden zu haben, wenn Sie Sie im C# -oder-Visual Basic Code verwenden, und das .NET Framework stellt das Standardverhalten für diese Methoden bereit.</span><span class="sxs-lookup"><span data-stu-id="3df45-155">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="3df45-156">Klassen, die in C# oder Visual Basic geschrieben sind, können die <xref:System.Object.Equals%28System.Object%29>-Methoden Überladung überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-156">classes that are written in C# or Visual Basic can override the <xref:System.Object.Equals%28System.Object%29> method overload.</span></span>  
  
## <a name="notes-for-callers"></a><span data-ttu-id="3df45-157">Hinweise für Aufrufer</span><span class="sxs-lookup"><span data-stu-id="3df45-157">Notes for Callers</span></span>  
 <span data-ttu-id="3df45-158">Abgeleitete Klassen überschreiben häufig die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>-Methode, um Wert Gleichheit zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="3df45-158">Derived classes frequently override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to implement value equality.</span></span> <span data-ttu-id="3df45-159">Außerdem bieten Typen häufig eine zusätzliche stark typisierte Überladung für die `Equals`-Methode, in der Regel durch Implementieren der <xref:System.IEquatable%601>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="3df45-159">In addition, types also frequently provide an additional strongly typed overload to the `Equals` method, typically by implementing the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="3df45-160">Wenn Sie die `Equals`-Methode zum Testen auf Gleichheit aufzurufen, sollten Sie wissen, ob die aktuelle Instanz <xref:System.Object.Equals%2A?displayProperty=nameWithType> außer Kraft setzt und verstehen, wie ein bestimmter Aufrufsatz einer `Equals` Methode aufgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-160">When you call the `Equals` method to test for equality, you should know whether the current instance overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType> and understand how a particular call to an `Equals` method is resolved.</span></span> <span data-ttu-id="3df45-161">Andernfalls können Sie einen Test auf Gleichheit durchführen, der sich von der vorgesehenen Methode unterscheidet, und die Methode gibt möglicherweise einen unerwarteten Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="3df45-161">Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</span></span>  
  
 <span data-ttu-id="3df45-162">Dies wird im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="3df45-162">The following example provides an illustration.</span></span> <span data-ttu-id="3df45-163">Er instanziiert drei <xref:System.Text.StringBuilder> Objekte mit identischen Zeichen folgen und führt dann vier Aufrufe an `Equals` Methoden aus.</span><span class="sxs-lookup"><span data-stu-id="3df45-163">It instantiates three <xref:System.Text.StringBuilder> objects with identical strings, and then makes four calls to `Equals` methods.</span></span> <span data-ttu-id="3df45-164">Der erste Methoden Aufrufwert gibt `true`zurück, und die restlichen drei Rückgabe `false`.</span><span class="sxs-lookup"><span data-stu-id="3df45-164">The first method call returns `true`, and the remaining three return `false`.</span></span>  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 <span data-ttu-id="3df45-165">Im ersten Fall wird die stark typisierte <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType>-Methoden Überladung, die auf Wert Gleichheit testet, aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="3df45-165">In the first case, the strongly typed <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> method overload, which tests for value equality, is called.</span></span> <span data-ttu-id="3df45-166">Da die den zwei <xref:System.Text.StringBuilder> Objekten zugewiesenen Zeichen folgen gleich sind, gibt die Methode `true`zurück.</span><span class="sxs-lookup"><span data-stu-id="3df45-166">Because the strings assigned to the two <xref:System.Text.StringBuilder> objects are equal, the method returns `true`.</span></span> <span data-ttu-id="3df45-167">Die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>wird von <xref:System.Text.StringBuilder> jedoch nicht überschrieben.</span><span class="sxs-lookup"><span data-stu-id="3df45-167">However, <xref:System.Text.StringBuilder> does not override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3df45-168">Wenn das <xref:System.Text.StringBuilder> Objekt in eine <xref:System.Object>umgewandelt wird, wenn eine <xref:System.Text.StringBuilder> Instanz einer Variablen vom Typ <xref:System.Object>zugewiesen ist, und wenn die <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>-Methode zwei <xref:System.Text.StringBuilder> Objekten übermittelt wird, wird die standardmäßige <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="3df45-168">Because of this, when the <xref:System.Text.StringBuilder> object is cast to an <xref:System.Object>, when a <xref:System.Text.StringBuilder> instance is assigned to a variable of type <xref:System.Object>, and when the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> method is passed two <xref:System.Text.StringBuilder> objects, the default <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="3df45-169">Da <xref:System.Text.StringBuilder> ein Referenztyp ist, entspricht dies dem übergeben der beiden <xref:System.Text.StringBuilder>-Objekte an die <xref:System.Object.ReferenceEquals%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="3df45-169">Because <xref:System.Text.StringBuilder> is a reference type, this is equivalent to passing the two <xref:System.Text.StringBuilder> objects to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="3df45-170">Obwohl alle drei <xref:System.Text.StringBuilder> Objekte identische Zeichen folgen enthalten, verweisen Sie auf drei unterschiedliche Objekte.</span><span class="sxs-lookup"><span data-stu-id="3df45-170">Although all three <xref:System.Text.StringBuilder> objects contain identical strings, they refer to three distinct objects.</span></span> <span data-ttu-id="3df45-171">Folglich geben diese drei Methodenaufrufe `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="3df45-171">As a result, these three method calls return `false`.</span></span>  
  
 <span data-ttu-id="3df45-172">Sie können das aktuelle-Objekt für Verweis Gleichheit mit einem anderen Objekt vergleichen, indem Sie die <xref:System.Object.ReferenceEquals%2A>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="3df45-172">You can compare the current object to another object for reference equality by calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="3df45-173">In Visual Basic können Sie auch das Schlüsselwort `is` verwenden (z. b. `If Me Is otherObject Then ...`).</span><span class="sxs-lookup"><span data-stu-id="3df45-173">In Visual Basic, you can also use the `is` keyword (for example, `If Me Is otherObject Then ...`).</span></span>  
  
## <a name="notes-for-inheritors"></a><span data-ttu-id="3df45-174">Hinweise für Vererber</span><span class="sxs-lookup"><span data-stu-id="3df45-174">Notes for Inheritors</span></span>  
 <span data-ttu-id="3df45-175">Wenn Sie einen eigenen Typ definieren, erbt dieser Typ die Funktionalität, die durch die `Equals`-Methode seines Basistyps definiert ist.</span><span class="sxs-lookup"><span data-stu-id="3df45-175">When you define your own type, that type inherits the functionality defined by the `Equals` method of its base type.</span></span> <span data-ttu-id="3df45-176">In der folgenden Tabelle ist die Standard Implementierung der `Equals`-Methode für die Hauptkategorien von Typen in der .NET Framework aufgelistet.</span><span class="sxs-lookup"><span data-stu-id="3df45-176">The following table lists the default implementation of the `Equals` method for the major categories of types in the .NET Framework.</span></span>  
  
|<span data-ttu-id="3df45-177">Typkategorie</span><span class="sxs-lookup"><span data-stu-id="3df45-177">Type category</span></span>|<span data-ttu-id="3df45-178">Gleichheit definiert durch</span><span class="sxs-lookup"><span data-stu-id="3df45-178">Equality defined by</span></span>|<span data-ttu-id="3df45-179">Comments</span><span class="sxs-lookup"><span data-stu-id="3df45-179">Comments</span></span>|  
|-------------------|-------------------------|--------------|  
|<span data-ttu-id="3df45-180">Von <xref:System.Object> direkt abgeleitete Klasse</span><span class="sxs-lookup"><span data-stu-id="3df45-180">Class derived directly from <xref:System.Object></span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="3df45-181">Verweis Gleichheit Äquivalent zum Aufrufen von <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3df45-181">Reference equality; equivalent to calling <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span></span>|  
|<span data-ttu-id="3df45-182">Struktur</span><span class="sxs-lookup"><span data-stu-id="3df45-182">Structure</span></span>|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="3df45-183">Wert Gleichheit; entweder direkter Byte-für-Byte-Vergleich oder Feld-für-Feld-Vergleich mithilfe von Reflektion.</span><span class="sxs-lookup"><span data-stu-id="3df45-183">Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</span></span>|  
|<span data-ttu-id="3df45-184">Enumeration</span><span class="sxs-lookup"><span data-stu-id="3df45-184">Enumeration</span></span>|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="3df45-185">Werte müssen denselben Enumerationstyp und denselben zugrunde liegenden Wert aufweisen.</span><span class="sxs-lookup"><span data-stu-id="3df45-185">Values must have the same enumeration type and the same underlying value.</span></span>|  
|<span data-ttu-id="3df45-186">Delegat</span><span class="sxs-lookup"><span data-stu-id="3df45-186">Delegate</span></span>|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="3df45-187">Delegaten müssen denselben Typ mit identischen Aufruf Listen aufweisen.</span><span class="sxs-lookup"><span data-stu-id="3df45-187">Delegates must have the same type with identical invocation lists.</span></span>|  
|<span data-ttu-id="3df45-188">Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="3df45-188">Interface</span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="3df45-189">Verweis Gleichheit.</span><span class="sxs-lookup"><span data-stu-id="3df45-189">Reference equality.</span></span>|  
  
 <span data-ttu-id="3df45-190">Bei einem Werttyp sollten Sie <xref:System.Object.Equals%2A>immer überschreiben, da Tests auf Gleichheit, die auf Reflektion basieren, eine schlechte Leistung bieten.</span><span class="sxs-lookup"><span data-stu-id="3df45-190">For a value type, you should always override <xref:System.Object.Equals%2A>, because tests for equality that rely on reflection offer poor performance.</span></span> <span data-ttu-id="3df45-191">Sie können auch die Standard Implementierung von <xref:System.Object.Equals%2A> für Verweis Typen überschreiben, um auf Wert Gleichheit anstelle der Verweis Gleichheit zu prüfen und die genaue Bedeutung von Wert Gleichheit zu definieren.</span><span class="sxs-lookup"><span data-stu-id="3df45-191">You can also override the default implementation of <xref:System.Object.Equals%2A> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</span></span> <span data-ttu-id="3df45-192">Solche Implementierungen von <xref:System.Object.Equals%2A> geben `true` zurück, wenn die beiden Objekte denselben Wert aufweisen, auch wenn Sie nicht dieselbe Instanz sind.</span><span class="sxs-lookup"><span data-stu-id="3df45-192">Such implementations of <xref:System.Object.Equals%2A> return `true` if the two objects have the same value, even if they are not the same instance.</span></span> <span data-ttu-id="3df45-193">Der Implementierer des Typs entscheidet, was den Wert eines Objekts ausmacht, aber es handelt sich in der Regel um einige oder alle Daten, die in den Instanzvariablen des-Objekts gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-193">The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</span></span> <span data-ttu-id="3df45-194">Beispielsweise basiert der Wert eines <xref:System.String> Objekts auf den Zeichen der Zeichenfolge. die <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType>-Methode überschreibt die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>-Methode, um `true` für zwei Zeichen folgen Instanzen zurückzugeben, die die gleichen Zeichen in derselben Reihenfolge enthalten.</span><span class="sxs-lookup"><span data-stu-id="3df45-194">For example, the value of a <xref:System.String> object is based on the characters of the string; the <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> method overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to return `true` for any two string instances that contain the same characters in the same order.</span></span>  
  
 <span data-ttu-id="3df45-195">Im folgenden Beispiel wird gezeigt, wie die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>-Methode überschrieben wird, um auf Wert Gleichheit zu testen.</span><span class="sxs-lookup"><span data-stu-id="3df45-195">The following example shows how to override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to test for value equality.</span></span> <span data-ttu-id="3df45-196">Er überschreibt die <xref:System.Object.Equals%2A>-Methode für die `Person`-Klasse.</span><span class="sxs-lookup"><span data-stu-id="3df45-196">It overrides the <xref:System.Object.Equals%2A> method for the `Person` class.</span></span> <span data-ttu-id="3df45-197">Wenn `Person` die Basisklassen Implementierung von Gleichheit akzeptiert, sind zwei `Person` Objekte nur dann gleich, wenn Sie auf ein einzelnes Objekt verwiesen haben.</span><span class="sxs-lookup"><span data-stu-id="3df45-197">If `Person` accepted its base class implementation of equality, two `Person` objects would be equal only if they referenced a single object.</span></span> <span data-ttu-id="3df45-198">In diesem Fall sind jedoch zwei `Person` Objekte gleich, wenn Sie über denselben Wert für die `Person.Id`-Eigenschaft verfügen.</span><span class="sxs-lookup"><span data-stu-id="3df45-198">However, in this case, two `Person` objects are equal if they have the same value for the `Person.Id` property.</span></span>  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 <span data-ttu-id="3df45-199">Zusätzlich zum Überschreiben von <xref:System.Object.Equals%2A>können Sie die <xref:System.IEquatable%601>-Schnittstelle implementieren, um einen stark typisierten Test auf Gleichheit bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="3df45-199">In addition to overriding <xref:System.Object.Equals%2A>, you can implement the <xref:System.IEquatable%601> interface to provide a strongly typed test for equality.</span></span>  
  
 <span data-ttu-id="3df45-200">Die folgenden-Anweisungen müssen für alle Implementierungen der <xref:System.Object.Equals%28System.Object%29>-Methode den Wert "true" aufweisen.</span><span class="sxs-lookup"><span data-stu-id="3df45-200">The following statements must be true for all implementations of the <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="3df45-201">In der Liste werden `x`, `y`und `z` Objekt Verweise darstellen, die nicht **null**sind.</span><span class="sxs-lookup"><span data-stu-id="3df45-201">In the list, `x`, `y`, and `z` represent object references that are not **null**.</span></span>  
  
-   <span data-ttu-id="3df45-202">`x.Equals(x)` gibt `true`zurück, außer in Fällen, die Gleit Komma Typen einschließen.</span><span class="sxs-lookup"><span data-stu-id="3df45-202">`x.Equals(x)` returns `true`, except in cases that involve floating-point types.</span></span> <span data-ttu-id="3df45-203">Siehe [ISO/IEC/IEEE 60559:2011, Informationstechnologie--Mikroprozessorsysteme--Gleit Komma Arithmetik](https://www.iso.org/standard/57469.html).</span><span class="sxs-lookup"><span data-stu-id="3df45-203">See [ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic](https://www.iso.org/standard/57469.html).</span></span>  
  
-   <span data-ttu-id="3df45-204">`x.Equals(y)` gibt denselben Wert zurück wie `y.Equals(x)`.</span><span class="sxs-lookup"><span data-stu-id="3df45-204">`x.Equals(y)` returns the same value as `y.Equals(x)`.</span></span>  
  
-   <span data-ttu-id="3df45-205">`x.Equals(y)` gibt `true` zurück, wenn `x` und `y` `NaN`sind.</span><span class="sxs-lookup"><span data-stu-id="3df45-205">`x.Equals(y)` returns `true` if both `x` and `y` are `NaN`.</span></span>  
  
-   <span data-ttu-id="3df45-206">Wenn `(x.Equals(y) && y.Equals(z))` `true`zurückgibt, gibt `x.Equals(z)` `true`zurück.</span><span class="sxs-lookup"><span data-stu-id="3df45-206">If `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`.</span></span>  
  
-   <span data-ttu-id="3df45-207">Aufeinander folgende Aufrufe von `x.Equals(y)` geben denselben Wert zurück, solange die Objekte, auf die von `x` und `y` verwiesen wird, nicht geändert werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-207">Successive calls to `x.Equals(y)` return the same value as long as the objects referenced by `x` and `y` are not modified.</span></span>  
  
-   <span data-ttu-id="3df45-208">`x.Equals(null)` gibt `false` zurück.</span><span class="sxs-lookup"><span data-stu-id="3df45-208">`x.Equals(null)` returns `false`.</span></span>  
  
 <span data-ttu-id="3df45-209">Implementierungen von <xref:System.Object.Equals%2A> dürfen keine Ausnahmen auslösen. Sie sollten immer einen Wert zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="3df45-209">Implementations of <xref:System.Object.Equals%2A> must not throw exceptions; they should always return a value.</span></span> <span data-ttu-id="3df45-210">Wenn `obj` z. b. `null`ist, sollte die <xref:System.Object.Equals%2A>-Methode `false` zurückgeben, anstatt eine <xref:System.ArgumentNullException>auszulösen.</span><span class="sxs-lookup"><span data-stu-id="3df45-210">For example, if `obj` is `null`, the <xref:System.Object.Equals%2A> method should return `false` instead of throwing an <xref:System.ArgumentNullException>.</span></span>  
  
 <span data-ttu-id="3df45-211">Beachten Sie beim Überschreiben von <xref:System.Object.Equals%28System.Object%29>die folgenden Richtlinien:</span><span class="sxs-lookup"><span data-stu-id="3df45-211">Follow these guidelines when overriding <xref:System.Object.Equals%28System.Object%29>:</span></span>  
  
-   <span data-ttu-id="3df45-212">Typen, die <xref:System.IComparable> implementieren, müssen <xref:System.Object.Equals%28System.Object%29>überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-212">Types that implement <xref:System.IComparable> must override <xref:System.Object.Equals%28System.Object%29>.</span></span>  
  
-   <span data-ttu-id="3df45-213">Typen, die <xref:System.Object.Equals%28System.Object%29> überschreiben, müssen auch <xref:System.Object.GetHashCode%2A>außer Kraft setzen. Andernfalls funktionieren Hash Tabellen möglicherweise nicht ordnungsgemäß.</span><span class="sxs-lookup"><span data-stu-id="3df45-213">Types that override <xref:System.Object.Equals%28System.Object%29> must also override <xref:System.Object.GetHashCode%2A>; otherwise, hash tables  might not work correctly.</span></span>  
  
-   <span data-ttu-id="3df45-214">Sie sollten die <xref:System.IEquatable%601>-Schnittstelle implementieren, um stark typisierte Tests auf Gleichheit zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="3df45-214">You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality.</span></span> <span data-ttu-id="3df45-215">Die <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>-Implementierung sollte Ergebnisse zurückgeben, die <xref:System.Object.Equals%2A>entsprechen.</span><span class="sxs-lookup"><span data-stu-id="3df45-215">Your <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementation should return results that are consistent with <xref:System.Object.Equals%2A>.</span></span>  
  
-   <span data-ttu-id="3df45-216">Wenn Ihre Programmiersprache das Überladen von Operatoren unterstützt und Sie den Gleichheits Operator für einen bestimmten Typ überladen, müssen Sie auch die <xref:System.Object.Equals%28System.Object%29>-Methode überschreiben, um das gleiche Ergebnis wie der Gleichheits Operator zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="3df45-216">If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator.</span></span> <span data-ttu-id="3df45-217">Dadurch wird sichergestellt, dass der Klassen Bibliotheks Code, der <xref:System.Object.Equals%2A> verwendet (z. b. <xref:System.Collections.ArrayList> und <xref:System.Collections.Hashtable>), so verhält, dass er mit der Art und Weise konsistent ist, wie der Gleichheits Operator von Anwendungscode verwendet wird</span><span class="sxs-lookup"><span data-stu-id="3df45-217">This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code.</span></span>  
  
### <a name="guidelines-for-reference-types"></a><span data-ttu-id="3df45-218">Richtlinien für Referenztypen</span><span class="sxs-lookup"><span data-stu-id="3df45-218">Guidelines for Reference Types</span></span>  
 <span data-ttu-id="3df45-219">Die folgenden Richtlinien gelten für das Überschreiben von <xref:System.Object.Equals%28System.Object%29> für einen Referenztyp:</span><span class="sxs-lookup"><span data-stu-id="3df45-219">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a reference type:</span></span>  
  
-   <span data-ttu-id="3df45-220">Überschreiben Sie <xref:System.Object.Equals%2A>, wenn die Semantik des Typs auf der Tatsache basiert, dass der Typ einige Werte darstellt.</span><span class="sxs-lookup"><span data-stu-id="3df45-220">Consider overriding <xref:System.Object.Equals%2A> if the semantics of the type are based on the fact that the type represents some value(s).</span></span>  
  
-   <span data-ttu-id="3df45-221">Die meisten Verweis Typen dürfen den Gleichheits Operator nicht überladen, auch wenn Sie <xref:System.Object.Equals%2A>überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-221">Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="3df45-222">Wenn Sie jedoch einen Verweistyp implementieren, der eine Wert Semantik aufweisen soll (z. b. ein komplexer Nummertyp), müssen Sie den Gleichheits Operator überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-222">However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</span></span>  
  
-   <span data-ttu-id="3df45-223">Sie sollten <xref:System.Object.Equals%2A> nicht für einen änderbaren Referenztyp überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-223">You should not override <xref:System.Object.Equals%2A> on a mutable reference type.</span></span> <span data-ttu-id="3df45-224">Dies liegt daran, dass das Überschreiben von <xref:System.Object.Equals%2A> erfordert, dass Sie auch die <xref:System.Object.GetHashCode%2A>-Methode überschreiben, wie im vorherigen Abschnitt erläutert wurde.</span><span class="sxs-lookup"><span data-stu-id="3df45-224">This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section.</span></span> <span data-ttu-id="3df45-225">Dies bedeutet, dass sich der Hashcode einer Instanz eines änderbaren Verweis Typs während seiner Lebensdauer ändern kann, was dazu führen kann, dass das Objekt in einer Hash Tabelle verloren geht.</span><span class="sxs-lookup"><span data-stu-id="3df45-225">This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</span></span>  
  
### <a name="guidelines-for-value-types"></a><span data-ttu-id="3df45-226">Richtlinien für Werttypen</span><span class="sxs-lookup"><span data-stu-id="3df45-226">Guidelines for Value Types</span></span>  
 <span data-ttu-id="3df45-227">Die folgenden Richtlinien gelten für das Überschreiben von <xref:System.Object.Equals%28System.Object%29> für einen Werttyp:</span><span class="sxs-lookup"><span data-stu-id="3df45-227">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a value type:</span></span>  
  
-   <span data-ttu-id="3df45-228">Wenn Sie einen Werttyp definieren, der ein oder mehrere Felder enthält, deren Werte Verweis Typen sind, sollten Sie <xref:System.Object.Equals%28System.Object%29>überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-228">If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="3df45-229">Die von <xref:System.ValueType> bereitgestellte <xref:System.Object.Equals%28System.Object%29> Implementierung führt einen Byte-pro-Byte-Vergleich für Werttypen durch, deren Felder alle Werttypen sind. Sie verwendet jedoch Reflektion, um einen Feld weisen Vergleich von Werttypen durchzuführen, deren Felder Verweis Typen enthalten.</span><span class="sxs-lookup"><span data-stu-id="3df45-229">The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</span></span>  
  
-   <span data-ttu-id="3df45-230">Wenn Sie <xref:System.Object.Equals%2A> überschreiben und die Entwicklungssprache das Überladen von Operatoren unterstützt, müssen Sie den Gleichheits Operator überladen.</span><span class="sxs-lookup"><span data-stu-id="3df45-230">If you override <xref:System.Object.Equals%2A> and your development language supports operator overloading, you must overload the equality operator.</span></span>  
  
-   <span data-ttu-id="3df45-231">Sie sollten die <xref:System.IEquatable%601>-Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="3df45-231">You should implement the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="3df45-232">Wenn Sie die stark typisierte <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> Methode aufrufen, wird das Boxing des `obj` Arguments vermieden.</span><span class="sxs-lookup"><span data-stu-id="3df45-232">Calling the strongly typed <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> method avoids boxing the `obj` argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3df45-233">Das folgende Beispiel zeigt eine `Point` Klasse, die die <xref:System.Object.Equals%2A>-Methode überschreibt, um Wert Gleichheit und eine `Point3D`-Klasse zu überschreiben, die von `Point`abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="3df45-233">The following example shows a `Point` class that overrides the <xref:System.Object.Equals%2A> method to provide value equality, and a `Point3D` class that is derived from `Point`.</span></span> <span data-ttu-id="3df45-234">Da `Point` <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> überschreibt, um auf Wert Gleichheit zu testen, wird die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>-Methode nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="3df45-234">Because `Point` overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to test for value equality, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is not called.</span></span> <span data-ttu-id="3df45-235">`Point3D.Equals` ruft jedoch `Point.Equals` auf, da `Point` <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> auf eine Weise implementiert, die Wert Gleichheit bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="3df45-235">However, `Point3D.Equals` calls `Point.Equals` because `Point` implements <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in a manner that provides value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 <span data-ttu-id="3df45-236">Die `Point.Equals`-Methode überprüft, ob das `obj`-Argument nicht **null** ist und dass es auf eine Instanz des gleichen Typs wie dieses Objekt verweist.</span><span class="sxs-lookup"><span data-stu-id="3df45-236">The `Point.Equals` method checks to make sure that the `obj` argument is not **null** and that it references an instance of the same type as this object.</span></span> <span data-ttu-id="3df45-237">Wenn eine der beiden Überprüfungen fehlschlägt, gibt die Methode `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="3df45-237">If either check fails, the method returns `false`.</span></span>  
  
 <span data-ttu-id="3df45-238">Die `Point.Equals`-Methode ruft die <xref:System.Object.GetType%2A>-Methode auf, um zu bestimmen, ob die Lauf Zeit Typen der beiden-Objekte identisch sind.</span><span class="sxs-lookup"><span data-stu-id="3df45-238">The `Point.Equals` method calls the <xref:System.Object.GetType%2A> method to determine whether the run-time types of the two objects are identical.</span></span> <span data-ttu-id="3df45-239">Wenn die Methode eine Überprüfung der Formular `obj is Point` in C# oder `TryCast(obj, Point)` in Visual Basic verwendet hat, würde die Überprüfung `true` in Fällen zurückgeben, in denen `obj` eine Instanz einer abgeleiteten Klasse von `Point`ist, auch wenn `obj` und die aktuelle Instanz nicht denselben Lauf Zeittyp aufweisen.</span><span class="sxs-lookup"><span data-stu-id="3df45-239">If the method used a check of the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic, the check would return `true` in cases where `obj` is an instance of a derived class of `Point`, even though `obj` and the current instance are not of the same run-time type.</span></span> <span data-ttu-id="3df45-240">Nachdem überprüft wurde, ob beide Objekte denselben Typ aufweisen, wandelt die Methode `obj` in den Typ `Point` und gibt das Ergebnis des Vergleichs der Instanzfelder der beiden Objekte zurück.</span><span class="sxs-lookup"><span data-stu-id="3df45-240">Having verified that both objects are of the same type, the method casts `obj` to type `Point` and returns the result of comparing the instance fields of the two objects.</span></span>  
  
 <span data-ttu-id="3df45-241">In `Point3D.Equals`wird die geerbte `Point.Equals` Methode, die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>überschreibt, aufgerufen, bevor etwas anderes ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-241">In `Point3D.Equals`, the inherited `Point.Equals` method, which overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, is invoked before anything else is done.</span></span> <span data-ttu-id="3df45-242">Da `Point3D` eine versiegelte Klasse (`NotInheritable` in Visual Basic) ist, ist eine Überprüfung in der C# Form `obj is Point` in oder `TryCast(obj, Point)` Visual Basic ausreichend, um sicherzustellen, dass `obj` ein `Point3D` Objekt ist.</span><span class="sxs-lookup"><span data-stu-id="3df45-242">Because `Point3D` is a sealed class (`NotInheritable` in Visual Basic), a check in the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic is adequate to ensure that `obj` is a `Point3D` object.</span></span> <span data-ttu-id="3df45-243">Wenn es sich um ein `Point3D` Objekt handelt, wird es in ein `Point` Objekt umgewandelt und an die Basisklassen Implementierung von <xref:System.Object.Equals%2A>übermittelt.</span><span class="sxs-lookup"><span data-stu-id="3df45-243">If it is a `Point3D` object, it is cast to a `Point` object and passed to the base class implementation of <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="3df45-244">Nur wenn die geerbte `Point.Equals` Methode `true` zurückgibt, vergleicht die Methode die `z` Instanzfelder, die in der abgeleiteten Klasse eingeführt wurden.</span><span class="sxs-lookup"><span data-stu-id="3df45-244">Only when the inherited `Point.Equals` method returns `true` does the method compare the `z` instance fields introduced in the derived class.</span></span>  
  
 <span data-ttu-id="3df45-245">Im folgenden Beispiel wird eine `Rectangle` Klasse definiert, die intern ein Rechteck als zwei `Point` Objekte implementiert.</span><span class="sxs-lookup"><span data-stu-id="3df45-245">The following example defines a `Rectangle` class that internally implements a rectangle as two `Point` objects.</span></span> <span data-ttu-id="3df45-246">Die `Rectangle`-Klasse überschreibt auch <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, um Wert Gleichheit bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="3df45-246">The `Rectangle` class also overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to provide for value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 <span data-ttu-id="3df45-247">Einige Sprachen, wie C# z. b. und Visual Basic Unterstützung der Operator Überladung</span><span class="sxs-lookup"><span data-stu-id="3df45-247">Some languages such as C# and Visual Basic support operator overloading.</span></span> <span data-ttu-id="3df45-248">Wenn ein Typ den Gleichheits Operator überlädt, muss er auch die <xref:System.Object.Equals%28System.Object%29>-Methode überschreiben, um die gleiche Funktionalität bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="3df45-248">When a type overloads the equality operator, it must also override the <xref:System.Object.Equals%28System.Object%29> method to provide the same functionality.</span></span> <span data-ttu-id="3df45-249">Dies wird in der Regel erreicht, indem die <xref:System.Object.Equals%28System.Object%29>-Methode in Bezug auf den überladenen Gleichheits Operator geschrieben wird, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="3df45-249">This is typically accomplished by writing the <xref:System.Object.Equals%28System.Object%29> method in terms of the overloaded equality operator, as in the following example.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 <span data-ttu-id="3df45-250">Da `Complex` ein Werttyp ist, kann er nicht von abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-250">Because `Complex` is a value type, it cannot be derived from.</span></span>  <span data-ttu-id="3df45-251">Daher muss die Methode zum Überschreiben von <xref:System.Object.Equals%28System.Object%29> <xref:System.Object.GetType%2A> nicht aufrufen, um den genauen Lauf Zeittyp der einzelnen Objekte zu bestimmen. stattdessen kann der `is`- C# Operator in oder der `TypeOf`-Operator in Visual Basic verwendet werden, um den Typ des `obj`-Parameters zu überprüfen.</span><span class="sxs-lookup"><span data-stu-id="3df45-251">Therefore, the override to <xref:System.Object.Equals%28System.Object%29> method need not call <xref:System.Object.GetType%2A> to determine the precise run-time type of each object, but can instead use the `is` operator in C# or the `TypeOf` operator in Visual Basic to check the type of the `obj` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA"><span data-ttu-id="3df45-252">Das erste zu vergleichende Objekt.</span><span class="sxs-lookup"><span data-stu-id="3df45-252">The first object to compare.</span></span></param>
        <param name="objB"><span data-ttu-id="3df45-253">Das zweite zu vergleichende Objekt.</span><span class="sxs-lookup"><span data-stu-id="3df45-253">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="3df45-254">Stellt fest, ob die angegebenen Objektinstanzen als gleich betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-254">Determines whether the specified object instances are considered equal.</span></span></summary>
        <returns><span data-ttu-id="3df45-255"><see langword="true" />, wenn die Objekte als gleich betrachtet werden, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3df45-255"><see langword="true" /> if the objects are considered equal; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="3df45-256">Wenn sowohl <paramref name="objA" />, als auch <paramref name="objB" />**NULL** sind, gibt diese Methode <see langword="true" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="3df45-256">If both <paramref name="objA" /> and <paramref name="objB" /> are **null**, the method returns <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3df45-257">Die statische <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> Methode gibt an, ob zwei Objekte, `objA` und `objB`, gleich sind.</span><span class="sxs-lookup"><span data-stu-id="3df45-257">The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, `objA` and  `objB`, are equal.</span></span> <span data-ttu-id="3df45-258">Außerdem können Sie Objekte, deren Wert **null** ist, auf Gleichheit testen.</span><span class="sxs-lookup"><span data-stu-id="3df45-258">It also enables you to test objects whose value is **null** for equality.</span></span> <span data-ttu-id="3df45-259">Er vergleicht `objA` und `objB` auf Gleichheit wie folgt:</span><span class="sxs-lookup"><span data-stu-id="3df45-259">It compares `objA` and `objB` for equality as follows:</span></span>  
  
-   <span data-ttu-id="3df45-260">Es bestimmt, ob die beiden-Objekte denselben Objekt Verweis darstellen.</span><span class="sxs-lookup"><span data-stu-id="3df45-260">It determines whether the two objects represent the same object reference.</span></span> <span data-ttu-id="3df45-261">Wenn dies der Fall ist, gibt die Methode `true`zurück.</span><span class="sxs-lookup"><span data-stu-id="3df45-261">If they do, the method returns `true`.</span></span> <span data-ttu-id="3df45-262">Dieser Test entspricht dem Aufrufen der <xref:System.Object.ReferenceEquals%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="3df45-262">This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="3df45-263">Außerdem gibt die Methode `true`zurück, wenn sowohl `objA` als auch `objB` **null**sind.</span><span class="sxs-lookup"><span data-stu-id="3df45-263">In addition, if both `objA` and `objB` are **null**, the method returns `true`.</span></span>  
  
-   <span data-ttu-id="3df45-264">Es bestimmt, ob entweder `objA` oder `objB` **null**ist.</span><span class="sxs-lookup"><span data-stu-id="3df45-264">It determines whether either `objA` or `objB` is **null**.</span></span> <span data-ttu-id="3df45-265">Wenn dies der Fall ist, wird `false`zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="3df45-265">If so, it returns `false`.</span></span>  
  
-   <span data-ttu-id="3df45-266">Wenn die beiden Objekte nicht denselben Objekt Verweis darstellen und keines von **null**ist, wird `objA`aufgerufen.`Equals`(`objB`) und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="3df45-266">If the two objects do not represent the same object reference and neither is **null**, it calls `objA`.`Equals`(`objB`) and returns the result.</span></span> <span data-ttu-id="3df45-267">Dies bedeutet Folgendes: Wenn `objA` die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>-Methode überschreibt, wird diese außer Kraft Setzung aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="3df45-267">This means that if `objA` overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, this override is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3df45-268">Im folgenden Beispiel wird die <xref:System.Object.Equals%28System.Object%2CSystem.Object%29>-Methode veranschaulicht und mit der <xref:System.Object.ReferenceEquals%2A>-Methode verglichen.</span><span class="sxs-lookup"><span data-stu-id="3df45-268">The following example illustrates the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method and compares it with the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Finalize() cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3df45-269">Gibt einem Objekt Gelegenheit zu dem Versuch, Ressourcen freizugeben und andere Bereinigungen durchzuführen, bevor es von der Garbage Collection freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-269">Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3df45-270">Die <xref:System.Object.Finalize%2A>-Methode wird verwendet, um Bereinigungs Vorgänge für nicht verwaltete Ressourcen durchzuführen, die vom aktuellen-Objekt aufbewahrt werden, bevor das-Objekt zerstört wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-270">The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</span></span> <span data-ttu-id="3df45-271">Die-Methode ist geschützt und kann daher nur über diese Klasse oder eine abgeleitete Klasse aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-271">The method is protected and therefore is accessible only through this class or through a derived class.</span></span>  
  
 <span data-ttu-id="3df45-272">In diesem Abschnitt:</span><span class="sxs-lookup"><span data-stu-id="3df45-272">In this section:</span></span>  
  
-   [<span data-ttu-id="3df45-273">Funktionsweise der Finalisierung</span><span class="sxs-lookup"><span data-stu-id="3df45-273">How finalization works</span></span>](#How)  
  
-   [<span data-ttu-id="3df45-274">Hinweise für Implementierer</span><span class="sxs-lookup"><span data-stu-id="3df45-274">Notes for implementers</span></span>](#Notes)  
  
-   [<span data-ttu-id="3df45-275">Die SafeHandle-Alternative</span><span class="sxs-lookup"><span data-stu-id="3df45-275">The SafeHandle alternative</span></span>](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a><span data-ttu-id="3df45-276">Funktionsweise der Finalisierung</span><span class="sxs-lookup"><span data-stu-id="3df45-276">How finalization works</span></span>  
 <span data-ttu-id="3df45-277">Die <xref:System.Object>-Klasse stellt keine Implementierung für die <xref:System.Object.Finalize%2A>-Methode bereit, und die Garbage Collector markiert keine Typen, die von <xref:System.Object> für den Abschluss abgeleitet sind, es sei denn, Sie überschreiben die <xref:System.Object.Finalize%2A>-Methode</span><span class="sxs-lookup"><span data-stu-id="3df45-277">The <xref:System.Object> class provides no implementation for the <xref:System.Object.Finalize%2A> method, and the garbage collector does not mark types derived from <xref:System.Object> for finalization unless they override the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 <span data-ttu-id="3df45-278">Wenn ein Typ die <xref:System.Object.Finalize%2A> Methode überschreibt, fügt der Garbage Collector einen Eintrag für jede Instanz des Typs einer internen Struktur hinzu, die als Abschluss Queue bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-278">If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</span></span> <span data-ttu-id="3df45-279">Die Finalisierungswarteschlange enthält Einträge für alle Objekte im verwalteten Heap, deren Finalisierungscode ausgeführt werden muss, bevor der Garbage Collector den Speicher freigeben kann.</span><span class="sxs-lookup"><span data-stu-id="3df45-279">The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</span></span> <span data-ttu-id="3df45-280">Der Garbage Collector ruft dann die <xref:System.Object.Finalize%2A>-Methode automatisch unter den folgenden Bedingungen auf:</span><span class="sxs-lookup"><span data-stu-id="3df45-280">The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:</span></span>  
  
-   <span data-ttu-id="3df45-281">Nachdem der Garbage Collector ermittelt hat, dass auf ein Objekt nicht mehr zugegriffen werden kann, es sei denn, das Objekt wurde von der Finalisierung durch einen aufzurufenden <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> Methode ausgenommen.</span><span class="sxs-lookup"><span data-stu-id="3df45-281">After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="3df45-282">**Nur auf .NET Framework**, wenn eine Anwendungsdomäne heruntergefahren wird, es sei denn, das Objekt ist von der Finalisierung ausgenommen.</span><span class="sxs-lookup"><span data-stu-id="3df45-282">**On .NET Framework only**, during shutdown of an application domain, unless the object is exempt from finalization.</span></span> <span data-ttu-id="3df45-283">Während des herunter Fahrens werden auch Objekte, die weiterhin zugänglich sind, fertiggestellt.</span><span class="sxs-lookup"><span data-stu-id="3df45-283">During shutdown, even objects that are still accessible are finalized.</span></span>  
  
 <span data-ttu-id="3df45-284"><xref:System.Object.Finalize%2A> wird automatisch nur einmal für eine bestimmte-Instanz aufgerufen, es sei denn, das Objekt wird mithilfe eines Mechanismus wie <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> neu registriert, und die <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>-Methode wurde nachfolgend nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="3df45-284"><xref:System.Object.Finalize%2A> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> and the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method has not been subsequently called.</span></span>  
  
 <span data-ttu-id="3df45-285">bei <xref:System.Object.Finalize%2A> Vorgängen gelten die folgenden Einschränkungen:</span><span class="sxs-lookup"><span data-stu-id="3df45-285"><xref:System.Object.Finalize%2A> operations have the following limitations:</span></span>  
  
-   <span data-ttu-id="3df45-286">Die genaue Zeit, zu der der Finalizer ausgeführt wird, ist nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="3df45-286">The exact time when the finalizer executes is undefined.</span></span> <span data-ttu-id="3df45-287">Um die deterministische Freigabe von Ressourcen für Instanzen Ihrer Klasse sicherzustellen, implementieren Sie eine `Close`-Methode, oder stellen Sie eine <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>-Implementierung bereit.</span><span class="sxs-lookup"><span data-stu-id="3df45-287">To ensure deterministic release of resources for instances of your class, implement a `Close` method or provide a <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
-   <span data-ttu-id="3df45-288">Die Finalizer von zwei Objekten sind nicht garantiert, dass Sie in einer bestimmten Reihenfolge ausgeführt werden, auch wenn ein Objekt auf das andere Objekt verweist.</span><span class="sxs-lookup"><span data-stu-id="3df45-288">The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</span></span> <span data-ttu-id="3df45-289">Das heißt, wenn Objekt a einen Verweis auf Objekt b hat und beide über Finalizer verfügen, wurde Objekt B möglicherweise bereits abgeschlossen, wenn der Finalizer von Objekt A gestartet wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-289">That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</span></span>  
  
-   <span data-ttu-id="3df45-290">Der Thread, auf dem der Finalizer ausgeführt wird, ist nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="3df45-290">The thread on which the finalizer runs is unspecified.</span></span>  
  
 <span data-ttu-id="3df45-291">Die <xref:System.Object.Finalize%2A>-Methode kann möglicherweise nicht vollständig ausgeführt werden oder unter den folgenden außergewöhnlichen Umständen überhaupt nicht ausgeführt werden:</span><span class="sxs-lookup"><span data-stu-id="3df45-291">The <xref:System.Object.Finalize%2A> method might not run to completion or might not run at all under the following exceptional circumstances:</span></span>  
  
-   <span data-ttu-id="3df45-292">Wenn ein anderer Finalizer unbegrenzt blockiert wird (in eine Endlosschleife wechselt, versucht, eine Sperre zu erhalten, die er niemals abrufen kann usw.).</span><span class="sxs-lookup"><span data-stu-id="3df45-292">If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</span></span> <span data-ttu-id="3df45-293">Da die Laufzeit versucht, Finalizer für den Abschluss auszuführen, werden möglicherweise andere Finalizer nicht aufgerufen, wenn ein Finalizer unbegrenzt blockiert wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-293">Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</span></span>  
  
-   <span data-ttu-id="3df45-294">, Wenn der Prozess beendet wird, ohne der Laufzeit die Möglichkeit zu geben, zu bereinigen.</span><span class="sxs-lookup"><span data-stu-id="3df45-294">If the process terminates without giving the runtime a chance to clean up.</span></span> <span data-ttu-id="3df45-295">In diesem Fall ist die erste Benachrichtigung des Prozesses bei der Beendigung der Laufzeit eine DLL_PROCESS_DETACH Benachrichtigung.</span><span class="sxs-lookup"><span data-stu-id="3df45-295">In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</span></span>  
  
 <span data-ttu-id="3df45-296">Die Laufzeit setzt das Beenden von Objekten während des herunter Fahrens fort, während die Anzahl der finalisierbaren Objekte weiterhin abnimmt.</span><span class="sxs-lookup"><span data-stu-id="3df45-296">The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</span></span>  
  
 <span data-ttu-id="3df45-297">Wenn <xref:System.Object.Finalize%2A> oder eine außer Kraft Setzung von <xref:System.Object.Finalize%2A> eine Ausnahme auslöst und die Laufzeit nicht von einer Anwendung gehostet wird, die die Standard Richtlinie überschreibt, beendet die Laufzeit den Prozess, und es werden keine aktiven `try`/`finally` Blöcke oder Finalizer ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3df45-297">If <xref:System.Object.Finalize%2A> or an override of <xref:System.Object.Finalize%2A> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active `try`/`finally` blocks or finalizers are executed.</span></span> <span data-ttu-id="3df45-298">Durch dieses Verhalten wird die Prozess Integrität sichergestellt, wenn der Finalizer Ressourcen nicht freigeben oder zerstören kann.</span><span class="sxs-lookup"><span data-stu-id="3df45-298">This behavior ensures process integrity if the finalizer cannot free or destroy resources.</span></span>  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a><span data-ttu-id="3df45-299">Überschreiben der Finalize-Methode</span><span class="sxs-lookup"><span data-stu-id="3df45-299">Overriding the Finalize method</span></span> 
 <span data-ttu-id="3df45-300">Sie sollten <xref:System.Object.Finalize%2A> für eine Klasse überschreiben, die nicht verwaltete Ressourcen verwendet, z. b. Datei Handles oder Datenbankverbindungen, die freigegeben werden müssen, wenn das verwaltete Objekt, das Sie verwendet, während der Garbage Collection verworfen wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-300">You should override <xref:System.Object.Finalize%2A> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</span></span> <span data-ttu-id="3df45-301">Sie sollten keine <xref:System.Object.Finalize%2A> Methode für verwaltete Objekte implementieren, da die Garbage Collector verwaltete Ressourcen automatisch freigibt.</span><span class="sxs-lookup"><span data-stu-id="3df45-301">You shouldn't implement a <xref:System.Object.Finalize%2A> method for managed objects because the garbage collector releases managed resources automatically.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3df45-302">Wenn ein <xref:System.Runtime.InteropServices.SafeHandle> Objekt verfügbar ist, das Ihre nicht verwaltete Ressource umschließt, empfiehlt es sich, das Lösch Muster mit einem sicheren Handle zu implementieren und <xref:System.Object.Finalize%2A>nicht zu überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-302">If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="3df45-303">Weitere Informationen finden Sie im Abschnitt " [SafeHandle-Alternative](#SafeHandle) ".</span><span class="sxs-lookup"><span data-stu-id="3df45-303">For more information, see [The SafeHandle alternative](#SafeHandle) section.</span></span>  
  
 <span data-ttu-id="3df45-304">Die <xref:System.Object.Finalize%2A?displayProperty=nameWithType>-Methode führt standardmäßig keine Aktion aus, aber Sie sollten <xref:System.Object.Finalize%2A> nur bei Bedarf überschreiben und nur nicht verwaltete Ressourcen freigeben.</span><span class="sxs-lookup"><span data-stu-id="3df45-304">The <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources.</span></span> <span data-ttu-id="3df45-305">Das Freigeben des Speichers dauert tendenziell viel länger, wenn ein Abschluss Vorgang ausgeführt wird, da er mindestens zwei Garbage Collections erfordert.</span><span class="sxs-lookup"><span data-stu-id="3df45-305">Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</span></span> <span data-ttu-id="3df45-306">Außerdem sollten Sie die <xref:System.Object.Finalize%2A>-Methode nur für Verweis Typen überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-306">In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only.</span></span> <span data-ttu-id="3df45-307">Der Common Language Runtime der nur Verweis Typen finalisiert.</span><span class="sxs-lookup"><span data-stu-id="3df45-307">The common language runtime only finalizes reference types.</span></span> <span data-ttu-id="3df45-308">Finalizer werden für Werttypen ignoriert.</span><span class="sxs-lookup"><span data-stu-id="3df45-308">It ignores finalizers on value types.</span></span>  

<span data-ttu-id="3df45-309">Der Gültigkeitsbereich der <xref:System.Object.Finalize%2A?displayProperty=nameWithType> Methode ist `protected`.</span><span class="sxs-lookup"><span data-stu-id="3df45-309">The scope of the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method is `protected`.</span></span> <span data-ttu-id="3df45-310">Sie sollten diesen eingeschränkten Gültigkeitsbereich beibehalten, wenn Sie die Methode in der Klasse überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-310">You should maintain this limited scope when you override the method in your class.</span></span> <span data-ttu-id="3df45-311">Wenn Sie eine <xref:System.Object.Finalize%2A> Methode schützen, verhindern Sie, dass Benutzer Ihrer Anwendung die <xref:System.Object.Finalize%2A> Methode eines Objekts direkt aufrufen.</span><span class="sxs-lookup"><span data-stu-id="3df45-311">By keeping a <xref:System.Object.Finalize%2A> method protected, you prevent users of your application from calling an object's <xref:System.Object.Finalize%2A> method directly.</span></span>
  
 <span data-ttu-id="3df45-312">Jede Implementierung von <xref:System.Object.Finalize%2A> in einem abgeleiteten Typ muss die Implementierung von <xref:System.Object.Finalize%2A>des Basistyps aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="3df45-312">Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="3df45-313">Dies ist der einzige Fall, in dem Anwendungscode <xref:System.Object.Finalize%2A>aufgerufen werden darf.</span><span class="sxs-lookup"><span data-stu-id="3df45-313">This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="3df45-314">Die <xref:System.Object.Finalize%2A>-Methode eines Objekts sollte keine Methode für andere Objekte als die ihrer Basisklasse aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="3df45-314">An object's <xref:System.Object.Finalize%2A> method shouldn't call a method on any objects other than that of its base class.</span></span> <span data-ttu-id="3df45-315">Der Grund hierfür ist, dass das aufrufende Objekt möglicherweise zur gleichen Zeit an die Garbage Collection übergeben wird wie die anderen aufgerufenen Objekte, z. B. wenn eine Common Language Runtime beendet wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-315">This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</span></span> 
  
> [!NOTE]
>  <span data-ttu-id="3df45-316">Der C# Compiler lässt nicht zu, dass Sie die <xref:System.Object.Finalize%2A>-Methode außer Kraft setzen.</span><span class="sxs-lookup"><span data-stu-id="3df45-316">The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="3df45-317">Stattdessen stellen Sie einen Finalizer bereit, indem Sie einen [debugtor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) für Ihre Klasse implementieren.</span><span class="sxs-lookup"><span data-stu-id="3df45-317">Instead, you provide a finalizer by implementing a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) for your class.</span></span> <span data-ttu-id="3df45-318">Ein C# Dekonstruktor ruft automatisch den Dekonstruktor der Basisklasse auf.</span><span class="sxs-lookup"><span data-stu-id="3df45-318">A C# destructor automatically calls the destructor of its base class.</span></span>  
>   
>  <span data-ttu-id="3df45-319">Visual C++ bietet auch eine eigene Syntax für die Implementierung der <xref:System.Object.Finalize%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="3df45-319">Visual C++ also provides its own syntax for implementing the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="3df45-320">Weitere Informationen finden Sie im Abschnitt "debugtoren und Finalizer" unter Gewusst [wie: definieren und Verarbeiten von Klassen und Strukturen (C++/CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span><span class="sxs-lookup"><span data-stu-id="3df45-320">For more information, see the "Destructors and finalizers" section of [How to: Define and Consume Classes and Structs (C++/CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span></span>  
  
 <span data-ttu-id="3df45-321">Da Garbage Collection nicht deterministisch ist, wissen Sie nicht genau, wann der Garbage Collector die Finalisierung ausführt.</span><span class="sxs-lookup"><span data-stu-id="3df45-321">Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</span></span> <span data-ttu-id="3df45-322">Um Ressourcen sofort freizugeben, können Sie auch das Lösch [Muster](~/docs/standard/garbage-collection/implementing-dispose.md) und die <xref:System.IDisposable>-Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="3df45-322">To release resources immediately, you can also choose to implement the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose.md) and the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="3df45-323">Die <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>-Implementierung kann von Consumern der-Klasse aufgerufen werden, um nicht verwaltete Ressourcen freizugeben, und Sie können die <xref:System.Object.Finalize%2A>-Methode verwenden, um nicht verwaltete Ressourcen freizugeben, wenn die <xref:System.IDisposable.Dispose%2A>-Methode nicht aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-323">The <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <xref:System.Object.Finalize%2A> method to free unmanaged resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called.</span></span>  
  
 <span data-ttu-id="3df45-324"><xref:System.Object.Finalize%2A> können fast jede Aktion ausführen, einschließlich der Wiederherstellung eines Objekts (d. h., dass das Objekt erneut zugänglich ist), nachdem es während der Garbage Collection bereinigt wurde.</span><span class="sxs-lookup"><span data-stu-id="3df45-324"><xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</span></span> <span data-ttu-id="3df45-325">Das Objekt kann jedoch nur einmal wieder auferstanden werden. <xref:System.Object.Finalize%2A> kann während Garbage Collection nicht für wiederbelebte Objekte aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-325">However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection.</span></span>
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a><span data-ttu-id="3df45-326">Die SafeHandle-Alternative</span><span class="sxs-lookup"><span data-stu-id="3df45-326">The SafeHandle alternative</span></span>  
 <span data-ttu-id="3df45-327">Das Erstellen zuverlässiger Finalizer ist oft schwierig, da Sie keine Annahmen über den Zustand Ihrer Anwendung treffen können und weil nicht behandelte System Ausnahmen wie <xref:System.OutOfMemoryException> und <xref:System.StackOverflowException> den Finalizer beenden.</span><span class="sxs-lookup"><span data-stu-id="3df45-327">Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer.</span></span> <span data-ttu-id="3df45-328">Anstatt einen Finalizer für die-Klasse zu implementieren, um nicht verwaltete Ressourcen freizugeben, können Sie ein Objekt verwenden, das von der <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>-Klasse abgeleitet wird, um die nicht verwalteten Ressourcen zu umschließen, und dann das Lösch Muster ohne Finalizer zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="3df45-328">Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</span></span> <span data-ttu-id="3df45-329">Der .NET Framework stellt die folgenden Klassen in den <xref:Microsoft.Win32?displayProperty=nameWithType>-Namespace bereit, die von <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>abgeleitet sind:</span><span class="sxs-lookup"><span data-stu-id="3df45-329">The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=nameWithType> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span></span>  
  
-   <span data-ttu-id="3df45-330"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> ist eine Wrapper Klasse für ein Datei handle.</span><span class="sxs-lookup"><span data-stu-id="3df45-330"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> is a wrapper class for a file handle.</span></span>  
  
-   <span data-ttu-id="3df45-331"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> ist eine Wrapper Klasse für im Speicher abgebildete Datei Handles.</span><span class="sxs-lookup"><span data-stu-id="3df45-331"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> is a wrapper class for memory-mapped file handles.</span></span>  
  
-   <span data-ttu-id="3df45-332"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> ist eine Wrapper Klasse für einen Zeiger auf einen Block von nicht verwaltetem Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="3df45-332"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> is a wrapper class for a pointer to a block of unmanaged memory.</span></span>  
  
-   <span data-ttu-id="3df45-333"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>und <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> sind Wrapper Klassen für kryptografische Handles.</span><span class="sxs-lookup"><span data-stu-id="3df45-333"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> are wrapper classes for cryptographic handles.</span></span>  
  
-   <span data-ttu-id="3df45-334"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> ist eine Wrapper Klasse für Pipehandles.</span><span class="sxs-lookup"><span data-stu-id="3df45-334"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> is a wrapper class for pipe handles.</span></span>  
  
-   <span data-ttu-id="3df45-335"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> ist eine Wrapper Klasse für ein Handle für einen Registrierungsschlüssel.</span><span class="sxs-lookup"><span data-stu-id="3df45-335"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> is a wrapper class for a handle to a registry key.</span></span>  
  
-   <span data-ttu-id="3df45-336"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> ist eine Wrapper Klasse für ein Wait-Handle.</span><span class="sxs-lookup"><span data-stu-id="3df45-336"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> is a wrapper class for a wait handle.</span></span>  
  
 <span data-ttu-id="3df45-337">Im folgenden Beispiel wird das Verwerfen- [Muster](~/docs/standard/garbage-collection/implementing-dispose.md) mit sicheren Handles verwendet, anstatt die <xref:System.Object.Finalize%2A>-Methode zu überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-337">The following example uses the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose.md) with safe handles instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="3df45-338">Es definiert eine `FileAssociation` Klasse, die Registrierungsinformationen zu der Anwendung umschließt, die Dateien mit einer bestimmten Dateierweiterung verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="3df45-338">It defines a `FileAssociation` class that wraps registry information about the application that handles files with a particular file extension.</span></span> <span data-ttu-id="3df45-339">Die beiden Registrierungs Handles, die von Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) -Funktionsaufrufen als `out`-Parameter zurückgegeben werden, werden an den <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>-Konstruktor übergeben.</span><span class="sxs-lookup"><span data-stu-id="3df45-339">The two registry handles returned as `out` parameters by Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) function calls are passed to the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor.</span></span> <span data-ttu-id="3df45-340">Die geschützte `Dispose`-Methode des Typs ruft dann die `SafeRegistryHandle.Dispose`-Methode auf, um diese beiden Handles freizugeben.</span><span class="sxs-lookup"><span data-stu-id="3df45-340">The type's protected `Dispose` method then calls the `SafeRegistryHandle.Dispose` method  to free these two handles.</span></span>  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="3df45-341">Im folgenden Beispiel wird überprüft, ob die <xref:System.Object.Finalize%2A>-Methode aufgerufen wird, wenn ein Objekt, das <xref:System.Object.Finalize%2A> überschreibt, zerstört wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-341">The following example verifies that the <xref:System.Object.Finalize%2A> method is called when an object that overrides <xref:System.Object.Finalize%2A> is destroyed.</span></span> <span data-ttu-id="3df45-342">Beachten Sie, dass die <xref:System.Object.Finalize%2A>-Methode in einer Produktionsanwendung außer Kraft gesetzt wird, um nicht verwaltete Ressourcen freizugeben, die vom-Objekt aufbewahrt werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-342">Note that, in a production application, the <xref:System.Object.Finalize%2A> method would be overridden to release unmanaged resources held by the object.</span></span> <span data-ttu-id="3df45-343">Beachten Sie außerdem, C# dass das Beispiel einen Dekonstruktor bereitstellt, anstatt die <xref:System.Object.Finalize%2A>-Methode zu überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-343">Also note that the C# example provides a destructor instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 <span data-ttu-id="3df45-344">Ein weiteres Beispiel, das die <xref:System.Object.Finalize%2A>-Methode überschreibt, finden Sie unter der <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>-Methode.</span><span class="sxs-lookup"><span data-stu-id="3df45-344">For an additional example that overrides the <xref:System.Object.Finalize%2A> method, see the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3df45-345">Dient als die Standard-Hashfunktion</span><span class="sxs-lookup"><span data-stu-id="3df45-345">Serves as the default hash function.</span></span></summary>
        <returns><span data-ttu-id="3df45-346">Ein Hashcode für das aktuelle Objekt.</span><span class="sxs-lookup"><span data-stu-id="3df45-346">A hash code for the current object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3df45-347">Ein Hashcode ist ein numerischer Wert, mit dem ein Objekt in einer Hash basierten Auflistung, z. b. die <xref:System.Collections.Generic.Dictionary%602> Klasse, die <xref:System.Collections.Hashtable>-Klasse oder ein von der <xref:System.Collections.DictionaryBase>-Klasse abgeleiteter Typ, eingefügt und identifiziert werden kann.</span><span class="sxs-lookup"><span data-stu-id="3df45-347">A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class.</span></span> <span data-ttu-id="3df45-348">Die <xref:System.Object.GetHashCode%2A>-Methode stellt diesen Hashcode für Algorithmen bereit, die schnelle Überprüfungen der Objekt Gleichheit benötigen.</span><span class="sxs-lookup"><span data-stu-id="3df45-348">The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3df45-349">Informationen zur Verwendung von Hashcodes in Hash Tabellen und einige zusätzliche Hash Code Algorithmen finden Sie im Eintrag [Hash Function](https://en.wikipedia.org/wiki/Hash_function) in Wikipedia.</span><span class="sxs-lookup"><span data-stu-id="3df45-349">For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the [Hash Function](https://en.wikipedia.org/wiki/Hash_function) entry in Wikipedia.</span></span>  
  
 <span data-ttu-id="3df45-350">Zwei Objekte, die gleich sind, gleichmäßige Rückgabe Hashcodes sind gleich.</span><span class="sxs-lookup"><span data-stu-id="3df45-350">Two objects that are equal return hash codes that are equal.</span></span> <span data-ttu-id="3df45-351">Umgekehrt ist dies jedoch nicht der Fall: gleiche Hashcodes implizieren keine Objekt Gleichheit, da verschiedene (ungleich) Objekte identische Hashcodes aufweisen können.</span><span class="sxs-lookup"><span data-stu-id="3df45-351">However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</span></span> <span data-ttu-id="3df45-352">Außerdem garantiert .net nicht die Standard Implementierung der <xref:System.Object.GetHashCode%2A>-Methode, und der von dieser Methode zurückgegebene Wert kann sich zwischen .net-Implementierungen, wie z. b. verschiedenen Versionen von .NET Framework und .net Core, und Plattformen wie 32-Bit-und 64-Bit-Plattformen unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="3df45-352">Furthermore, .NET does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET implementations, such as different versions of .NET Framework and .NET Core, and platforms, such as 32-bit and 64-bit platforms.</span></span> <span data-ttu-id="3df45-353">Verwenden Sie aus diesen Gründen nicht die Standard Implementierung dieser Methode als eindeutigen Objekt Bezeichner für Hash Zwecke.</span><span class="sxs-lookup"><span data-stu-id="3df45-353">For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</span></span> <span data-ttu-id="3df45-354">Es folgen zwei Konsequenzen:</span><span class="sxs-lookup"><span data-stu-id="3df45-354">Two consequences follow from this:</span></span>  
  
-   <span data-ttu-id="3df45-355">Sie sollten nicht davon ausgehen, dass die gleichen Hashcodes Objekt Gleichheit implizieren.</span><span class="sxs-lookup"><span data-stu-id="3df45-355">You should not assume that equal hash codes imply object equality.</span></span>  
  
-   <span data-ttu-id="3df45-356">Sie sollten niemals einen Hashcode außerhalb der Anwendungsdomäne beibehalten oder verwenden, in der er erstellt wurde, da das gleiche Objekt über Anwendungs Domänen, Prozesse und Plattformen hinweg einen Hash durchführen kann.</span><span class="sxs-lookup"><span data-stu-id="3df45-356">You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="3df45-357">Ein Hashcode ist für die effiziente Einfügung und Suche in Auflistungen vorgesehen, die auf einer Hash Tabelle basieren.</span><span class="sxs-lookup"><span data-stu-id="3df45-357">A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</span></span> <span data-ttu-id="3df45-358">Ein Hashcode ist kein dauerhafter Wert.</span><span class="sxs-lookup"><span data-stu-id="3df45-358">A hash code is not a permanent value.</span></span> <span data-ttu-id="3df45-359">Aus diesem Grund:</span><span class="sxs-lookup"><span data-stu-id="3df45-359">For this reason:</span></span>  
>   
> -   <span data-ttu-id="3df45-360">Serialisieren Sie keine Hash Code Werte, oder speichern Sie Sie nicht in Datenbanken.</span><span class="sxs-lookup"><span data-stu-id="3df45-360">Do not serialize hash code values or store them in databases.</span></span>  
> -   <span data-ttu-id="3df45-361">Verwenden Sie den Hashcode nicht als Schlüssel zum Abrufen eines Objekts aus einer Schlüssel gebundenen Auflistung.</span><span class="sxs-lookup"><span data-stu-id="3df45-361">Do not use the hash code as the key to retrieve an object from a keyed collection.</span></span>  
> -   <span data-ttu-id="3df45-362">Senden Sie keine Hashcodes über Anwendungs Domänen oder Prozesse hinweg.</span><span class="sxs-lookup"><span data-stu-id="3df45-362">Do not send hash codes across application domains or processes.</span></span> <span data-ttu-id="3df45-363">In einigen Fällen können Hashcodes pro Prozess oder pro Anwendungsdomäne berechnet werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-363">In some cases, hash codes may be computed on a per-process or per-application domain basis.</span></span>  
> -   <span data-ttu-id="3df45-364">Verwenden Sie nicht den Hashcode anstelle eines Werts, der von einer kryptografischen Hash Funktion zurückgegeben wird, wenn Sie einen kryptografisch starken Hash benötigen.</span><span class="sxs-lookup"><span data-stu-id="3df45-364">Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="3df45-365">Verwenden Sie für kryptografische Hashes eine Klasse, die von der <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> oder <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> Klasse abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="3df45-365">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
> -   <span data-ttu-id="3df45-366">Testen Sie nicht auf Gleichheit von Hashcodes, um zu bestimmen, ob zwei Objekte gleich sind.</span><span class="sxs-lookup"><span data-stu-id="3df45-366">Do not test for equality of hash codes to determine whether two objects are equal.</span></span> <span data-ttu-id="3df45-367">(Ungleiche Objekte können identische Hashcodes aufweisen.) Um auf Gleichheit zu prüfen, wenden Sie die Methode <xref:System.Object.ReferenceEquals%2A> oder <xref:System.Object.Equals%2A> an.</span><span class="sxs-lookup"><span data-stu-id="3df45-367">(Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="3df45-368">Die <xref:System.Object.GetHashCode%2A>-Methode kann von einem abgeleiteten Typ überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-368">The <xref:System.Object.GetHashCode%2A> method can be overridden by a derived type.</span></span> <span data-ttu-id="3df45-369">Wenn <xref:System.Object.GetHashCode%2A> nicht überschrieben wird, werden Hashcodes für Verweis Typen berechnet, indem die <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>-Methode der Basisklasse aufgerufen wird, die einen Hashcode basierend auf dem Verweis eines Objekts berechnet. Weitere Informationen finden Sie unter <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3df45-369">If <xref:System.Object.GetHashCode%2A> is not overridden, hash codes for reference types are computed by calling the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3df45-370">Das heißt, dass zwei Objekte, für die die <xref:System.Object.ReferenceEquals%2A> Methode `true` zurückgibt, über identische Hashcodes verfügen.</span><span class="sxs-lookup"><span data-stu-id="3df45-370">In other words, two objects for which the <xref:System.Object.ReferenceEquals%2A> method returns `true` have identical hash codes.</span></span> <span data-ttu-id="3df45-371">Wenn Werttypen <xref:System.Object.GetHashCode%2A>nicht überschreiben, verwendet die <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType>-Methode der Basisklasse Reflektion, um den Hashcode basierend auf den Werten der Felder des Typs zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="3df45-371">If value types do not override <xref:System.Object.GetHashCode%2A>, the <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</span></span> <span data-ttu-id="3df45-372">Anders ausgedrückt: Werttypen, deren Felder gleich sind, haben gleiche Hashcodes.</span><span class="sxs-lookup"><span data-stu-id="3df45-372">In other words, value types whose fields have equal values have equal hash codes.</span></span> <span data-ttu-id="3df45-373">Weitere Informationen zum Überschreiben von <xref:System.Object.GetHashCode%2A>finden Sie im Abschnitt "Hinweise zu Vererbung".</span><span class="sxs-lookup"><span data-stu-id="3df45-373">For more information about overriding <xref:System.Object.GetHashCode%2A>, see the "Notes to Inheritors" section.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="3df45-374">Wenn Sie die <xref:System.Object.GetHashCode%2A>-Methode außer Kraft setzen, sollten Sie auch <xref:System.Object.Equals%2A>außer Kraft setzen und umgekehrt.</span><span class="sxs-lookup"><span data-stu-id="3df45-374">If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa.</span></span> <span data-ttu-id="3df45-375">Wenn die überschriebene <xref:System.Object.Equals%2A> Methode `true` zurückgibt, wenn zwei Objekte auf Gleichheit geprüft werden, muss die überschriebene <xref:System.Object.GetHashCode%2A> Methode den gleichen Wert für die beiden Objekte zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="3df45-375">If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects.</span></span>  
  
 <span data-ttu-id="3df45-376">Wenn ein Objekt, das als Schlüssel in einer Hash Tabelle verwendet wird, keine nützliche Implementierung von <xref:System.Object.GetHashCode%2A>bereitstellt, können Sie einen Hashcode-Anbieter angeben, indem Sie eine <xref:System.Collections.IEqualityComparer>-Implementierung für eine der über Ladungen des <xref:System.Collections.Hashtable>-Klassenkonstruktors bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="3df45-376">If an object that is used as a key in a hash table does not provide a useful implementation of <xref:System.Object.GetHashCode%2A>, you can specify a hash code provider by supplying an <xref:System.Collections.IEqualityComparer> implementation to one of the overloads of the <xref:System.Collections.Hashtable> class constructor.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="3df45-377">Hinweise für den [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="3df45-377">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="3df45-378">Wenn Sie die <xref:System.Object.GetHashCode%2A>-Methode für eine Klasse in der [!INCLUDE[wrt](~/includes/wrt-md.md)]aufzurufen, wird das Standardverhalten für Klassen bereitstellt, die <xref:System.Object.GetHashCode%2A>nicht überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-378">When you call the <xref:System.Object.GetHashCode%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="3df45-379">Dies ist ein Teil der Unterstützung, die der .NET Framework für die [!INCLUDE[wrt](~/includes/wrt-md.md)] bietet (siehe [.NET Framework Support für Windows Store-Apps und Windows-Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="3df45-379">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="3df45-380">Klassen im [!INCLUDE[wrt](~/includes/wrt-md.md)] erben <xref:System.Object>nicht und implementieren derzeit keine <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="3df45-380">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement a <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="3df45-381">Sie scheinen jedoch <xref:System.Object.ToString%2A>-, <xref:System.Object.Equals%28System.Object%29>-und <xref:System.Object.GetHashCode%2A>-Methoden zu haben, wenn Sie Sie im C# -oder-Visual Basic Code verwenden, und das .NET Framework stellt das Standardverhalten für diese Methoden bereit.</span><span class="sxs-lookup"><span data-stu-id="3df45-381">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="3df45-382">Klassen, die in C# oder Visual Basic geschrieben sind, können die <xref:System.Object.GetHashCode%2A>-Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-382">classes that are written in C# or Visual Basic can override the <xref:System.Object.GetHashCode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3df45-383">Eine der einfachsten Möglichkeiten, einen Hashcode für einen numerischen Wert zu berechnen, der denselben oder einen kleineren Bereich aufweist als der <xref:System.Int32> Typ, besteht darin, diesen Wert einfach zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="3df45-383">One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <xref:System.Int32> type is to simply return that value.</span></span> <span data-ttu-id="3df45-384">Das folgende Beispiel zeigt eine solche Implementierung für eine `Number` Struktur.</span><span class="sxs-lookup"><span data-stu-id="3df45-384">The following example shows such an implementation for a `Number` structure.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 <span data-ttu-id="3df45-385">Häufig verfügt ein Typ über mehrere Datenfelder, die an der Erstellung des Hashcodes beteiligt sein können.</span><span class="sxs-lookup"><span data-stu-id="3df45-385">Frequently, a type has multiple data fields that can participate in generating the hash code.</span></span> <span data-ttu-id="3df45-386">Eine Möglichkeit, einen Hashcode zu generieren, besteht darin, diese Felder mithilfe eines `XOR (eXclusive OR)` Vorgangs zu kombinieren, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="3df45-386">One way to generate a hash code is to combine these fields using an `XOR (eXclusive OR)` operation, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 <span data-ttu-id="3df45-387">Im vorherigen Beispiel wird derselbe Hashcode für (N1, N2) und (N2, N1) zurückgegeben, sodass möglicherweise mehr Kollisionen generiert, als wünschenswert sind.</span><span class="sxs-lookup"><span data-stu-id="3df45-387">The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</span></span> <span data-ttu-id="3df45-388">Es stehen eine Reihe von Lösungen zur Verfügung, sodass Hashcodes in diesen Fällen nicht identisch sind.</span><span class="sxs-lookup"><span data-stu-id="3df45-388">A number of solutions are available so that hash codes in these cases are not identical.</span></span> <span data-ttu-id="3df45-389">Eine besteht darin, den Hashcode eines `Tuple` Objekts zurückzugeben, das die Reihenfolge der einzelnen Felder widerspiegelt.</span><span class="sxs-lookup"><span data-stu-id="3df45-389">One is to return the hash code of a `Tuple` object that reflects the order of each field.</span></span> <span data-ttu-id="3df45-390">Das folgende Beispiel zeigt eine mögliche Implementierung, die die <xref:System.Tuple%602>-Klasse verwendet.</span><span class="sxs-lookup"><span data-stu-id="3df45-390">The following example shows a possible implementation that uses the <xref:System.Tuple%602> class.</span></span> <span data-ttu-id="3df45-391">Beachten Sie jedoch, dass sich der Leistungs Aufwand beim Instanziieren eines `Tuple` Objekts erheblich auf die Gesamtleistung einer Anwendung auswirken kann, in der eine große Anzahl von Objekten in Hash Tabellen gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-391">Note, though, that the performance overhead of instantiating a `Tuple` object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 <span data-ttu-id="3df45-392">Eine zweite Alternative Lösung besteht darin, die einzelnen Hashcodes zu gewichten, indem die Hashcodes aufeinander folgender Felder um zwei oder mehr Bits verschoben werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-392">A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</span></span> <span data-ttu-id="3df45-393">Anstatt verworfen zu werden, sollten Bits, die über Bit 31 hinaus verschoben werden, umschlossen werden, anstatt verworfen zu werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-393">Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded.</span></span> <span data-ttu-id="3df45-394">Da Bits von den Left Shift-Operatoren sowohl C# in als auch Visual Basic verworfen werden, muss eine Left Shift-and-Wrap-Methode wie die folgende erstellt werden:</span><span class="sxs-lookup"><span data-stu-id="3df45-394">Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 <span data-ttu-id="3df45-395">Im folgenden Beispiel wird dann diese Shift-and-Wrap-Methode verwendet, um den Hashcode der `Point` Struktur zu berechnen, die in den vorherigen Beispielen verwendet wurde.</span><span class="sxs-lookup"><span data-stu-id="3df45-395">The following example then uses this shift-and-wrap method to compute the hash code of the `Point` structure used in the previous examples.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="3df45-396">Eine Hash Funktion wird verwendet, um schnell eine Zahl (Hashcode) zu generieren, die dem Wert eines Objekts entspricht.</span><span class="sxs-lookup"><span data-stu-id="3df45-396">A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object.</span></span> <span data-ttu-id="3df45-397">Hash Funktionen sind in der Regel für jeden Typ spezifisch und müssen aus Gründen der Eindeutigkeit mindestens eines der Instanzfelder als Eingabe verwenden.</span><span class="sxs-lookup"><span data-stu-id="3df45-397">Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input.</span></span> <span data-ttu-id="3df45-398">Hashcodes sollten nicht mithilfe der Werte statischer Felder berechnet werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-398">Hash codes should not be computed by using the values of static fields.</span></span>  
  
<span data-ttu-id="3df45-399">Bei Klassen, die von <see cref="T:System.Object" />abgeleitet werden, kann die <see langword="GetHashCode" />-Methode nur an die Basisklasse <see cref="M:System.Object.GetHashCode" />-Implementierung delegieren, wenn die abgeleitete Klasse Gleichheit als Verweis Gleichheit definiert.</span><span class="sxs-lookup"><span data-stu-id="3df45-399">For classes derived from <see cref="T:System.Object" />, the <see langword="GetHashCode" /> method can delegate to the base class <see cref="M:System.Object.GetHashCode" /> implementation only if the derived class defines equality to be reference equality.</span></span> <span data-ttu-id="3df45-400">Die Standard Implementierung von <see cref="M:System.Object.GetHashCode" /> für Verweis Typen gibt einen Hashcode zurück, der dem Wert entspricht, der von der <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />-Methode zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-400">The default implementation of <see cref="M:System.Object.GetHashCode" /> for reference types returns a hash code that is equivalent to the one returned by the <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> method.</span></span> <span data-ttu-id="3df45-401">Sie können <see cref="M:System.Object.GetHashCode" /> für unveränderliche Verweis Typen überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-401">You can override <see cref="M:System.Object.GetHashCode" /> for immutable reference types.</span></span> <span data-ttu-id="3df45-402">Im Allgemeinen sollten Sie für änderbare Verweis Typen <see cref="M:System.Object.GetHashCode" /> nur dann überschreiben, wenn Folgendes:</span><span class="sxs-lookup"><span data-stu-id="3df45-402">In general, for mutable reference types, you should override <see cref="M:System.Object.GetHashCode" /> only if:</span></span> 
<span data-ttu-id="3df45-403">-Sie können den Hashcode aus Feldern berechnen, die nicht änderbar sind. noch</span><span class="sxs-lookup"><span data-stu-id="3df45-403">-   You can compute the hash code from fields that are not mutable; or</span></span> 
<span data-ttu-id="3df45-404">-Sie können sicherstellen, dass sich der Hashcode eines änderbaren Objekts nicht ändert, während das Objekt in einer Auflistung enthalten ist, die auf seinem Hashcode basiert.</span><span class="sxs-lookup"><span data-stu-id="3df45-404">-   You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</span></span>  
  
<span data-ttu-id="3df45-405">Andernfalls denken Sie möglicherweise, dass das änderbare Objekt in der Hash Tabelle verloren geht.</span><span class="sxs-lookup"><span data-stu-id="3df45-405">Otherwise, you might think that the mutable object is lost in the hash table.</span></span> <span data-ttu-id="3df45-406">Wenn Sie <see cref="M:System.Object.GetHashCode" /> für einen änderbaren Referenztyp überschreiben möchten, sollte in der Dokumentation deutlich werden, dass die Benutzer des Typs Objektwerte nicht ändern sollten, während das Objekt in einer Hash Tabelle gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-406">If you do choose to override <see cref="M:System.Object.GetHashCode" /> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.</span></span>  
  
<span data-ttu-id="3df45-407">Für Werttypen bietet <see cref="M:System.ValueType.GetHashCode" /> eine standardmäßige Hash Code Implementierung, die Reflektion verwendet.</span><span class="sxs-lookup"><span data-stu-id="3df45-407">For value types, <see cref="M:System.ValueType.GetHashCode" /> provides a default hash code implementation that uses reflection.</span></span> <span data-ttu-id="3df45-408">Sie sollten diese überschreiben, um die Leistung zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="3df45-408">You should consider overriding it for better performance.</span></span>  
  
 <block subset="none" type="note"><para>  
 <span data-ttu-id="3df45-409">Weitere Informationen und Beispiele, in denen Hashcodes auf unterschiedlichste Weise berechnet werden, finden Sie im Abschnitt "Beispiele".</span><span class="sxs-lookup"><span data-stu-id="3df45-409">For more information and examples that compute hash codes in a variety of ways, see the Examples section.</span></span>  
  
</para></block>  
  
 <span data-ttu-id="3df45-410">Eine Hash Funktion muss über die folgenden Eigenschaften verfügen:</span><span class="sxs-lookup"><span data-stu-id="3df45-410">A hash function must have the following properties:</span></span> 
<span data-ttu-id="3df45-411">Wenn zwei-Objekte als gleich verglichen werden, muss die <see cref="M:System.Object.GetHashCode" />-Methode für jedes-Objekt den gleichen Wert zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="3df45-411">-   If two objects compare as equal, the <see cref="M:System.Object.GetHashCode" /> method for each object must return the same value.</span></span> <span data-ttu-id="3df45-412">Wenn jedoch zwei-Objekte nicht als gleich verglichen werden, müssen die <see cref="M:System.Object.GetHashCode" />-Methoden für die beiden-Objekte keine anderen Werte zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="3df45-412">However, if two objects do not compare as equal, the <see cref="M:System.Object.GetHashCode" /> methods for the two objects do not have to return different values.</span></span>  
  
<span data-ttu-id="3df45-413">-Die <see cref="M:System.Object.GetHashCode" />-Methode für ein Objekt muss den gleichen Hashcode immer wieder zurückgeben, solange keine Änderung des Objekt Zustands vorliegt, der den Rückgabewert der [System. Object. gleich](xref:System.Object.Equals*) -Methode des Objekts bestimmt.</span><span class="sxs-lookup"><span data-stu-id="3df45-413">-   The <see cref="M:System.Object.GetHashCode" /> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's [System.Object.Equals](xref:System.Object.Equals*) method.</span></span> <span data-ttu-id="3df45-414">Beachten Sie, dass dies nur für die aktuelle Ausführung einer Anwendung gilt und dass ein anderer Hashcode zurückgegeben werden kann, wenn die Anwendung erneut ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-414">Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.</span></span>  
  
<span data-ttu-id="3df45-415">-Für eine optimale Leistung sollte eine Hash Funktion eine gleichmäßige Verteilung für alle Eingaben generieren, einschließlich der stark gruppierten Eingaben.</span><span class="sxs-lookup"><span data-stu-id="3df45-415">-   For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered.</span></span> <span data-ttu-id="3df45-416">Dies impliziert, dass kleine Änderungen am Objektzustand zu großen Änderungen am resultierenden Hashcode führen sollten, um die beste Leistung der Hash Tabelle zu erzielen.</span><span class="sxs-lookup"><span data-stu-id="3df45-416">An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.</span></span>  
  
<span data-ttu-id="3df45-417">-Hash Funktionen sollten für die Berechnung günstig sein.</span><span class="sxs-lookup"><span data-stu-id="3df45-417">-   Hash functions should be inexpensive to compute.</span></span>  
  
<span data-ttu-id="3df45-418">-Die <see cref="M:System.Object.GetHashCode" /> Methode sollte keine Ausnahmen auslösen.</span><span class="sxs-lookup"><span data-stu-id="3df45-418">-   The <see cref="M:System.Object.GetHashCode" /> method should not throw exceptions.</span></span>  
  
<span data-ttu-id="3df45-419">Beispielsweise gibt die Implementierung der <see cref="M:System.String.GetHashCode" />-Methode, die von der <see cref="T:System.String" />-Klasse bereitgestellt wird, identische Hashcodes für identische Zeichen folgen Werte zurück.</span><span class="sxs-lookup"><span data-stu-id="3df45-419">For example, the implementation of the <see cref="M:System.String.GetHashCode" /> method provided by the <see cref="T:System.String" /> class returns identical hash codes for identical string values.</span></span> <span data-ttu-id="3df45-420">Daher geben zwei <see cref="T:System.String" />-Objekte denselben Hashcode zurück, wenn Sie denselben Zeichen folgen Wert darstellen.</span><span class="sxs-lookup"><span data-stu-id="3df45-420">Therefore, two <see cref="T:System.String" /> objects return the same hash code if they represent the same string value.</span></span> <span data-ttu-id="3df45-421">Außerdem verwendet die-Methode alle Zeichen in der Zeichenfolge, um eine relativ zufällig verteilte Ausgabe zu generieren, auch wenn die Eingabe in bestimmten Bereichen gruppiert ist (z. b. können viele Benutzer Zeichen folgen haben, die nur die unteren 128 ASCII-Zeichen enthalten, auch wenn eine die Zeichenfolge kann jedes der 65.535 Unicode-Zeichen enthalten.)</span><span class="sxs-lookup"><span data-stu-id="3df45-421">Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).</span></span>  
  
<span data-ttu-id="3df45-422">Das Bereitstellen einer guten Hash Funktion für eine Klasse kann die Leistung beim Hinzufügen dieser Objekte zu einer Hash Tabelle erheblich beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="3df45-422">Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table.</span></span> <span data-ttu-id="3df45-423">In einer Hash Tabelle mit Schlüsseln, die eine gute Implementierung einer Hash Funktion bereitstellen, benötigt das Suchen nach einem Element Konstante Zeit (z. b. ein O (1)-Vorgang).</span><span class="sxs-lookup"><span data-stu-id="3df45-423">In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation).</span></span> <span data-ttu-id="3df45-424">In einer Hash Tabelle, bei der die Implementierung einer Hash Funktion unzureichend ist, hängt die Leistung einer Suche von der Anzahl der Elemente in der Hash Tabelle ab (z. b. eines O (`n`)-Vorgangs, bei dem `n` die Anzahl der Elemente in der Hash Tabelle ist).</span><span class="sxs-lookup"><span data-stu-id="3df45-424">In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(`n`) operation, where `n` is the number of items in the hash table).</span></span> <span data-ttu-id="3df45-425">Ein böswilliger Benutzer kann Daten eingeben, die die Anzahl der Konflikte erhöhen. Dies kann die Leistung von Anwendungen, die von Hash Tabellen abhängen, unter den folgenden Bedingungen erheblich beeinträchtigen:</span><span class="sxs-lookup"><span data-stu-id="3df45-425">A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:</span></span> 
<span data-ttu-id="3df45-426">-Wenn Hash Funktionen häufige Konflikte verursachen.</span><span class="sxs-lookup"><span data-stu-id="3df45-426">-   When hash functions produce frequent collisions.</span></span>  
  
<span data-ttu-id="3df45-427">: Wenn ein großer Anteil von Objekten in einer Hash Tabelle Hashcodes erzeugt, die gleich oder ungefähr gleich zueinander sind.</span><span class="sxs-lookup"><span data-stu-id="3df45-427">-   When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.</span></span>  
  
<span data-ttu-id="3df45-428">: Wenn Benutzer die Daten eingeben, aus denen der Hashcode berechnet wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-428">-   When users input the data from which the hash code is computed.</span></span>  
  
<span data-ttu-id="3df45-429">Abgeleitete Klassen, die <see cref="M:System.Object.GetHashCode" /> überschreiben, müssen auch <see cref="M:System.Object.Equals(System.Object)" /> überschreiben, um sicherzustellen, dass zwei als gleich betrachtet werden Andernfalls funktioniert der <see cref="T:System.Collections.Hashtable" /> Typ möglicherweise nicht ordnungsgemäß.</span><span class="sxs-lookup"><span data-stu-id="3df45-429">Derived classes that override <see cref="M:System.Object.GetHashCode" /> must also override <see cref="M:System.Object.Equals(System.Object)" /> to guarantee that two objects considered equal have the same hash code; otherwise, the <see cref="T:System.Collections.Hashtable" /> type might not work correctly.</span></span></para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3df45-430">Ruft den <see cref="T:System.Type" /> der aktuellen Instanz ab.</span><span class="sxs-lookup"><span data-stu-id="3df45-430">Gets the <see cref="T:System.Type" /> of the current instance.</span></span></summary>
        <returns><span data-ttu-id="3df45-431">Der genaue Laufzeittyp der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="3df45-431">The exact runtime type of the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3df45-432">Da <xref:System.Object?displayProperty=nameWithType> die Basisklasse für alle Typen im .net-Typsystem ist, kann die <xref:System.Object.GetType%2A>-Methode verwendet werden, um <xref:System.Type>-Objekte zurückzugeben, die alle .NET-Typen darstellen.</span><span class="sxs-lookup"><span data-stu-id="3df45-432">Because <xref:System.Object?displayProperty=nameWithType> is the base class for all types in the .NET type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET types.</span></span> <span data-ttu-id="3df45-433">.Net erkennt die folgenden fünf Kategorien von Typen:</span><span class="sxs-lookup"><span data-stu-id="3df45-433">.NET recognizes the following five categories of types:</span></span>  
  
-   <span data-ttu-id="3df45-434">Klassen, die von <xref:System.Object?displayProperty=nameWithType>abgeleitet sind,</span><span class="sxs-lookup"><span data-stu-id="3df45-434">Classes, which are derived from <xref:System.Object?displayProperty=nameWithType>,</span></span>  
  
-   <span data-ttu-id="3df45-435">Werttypen, die von <xref:System.ValueType?displayProperty=nameWithType>abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-435">Value types, which are derived from <xref:System.ValueType?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="3df45-436">Schnittstellen, die von <xref:System.Object?displayProperty=nameWithType> abgeleitet werden, beginnend mit dem .NET Framework 2,0.</span><span class="sxs-lookup"><span data-stu-id="3df45-436">Interfaces, which are derived from <xref:System.Object?displayProperty=nameWithType> starting with the .NET Framework 2.0.</span></span>  
  
-   <span data-ttu-id="3df45-437">Enumerationen, die von <xref:System.Enum?displayProperty=nameWithType>abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-437">Enumerations, which are derived from <xref:System.Enum?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="3df45-438">Delegaten, die von <xref:System.MulticastDelegate?displayProperty=nameWithType>abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-438">Delegates, which are derived from <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="3df45-439">Bei zwei Objekten `x` und `y`, die identische Lauf Zeit Typen aufweisen, gibt `Object.ReferenceEquals(x.GetType(),y.GetType())` `true`zurück.</span><span class="sxs-lookup"><span data-stu-id="3df45-439">For two objects `x` and `y` that have identical runtime types, `Object.ReferenceEquals(x.GetType(),y.GetType())` returns `true`.</span></span> <span data-ttu-id="3df45-440">Im folgenden Beispiel wird die <xref:System.Object.GetType%2A>-Methode mit der <xref:System.Object.ReferenceEquals%2A>-Methode verwendet, um zu bestimmen, ob ein numerischer Wert dem gleichen Typ wie zwei andere numerische Werte entspricht.</span><span class="sxs-lookup"><span data-stu-id="3df45-440">The following example uses the <xref:System.Object.GetType%2A> method with the <xref:System.Object.ReferenceEquals%2A> method to determine whether one numeric value is the same type as two other numeric values.</span></span>  
  
 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 [!code-csharp-interactive[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  <span data-ttu-id="3df45-441">Um zu ermitteln, ob ein Objekt ein bestimmter Typ ist, können Sie das typvergleichs Schlüsselwort oder das Konstrukt ihrer Sprache verwenden.</span><span class="sxs-lookup"><span data-stu-id="3df45-441">To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</span></span> <span data-ttu-id="3df45-442">Beispielsweise können Sie das `TypeOf…Is`-Konstrukt in Visual Basic oder das `is`-Schlüsselwort C#in verwenden.</span><span class="sxs-lookup"><span data-stu-id="3df45-442">For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#.</span></span>  
  
 <span data-ttu-id="3df45-443">Die <xref:System.Object.GetType%2A>-Methode wird von allen Typen geerbt, die von <xref:System.Object>abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-443">The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>.</span></span> <span data-ttu-id="3df45-444">Dies bedeutet, dass Sie zusätzlich zur Verwendung des Vergleichs Schlüsselworts ihrer eigenen Sprache die <xref:System.Object.GetType%2A>-Methode verwenden können, um den Typ eines bestimmten Objekts zu bestimmen, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="3df45-444">This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <span data-ttu-id="3df45-445">Das <xref:System.Type>-Objekt macht die Metadaten verfügbar, die der-Klasse der aktuellen <xref:System.Object>zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="3df45-445">The <xref:System.Type> object exposes the metadata associated with the class of the current <xref:System.Object>.</span></span>  
  
   
  
## Examples  

 <span data-ttu-id="3df45-446">Im folgenden Codebeispiel wird veranschaulicht, dass <xref:System.Object.GetType%2A> den Lauf Zeittyp der aktuellen Instanz zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="3df45-446">The following code example demonstrates that <xref:System.Object.GetType%2A> returns the runtime type of the current instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3df45-447">Erstellt eine flache Kopie des aktuellen <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="3df45-447">Creates a shallow copy of the current <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="3df45-448">Eine flache Kopie des aktuellen <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="3df45-448">A shallow copy of the current <see cref="T:System.Object" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3df45-449">Durch die <xref:System.Object.MemberwiseClone%2A>-Methode wird eine flache Kopie erstellt, indem ein neues-Objekt erstellt und dann die nicht statischen Felder des aktuellen-Objekts in das neue-Objekt kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-449">The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</span></span> <span data-ttu-id="3df45-450">Wenn ein Feld ein Werttyp ist, wird eine Bit-für-Bit-Kopie des Felds ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="3df45-450">If a field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="3df45-451">Wenn ein Feld ein Referenztyp ist, wird der Verweis kopiert, aber das Objekt, auf das verwiesen wird, nicht. Daher verweisen das ursprüngliche Objekt und der zugehörige Klon auf dasselbe Objekt.</span><span class="sxs-lookup"><span data-stu-id="3df45-451">If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</span></span>  
  
 <span data-ttu-id="3df45-452">Angenommen, ein Objekt mit dem Namen X verweist auf die Objekte A und B. Object B wiederum verweist auf Objekt C. Eine flache Kopie von X erstellt ein neues Objekt x2, das auch auf die Objekte A und B verweist. Im Gegensatz dazu erstellt eine tiefe Kopie von X ein neues Objekt x2, das auf die neuen Objekte a2 und B2 verweist, die Kopien von a und B. B2 wiederum auf das neue Objekt C2, das eine Kopie von C ist. Das Beispiel veranschaulicht den Unterschied zwischen einem flachen und einem Deep Copy-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="3df45-452">For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</span></span>  
  
 <span data-ttu-id="3df45-453">Es gibt zahlreiche Möglichkeiten, einen Deep Copy-Vorgang zu implementieren, wenn der flache Kopiervorgang, der von der <xref:System.Object.MemberwiseClone%2A>-Methode ausgeführt wird, nicht Ihren Anforderungen entspricht.</span><span class="sxs-lookup"><span data-stu-id="3df45-453">There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs.</span></span> <span data-ttu-id="3df45-454">Hierzu gehört Folgendes:</span><span class="sxs-lookup"><span data-stu-id="3df45-454">These include the following:</span></span>  
  
-   <span data-ttu-id="3df45-455">Rufen Sie einen Klassenkonstruktor des Objekts auf, das kopiert werden soll, um ein zweites Objekt mit Eigenschafts Werten zu erstellen, die aus dem ersten Objekt entnommen werden</span><span class="sxs-lookup"><span data-stu-id="3df45-455">Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</span></span> <span data-ttu-id="3df45-456">Dabei wird davon ausgegangen, dass die Werte eines Objekts vollständig durch den Klassenkonstruktor definiert werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-456">This assumes that the values of an object are entirely defined by its class constructor.</span></span>  
  
-   <span data-ttu-id="3df45-457">Rufen Sie die <xref:System.Object.MemberwiseClone%2A>-Methode auf, um eine flache Kopie eines Objekts zu erstellen, und weisen Sie dann neue Objekte zu, deren Werte mit dem ursprünglichen Objekt identisch sind, und den Eigenschaften oder Feldern, deren Werte Verweis Typen sind.</span><span class="sxs-lookup"><span data-stu-id="3df45-457">Call the <xref:System.Object.MemberwiseClone%2A> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</span></span> <span data-ttu-id="3df45-458">Diese Vorgehensweise wird durch die `DeepCopy`-Methode im Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="3df45-458">The `DeepCopy` method in the example illustrates this approach.</span></span>  
  
-   <span data-ttu-id="3df45-459">Serialisieren Sie das Objekt, das tief kopiert werden soll, und stellen Sie die serialisierten Daten dann in einer anderen Objektvariablen wieder her.</span><span class="sxs-lookup"><span data-stu-id="3df45-459">Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</span></span>  
  
-   <span data-ttu-id="3df45-460">Verwenden Sie Reflektion mit Rekursion, um den Deep Copy-Vorgang auszuführen.</span><span class="sxs-lookup"><span data-stu-id="3df45-460">Use reflection with recursion to perform the deep copy operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3df45-461">Im folgenden Beispiel wird die <xref:System.Object.MemberwiseClone%2A>-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="3df45-461">The following example illustrates the <xref:System.Object.MemberwiseClone%2A> method.</span></span> <span data-ttu-id="3df45-462">Es definiert eine `ShallowCopy` Methode, die die <xref:System.Object.MemberwiseClone%2A>-Methode aufruft, um einen flachen Kopiervorgang für ein `Person`-Objekt auszuführen.</span><span class="sxs-lookup"><span data-stu-id="3df45-462">It defines a `ShallowCopy` method that calls the <xref:System.Object.MemberwiseClone%2A> method to perform a shallow copy operation on a `Person` object.</span></span> <span data-ttu-id="3df45-463">Außerdem wird eine `DeepCopy` Methode definiert, die einen Deep Copy-Vorgang für ein `Person`-Objekt ausführt.</span><span class="sxs-lookup"><span data-stu-id="3df45-463">It also defines a `DeepCopy` method that performs a deep copy operation on a `Person` object.</span></span>  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 <span data-ttu-id="3df45-464">In diesem Beispiel gibt die `Person.IdInfo`-Eigenschaft ein `IdInfo`-Objekt zurück.</span><span class="sxs-lookup"><span data-stu-id="3df45-464">In this example, the `Person.IdInfo` property returns an `IdInfo` object.</span></span> <span data-ttu-id="3df45-465">Wie die Ausgabe des Beispiels zeigt, ist das geklonte `Person`-Objekt, wenn ein `Person` Objekt durch Aufrufen der <xref:System.Object.MemberwiseClone%2A>-Methode geklont wird, eine unabhängige Kopie des ursprünglichen-Objekts, mit dem Unterschied, dass Sie denselben `Person.IdInfo` Objekt Verweis gemeinsam verwenden.</span><span class="sxs-lookup"><span data-stu-id="3df45-465">As the output from the example shows, when a `Person` object is cloned by calling the <xref:System.Object.MemberwiseClone%2A> method, the cloned `Person` object is an independent copy of the original object, except that they share the same `Person.IdInfo` object reference.</span></span> <span data-ttu-id="3df45-466">Folglich ändert das Ändern der `Person.IdInfo`-Eigenschaft des Klons die `Person.IdInfo` Eigenschaft des ursprünglichen Objekts.</span><span class="sxs-lookup"><span data-stu-id="3df45-466">As a result, modifying the clone's `Person.IdInfo` property changes the original object's `Person.IdInfo` property.</span></span> <span data-ttu-id="3df45-467">Wenn dagegen ein Deep Copy-Vorgang ausgeführt wird, kann das geklonte `Person` Objekt, einschließlich seiner `Person.IdInfo`-Eigenschaft, geändert werden, ohne dass sich dies auf das ursprüngliche Objekt auswirkt.</span><span class="sxs-lookup"><span data-stu-id="3df45-467">On the other hand, when a deep copy operation is performed, the cloned `Person` object, including its `Person.IdInfo` property, can be modified without affecting the original object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA"><span data-ttu-id="3df45-468">Das erste zu vergleichende Objekt.</span><span class="sxs-lookup"><span data-stu-id="3df45-468">The first object to compare.</span></span></param>
        <param name="objB"><span data-ttu-id="3df45-469">Das zweite zu vergleichende Objekt.</span><span class="sxs-lookup"><span data-stu-id="3df45-469">The second object  to compare.</span></span></param>
        <summary><span data-ttu-id="3df45-470">Stellt fest, ob die angegebenen <see cref="T:System.Object" />-Instanzen dieselbe Instanz sind.</span><span class="sxs-lookup"><span data-stu-id="3df45-470">Determines whether the specified <see cref="T:System.Object" /> instances are the same instance.</span></span></summary>
        <returns><span data-ttu-id="3df45-471"><see langword="true" />, wenn <paramref name="objA" /> dieselbe Instanz wie <paramref name="objB" /> ist oder beide **NULL** sind, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3df45-471"><see langword="true" /> if <paramref name="objA" /> is the same instance as <paramref name="objB" /> or if both are **null**; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3df45-472">Anders als die <xref:System.Object.Equals%2A>-Methode und der Gleichheits Operator kann die <xref:System.Object.ReferenceEquals%2A>-Methode nicht überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-472">Unlike the <xref:System.Object.Equals%2A> method and the equality operator, the <xref:System.Object.ReferenceEquals%2A> method cannot be overridden.</span></span> <span data-ttu-id="3df45-473">Wenn Sie daher zwei Objekt Verweise auf Gleichheit testen möchten, und Sie sich nicht sicher sind, ob die `Equals`-Methode implementiert ist, können Sie die <xref:System.Object.ReferenceEquals%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="3df45-473">Because of this, if you want to test two object references for equality and you are unsure about the implementation of the `Equals` method, you can call the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 <span data-ttu-id="3df45-474">Der Rückgabewert der <xref:System.Object.ReferenceEquals%2A>-Methode erscheint in den folgenden beiden Szenarien möglicherweise als anormale:</span><span class="sxs-lookup"><span data-stu-id="3df45-474">However, the return value of the <xref:System.Object.ReferenceEquals%2A> method may appear to be anomalous in these two scenarios:</span></span>  
  
-   <span data-ttu-id="3df45-475">Beim Vergleichen von Werttypen.</span><span class="sxs-lookup"><span data-stu-id="3df45-475">When comparing value types.</span></span> <span data-ttu-id="3df45-476">Wenn `objA` und `objB` Werttypen sind, werden Sie vor der Übergabe an die <xref:System.Object.ReferenceEquals%2A>-Methode gekapselt.</span><span class="sxs-lookup"><span data-stu-id="3df45-476">If `objA` and `objB` are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="3df45-477">Dies bedeutet, dass, wenn sowohl `objA` als auch `objB` die gleiche Instanz eines Werttyps darstellen, die <xref:System.Object.ReferenceEquals%2A>-Methode trotzdem `false`zurückgibt, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="3df45-477">This means that if both `objA` and `objB` represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns `false`, as the following example shows.</span></span>  
  
     [!code-csharp-interactive[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     <span data-ttu-id="3df45-478">Informationen zu Boxing-Werttypen finden Sie unter [Boxing und Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span><span class="sxs-lookup"><span data-stu-id="3df45-478">For information on boxing value types, see [Boxing and Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span></span>  
  
-   <span data-ttu-id="3df45-479">Beim Vergleichen von Zeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="3df45-479">When comparing strings.</span></span> <span data-ttu-id="3df45-480">Wenn `objA` und `objB` Zeichen folgen sind, gibt die <xref:System.Object.ReferenceEquals%2A>-Methode `true` zurück, wenn die Zeichenfolge interniert ist.</span><span class="sxs-lookup"><span data-stu-id="3df45-480">If `objA` and `objB` are strings, the <xref:System.Object.ReferenceEquals%2A> method returns `true` if the string is interned.</span></span> <span data-ttu-id="3df45-481">Es wird kein Test auf Wert Gleichheit durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="3df45-481">It does not perform a test for value equality.</span></span>  <span data-ttu-id="3df45-482">Im folgenden Beispiel sind `s1` und `s2` gleich, da es sich um zwei Instanzen einer einzelnen, Internpool vorhanden Zeichenfolge handelt.</span><span class="sxs-lookup"><span data-stu-id="3df45-482">In the following example, `s1` and `s2` are equal because they are two instances of a single interned string.</span></span> <span data-ttu-id="3df45-483">`s3` und `s4` sind jedoch nicht gleich, denn obwohl Sie identische Zeichen folgen Werte aufweisen, wird diese Zeichenfolge nicht interniert.</span><span class="sxs-lookup"><span data-stu-id="3df45-483">However, `s3` and `s4` are not equal, because although they are have identical string values, that string is not interned.</span></span>  
  
     [!code-csharp-interactive[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     <span data-ttu-id="3df45-484">Weitere Informationen zum Zusammensetzen von Zeichen folgen finden Sie unter <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3df45-484">For more information about string interning, see <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

 <span data-ttu-id="3df45-485">Im folgenden Beispiel wird <xref:System.Object.ReferenceEquals%2A> verwendet, um zu bestimmen, ob zwei-Objekte dieselbe Instanz sind.</span><span class="sxs-lookup"><span data-stu-id="3df45-485">The following example uses <xref:System.Object.ReferenceEquals%2A> to determine if two objects are the same instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp-interactive[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3df45-486">Gibt eine Zeichenfolge zurück, die das aktuelle Objekt darstellt.</span><span class="sxs-lookup"><span data-stu-id="3df45-486">Returns a string that represents the current object.</span></span></summary>
        <returns><span data-ttu-id="3df45-487">Eine Zeichenfolge, die das aktuelle Objekt darstellt.</span><span class="sxs-lookup"><span data-stu-id="3df45-487">A string that represents the current object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3df45-488"><xref:System.Object.ToString%2A?displayProperty=nameWithType> ist die wichtigste Formatierungs Methode im .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="3df45-488"><xref:System.Object.ToString%2A?displayProperty=nameWithType> is the major formatting method in the .NET Framework.</span></span> <span data-ttu-id="3df45-489">Ein Objekt wird in seine Zeichen folgen Darstellung konvertiert, sodass es für die Anzeige geeignet ist.</span><span class="sxs-lookup"><span data-stu-id="3df45-489">It converts an object to its string representation so that it is suitable for display.</span></span> <span data-ttu-id="3df45-490">(Informationen zur Unterstützung von Formaten in der .NET Framework finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).) Standard Implementierungen der <xref:System.Object.ToString%2A?displayProperty=nameWithType>-Methode geben den voll qualifizierten Namen des Objekt Typs zurück.</span><span class="sxs-lookup"><span data-stu-id="3df45-490">(For information about formatting support in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Default implementations of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method return the fully qualified name of the object's type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3df45-491">Sie haben diese Seite möglicherweise erreicht, indem Sie den Link aus der Mitglieds Liste eines anderen Typs befolgen.</span><span class="sxs-lookup"><span data-stu-id="3df45-491">You may have reached this page by following the link from the member list of another type.</span></span> <span data-ttu-id="3df45-492">Dies liegt daran, dass der Typ <xref:System.Object.ToString%2A?displayProperty=nameWithType>nicht außer Kraft setzt.</span><span class="sxs-lookup"><span data-stu-id="3df45-492">That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3df45-493">Stattdessen erbt Sie die Funktionalität der <xref:System.Object.ToString%2A?displayProperty=nameWithType>-Methode.</span><span class="sxs-lookup"><span data-stu-id="3df45-493">Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="3df45-494">Typen überschreiben häufig die <xref:System.Object.ToString%2A?displayProperty=nameWithType>-Methode, um eine geeignetere Zeichen folgen Darstellung eines bestimmten Typs bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="3df45-494">Types frequently override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide a more suitable string representation of a particular type.</span></span> <span data-ttu-id="3df45-495">Typen überladen auch häufig die <xref:System.Object.ToString%2A?displayProperty=nameWithType>-Methode, um Unterstützung für Format Zeichenfolgen oder Kultur abhängige Formatierung bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="3df45-495">Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide support for format strings or culture-sensitive formatting.</span></span>  

 <span data-ttu-id="3df45-496">In diesem Abschnitt:</span><span class="sxs-lookup"><span data-stu-id="3df45-496">In this section:</span></span>  
  
 <span data-ttu-id="3df45-497">[Die standardmäßige Object. destring ()-Methode](#Default) </span><span class="sxs-lookup"><span data-stu-id="3df45-497">[The default Object.ToString() method](#Default) </span></span>  
 <span data-ttu-id="3df45-498">Überschreiben [der Object. destring ()-Methode](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="3df45-498">[Overriding the Object.ToString() method](#Overriding) </span></span>  
 <span data-ttu-id="3df45-499">[Überladen der Methode "destring](#Overloading) " </span><span class="sxs-lookup"><span data-stu-id="3df45-499">[Overloading the ToString method](#Overloading) </span></span>  
 <span data-ttu-id="3df45-500">[Erweitern der Object. destring-Methode](#Extending) </span><span class="sxs-lookup"><span data-stu-id="3df45-500">[Extending the Object.ToString method](#Extending) </span></span>  
 [<span data-ttu-id="3df45-501">Hinweise für den Windows-Runtime</span><span class="sxs-lookup"><span data-stu-id="3df45-501">Notes for the Windows Runtime</span></span>](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a><span data-ttu-id="3df45-502">Die Default Object. destring ()-Methode</span><span class="sxs-lookup"><span data-stu-id="3df45-502">The default Object.ToString() method</span></span>  
 <span data-ttu-id="3df45-503">Die Standard Implementierung der <xref:System.Object.ToString%2A>-Methode gibt den voll qualifizierten Namen des <xref:System.Object>Typs zurück, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="3df45-503">The default implementation of the <xref:System.Object.ToString%2A> method returns the fully qualified name of the type of the <xref:System.Object>, as the following example shows.</span></span>  
  
 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp-interactive[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 <span data-ttu-id="3df45-504">Da <xref:System.Object> die Basisklasse aller Verweis Typen in der .NET Framework ist, wird dieses Verhalten von Verweis Typen geerbt, die die <xref:System.Object.ToString%2A>-Methode nicht überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-504">Because <xref:System.Object> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <xref:System.Object.ToString%2A> method.</span></span> <span data-ttu-id="3df45-505">Das folgende Beispiel veranschaulicht dies.</span><span class="sxs-lookup"><span data-stu-id="3df45-505">The following example illustrates this.</span></span> <span data-ttu-id="3df45-506">Es definiert eine Klasse mit dem Namen `Object1`, die die Standard Implementierung aller <xref:System.Object> Member akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="3df45-506">It defines a class named `Object1` that accepts the default implementation of all <xref:System.Object> members.</span></span> <span data-ttu-id="3df45-507">Die <xref:System.Object.ToString%2A>-Methode gibt den voll qualifizierten Typnamen des Objekts zurück.</span><span class="sxs-lookup"><span data-stu-id="3df45-507">Its <xref:System.Object.ToString%2A> method returns the object's fully qualified type name.</span></span>  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a><span data-ttu-id="3df45-508">Überschreiben der Object. destring ()-Methode</span><span class="sxs-lookup"><span data-stu-id="3df45-508">Overriding the Object.ToString() method</span></span>  
 <span data-ttu-id="3df45-509">Typen überschreiben häufig die <xref:System.Object.ToString%2A?displayProperty=nameWithType>-Methode, um eine Zeichenfolge zurückzugeben, die die Objektinstanz darstellt.</span><span class="sxs-lookup"><span data-stu-id="3df45-509">Types commonly override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return a string that represents the object instance.</span></span> <span data-ttu-id="3df45-510">Beispielsweise stellen die Basis Typen, z. b. <xref:System.Char>, <xref:System.Int32>und <xref:System.String>, <xref:System.Object.ToString%2A> Implementierungen bereit, die die Zeichen folgen Form des Werts zurückgeben, den das Objekt darstellt.</span><span class="sxs-lookup"><span data-stu-id="3df45-510">For example, the base types such as <xref:System.Char>, <xref:System.Int32>, and <xref:System.String> provide <xref:System.Object.ToString%2A> implementations that return the string form of the value that the object represents.</span></span> <span data-ttu-id="3df45-511">Im folgenden Beispiel wird eine-Klasse definiert, `Object2`, die die <xref:System.Object.ToString%2A>-Methode überschreibt, um den Typnamen zusammen mit seinem Wert zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="3df45-511">The following example defines a class, `Object2`, that overrides the <xref:System.Object.ToString%2A> method to return the type name along with its value.</span></span>  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 <span data-ttu-id="3df45-512">In der folgenden Tabelle werden die Typkategorien in .NET aufgelistet, und es wird angegeben, ob die <xref:System.Object.ToString%2A?displayProperty=nameWithType>-Methode überschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-512">The following table lists the type categories in .NET and indicates whether or not they override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
|<span data-ttu-id="3df45-513">Typkategorie</span><span class="sxs-lookup"><span data-stu-id="3df45-513">Type category</span></span>|<span data-ttu-id="3df45-514">Überschreibt Object.-Zeichenfolge ()</span><span class="sxs-lookup"><span data-stu-id="3df45-514">Overrides Object.ToString()</span></span>|<span data-ttu-id="3df45-515">Verhalten</span><span class="sxs-lookup"><span data-stu-id="3df45-515">Behavior</span></span>|  
|-------------------|-----------------------------------|--------------|  
|<span data-ttu-id="3df45-516">Klasse</span><span class="sxs-lookup"><span data-stu-id="3df45-516">Class</span></span>|<span data-ttu-id="3df45-517">nicht verfügbar</span><span class="sxs-lookup"><span data-stu-id="3df45-517">n/a</span></span>|<span data-ttu-id="3df45-518">nicht verfügbar</span><span class="sxs-lookup"><span data-stu-id="3df45-518">n/a</span></span>|  
|<span data-ttu-id="3df45-519">Struktur</span><span class="sxs-lookup"><span data-stu-id="3df45-519">Structure</span></span>|<span data-ttu-id="3df45-520">Ja (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="3df45-520">Yes (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="3df45-521">Identisch mit `Object.ToString()`</span><span class="sxs-lookup"><span data-stu-id="3df45-521">Same as `Object.ToString()`</span></span>|  
|<span data-ttu-id="3df45-522">Enumeration</span><span class="sxs-lookup"><span data-stu-id="3df45-522">Enumeration</span></span>|<span data-ttu-id="3df45-523">Ja (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="3df45-523">Yes (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="3df45-524">Der Elementname</span><span class="sxs-lookup"><span data-stu-id="3df45-524">The member name</span></span>|  
|<span data-ttu-id="3df45-525">Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="3df45-525">Interface</span></span>|<span data-ttu-id="3df45-526">Nein</span><span class="sxs-lookup"><span data-stu-id="3df45-526">No</span></span>|<span data-ttu-id="3df45-527">nicht verfügbar</span><span class="sxs-lookup"><span data-stu-id="3df45-527">n/a</span></span>|  
|<span data-ttu-id="3df45-528">Delegat</span><span class="sxs-lookup"><span data-stu-id="3df45-528">Delegate</span></span>|<span data-ttu-id="3df45-529">Nein</span><span class="sxs-lookup"><span data-stu-id="3df45-529">No</span></span>|<span data-ttu-id="3df45-530">nicht verfügbar</span><span class="sxs-lookup"><span data-stu-id="3df45-530">n/a</span></span>|  
  
 <span data-ttu-id="3df45-531">Weitere Informationen zum Überschreiben von <xref:System.Object.ToString%2A>finden Sie im Abschnitt "Hinweise zu Vererbung".</span><span class="sxs-lookup"><span data-stu-id="3df45-531">See the Notes to Inheritors section for additional information on overriding <xref:System.Object.ToString%2A>.</span></span>  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a><span data-ttu-id="3df45-532">Über Laden der Methode "destring"</span><span class="sxs-lookup"><span data-stu-id="3df45-532">Overloading the ToString method</span></span>  
 <span data-ttu-id="3df45-533">Neben dem Überschreiben der Parameter losen <xref:System.Object.ToString?displayProperty=nameWithType>-Methode überladen viele Typen die `ToString`-Methode, um Versionen der Methode bereitzustellen, die Parameter akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="3df45-533">In addition to overriding the parameterless <xref:System.Object.ToString?displayProperty=nameWithType> method, many types overload the `ToString` method to provide versions of the method that accept parameters.</span></span> <span data-ttu-id="3df45-534">In den meisten Fällen wird dies erreicht, um Unterstützung für Variablen Formatierung und Kultur abhängige Formatierung bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="3df45-534">Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="3df45-535">Im folgenden Beispiel wird die `ToString`-Methode überladen, um eine Ergebnis Zeichenfolge zurückzugeben, die den Wert verschiedener Felder einer `Automobile` Klasse enthält.</span><span class="sxs-lookup"><span data-stu-id="3df45-535">The following example overloads the `ToString` method to return a result string that includes the value of various fields of an `Automobile` class.</span></span> <span data-ttu-id="3df45-536">Es definiert vier Format Zeichenfolgen: G, die den Modellnamen und das Jahr zurückgibt. D: gibt den Modellnamen, das Jahr und die Anzahl der Türen zurück. C: gibt den Modellnamen, das Jahr und die Anzahl der Zylinder zurück. und eine, die eine Zeichenfolge mit allen vier Feldwerten zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="3df45-536">It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</span></span>  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 <span data-ttu-id="3df45-537">Im folgenden Beispiel wird die überladene <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode aufgerufen, um die Kultur abhängige Formatierung eines Währungs Werts anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="3df45-537">The following example calls the overloaded <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method to display culture-sensitive formatting of a currency value.</span></span>  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 <span data-ttu-id="3df45-538">Weitere Informationen zu Format Zeichenfolgen und der Kultur abhängigen Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="3df45-538">For more information on format strings and culture-sensitive formatting, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span> <span data-ttu-id="3df45-539">Informationen zu den von numerischen Werten unterstützten Format Zeichenfolgen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)</span><span class="sxs-lookup"><span data-stu-id="3df45-539">For the format strings supported by numeric values, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="3df45-540">Informationen zu den von Datums-und Uhrzeitwerten unterstützten Format Zeichenfolgen finden Sie unter Standard Format Zeichenfolgen für [Datum und Uhrzeit](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-date-and-time-format-strings.md)Format Zeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="3df45-540">For the format strings supported by date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a><span data-ttu-id="3df45-541">Erweitern der Object. destring-Methode</span><span class="sxs-lookup"><span data-stu-id="3df45-541">Extending the Object.ToString method</span></span>  
 <span data-ttu-id="3df45-542">Da ein Typ die Standard <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode erbt, ist das Verhalten möglicherweise unerwünscht und soll geändert werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-542">Because a type inherits the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, you may find its behavior undesirable and want to change it.</span></span> <span data-ttu-id="3df45-543">Dies gilt insbesondere für Arrays und Auflistungs Klassen.</span><span class="sxs-lookup"><span data-stu-id="3df45-543">This is particularly true of arrays and collection classes.</span></span> <span data-ttu-id="3df45-544">Obwohl Sie möglicherweise erwarten, dass die `ToString`-Methode eines Arrays oder einer Auflistungs Klasse die Werte der zugehörigen Member anzeigt, zeigt Sie stattdessen den voll qualifizierten Typnamen des Typs an, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="3df45-544">While you may expect the `ToString` method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</span></span>  
  
 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 [!code-csharp-interactive[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 <span data-ttu-id="3df45-545">Sie haben mehrere Optionen, um die gewünschte Ergebnis Zeichenfolge zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="3df45-545">You have several options to produce the result string that you'd like.</span></span>  
  
-   <span data-ttu-id="3df45-546">Wenn der Typ ein Array, ein Auflistungs Objekt oder ein Objekt ist, das die <xref:System.Collections.IEnumerable>-oder <xref:System.Collections.Generic.IEnumerable%601> Schnittstellen implementiert, können Sie seine Elemente mithilfe der `foreach`-Anweisung C# in oder dem `For Each...Next` Konstrukt in Visual Basic auflisten.</span><span class="sxs-lookup"><span data-stu-id="3df45-546">If the type is an array, a collection object, or an object that implements the <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> interfaces, you can enumerate its elements by using the `foreach` statement in C# or the `For Each...Next` construct in Visual Basic.</span></span>  
  
-   <span data-ttu-id="3df45-547">Wenn die Klasse nicht `sealed` (in C#) oder `NotInheritable` (in Visual Basic) ist, können Sie eine Wrapper Klasse entwickeln, die von der Basisklasse erbt, deren <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode Sie anpassen möchten.</span><span class="sxs-lookup"><span data-stu-id="3df45-547">If the class is not `sealed` (in C#) or `NotInheritable` (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <xref:System.Object.ToString%2A?displayProperty=nameWithType> method you want to customize.</span></span> <span data-ttu-id="3df45-548">Hierfür müssen Sie mindestens folgende Schritte ausführen:</span><span class="sxs-lookup"><span data-stu-id="3df45-548">At a minimum, this requires that you do the following:</span></span>  
  
    1.  <span data-ttu-id="3df45-549">Implementieren Sie alle erforderlichen Konstruktoren.</span><span class="sxs-lookup"><span data-stu-id="3df45-549">Implement any necessary constructors.</span></span> <span data-ttu-id="3df45-550">Abgeleitete Klassen erben nicht Ihre Basisklassenkonstruktoren.</span><span class="sxs-lookup"><span data-stu-id="3df45-550">Derived classes do not inherit their base class constructors.</span></span>  
  
    2.  <span data-ttu-id="3df45-551">Überschreiben Sie die <xref:System.Object.ToString%2A?displayProperty=nameWithType>-Methode, um die gewünschte Ergebnis Zeichenfolge zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="3df45-551">Override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the result string that you'd like.</span></span>  
  
     <span data-ttu-id="3df45-552">Im folgenden Beispiel wird eine Wrapper Klasse für die <xref:System.Collections.Generic.List%601>-Klasse definiert.</span><span class="sxs-lookup"><span data-stu-id="3df45-552">The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class.</span></span> <span data-ttu-id="3df45-553">Er überschreibt die <xref:System.Object.ToString%2A?displayProperty=nameWithType>-Methode, um den Wert jeder Methode der Auflistung anstelle des voll qualifizierten Typnamens anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="3df45-553">It overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to display the value of each method of the collection rather than the fully qualified type name.</span></span>  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   <span data-ttu-id="3df45-554">Entwickeln Sie eine [Erweiterungsmethode](~/docs/standard/design-guidelines/extension-methods.md) , die die gewünschte Ergebnis Zeichenfolge zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="3df45-554">Develop an [extension method](~/docs/standard/design-guidelines/extension-methods.md) that returns the result string that you want.</span></span> <span data-ttu-id="3df45-555">Beachten Sie, dass Sie die standardmäßige <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode nicht auf diese Weise überschreiben können (d. h C#., die Erweiterungs Klasse (in) oder das Modul (in Visual Basic) kann keine Parameter lose Methode mit dem Namen `ToString` aufweisen, die anstelle der `ToString`-Methode des ursprünglichen Typs aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="3df45-555">Note that you can't override the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named `ToString` that is called in place of the original type's `ToString` method.</span></span> <span data-ttu-id="3df45-556">Sie müssen einen anderen Namen für die Parameter lose `ToString` Ersetzung angeben.</span><span class="sxs-lookup"><span data-stu-id="3df45-556">You'll have to provide some other name for your parameterless `ToString` replacement.</span></span>  
  
     <span data-ttu-id="3df45-557">Im folgenden Beispiel werden zwei Methoden definiert, mit denen die <xref:System.Collections.Generic.List%601>-Klasse erweitert wird: eine parameterlose `ToString2`-Methode und eine `ToString`-Methode mit einem <xref:System.String> Parameter, der eine Format Zeichenfolge darstellt.</span><span class="sxs-lookup"><span data-stu-id="3df45-557">The following example defines two methods that extend the <xref:System.Collections.Generic.List%601> class: a parameterless `ToString2` method, and a `ToString` method with a <xref:System.String> parameter that represents a format string.</span></span>  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="3df45-558">Hinweise für den [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="3df45-558">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="3df45-559">Wenn Sie die <xref:System.Object.ToString%2A>-Methode für eine Klasse in der [!INCLUDE[wrt](~/includes/wrt-md.md)]aufzurufen, wird das Standardverhalten für Klassen bereitstellt, die <xref:System.Object.ToString%2A>nicht überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-559">When you call the <xref:System.Object.ToString%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="3df45-560">Dies ist ein Teil der Unterstützung, die der .NET Framework für die [!INCLUDE[wrt](~/includes/wrt-md.md)] bietet (siehe [.NET Framework Support für Windows Store-Apps und Windows-Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="3df45-560">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="3df45-561">Klassen im [!INCLUDE[wrt](~/includes/wrt-md.md)] erben <xref:System.Object>nicht und implementieren nicht immer eine <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="3df45-561">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and don't always implement a <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="3df45-562">Allerdings scheinen Sie immer <xref:System.Object.ToString%2A>-, <xref:System.Object.Equals%28System.Object%29>-und <xref:System.Object.GetHashCode%2A>-Methoden zu haben, wenn Sie Sie C# im-oder-Visual Basic Code verwenden, und der .NET Framework stellt ein Standardverhalten für diese Methoden bereit.</span><span class="sxs-lookup"><span data-stu-id="3df45-562">However, they always appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</span></span>  
  
 <span data-ttu-id="3df45-563">Beginnend mit dem [!INCLUDE[net_v451](~/includes/net-v451-md.md)]verwendet das Common Language Runtime [istringable. Start String](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) für ein [!INCLUDE[wrt](~/includes/wrt-md.md)]-Objekt, bevor es auf die Standard Implementierung <xref:System.Object.ToString%2A?displayProperty=nameWithType>zurückfällt.</span><span class="sxs-lookup"><span data-stu-id="3df45-563">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], the common language runtime will use [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) on a [!INCLUDE[wrt](~/includes/wrt-md.md)] object before falling back to the default implementation of <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="3df45-564">Klassen, die in C# oder Visual Basic geschrieben sind, können die <xref:System.Object.ToString%2A>-Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-564">classes that are written in C# or Visual Basic can override the <xref:System.Object.ToString%2A> method.</span></span>  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a><span data-ttu-id="3df45-565">Der [!INCLUDE[wrt](~/includes/wrt-md.md)] und die istringable-Schnittstelle</span><span class="sxs-lookup"><span data-stu-id="3df45-565">The [!INCLUDE[wrt](~/includes/wrt-md.md)] and the IStringable Interface</span></span>  
 <span data-ttu-id="3df45-566">Beginnend mit [!INCLUDE[win81](~/includes/win81-md.md)]enthält die [!INCLUDE[wrt](~/includes/wrt-md.md)] eine [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) -Schnittstelle, deren einzige Methode, [istringable. destring](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), eine grundlegende Formatierungs Unterstützung bietet, die vergleichbar mit der von <xref:System.Object.ToString%2A?displayProperty=nameWithType>bereitgestellten ist.</span><span class="sxs-lookup"><span data-stu-id="3df45-566">Starting with [!INCLUDE[win81](~/includes/win81-md.md)], the [!INCLUDE[wrt](~/includes/wrt-md.md)] includes an [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface whose single method, [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), provides basic formatting support comparable to that provided by <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3df45-567">Um Mehrdeutigkeit zu vermeiden, sollten Sie [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) nicht für verwaltete Typen implementieren.</span><span class="sxs-lookup"><span data-stu-id="3df45-567">To prevent ambiguity, you should not implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on managed types.</span></span>  
  
 <span data-ttu-id="3df45-568">Wenn verwaltete Objekte von System eigenem Code oder von Code, der in Sprachen wie JavaScript oder C++/CX geschrieben ist, aufgerufen werden, scheinen Sie [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="3df45-568">When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span> <span data-ttu-id="3df45-569">Der Common Language Runtime leitet automatisch Aufrufe von [istringable. destring](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) an <xref:System.Object.ToString%2A?displayProperty=nameWithType> in dem Ereignis, das [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) nicht für das verwaltete Objekt implementiert ist.</span><span class="sxs-lookup"><span data-stu-id="3df45-569">The common language runtime will automatically route calls from [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) to <xref:System.Object.ToString%2A?displayProperty=nameWithType> in the event [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) is not implemented on the managed object.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="3df45-570">Da der Common Language Runtime die [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) -Schnittstelle für alle verwalteten Typen in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]-Apps automatisch implementiert, empfiehlt es sich, keine eigene [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) -Implementierung bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="3df45-570">Because the common language runtime auto-implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation.</span></span> <span data-ttu-id="3df45-571">Die Implementierung von [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) kann beim Aufrufen von `ToString` aus [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX oder JavaScript zu unbeabsichtigtem Verhalten führen.</span><span class="sxs-lookup"><span data-stu-id="3df45-571">Implementing [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript.</span></span>  
  
 <span data-ttu-id="3df45-572">Wenn Sie [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in einem öffentlich verwalteten Typ implementieren möchten, der in eine [!INCLUDE[wrt](~/includes/wrt-md.md)] Komponente exportiert wird, gelten die folgenden Einschränkungen:</span><span class="sxs-lookup"><span data-stu-id="3df45-572">If you do choose to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in a public managed type that is exported in a [!INCLUDE[wrt](~/includes/wrt-md.md)] component, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="3df45-573">Sie können die [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) -Schnittstelle nur in einer "Klasse implementiert"-Beziehung definieren, z. b.</span><span class="sxs-lookup"><span data-stu-id="3df45-573">You can define the [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface only in a "class implements" relationship, such as</span></span>  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     <span data-ttu-id="3df45-574">in C# oder</span><span class="sxs-lookup"><span data-stu-id="3df45-574">in C#, or</span></span>  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     <span data-ttu-id="3df45-575">in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="3df45-575">in Visual Basic.</span></span>  
  
-   <span data-ttu-id="3df45-576">Sie können [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) nicht in einer Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="3df45-576">You cannot implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on an interface.</span></span>  
  
-   <span data-ttu-id="3df45-577">Sie können einen Parameter nicht als Typ [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)deklarieren.</span><span class="sxs-lookup"><span data-stu-id="3df45-577">You cannot declare a parameter to be of type [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span>  
  
-   <span data-ttu-id="3df45-578">[Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) kann nicht der Rückgabetyp einer Methode, einer Eigenschaft oder eines Felds sein.</span><span class="sxs-lookup"><span data-stu-id="3df45-578">[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cannot be the return type of a method, property, or field.</span></span>  
  
-   <span data-ttu-id="3df45-579">Sie können die [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) -Implementierung nicht aus Basisklassen ausblenden, indem Sie eine Methoden Definition wie die folgende verwenden:</span><span class="sxs-lookup"><span data-stu-id="3df45-579">You cannot hide your [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation from base classes by using a method definition such as the following:</span></span>  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     <span data-ttu-id="3df45-580">Stattdessen muss die Implementierung [istringable. destring](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) die Basisklassen Implementierung immer überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3df45-580">Instead, the [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation must always override the base class implementation.</span></span> <span data-ttu-id="3df45-581">Sie können eine `ToString`-Implementierung nur ausblenden, indem Sie sie auf einer stark typisierten Klasseninstanz aufrufen.</span><span class="sxs-lookup"><span data-stu-id="3df45-581">You can hide a `ToString` implementation only by invoking it on a strongly typed class instance.</span></span>  
  
 <span data-ttu-id="3df45-582">Beachten Sie, dass unter einer Vielzahl von Bedingungen Aufrufe von System eigenem Code zu einem verwalteten Typ, der [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementiert oder seine Implementierung von " [destring](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) " verbirgt, zu unerwartetem Verhalten führen können.</span><span class="sxs-lookup"><span data-stu-id="3df45-582">Note that under a variety of conditions, calls from native code to a managed type that implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) or hides its [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation can produce unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="3df45-583">Wenn Sie eigene Typen implementieren, sollten Sie die <see cref="M:System.Object.ToString" />-Methode überschreiben, um Werte zurückzugeben, die für diese Typen von Bedeutung sind.</span><span class="sxs-lookup"><span data-stu-id="3df45-583">When you implement your own types, you should override the <see cref="M:System.Object.ToString" /> method to return values that are meaningful for those types.</span></span> <span data-ttu-id="3df45-584">Abgeleitete Klassen, die mehr Kontrolle über die Formatierung benötigen, als <see cref="M:System.Object.ToString" />, können die <see cref="T:System.IFormattable" />-Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="3df45-584">Derived classes that require more control over formatting than <see cref="M:System.Object.ToString" /> provides can implement the <see cref="T:System.IFormattable" /> interface.</span></span> <span data-ttu-id="3df45-585">Die <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" />-Methode ermöglicht Ihnen das Definieren von Format Zeichenfolgen, die die Formatierung steuern, und die Verwendung eines <see cref="T:System.IFormatProvider" /> Objekts, das die Kultur abhängige Formatierung bereitstellen kann.</span><span class="sxs-lookup"><span data-stu-id="3df45-585">Its <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> method enables you to define format strings that control formatting and to use an <see cref="T:System.IFormatProvider" /> object that can provide for culture-specific formatting.</span></span>  
  
<span data-ttu-id="3df45-586">Für außer Kraft setzungen der <see cref="M:System.Object.ToString" /> Methode sollten folgende Richtlinien beachtet werden:</span><span class="sxs-lookup"><span data-stu-id="3df45-586">Overrides of the <see cref="M:System.Object.ToString" /> method should follow these guidelines:</span></span> 
<span data-ttu-id="3df45-587">-Die zurückgegebene Zeichenfolge sollte von Menschen benutzerfreundlich und lesbar sein.</span><span class="sxs-lookup"><span data-stu-id="3df45-587">-   The returned string should be friendly and readable by humans.</span></span>  
  
<span data-ttu-id="3df45-588">-Die zurückgegebene Zeichenfolge sollte den Wert der Objektinstanz eindeutig identifizieren.</span><span class="sxs-lookup"><span data-stu-id="3df45-588">-   The returned string should uniquely identify the value of the object instance.</span></span>  
  
<span data-ttu-id="3df45-589">-Die zurückgegebene Zeichenfolge sollte so kurz wie möglich sein, damit Sie von einem Debugger angezeigt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3df45-589">-   The returned string should be as short as possible so that it is suitable for display by a debugger.</span></span>  
  
<span data-ttu-id="3df45-590">-Die <see cref="M:System.Object.ToString" /> Überschreibung darf <see cref="F:System.String.Empty" /> oder eine NULL-Zeichenfolge nicht zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="3df45-590">-   Your <see cref="M:System.Object.ToString" /> override should not return <see cref="F:System.String.Empty" /> or a null string.</span></span>  
  
<span data-ttu-id="3df45-591">-Die <see cref="M:System.Object.ToString" /> Überschreibung sollte keine Ausnahme auslösen.</span><span class="sxs-lookup"><span data-stu-id="3df45-591">-   Your <see cref="M:System.Object.ToString" /> override should not throw an exception.</span></span>  
  
<span data-ttu-id="3df45-592">Wenn die Zeichen folgen Darstellung einer Instanz Kultur abhängig ist oder auf verschiedene Arten formatiert werden kann, implementieren Sie die <see cref="T:System.IFormattable" />-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="3df45-592">-   If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <see cref="T:System.IFormattable" /> interface.</span></span>  
  
<span data-ttu-id="3df45-593">-Wenn die zurückgegebene Zeichenfolge vertrauliche Informationen enthält, sollten Sie zuerst eine entsprechende Berechtigung anfordern.</span><span class="sxs-lookup"><span data-stu-id="3df45-593">-   If the returned string includes sensitive information, you should first demand an appropriate permission.</span></span> <span data-ttu-id="3df45-594">Wenn die Anforderung erfolgreich ist, können Sie die vertraulichen Informationen zurückgeben. Andernfalls sollten Sie eine Zeichenfolge zurückgeben, in der die vertraulichen Informationen ausgeschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="3df45-594">If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.</span></span>  
  
<span data-ttu-id="3df45-595">-Die <see cref="M:System.Object.ToString" /> Außerkraftsetzung sollte keine beobachtbaren Nebeneffekte aufweisen, um Komplikationen beim Debuggen zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="3df45-595">-   Your <see cref="M:System.Object.ToString" /> override should have no observable side effects to avoid complications in debugging.</span></span> <span data-ttu-id="3df45-596">Beispielsweise sollte ein Aufrufder <see cref="M:System.Object.ToString" />-Methode nicht den Wert von Instanzfeldern ändern.</span><span class="sxs-lookup"><span data-stu-id="3df45-596">For example, a call to the <see cref="M:System.Object.ToString" /> method should not change the value of instance fields.</span></span>  
  
<span data-ttu-id="3df45-597">-Wenn der Typ eine-Methode für die Methode implementiert (oder <see langword="Parse" /> oder <see langword="TryParse" /> Methode, einen Konstruktor oder eine andere statische Methode, die eine Instanz des Typs aus einer Zeichenfolge instanziiert), sollten Sie sicherstellen, dass die von der <see cref="M:System.Object.ToString" />-Methode zurückgegebene Zeichenfolge in eine Objektinstanz konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="3df45-597">-   If your type implements a parsing method (or <see langword="Parse" /> or <see langword="TryParse" /> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <see cref="M:System.Object.ToString" /> method can be converted to an object instance.</span></span></para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="3df45-598">Formatieren von Typen in .NET</span><span class="sxs-lookup"><span data-stu-id="3df45-598">Formatting Types in .NET</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
