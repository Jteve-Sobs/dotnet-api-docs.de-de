<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Object.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5541af8485b08c84b2be0fd08e48a22d8881ee936.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">541af8485b08c84b2be0fd08e48a22d8881ee936</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Object">
          <source>Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes.</source>
          <target state="translated">Unterstützt sämtliche Klassen in der Hierarchie von .NET Framework-Klassen und stellt abgeleiteten Klassen Low-Level-Dienste zur Verfügung.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Object">
          <source>This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.</source>
          <target state="translated">Dies ist die allen Klassen von .NET Framework übergeordnete Basisklasse und stellt den Stamm der Typhierarchie dar.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Languages typically do not require a class to declare inheritance from <ph id="ph1">&lt;xref:System.Object&gt;</ph> because the inheritance is implicit.</source>
          <target state="translated">Sprachen erfordern in der Regel keine Klasse zur Deklaration der Vererbung von <ph id="ph1">&lt;xref:System.Object&gt;</ph> , da die Vererbung implizit ist.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Because all classes in the .NET Framework are derived from <ph id="ph1">&lt;xref:System.Object&gt;</ph>, every method defined in the <ph id="ph2">&lt;xref:System.Object&gt;</ph> class is available in all objects in the system.</source>
          <target state="translated">Da alle Klassen in .NET Framework abgeleitet sind <ph id="ph1">&lt;xref:System.Object&gt;</ph>, jede Methode definiert, die der <ph id="ph2">&lt;xref:System.Object&gt;</ph> Klasse steht in allen Objekten im System.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Derived classes can and do override some of these methods, including:</source>
          <target state="translated">Abgeleitete Klassen, und überschreiben Sie einigen dieser Methoden, einschließlich:</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> - Supports comparisons between objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> – Unterstützt Vergleiche zwischen Objekten.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> - Performs cleanup operations before an object is automatically reclaimed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> – Führt Bereinigungsvorgänge durch, bevor ein Objekt automatisch freigegeben wird.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> - Generates a number corresponding to the value of the object to support the use of a hash table.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> -Generiert eine Zahl, die entsprechend dem Wert des Objekts zur Unterstützung einer Hashtabelle.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> - Manufactures a human-readable text string that describes an instance of the class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> – Stellt eine lesbare Zeichenfolge, die eine Instanz der Klasse beschreibt.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Performance Considerations</source>
          <target state="translated">Überlegungen zur Leistung</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">Wenn Sie eine Klasse, z. B. eine Auflistung entwerfen, die jede Art von Objekt behandelt werden müssen, können Sie Klassenmember, die Instanzen von akzeptieren erstellen die <ph id="ph1">&lt;xref:System.Object&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>However, the process of boxing and unboxing a type carries a performance cost.</source>
          <target state="translated">Der Prozess von Boxing und unboxing eines Typs birgt jedoch Kosten der Leistung.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</source>
          <target state="translated">Wenn Sie wissen, dass die neue Klasse häufig bestimmte Werttypen behandelt, können Sie eine der beiden Taktiken Boxing begegnet verwenden.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Create a general method that accepts an <ph id="ph1">&lt;xref:System.Object&gt;</ph> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</source>
          <target state="translated">Erstellen Sie eine allgemeine Methode, die akzeptiert ein <ph id="ph1">&lt;xref:System.Object&gt;</ph> Typ und einen Satz von typspezifische methodenüberladungen, die jeden Typ Sie erwarten, die Klasse akzeptieren dass, um häufig zu behandeln.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</source>
          <target state="translated">Wenn eine typspezifischen Methode vorhanden, das den Parametertyp des aufrufenden akzeptiert ist, keine Boxing-Konvertierung tritt ein, und die typspezifischen Methode aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</source>
          <target state="translated">Ist keine Methodenargument, das dem aufrufenden Parametertyp übereinstimmt, wird der Parameter geschachtelt und allgemeine aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Design your type and its members to use generics.</source>
          <target state="translated">Entwerfen Sie Ihren Typ und ihre Member zum Verwenden von Generika.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</source>
          <target state="translated">Die common Language Runtime erstellt geschlossenen generischen Typs an, wenn Sie eine Instanz der Klasse erstellen, und geben Sie ein generisches Typargument.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>The generic method is type-specific and can be invoked without boxing the calling parameter.</source>
          <target state="translated">Die generische Methode ist typspezifische und aufgerufen werden kann, ohne den aufrufenden Parameter boxing.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Although it is sometimes necessary to develop general purpose classes that accept and return <ph id="ph1">&lt;xref:System.Object&gt;</ph> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</source>
          <target state="translated">Obwohl es in einigen Fällen notwendig ist, allgemeine Klassen zu entwickeln, akzeptieren und zurückgeben <ph id="ph1">&lt;xref:System.Object&gt;</ph> Typen, können Sie die Leistung verbessern, durch die Bereitstellung auch einer typspezifische-Klasse, um einen häufig verwendeten Typ behandeln.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</source>
          <target state="translated">Bereitstellen einer Klasse, die zum Festlegen und Abrufen von booleschen Werten entfällt z. B. die Kosten für Boxing und unboxing boolesche Werte.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>The following example defines a Point type derived from the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class and overrides many of the virtual methods of the <ph id="ph2">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">Das folgende Beispiel definiert einen Punkttyp abgeleitet wurde. die <ph id="ph1">&lt;xref:System.Object&gt;</ph> -Klasse und überschreibt viele der virtuellen Methoden für die <ph id="ph2">&lt;xref:System.Object&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>In addition, the example shows how to call many of the static and instance methods of the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">Darüber hinaus wird im Beispiel gezeigt, wie viele der statischen aufrufen und Instanzmethoden von der <ph id="ph1">&lt;xref:System.Object&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Public static (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) members of this type are thread safe.</source>
          <target state="translated">Öffentliche statische (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) Member dieses Typs sind threadsicher.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Instance members are not guaranteed to be thread-safe.</source>
          <target state="translated">Instanzmember sind nicht unbedingt threadsicher sein.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Object.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.#ctor">
          <source>This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">Dieser Konstruktor wird von Konstruktoren in abgeleiteten Klassen aufgerufen, aber es kann auch direkt erstellen eine Instanz von verwendet die <ph id="ph1">&lt;xref:System.Object&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="T:System.Object">
          <source>Determines whether two object instances are equal.</source>
          <target state="translated">Stellt fest, ob zwei Objektinstanzen gleich sind.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object)">
          <source>The object to compare with the current object.</source>
          <target state="translated">Das Objekt, das mit dem aktuellen Objekt verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object)">
          <source>Determines whether the specified object is equal to the current object.</source>
          <target state="translated">Bestimmt, ob das angegebene Objekt mit dem aktuellen Objekt identisch ist.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified object  is equal to the current object; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das angegebene Objekt und das aktuelle Objekt gleich sind, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The type of comparison between the current instance and the <ph id="ph1">`obj`</ph> parameter depends on whether the current instance is a reference type or a value type.</source>
          <target state="translated">Der Typ des Vergleichs zwischen der aktuellen Instanz und die <ph id="ph1">`obj`</ph> Parameter, hängt davon ab, ob die aktuelle Instanz ein Verweistyp oder ein Werttyp ist.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If the current instance is a reference type, the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method tests for reference equality, and a call to the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method is equivalent to a call to the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">Wenn die aktuelle Instanz ein Verweistyp ist die <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> Methode Tests hinsichtlich ihrer Verweisgleichheit und einem Aufruf von der <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> Methode ist äquivalent zu einem Aufruf von der <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Reference equality means that the object variables that are compared refer to the same object.</source>
          <target state="translated">Verweisgleichheit bedeutet, dass die Objektvariablen, die verglichen werden auf dasselbe Objekt verweisen.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example illustrates the result of such a comparison.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht das Ergebnis von einem solchen Vergleich werden.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It defines a <ph id="ph1">`Person`</ph> class, which is a reference type, and calls the <ph id="ph2">`Person`</ph> class constructor to instantiate two new <ph id="ph3">`Person`</ph> objects, <ph id="ph4">`person1a`</ph> and <ph id="ph5">`person2`</ph>, which have the same value.</source>
          <target state="translated">Definiert eine <ph id="ph1">`Person`</ph> Klasse, die ein Verweistyp ist, und ruft die <ph id="ph2">`Person`</ph> Klassenkonstruktor zwei neue instanziieren <ph id="ph3">`Person`</ph> Objekte <ph id="ph4">`person1a`</ph> und <ph id="ph5">`person2`</ph>, die den gleichen Wert aufweisen.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It also assigns <ph id="ph1">`person1a`</ph> to another object variable, <ph id="ph2">`person1b`</ph>.</source>
          <target state="translated">Außerdem weist er <ph id="ph1">`person1a`</ph> auf einem anderen Objektvariable <ph id="ph2">`person1b`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As the output from the example shows, <ph id="ph1">`person1a`</ph> and <ph id="ph2">`person1b`</ph> are equal because they reference the same object.</source>
          <target state="translated">Wie die Ausgabe des Beispiels zeigt <ph id="ph1">`person1a`</ph> und <ph id="ph2">`person1b`</ph> gleich sind, da sie dasselbe Objekt verweisen.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, <ph id="ph1">`person1a`</ph> and <ph id="ph2">`person2`</ph> are not equal, although they have the same value.</source>
          <target state="translated">Allerdings <ph id="ph1">`person1a`</ph> und <ph id="ph2">`person2`</ph> ungleich sind, obwohl sie den gleichen Wert aufweisen.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If the current instance is a value type, the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method tests for value equality.</source>
          <target state="translated">Wenn die aktuelle Instanz ein Werttyp ist, ist die <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> Methode Wertgleichheit.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Value equality means the following:</source>
          <target state="translated">Wertgleichheit bedeutet Folgendes:</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The two objects are of the same type.</source>
          <target state="translated">Die beiden Objekte sind vom gleichen Typ.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As the following example shows, a <ph id="ph1">&lt;xref:System.Byte&gt;</ph> object that has a value of 12 does not equal an <ph id="ph2">&lt;xref:System.Int32&gt;</ph> object that has a value of 12, because the two objects have different run-time types.</source>
          <target state="translated">Wie im folgenden Beispiel wird gezeigt, eine <ph id="ph1">&lt;xref:System.Byte&gt;</ph> -Objekt, das den Wert 12 hat stimmt nicht mit einer <ph id="ph2">&lt;xref:System.Int32&gt;</ph> -Objekt, das den Wert 12, aufweist, da die beiden Objekte zur Laufzeit verschiedene verfügen.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The values of the public and private fields of the two objects are equal.</source>
          <target state="translated">Die Werte der öffentliche und private Felder der beiden Objekte sind gleich.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example tests for value equality.</source>
          <target state="translated">Das folgende Beispiel testet Wertgleichheit.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It defines a <ph id="ph1">`Person`</ph> structure, which is a value type, and calls the <ph id="ph2">`Person`</ph> class constructor to instantiate two new <ph id="ph3">`Person`</ph> objects, <ph id="ph4">`person1`</ph> and <ph id="ph5">`person2`</ph>, which have the same value.</source>
          <target state="translated">Definiert eine <ph id="ph1">`Person`</ph> -Struktur, die ein Werttyp ist, und ruft die <ph id="ph2">`Person`</ph> Klassenkonstruktor zwei neue instanziieren <ph id="ph3">`Person`</ph> Objekte <ph id="ph4">`person1`</ph> und <ph id="ph5">`person2`</ph>, die den gleichen Wert aufweisen.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As the output from the example shows, although the two object variables refer to different objects, <ph id="ph1">`person1`</ph> and <ph id="ph2">`person2`</ph> are equal because they have the same value for the private <ph id="ph3">`personName`</ph> field.</source>
          <target state="translated">Wie die Ausgabe des Beispiels zeigt, obwohl die beiden Objektvariablen auf unterschiedliche Objekte verweisen, <ph id="ph1">`person1`</ph> und <ph id="ph2">`person2`</ph> gleich sind, da sie den gleichen Wert für die Private aufweisen <ph id="ph3">`personName`</ph> Feld.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class is the base class for all types in the .NET Framework, the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method provides the default equality comparison for all other types.</source>
          <target state="translated">Da die <ph id="ph1">&lt;xref:System.Object&gt;</ph> Klasse ist die Basisklasse für alle Typen in .NET Framework, die <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> Methode bietet die Standard-Gleichheitsvergleich für alle anderen Typen.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, types often override the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method to implement value equality.</source>
          <target state="translated">Typen jedoch häufig überschreiben die <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> Methode für die Implementierung der Wertgleichheit.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For more information, see the Notes for Callers and Notes for Inheritors sections.</source>
          <target state="translated">Weitere Informationen finden Sie unter die Anmerkungen zu dieser Aufrufer und Hinweise für Vererber Abschnitte.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">Hinweise für die <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When you call the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method overload on a class in the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen der <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> methodenüberladung für eine Klasse in der <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, es stellt das Standardverhalten für Klassen, die nicht außer Kraft setzen <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">Dies ist Teil der Unterstützung von .NET Framework für die <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (siehe <bpt id="p1">[</bpt>.NET Framework Unterstützung für Windows Store-Apps und Windows-Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Classes in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id="ph2">&lt;xref:System.Object&gt;</ph>, and currently don’t implement an <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method.</source>
          <target state="translated">Klassen in der <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> erben nicht <ph id="ph2">&lt;xref:System.Object&gt;</ph>, und zurzeit nicht implementieren eine <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, they appear to have <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</source>
          <target state="translated">Allerdings sie angezeigt werden, damit <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, und <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> Methoden, wenn Sie in c# oder Visual Basic-Code werden verwendet, und die .NET Framework das Standardverhalten für diese Methoden bietet.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method overload.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> Klassen, die in c# oder Visual Basic geschrieben sind, können außer Kraft setzen die <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Notes for Callers</source>
          <target state="translated">Hinweise für Aufrufer</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Derived classes frequently override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method to implement value equality.</source>
          <target state="translated">Abgeleitete Klassen überschreiben, die häufig die <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> Methode für die Implementierung der Wertgleichheit.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In addition, types also frequently provide an additional strongly typed overload to the <ph id="ph1">`Equals`</ph> method, typically by implementing the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> interface.</source>
          <target state="translated">Darüber hinaus auch häufig bieten eine zusätzliche stark typisierte Überladung für die <ph id="ph1">`Equals`</ph> Methode, in der Regel durch die Implementierung der <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When you call the <ph id="ph1">`Equals`</ph> method to test for equality, you should know whether the current instance overrides <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> and understand how a particular call to an <ph id="ph3">`Equals`</ph> method is resolved.</source>
          <target state="translated">Beim Aufrufen der <ph id="ph1">`Equals`</ph> Methode auf Gleichheit, sollten Sie wissen, ob die aktuelle Instanz überschreibt <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> und zu verstehen, wie ein bestimmter Aufruf eine <ph id="ph3">`Equals`</ph> Methode aufgelöst wird.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</source>
          <target state="translated">Hingegen Sie werden einen Test durchführen, Gleichheit unterscheidet sich von was Sie beabsichtigt haben, und die Methode kann einen unerwarteten Wert zurückgeben.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example provides an illustration.</source>
          <target state="translated">Dies wird im folgenden Beispiel veranschaulicht.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It instantiates three <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objects with identical strings, and then makes four calls to <ph id="ph2">`Equals`</ph> methods.</source>
          <target state="translated">Drei instanziiert <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> Objekte mit Zeichenfolgen identisch, und stellt anschließend vier Aufrufe zu <ph id="ph2">`Equals`</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The first method call returns <ph id="ph1">`true`</ph>, and the remaining three return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Die erste Methode aufrufen, gibt <ph id="ph1">`true`</ph>, und die verbleibenden drei Rückgabe <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In the first case, the strongly typed <ph id="ph1">&lt;xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType&gt;</ph> method overload, which tests for value equality, is called.</source>
          <target state="translated">Im ersten Fall, die stark typisierte <ph id="ph1">&lt;xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType&gt;</ph> -methodenüberladung, der Wertgleichheit getestet wird, aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because the strings assigned to the two <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objects are equal, the method returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Da die beiden Zeichenfolgen zugewiesen <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> -Objekte gleich sind, gibt die Methode zurück <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> does not override <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Allerdings <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> überschreibt nicht <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because of this, when the <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> object is cast to an <ph id="ph2">&lt;xref:System.Object&gt;</ph>, when a <ph id="ph3">&lt;xref:System.Text.StringBuilder&gt;</ph> instance is assigned to a variable of type <ph id="ph4">&lt;xref:System.Object&gt;</ph>, and when the <ph id="ph5">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> method is passed two <ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph> objects, the default <ph id="ph7">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method is called.</source>
          <target state="translated">Aus diesem Grund beim der <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> Objekt umgewandelt wird ein <ph id="ph2">&lt;xref:System.Object&gt;</ph>, wenn eine <ph id="ph3">&lt;xref:System.Text.StringBuilder&gt;</ph> Instanz einer Variablen vom Typ zugewiesen <ph id="ph4">&lt;xref:System.Object&gt;</ph>, und wann die <ph id="ph5">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> Methode werden zwei übergeben <ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph> Objekte, die Standardeinstellung <ph id="ph7">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> Methode wird aufgerufen.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> is a reference type, this is equivalent to passing the two <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> objects to the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">Da <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> ist ein Verweistyp, dies entspricht dem Übergeben der beiden <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> -Objekte und die <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Although all three <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objects contain identical strings, they refer to three distinct objects.</source>
          <target state="translated">Obwohl alle drei <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> Objekte enthalten identische Zeichenfolgen, die sie auf drei unterschiedliche Objekte verweisen.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As a result, these three method calls return <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Daher diese drei Methodenaufrufe return <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You can compare the current object to another object for reference equality by calling the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">Sie können das aktuelle Objekt einem anderen Objekt auf Verweisgleichheit vergleichen, durch Aufrufen der <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In Visual Basic, you can also use the <ph id="ph1">`is`</ph> keyword (for example, <ph id="ph2">`If Me Is otherObject Then ...`</ph>).</source>
          <target state="translated">In Visual Basic können Sie auch die <ph id="ph1">`is`</ph> Schlüsselwort (z. B. <ph id="ph2">`If Me Is otherObject Then ...`</ph>).</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Notes for Inheritors</source>
          <target state="translated">Hinweise zur Vererbung</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When you define your own type, that type inherits the functionality defined by the <ph id="ph1">`Equals`</ph> method of its base type.</source>
          <target state="translated">Wenn Sie einen eigenen Typ definieren, erbt dieses Typs Funktionen, die definiert die <ph id="ph1">`Equals`</ph> Methode des Basistyps.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following table lists the default implementation of the <ph id="ph1">`Equals`</ph> method for the major categories of types in the .NET Framework.</source>
          <target state="translated">Die folgende Tabelle enthält die standardmäßige Implementierung des der <ph id="ph1">`Equals`</ph> Methode für die Hauptkategorien von Typen in .NET Framework.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Type category</source>
          <target state="translated">Typkategorie</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Equality defined by</source>
          <target state="translated">Durch definierten Gleichheit</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Comments</source>
          <target state="translated">Kommentare</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Class derived directly from <ph id="ph1">&lt;xref:System.Object&gt;</ph></source>
          <target state="translated">Direkte abgeleitete Klasse <ph id="ph1">&lt;xref:System.Object&gt;</ph></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Reference equality; equivalent to calling <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Verweisgleichheit; entspricht dem Aufruf von <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Structure</source>
          <target state="translated">Struktur</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</source>
          <target state="translated">Wertgleichheit; direkte Byte-pro-Byte-Vergleich oder Feld-nach-Feld-Vergleich über Reflektion ermöglicht.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Enumeration</source>
          <target state="translated">Enumeration</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Values must have the same enumeration type and the same underlying value.</source>
          <target state="translated">Werte müssen den gleichen Enumerationstyp und den gleichen zugrunde liegenden Wert aufweisen.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Delegate</source>
          <target state="translated">delegate</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Delegates must have the same type with identical invocation lists.</source>
          <target state="translated">Delegaten müssen den gleichen Typ mit identischen Aufruflisten besitzen.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Interface</source>
          <target state="translated">Interface</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Reference equality.</source>
          <target state="translated">Verweisgleichheit.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For a value type, you should always override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>, because tests for equality that rely on reflection offer poor performance.</source>
          <target state="translated">Für einen Werttyp aufweist, sollten Sie immer überschreiben <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>, da Tests Gleichheit, die auf Reflektion beruhen, denen eine schlechte Leistung bieten.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You can also override the default implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</source>
          <target state="translated">Sie können auch die standardmäßige Implementierung des überschreiben <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> für Verweistypen, um Wertgleichheit statt Verweisgleichheit zu testen und um die genaue Bedeutung der Wertgleichheit zu definieren.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Such implementations of <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> return <ph id="ph2">`true`</ph> if the two objects have the same value, even if they are not the same instance.</source>
          <target state="translated">Solche Implementierungen von <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> zurückgeben <ph id="ph2">`true`</ph> , wenn die beiden Objekte den gleichen Wert verfügen, auch wenn sie nicht dieselbe Instanz sind.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</source>
          <target state="translated">Der Implementierung des Typs entscheidet, woraus sich der Wert eines Objekts zusammensetzt, aber es ist in der Regel einige oder alle Daten in den Instanzvariablen des Objekts gespeichert.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For example, the value of a <ph id="ph1">&lt;xref:System.String&gt;</ph> object is based on the characters of the string; the <ph id="ph2">&lt;xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method overrides the <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method to return <ph id="ph4">`true`</ph> for any two string instances that contain the same characters in the same order.</source>
          <target state="translated">Beispielsweise den Wert der eine <ph id="ph1">&lt;xref:System.String&gt;</ph> Objekt wird anhand der Zeichen der Zeichenfolge; der <ph id="ph2">&lt;xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> methodenüberschreibungen der <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> -Methode zur Rückgabe <ph id="ph4">`true`</ph> für eine beliebige Zeichenfolge zwei Instanzen, die die gleichen Zeichen in der gleichen Reihenfolge enthalten.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example shows how to override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method to test for value equality.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht das Überschreiben der <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> Methode zum Testen Wertgleichheit.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method for the <ph id="ph2">`Person`</ph> class.</source>
          <target state="translated">Es überschreibt die <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> Methode für die <ph id="ph2">`Person`</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If <ph id="ph1">`Person`</ph> accepted its base class implementation of equality, two <ph id="ph2">`Person`</ph> objects would be equal only if they referenced a single object.</source>
          <target state="translated">Wenn <ph id="ph1">`Person`</ph> seiner Basisklasse-Implementierung von Gleichheit, akzeptiert zwei <ph id="ph2">`Person`</ph> Objekte wäre nur gleich, wenn sie ein einzelnes Objekt, auf die verwiesen wird.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, in this case, two <ph id="ph1">`Person`</ph> objects are equal if they have the same value for the <ph id="ph2">`Person.Id`</ph> property.</source>
          <target state="translated">In diesem Fall jedoch zwei <ph id="ph1">`Person`</ph> Objekte sind gleich, wenn sie den gleichen Wert für die <ph id="ph2">`Person.Id`</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In addition to overriding <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>, you can implement the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> interface to provide a strongly typed test for equality.</source>
          <target state="translated">Neben dem Außerkraftsetzen von <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>, können Sie implementieren die <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> Schnittstelle, um eine stark typisierte Test auf Gleichheit bereitzustellen.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following statements must be true for all implementations of the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method.</source>
          <target state="translated">Die folgenden Anweisungen müssen für alle Implementierungen von "true" werden die <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In the list, <ph id="ph1">`x`</ph>, <ph id="ph2">`y`</ph>, and <ph id="ph3">`z`</ph> represent object references that are not <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</source>
          <target state="translated">In der Liste <ph id="ph1">`x`</ph>, <ph id="ph2">`y`</ph>, und <ph id="ph3">`z`</ph> darstellen von Objektverweisen, die nicht <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(x)`</ph> returns <ph id="ph2">`true`</ph>, except in cases that involve floating-point types.</source>
          <target state="translated"><ph id="ph1">`x.Equals(x)`</ph> Gibt <ph id="ph2">`true`</ph>, es sei denn, die Gleitkommatypen einschließen.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>See ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic.</source>
          <target state="translated">Finden Sie unter ISO/IEC/IEEE 60559:2011, Informationstechnologie--Mikroprozessor Systeme--Gleitkommazahlen.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(y)`</ph> returns the same value as <ph id="ph2">`y.Equals(x)`</ph>.</source>
          <target state="translated"><ph id="ph1">`x.Equals(y)`</ph> Gibt den gleichen Wert wie <ph id="ph2">`y.Equals(x)`</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(y)`</ph> returns <ph id="ph2">`true`</ph> if both <ph id="ph3">`x`</ph> and <ph id="ph4">`y`</ph> are <ph id="ph5">`NaN`</ph>.</source>
          <target state="translated"><ph id="ph1">`x.Equals(y)`</ph> Gibt <ph id="ph2">`true`</ph> Wenn beide <ph id="ph3">`x`</ph> und <ph id="ph4">`y`</ph> sind <ph id="ph5">`NaN`</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If <ph id="ph1">`(x.Equals(y) &amp;&amp; y.Equals(z))`</ph> returns <ph id="ph2">`true`</ph>, then <ph id="ph3">`x.Equals(z)`</ph> returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`(x.Equals(y) &amp;&amp; y.Equals(z))`</ph> gibt <ph id="ph2">`true`</ph>, klicken Sie dann <ph id="ph3">`x.Equals(z)`</ph> gibt <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Successive calls to <ph id="ph1">`x.Equals(y)`</ph> return the same value as long as the objects referenced by <ph id="ph2">`x`</ph> and <ph id="ph3">`y`</ph> are not modified.</source>
          <target state="translated">Aufeinander folgende Aufrufe von <ph id="ph1">`x.Equals(y)`</ph> zurückgeben, denselben Wert, solange die Objekte verweist <ph id="ph2">`x`</ph> und <ph id="ph3">`y`</ph> werden nicht geändert.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(null)`</ph> returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`x.Equals(null)`</ph> gibt <ph id="ph2">`false`</ph> zurück.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Implementations of <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> must not throw exceptions; they should always return a value.</source>
          <target state="translated">Implementierungen von <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> darf keine Ausnahmen auslösen, sollten sie stets einen Wert zurückgeben.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For example, if <ph id="ph1">`obj`</ph> is <ph id="ph2">`null`</ph>, the <ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph> method should return <ph id="ph4">`false`</ph> instead of throwing an <ph id="ph5">&lt;xref:System.ArgumentNullException&gt;</ph>.</source>
          <target state="translated">Z. B. wenn <ph id="ph1">`obj`</ph> ist <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph> -Methode zurückgeben sollte <ph id="ph4">`false`</ph> statt einer <ph id="ph5">&lt;xref:System.ArgumentNullException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Follow these guidelines when overriding <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>:</source>
          <target state="translated">Befolgen Sie diese Richtlinien zum Überschreiben <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>:</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Types that implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> must override <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</source>
          <target state="translated">Typen implementiert, <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> müssen überschreiben <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Types that override <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> must also override <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>; otherwise, hash tables  might not work correctly.</source>
          <target state="translated">Diese Außerkraftsetzung Typen <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> müssen auch überschreiben <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>ist, andernfalls Hashtabellen funktionieren eventuell nicht richtig.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You should consider implementing the <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> interface to support strongly typed tests for equality.</source>
          <target state="translated">Sie sollten erwägen, implementieren die <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> -Schnittstelle zur Unterstützung von stark typisierten Gleichheit.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Your <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph> implementation should return results that are consistent with <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated">Ihre <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph> Implementierung sollten Ergebnisse zurück, die mit konsistent sind <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method to return the same result as the equality operator.</source>
          <target state="translated">Wenn Ihre Programmiersprache unterstützt Überladen von Operatoren und Sie den Gleichheitsoperator für einen angegebenen Typ überladen, müssen Sie auch überschreiben die <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> Methode, um das gleiche Ergebnis wie den Gleichheitsoperator zurückzugeben.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This  helps ensure that class library code that uses <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> (such as <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>) behaves in a manner that is consistent with the way the equality operator is used by application code.</source>
          <target state="translated">So kann sichergestellt werden, die verwendet diese Klassenbibliothekscode <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> (z. B. <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> und <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>) verhält sich in einer Weise, die konsistent mit der Funktionsweise des Gleichheitsoperators wird vom Anwendungscode verwendet.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Guidelines for Reference Types</source>
          <target state="translated">Richtlinien für Referenztypen</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following guidelines apply to overriding <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> for a reference type:</source>
          <target state="translated">Die folgenden Richtlinien gelten für überschreiben <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> für einen Referenztyp darstellt:</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Consider overriding <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> if the semantics of the type are based on the fact that the type represents some value(s).</source>
          <target state="translated">Betrachten Sie überschreiben <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> , wenn die Semantik des Typs ist, basiert sowohl, dass der Typ einige Werte darstellt.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Most reference types must not overload the equality operator, even if they override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated">Die meisten Verweistypen müssen nicht den Gleichheitsoperator überladen, auch wenn sie außer Kraft setzen <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</source>
          <target state="translated">Wenn Sie einen Verweistyp implementieren, der Wertsemantik, z. B. eine komplexe Zahl Typ besitzen müssen Sie den Gleichheitsoperator überschreiben.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You should not override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> on a mutable reference type.</source>
          <target state="translated">Sie sollten nicht überschreiben <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> auf einen änderbaren Referenztyp.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This is because overriding <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> requires that you also override the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, as discussed in the previous section.</source>
          <target state="translated">Dies ist, da überschreiben <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> erfordert, dass Sie auch überschreiben die <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> -Methode, wie im vorherigen Abschnitt erläutert.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</source>
          <target state="translated">Dies bedeutet, dass der Hashcode für eine Instanz des einen änderbaren Referenztyp während seiner Lebensdauer ändern kann, die das Objekt, das verloren geht, werden in einer Hashtabelle verursachen können.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Guidelines for Value Types</source>
          <target state="translated">Richtlinien für Werttypen</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following guidelines apply to overriding <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> for a value type:</source>
          <target state="translated">Die folgenden Richtlinien gelten für überschreiben <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> für einen Werttyp:</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If you are defining a value type that includes one or more fields whose values are reference types, you should override <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</source>
          <target state="translated">Wenn Sie einen Werttyp definieren, die eine oder mehrere Felder enthält, deren Werte Verweistypen sind, sollten Sie überschreiben <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> implementation provided by <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> Implementierung, die <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> führt einen Byte-pro-Byte-Vergleich für, deren Werttypen Felder sind alle Werttypen, aber es verwendet Reflektion, um ein Feld-nach-Feld-Vergleich von Werttypen durchgeführt werden, deren Felder enthalten, Referenztypen sind.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If you override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and your development language supports operator overloading, you must overload the equality operator.</source>
          <target state="translated">Wenn Sie außer Kraft setzen <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> und Ihre Entwicklungssprache unterstützt Operatoren überladen, müssen Sie den Gleichheitsoperator überladen.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You should implement the <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> interface.</source>
          <target state="translated">Implementieren Sie die <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Calling the strongly typed <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph> method avoids boxing the <ph id="ph2">`obj`</ph> argument.</source>
          <target state="translated">Aufrufen der stark typisierten <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph> Methode wird vermieden, Boxing der <ph id="ph2">`obj`</ph> Argument.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example shows a <ph id="ph1">`Point`</ph> class that overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method to provide value equality, and a <ph id="ph3">`Point3D`</ph> class that is derived from <ph id="ph4">`Point`</ph>.</source>
          <target state="translated">Das folgende Beispiel zeigt eine <ph id="ph1">`Point`</ph> -Klasse, überschreibt die <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> Methode, um Wertgleichheit, bereitzustellen und eine <ph id="ph3">`Point3D`</ph> -Klasse, die abgeleitet ist <ph id="ph4">`Point`</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">`Point`</ph> overrides <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> to test for value equality, the <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method is not called.</source>
          <target state="translated">Da <ph id="ph1">`Point`</ph> überschreibt <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> Wertgleichheit, Testen der <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> Methode wird nicht aufgerufen.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, <ph id="ph1">`Point3D.Equals`</ph> calls <ph id="ph2">`Point.Equals`</ph> because <ph id="ph3">`Point`</ph> implements <ph id="ph4">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> in a manner that provides value equality.</source>
          <target state="translated">Allerdings <ph id="ph1">`Point3D.Equals`</ph> Aufrufe <ph id="ph2">`Point.Equals`</ph> da <ph id="ph3">`Point`</ph> implementiert <ph id="ph4">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> in einer Weise, die Wertgleichheit bereitstellt.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">`Point.Equals`</ph> method checks to make sure that the <ph id="ph2">`obj`</ph> argument is not <bpt id="p1">**</bpt>null<ept id="p1">**</ept> and that it references an instance of the same type as this object.</source>
          <target state="translated">Die <ph id="ph1">`Point.Equals`</ph> Methode überprüft, um sicherzustellen, dass die <ph id="ph2">`obj`</ph> Argument ist kein <bpt id="p1">**</bpt>null<ept id="p1">**</ept> und eine Instanz des gleichen Typs wie dieses Objekt verweist.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If either check fails, the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Wenn entweder ein Fehler auftritt überprüfen, gibt die Methode <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">`Point.Equals`</ph> method calls the <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> method to determine whether the run-time types of the two objects are identical.</source>
          <target state="translated">Die <ph id="ph1">`Point.Equals`</ph> Methodenaufrufe der <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> Methode, um zu bestimmen, ob die Laufzeit-Typen der beiden Objekte identisch sind.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If the method used a check of the form <ph id="ph1">`obj is Point`</ph> in C# or <ph id="ph2">`TryCast(obj, Point)`</ph> in Visual Basic, the check would return <ph id="ph3">`true`</ph> in cases where <ph id="ph4">`obj`</ph> is an instance of a derived class of <ph id="ph5">`Point`</ph>, even though <ph id="ph6">`obj`</ph> and the current instance are not of the same run-time type.</source>
          <target state="translated">Wenn die Methode eine Prüfung des Formulars verwendet <ph id="ph1">`obj is Point`</ph> in c# oder <ph id="ph2">`TryCast(obj, Point)`</ph> in Visual Basic die Überprüfung zurückgeben würde <ph id="ph3">`true`</ph> in Fällen, in denen <ph id="ph4">`obj`</ph> ist eine Instanz einer abgeleiteten Klasse von <ph id="ph5">`Point`</ph>, obwohl <ph id="ph6">`obj`</ph> und der aktuelle Instanz sind nicht vom gleichen Typ zur Laufzeit.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Having verified that both objects are of the same type, the method casts <ph id="ph1">`obj`</ph> to type <ph id="ph2">`Point`</ph> and returns the result of comparing the instance fields of the two objects.</source>
          <target state="translated">Wenn Sie überprüft haben, dass beide Objekte denselben Typ, die Methode Umwandlungen sind <ph id="ph1">`obj`</ph> Eingabe <ph id="ph2">`Point`</ph> und gibt das Ergebnis des Vergleichs den Instanzfelder der beiden Objekte zurück.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In <ph id="ph1">`Point3D.Equals`</ph>, the inherited <ph id="ph2">`Point.Equals`</ph> method, which overrides <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>, is invoked before anything else is done.</source>
          <target state="translated">In <ph id="ph1">`Point3D.Equals`</ph>, die geerbte <ph id="ph2">`Point.Equals`</ph> -Methode, die überschreibt <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>, wird aufgerufen, bevor Sie etwas anderes erfolgt.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">`Point3D`</ph> is a sealed class (<ph id="ph2">`NotInheritable`</ph> in Visual Basic), a check in the form <ph id="ph3">`obj is Point`</ph> in C# or <ph id="ph4">`TryCast(obj, Point)`</ph> in Visual Basic is adequate to ensure that <ph id="ph5">`obj`</ph> is a <ph id="ph6">`Point3D`</ph> object.</source>
          <target state="translated">Da <ph id="ph1">`Point3D`</ph> ist eine versiegelte Klasse (<ph id="ph2">`NotInheritable`</ph> in Visual Basic), eine Überprüfung in der Form <ph id="ph3">`obj is Point`</ph> in c# oder <ph id="ph4">`TryCast(obj, Point)`</ph> in Visual Basic ist ausreichend, um sicherzustellen, dass <ph id="ph5">`obj`</ph> ist ein <ph id="ph6">`Point3D`</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If it is a <ph id="ph1">`Point3D`</ph> object, it is cast to a <ph id="ph2">`Point`</ph> object and passed to the base class implementation of <ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated">Wird jedoch eine <ph id="ph1">`Point3D`</ph> -Objekt, der Umwandlung in einen <ph id="ph2">`Point`</ph> -Objekt und übergeben der basisklassenimplementierung <ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Only when the inherited <ph id="ph1">`Point.Equals`</ph> method returns <ph id="ph2">`true`</ph> does the method compare the <ph id="ph3">`z`</ph> instance fields introduced in the derived class.</source>
          <target state="translated">Nur, wenn die geerbte <ph id="ph1">`Point.Equals`</ph> -Methode zurückkehrt <ph id="ph2">`true`</ph> wird von der Methode Vergleich der <ph id="ph3">`z`</ph> Instanzenfelder in der abgeleiteten Klasse eingeführt.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example defines a <ph id="ph1">`Rectangle`</ph> class that internally implements a rectangle as two <ph id="ph2">`Point`</ph> objects.</source>
          <target state="translated">Das folgende Beispiel definiert eine <ph id="ph1">`Rectangle`</ph> Klasse, die intern ein Rechteck als zwei implementiert <ph id="ph2">`Point`</ph> Objekte.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">`Rectangle`</ph> class also overrides <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> to provide for value equality.</source>
          <target state="translated">Die <ph id="ph1">`Rectangle`</ph> -Klasse überschreibt außerdem <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> Wertgleichheit bereit.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Some languages such as C# and Visual Basic support operator overloading.</source>
          <target state="translated">In einigen Sprachen wie c# und Visual Basic unterstützt Operatoren überladen.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When a type overloads the equality operator, it must also override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method to provide the same functionality.</source>
          <target state="translated">Wenn ein Typ den Gleichheitsoperator überlädt, muss er auch überschreiben die <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> Methode, um die gleiche Funktionalität bereitzustellen.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This is typically accomplished by writing the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method in terms of the overloaded equality operator, as in the following example.</source>
          <target state="translated">Dies erfolgt in der Regel durch Schreiben der <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> Methode im Hinblick auf den überladenen Gleichheitsoperator, wie im folgenden Beispiel gezeigt.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">`Complex`</ph> is a value type, it cannot be derived from.</source>
          <target state="translated">Da <ph id="ph1">`Complex`</ph> ist ein Werttyp ist, es kann nicht abgeleitet werden.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Therefore, the override to <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method need not call <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> to determine the precise run-time type of each object, but can instead use the <ph id="ph3">`is`</ph> operator in C# or the <ph id="ph4">`TypeOf`</ph> operator in Visual Basic to check the type of the <ph id="ph5">`obj`</ph> parameter.</source>
          <target state="translated">Aus diesem Grund die Außerkraftsetzung so, <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> Methode nicht aufrufen muss <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> um zu bestimmen, der genaue Laufzeittyp der einzelnen Objekte, kann aber stattdessen verwenden die <ph id="ph3">`is`</ph> Operator in c# oder der <ph id="ph4">`TypeOf`</ph> -Operator in Visual Basic zum Überprüfen des Typs der <ph id="ph5">`obj`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The first object to compare.</source>
          <target state="translated">Das erste zu vergleichende Objekt.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The second object to compare.</source>
          <target state="translated">Das zweite zu vergleichende Objekt.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>Determines whether the specified object instances are considered equal.</source>
          <target state="translated">Stellt fest, ob die angegebenen Objektinstanzen als gleich betrachtet werden.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the objects are considered equal; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Objekte als gleich betrachtet werden, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If both <ph id="ph1">&lt;paramref name="objA" /&gt;</ph> and <ph id="ph2">&lt;paramref name="objB" /&gt;</ph> are <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, the method returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Wenn sowohl <ph id="ph1">&lt;paramref name="objA" /&gt;</ph>, als auch <ph id="ph2">&lt;paramref name="objB" /&gt;</ph> <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> sind, gibt diese Methode <ph id="ph3">&lt;see langword="true" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The static <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph> method indicates whether two objects, <ph id="ph2">`objA`</ph> and  <ph id="ph3">`objB`</ph>, are equal.</source>
          <target state="translated">Die statische <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph> Methode gibt an, ob zwei Objekte, <ph id="ph2">`objA`</ph> und <ph id="ph3">`objB`</ph>, gleich sind.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It also enables you to test objects whose value is <bpt id="p1">**</bpt>null<ept id="p1">**</ept> for equality.</source>
          <target state="translated">Außerdem können Sie Objekte zu testen, deren Wert <bpt id="p1">**</bpt>null<ept id="p1">**</ept> Gleichheit.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It compares <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> for equality as follows:</source>
          <target state="translated">Es vergleicht <ph id="ph1">`objA`</ph> und <ph id="ph2">`objB`</ph> Gleichheit wie folgt:</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It determines whether the two objects represent the same object reference.</source>
          <target state="translated">Sie bestimmt, ob die beiden Objekte den gleichen Objektverweis darstellen.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If they do, the method returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Wenn dies der Fall, gibt die Methode <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>This test is equivalent to calling the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">Dieser Test entspricht dem Aufrufen der <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>In addition, if both <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> are <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, the method returns <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Darüber hinaus, wenn beide <ph id="ph1">`objA`</ph> und <ph id="ph2">`objB`</ph> sind <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, gibt die Methode <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It determines whether either <ph id="ph1">`objA`</ph> or <ph id="ph2">`objB`</ph> is <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</source>
          <target state="translated">Bestimmt, ob entweder <ph id="ph1">`objA`</ph> oder <ph id="ph2">`objB`</ph> ist <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If so, it returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Wenn also zurückgegeben <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If the two objects do not represent the same object reference and neither is <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, it calls <ph id="ph1">`objA`</ph>.<ph id="ph2">`Equals`</ph>(<ph id="ph3">`objB`</ph>) and returns the result.</source>
          <target state="translated">Wenn die beiden Objekte nicht den gleichen Objektverweis darstellen und weder ist <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, ruft er <ph id="ph1">`objA`</ph>.<ph id="ph2">`Equals`</ph> (<ph id="ph3">`objB`</ph>) und gibt das Ergebnis zurück.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>This means that if <ph id="ph1">`objA`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, this override is called.</source>
          <target state="translated">Dies bedeutet, dass bei <ph id="ph1">`objA`</ph> überschreibt die <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> Methode, diese Außerkraftsetzung wird aufgerufen.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph> method and compares it with the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph> Methode und vergleicht ihn mit der <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Object.Finalize">
          <source>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</source>
          <target state="translated">Gibt einem Objekt Gelegenheit zu dem Versuch, Ressourcen freizugeben und andere Bereinigungen durchzuführen, bevor es von der Garbage Collection freigegeben wird.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> Methode wird verwendet, um Bereinigungsvorgänge für nicht verwaltete Ressourcen, die durch das aktuelle Objekt gehalten werden, bevor das Objekt zerstört wird.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The method is protected and therefore is accessible only through this class or through a derived class.</source>
          <target state="translated">Die Methode wird geschützt und wird daher nur über diese Klasse oder durch eine abgeleitete Klasse zugegriffen werden.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>In this section:</source>
          <target state="translated">In diesem Abschnitt</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><bpt id="p1">[</bpt>How finalization works<ept id="p1">](#How)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Funktionsweise der Finalisierung<ept id="p1">](#How)</ept></target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><bpt id="p1">[</bpt>Notes for implementers<ept id="p1">](#Notes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Hinweise für Implementierer<ept id="p1">](#Notes)</ept></target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><bpt id="p1">[</bpt>The SafeHandle alternative<ept id="p1">](#SafeHandle)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die SafeHandle-alternative<ept id="p1">](#SafeHandle)</ept></target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>How finalization works</source>
          <target state="translated">Funktionsweise der Finalisierung</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object&gt;</ph> class provides no implementation for the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, and the garbage collector does not mark types derived from <ph id="ph3">&lt;xref:System.Object&gt;</ph> for finalization unless they override the <ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Object&gt;</ph> Klasse enthält keine Implementierung für die <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> -Methode und der Garbage Collector nicht von abgeleitete Typen markieren <ph id="ph3">&lt;xref:System.Object&gt;</ph> auf einen Abschluss warten, wenn sie außer Kraft setzen die <ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If a type does override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</source>
          <target state="translated">Wenn ein Typ überschreibt die <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> -Methode der Garbage Collector wird ein Eintrag für jede Instanz des Typs in eine interne Struktur, die die Warteschlange der Abschluss aufgerufen.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</source>
          <target state="translated">Die Abschluss Warteschlange enthält Einträge für alle Objekte im verwalteten Heap, dessen Abschluss Code ausgeführt werden muss, bevor der Garbage Collector den Arbeitsspeicher freigeben kann.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The garbage collector then calls the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method automatically under the following conditions:</source>
          <target state="translated">Anschließend ruft der Garbage Collector die <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> Methode automatisch in den folgenden Situationen:</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Nachdem der Garbage Collector ermittelt hat, dass ein Objekt kann nicht zugegriffen werden, es sei denn, das Objekt von der Finalisierung durch einen Aufruf von ausgenommen wurde die <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>During shutdown of an application domain, unless the object is exempt from finalization.</source>
          <target state="translated">Während des Herunterfahrens einer Anwendungsdomäne es sei denn, das Objekt von der Finalisierung ausgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>During shutdown, even objects that are still accessible are finalized.</source>
          <target state="translated">Während des Herunterfahrens können sogar Objekte, die immer noch zugänglich sind abgeschlossen.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <ph id="ph2">&lt;xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType&gt;</ph> and the <ph id="ph3">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> method has not been subsequently called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> wird automatisch aufgerufen nur einmal auf eine bestimmte Instanz, es sei denn, das Objekt erneut registriert wird, wie z. B. mit einem Mechanismus <ph id="ph2">&lt;xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType&gt;</ph> und die <ph id="ph3">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> Methode nicht anschließend aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> operations have the following limitations:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> Vorgänge weisen die folgenden Einschränkungen:</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The exact time when the finalizer executes is undefined.</source>
          <target state="translated">Die genaue Uhrzeit, wann der Finalizer ausgeführt wird, ist nicht definiert.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>To ensure deterministic release of resources for instances of your class, implement a <ph id="ph1">`Close`</ph> method or provide a <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation.</source>
          <target state="translated">Um deterministische Freigabe von Ressourcen für Instanzen Ihrer Klasse implementiert sicherzustellen, dass eine <ph id="ph1">`Close`</ph> Methode, oder geben Sie einen <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> Implementierung.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</source>
          <target state="translated">Die Finalizer zweier Objekte werden nicht in einer bestimmten Reihenfolge ausgeführt garantiert, selbst wenn ein Objekt in den anderen verweist.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</source>
          <target state="translated">D. h. wenn Objekt A verfügt über einen Verweis auf das Objekt B, und beide Finalizer besitzen, Objekt B möglicherweise bereits beendet wurden, wenn der Finalizer des Objekts ein beginnt.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The thread on which the finalizer runs is unspecified.</source>
          <target state="translated">Der Thread, auf dem der Finalizer ausgeführt wird, ist nicht angegeben.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method might not run to completion or might not run at all under the following exceptional circumstances:</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> Methode möglicherweise nicht bis zum Abschluss ausgeführt, oder unter den folgenden außergewöhnlichen Umständen möglicherweise nicht alle ausgeführt:</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</source>
          <target state="translated">Wenn eine andere Finalizer auf unbestimmte Zeit blockiert (wechselt in eine Endlosschleife versucht, eine Sperre kann es nie zu erhalten und so weiter).</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</source>
          <target state="translated">Da die Runtime versucht, Finalizer bis zum Abschluss ausgeführt, möglicherweise andere Finalizer nicht wenn ein Finalizer blockiert unbegrenzt aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If the process terminates without giving the runtime a chance to clean up.</source>
          <target state="translated">Wenn der Prozess beendet, ohne dadurch die Möglichkeit zum Bereinigen von der Laufzeitmoduls.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</source>
          <target state="translated">In diesem Fall wird die Laufzeit die erste Benachrichtigung für Beendigung des Prozesses eine DLL_PROCESS_DETACH-Benachrichtigung.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</source>
          <target state="translated">Die Common Language Runtime weiterhin Threadobjekte während des Herunterfahrens nur, während die Anzahl der finalisierbare Objekte weiterhin verringern.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> or an override of <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active <ph id="ph3">`try`</ph><ph id="ph4">/</ph><ph id="ph5">`finally`</ph> blocks or finalizers are executed.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> oder eine Überschreibung der <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> löst eine Ausnahme aus, und die Common Language Runtime nicht von einer Anwendung, die die Standardrichtlinie überschreibt gehostet wird, die Runtime beendet den Prozess und keine aktiven <ph id="ph3">`try`</ph> <ph id="ph4">/</ph> <ph id="ph5">`finally`</ph> Blöcke oder Finalizer werden ausgeführt.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>This behavior ensures process integrity if the finalizer cannot free or destroy resources.</source>
          <target state="translated">Dieses Verhalten wird Prozessintegrität sichergestellt, wenn der Finalizer nicht freigeben oder Löschen von Ressourcen.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Overriding the Finalize method</source>
          <target state="translated">Überschreiben der Finalize-Methode</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>You should override <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</source>
          <target state="translated">Sie sollten überschreiben <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> für eine Klasse, die nicht verwaltete Ressourcen wie Dateihandles oder Datenbankverbindungen, die freigegeben werden müssen, wenn das verwaltete Objekt, das sie verwendet, während der Garbagecollection verworfen wird verwendet.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>You shouldn't implement a <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method for managed objects because the garbage collector releases managed resources automatically.</source>
          <target state="translated">Sie sollten nicht implementieren eine <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> Methode für verwaltete Objekte auf, da der Garbage Collector automatisch verwendeten verwaltete Ressourcen frei.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
          <target state="translated">Wenn eine <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> Objekt ist verfügbar, die nicht verwaltete Ressource einschließt, die empfohlene Alternative ist das Implementieren des Dispose-Musters mit einem sicheren Handle und nicht überschreiben <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>For more information, see <bpt id="p1">[</bpt>The SafeHandle alternative<ept id="p1">](#SafeHandle)</ept> section.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>die SafeHandle-Alternative<ept id="p1">](#SafeHandle)</ept> Abschnitt.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method does nothing by default, but you should override <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> only if necessary, and only to release unmanaged resources.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> Methode hat keine Funktion in der Standardeinstellung, aber Sie sollten überschreiben <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> nur, wenn erforderlich, und dies nur auf nicht verwaltete Ressourcen freizugeben.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</source>
          <target state="translated">Freigeben von Arbeitsspeicher ist länger dauert, wenn ein Finalisierung-Vorgang ausgeführt wird, da er mindestens zwei Garbage Collections erforderlich ist.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>In addition, you should override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method for reference types only.</source>
          <target state="translated">Darüber hinaus sollten Sie überschreiben die <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> Methode Referenzzwecken nur Typen.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The common language runtime only finalizes reference types.</source>
          <target state="translated">Die common Language Runtime finalisiert nur Verweistypen.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>It ignores finalizers on value types.</source>
          <target state="translated">Finalizer für Werttypen werden ignoriert.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The scope of the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method is <ph id="ph2">`protected`</ph>.</source>
          <target state="translated">Der Geltungsbereich der <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> Methode ist <ph id="ph2">`protected`</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>You should maintain this limited scope when you override the method in your class.</source>
          <target state="translated">Sie sollten diesen eingeschränkten Gültigkeitsbereich beibehalten, wenn Sie die Methode in der Klasse überschreiben.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>By keeping a <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method protected, you prevent users of your application from calling an object's <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method directly.</source>
          <target state="translated">Hält einen <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> geschützte Methode, können Benutzer der Anwendung ein Objekt aufrufen <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> -Methode direkt.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Every implementation of <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> in a derived type must call its base type's implementation of <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
          <target state="translated">Jede Implementierung von <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> müssen in einem abgeleiteten Typ seinem Basistyp Implementierung von Aufrufen <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>This is the only case in which application code is allowed to call <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
          <target state="translated">Dies ist der einzige Fall, in der Anwendung Code aufrufen darf <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>An object's <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method shouldn't call a method on any objects other than that of its base class.</source>
          <target state="translated">Ein Objekt <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> darf keine Methode eine Methode aufrufen, auf alle Objekte, die von ihrer Basisklasse.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</source>
          <target state="translated">Der Grund hierfür ist, dass das aufrufende Objekt möglicherweise zur gleichen Zeit an die Garbage Collection übergeben wird wie die anderen aufgerufenen Objekte, z. B. wenn eine Common Language Runtime beendet wird.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The C# compiler does not allow you to override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Der C#-Compiler lässt nicht zu, Sie überschreiben die <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Instead, you provide a finalizer by implementing a <bpt id="p1">[</bpt>destructor<ept id="p1">](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)</ept> for your class.</source>
          <target state="translated">Stattdessen Sie einen Finalizer bereitstellen, durch die Implementierung einer <bpt id="p1">[</bpt>Destruktor<ept id="p1">](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)</ept> für die Klasse.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>A C# destructor automatically calls the destructor of its base class.</source>
          <target state="translated">Ein C#-Destruktor ruft automatisch den Destruktor ihrer Basisklasse.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Visual C++ also provides its own syntax for implementing the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Visual C++ bietet auch eine eigene Syntax für die Implementierung der <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>For more information, see the "Destructors and finalizers" section of <bpt id="p1">[</bpt>How to: Define and Consume Classes and Structs (C++/CLI)<ept id="p1">](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt "Destruktoren und Finalizer" <bpt id="p1">[</bpt>wie: definieren und Verarbeiten von Klassen und Strukturen (C + c++ / CLI)<ept id="p1">](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)</ept>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</source>
          <target state="translated">Da der Garbagecollection nicht deterministisch ist, wissen Sie nicht genau, wenn der Garbage Collector Finalisierung ausführt.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>To release resources immediately, you can also choose to implement the <bpt id="p1">[</bpt>dispose pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> and the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Um Ressourcen freizugeben sofort Wunsch können Sie zum Implementieren der <bpt id="p1">[</bpt>dispose-Muster<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> und <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method to free unmanaged resources in the event that the <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method is not called.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> Implementierung kann aufgerufen werden, durch den Consumer Ihrer Klasse das Freigeben von nicht verwalteten Ressourcen und können Sie die <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> Methode, um nicht verwaltete Ressourcen freizugeben, wenn die <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> Methode wird nicht aufgerufen.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> dauert die nahezu jede Aktion, z. B. kann ein Objekt (die das Objekt wieder zugänglich gemacht werden,) zugänglich. nachdem sie während der Garbagecollection bereinigt wurden.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>However, the object can only be resurrected once; <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> cannot be called on resurrected objects during garbage collection.</source>
          <target state="translated">Allerdings kann das Objekt nur einmal wieder zugänglich gemacht werden; <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> kann nicht wieder zugänglich gemachte Objekte während der Garbagecollection aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>There is one action that your implementation of <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> should never take: it should never throw an exception.</source>
          <target state="translated">Es ist eine Aktion, die Ihre Implementierung von <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> abwartet, nie: sollten sie nie eine Ausnahme auslösen.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If any exceptions thrown by methods called from the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method are unhandled by the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, the runtime assumes that the <ph id="ph3">&lt;xref:System.Object.Finalize%2A&gt;</ph> method returned and continues to call the <ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph> methods of other objects.</source>
          <target state="translated">Bei einem von Methoden ausgelösten Ausnahmen in Aufruf der <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> Methode werden nicht behandelt, durch die <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> -Methode, die Common Language Runtime setzt voraus, dass die <ph id="ph3">&lt;xref:System.Object.Finalize%2A&gt;</ph> Methode zurückgegeben, und rufen Sie weiterhin die <ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph> Methoden anderer Objekte.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The SafeHandle alternative</source>
          <target state="translated">Die SafeHandle-Alternative</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> and <ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph> terminate the finalizer.</source>
          <target state="translated">Zuverlässige Finalizer ist oft schwierig, da Sie Annahmen über den Zustand der Anwendung vornehmen können, und wie z. B. Systemausnahmen nicht behandelt <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> und <ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph> den Finalizer zu beenden.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</source>
          <target state="translated">Anstatt zu implementieren einen Finalizer für die Klasse, um nicht verwaltete Ressourcen freizugeben, können Sie ein Objekt, das von abgeleitet ist die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph> -Klasse Wrapper für die nicht verwalteten Ressourcen und anschließenden Implementieren des Dispose-Musters, ohne einen Finalizer.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The .NET Framework provides the following classes in the <ph id="ph1">&lt;xref:Microsoft.Win32?displayProperty=nameWithType&gt;</ph> namespace that are derived from <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph>:</source>
          <target state="translated">.NET Framework bietet die folgenden Klassen in der <ph id="ph1">&lt;xref:Microsoft.Win32?displayProperty=nameWithType&gt;</ph> Namespace, die von der abgeleiteten <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph>:</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> is a wrapper class for a file handle.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> ist eine Wrapperklasse für ein Dateihandle.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle&gt;</ph> is a wrapper class for memory-mapped file handles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle&gt;</ph> ist eine Wrapperklasse für die Speicherabbilddatei Handles an.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle&gt;</ph> is a wrapper class for a pointer to a block of unmanaged memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle&gt;</ph> ist eine Wrapperklasse für ein Zeiger auf einen nicht verwalteten Speicherblock.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle&gt;</ph>, <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle&gt;</ph>, and <ph id="ph3">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle&gt;</ph> are wrapper classes for cryptographic handles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle&gt;</ph>, <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle&gt;</ph>, und <ph id="ph3">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle&gt;</ph> Wrapperklassen für kryptografische behandelt werden.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafePipeHandle&gt;</ph> is a wrapper class for pipe handles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafePipeHandle&gt;</ph> ist eine Wrapperklasse für Pipehandles an.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> is a wrapper class for a handle to a registry key.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> ist eine Wrapperklasse für ein Handle für einen Registrierungsschlüssel an.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> is a wrapper class for a wait handle.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> ist eine Wrapperklasse für ein Wait-Handle.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The following example uses the <bpt id="p1">[</bpt>dispose pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> with safe handles instead of overriding the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Im folgenden Beispiel wird die <bpt id="p1">[</bpt>dispose-Muster<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> mit SafeHandles anstelle von der <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>It defines a <ph id="ph1">`FileAssociation`</ph> class that wraps registry information about the application that handles files with a particular file extension.</source>
          <target state="translated">Definiert eine <ph id="ph1">`FileAssociation`</ph> Klasse, die Registrierungsinformationen zur Anwendung umschließt, die Dateien mit einer bestimmten Dateierweiterung behandelt.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The two registry handles returned as <ph id="ph1">`out`</ph> parameters by Windows <bpt id="p1">[</bpt>RegOpenKeyEx<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)</ept> function calls are passed to the <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> constructor.</source>
          <target state="translated">Die zwei Registrierungshandles zurückgegeben als <ph id="ph1">`out`</ph> Parameter durch Windows <bpt id="p1">[</bpt>RegOpenKeyEx<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)</ept> an Funktionsaufrufe übergeben werden die <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The type's protected <ph id="ph1">`Dispose`</ph> method then calls the <ph id="ph2">`SafeRegistryHandle.Dispose`</ph> method  to free these two handles.</source>
          <target state="translated">Der Typ der geschützte <ph id="ph1">`Dispose`</ph> -Methode ruft dann die <ph id="ph2">`SafeRegistryHandle.Dispose`</ph> Methode, um diese zwei Handles freizugeben.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The following example verifies that the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method is called when an object that overrides <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> is destroyed.</source>
          <target state="translated">Im folgenden Beispiel wird überprüft, ob die <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> Methode wird aufgerufen, wenn ein Objekt, das überschreibt <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> zerstört wird.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Note that, in a production application, the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method would be overridden to release unmanaged resources held by the object.</source>
          <target state="translated">Beachten Sie, dass in einer produktionsanwendung die <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> Methode würde überschrieben werden, um nicht verwaltete Ressourcen frei, die für das Objekt freizugeben.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Also note that the C# example provides a destructor instead of overriding the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Beachten Sie, dass im C#-Beispiel einen Destruktor anstelle von bietet die <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>For an additional example that overrides the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, see the <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Für ein weiteres Beispiel, die überschreibt die <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> -Methode finden Sie unter der <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Object.GetHashCode">
          <source>Serves as the default hash function.</source>
          <target state="translated">Fungiert als die Standardhashfunktion.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Object.GetHashCode">
          <source>A hash code for the current object.</source>
          <target state="translated">Ein Hashcode für das aktuelle Objekt.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> class, the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> class, or a type derived from the <ph id="ph3">&lt;xref:System.Collections.DictionaryBase&gt;</ph> class.</source>
          <target state="translated">Ein Hashcode ist ein numerischer Wert, der verwendet wird, zum Einfügen und identifizieren z. B. ein Objekt in einer Auflistung hashbasierten der <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> -Klasse, die <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> Klasse oder einen Typ abgeleitet wurde. die <ph id="ph3">&lt;xref:System.Collections.DictionaryBase&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method provides this hash code for algorithms that need quick checks of object equality.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> Methode bietet diese Hashcode für Algorithmen, die schnelle Überprüfung der Objektgleichheit benötigen.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the <bpt id="p1">[</bpt>Hash Function<ept id="p1">](http://en.wikipedia.org/wiki/Hash_function)</ept> entry in Wikipedia.</source>
          <target state="translated">Informationen zur Verwendung von Hashcodes in Hashtabellen sowie einige zusätzliche Code Hashalgorithmen finden Sie unter der <bpt id="p1">[</bpt>Hashfunktion<ept id="p1">](http://en.wikipedia.org/wiki/Hash_function)</ept> Eintrag in Wikipedia.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Two objects that are equal return hash codes that are equal.</source>
          <target state="translated">Zwei Objekte gleich return Hashcodes, die gleich sind.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</source>
          <target state="translated">Das Gegenteil stimmt aber nicht "true": gleich Hashcodes implizieren keine Objektgleichheit, da verschiedene (ungleich) Objekte identische Hashcodes verfügen können.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Furthermore, the .NET Framework does not guarantee the default implementation of the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms.</source>
          <target state="translated">.NET Framework gewährleistet zudem nicht die standardmäßige Implementierung des der <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> -Methode, und der Wert, der diese Methode gibt unterschiedlich ausfallen, zwischen .NET Framework-Versionen und Plattformen, wie z. B. 32-Bit und 64-Bit-Plattformen.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</source>
          <target state="translated">Aus diesen Gründen verwenden Sie nicht die standardmäßige Implementierung dieser Methode als eine eindeutige Objekt-ID für hashing Zwecke.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Two consequences follow from this:</source>
          <target state="translated">Führen Sie die zwei Konsequenzen aus diesem:</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You should not assume that equal hash codes imply object equality.</source>
          <target state="translated">Sie sollten nicht davon ausgehen, dass gleich Hashcodes Objektgleichheit hinweisen.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</source>
          <target state="translated">Sie sollten nie beibehalten oder einen Hashcode außerhalb der Anwendungsdomäne, in der es erstellt wurde, verwenden, da das gleiche Objekt zwischen Anwendungsdomänen, Prozessen und Plattformen hash kann.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</source>
          <target state="translated">Ein Hashcode richtet effizientes einfügen und Suche in Sammlungen, die auf eine Hashtabelle basieren.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash code is not a permanent value.</source>
          <target state="translated">Ein Hashcode ist kein permanente Wert.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For this reason:</source>
          <target state="translated">Aus diesem Grund:</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not serialize hash code values or store them in databases.</source>
          <target state="translated">Serialisieren Sie Hashwerte für Code nicht, und in Datenbanken zu speichern.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not use the hash code as the key to retrieve an object from a keyed collection.</source>
          <target state="translated">Verwenden Sie nicht den Hash als Schlüssel an, um ein Objekt aus einer schlüsselgebundenen Auflistung abzurufen.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not send hash codes across application domains or processes.</source>
          <target state="translated">Senden Sie über Anwendungsdomänen oder Prozessen nicht Hashcodes.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In some cases, hash codes may be computed on a per-process or per-application domain basis.</source>
          <target state="translated">In einigen Fällen können der Hashcodes pro Domäne pro Prozess oder pro Anwendung berechnet werden.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</source>
          <target state="translated">Verwenden Sie nicht den Hashcode, statt eines Werts von einer kryptografischen Hashfunktion zurückgegeben, wenn Sie einen kryptografisch starken Hash benötigen.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For cryptographic hashes, use a class derived from the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType&gt;</ph> class.</source>
          <target state="translated">Verwenden Sie für kryptografische Hashes eine abgeleitete Klasse die <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not test for equality of hash codes to determine whether two objects are equal.</source>
          <target state="translated">Testen Sie nicht auf die Gleichheit von Hashcodes, um zu bestimmen, ob zwei Objekte gleich sind.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>(Unequal objects can have identical hash codes.) To test for equality, call the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method.</source>
          <target state="translated">(Ungleich Objekte können identische Hashcodes verfügen.) Um auf Gleichheit zu testen, rufen Sie die <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method can be overridden by a derived type.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> Methode kann durch einen abgeleiteten Typ überschrieben werden.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> is not overridden, hash codes for reference types are computed by calling the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method of the base class, which computes a hash code based on an object's reference; for more information, see <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> wird nicht überschrieben, Hashcodes für Verweistypen berechnet werden, durch Aufrufen der <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> Methode der Basisklasse, die einen Hashcode berechnet basierend auf ein Objekt Verweis; Weitere Informationen, finden Sie unter <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In other words, two objects for which the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> have identical hash codes.</source>
          <target state="translated">Das heißt, zwei Objekte auf dem die <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> -Methode zurückkehrt <ph id="ph2">`true`</ph> haben identische Hashcodes.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If value types do not override <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</source>
          <target state="translated">Wenn Werttypen nicht außer Kraft setzen <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>die <ph id="ph2">&lt;xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> -Methode der Basisklasse verwendet Reflektion, um den Hashcode anhand der Werte der Felder des Typs zu berechnen.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In other words, value types whose fields have equal values have equal hash codes.</source>
          <target state="translated">Werttypen, deren Felder identische Werte haben, haben also gleich Hashcodes.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For more information about overriding <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, see the "Notes to Inheritors" section.</source>
          <target state="translated">Weitere Informationen zum Überschreiben <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, finden Sie im Abschnitt "Hinweise zur Vererbung".</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If you override the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, you should also override <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>, and vice versa.</source>
          <target state="translated">Wenn Sie überschreiben die <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> , Sie sollten auch-methodenüberschreibung <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>, und umgekehrt.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If your overridden <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> when two objects are tested for equality, your overridden <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method must return the same value for the two objects.</source>
          <target state="translated">Wenn die überschriebene <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> -Methode zurückkehrt <ph id="ph2">`true`</ph> Wenn werden zwei Objekte auf Gleichheit, die außer Kraft gesetzte getestet <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> Methode muss für die beiden Objekte den gleichen Wert zurück.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If an object that is used as a key in a hash table does not provide a useful implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, you can specify a hash code provider by supplying an <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> implementation to one of the overloads of the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> class constructor.</source>
          <target state="translated">Wenn ein Objekt, das in einer Hashtabelle als Schlüssel verwendet wird, keine geeignete Implementierung von bietet <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, Sie können einen Hashcode-Standardanbieter angeben, durch Angabe einer <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> -Implementierung, die eine der Überladungen der der <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> Klassenkonstruktor.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">Hinweise für die <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When you call the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method on a class in the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen der <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> Methode einer Klasse in der <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, es stellt das Standardverhalten für Klassen, die nicht außer Kraft setzen <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">Dies ist Teil der Unterstützung von .NET Framework für die <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (siehe <bpt id="p1">[</bpt>.NET Framework Unterstützung für Windows Store-Apps und Windows-Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Classes in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id="ph2">&lt;xref:System.Object&gt;</ph>, and currently don’t implement a <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">Klassen in der <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> erben nicht <ph id="ph2">&lt;xref:System.Object&gt;</ph>, und zurzeit nicht implementieren eine <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>However, they appear to have <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</source>
          <target state="translated">Allerdings sie angezeigt werden, damit <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, und <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> Methoden, wenn Sie in c# oder Visual Basic-Code werden verwendet, und die .NET Framework das Standardverhalten für diese Methoden bietet.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> Klassen, die in c# oder Visual Basic geschrieben sind, können außer Kraft setzen die <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <ph id="ph1">&lt;xref:System.Int32&gt;</ph> type is to simply return that value.</source>
          <target state="translated">Einer der einfachsten Möglichkeiten, einen Hashcode für einen numerischen Wert zu berechnen, der der gleichen oder einer kleineren Bereich als hat die <ph id="ph1">&lt;xref:System.Int32&gt;</ph> ist einfach, der Wert zurückgegeben.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The following example shows such an implementation for a <ph id="ph1">`Number`</ph> structure.</source>
          <target state="translated">Das folgende Beispiel zeigt eine Implementierung für eine <ph id="ph1">`Number`</ph> Struktur.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Frequently, a type has multiple data fields that can participate in generating the hash code.</source>
          <target state="translated">In vielen Fällen hat einen Typ mehrere Datenfelder, die beim Generieren des Hashcodes einbezogen werden können.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>One way to generate a hash code is to combine these fields using an <ph id="ph1">`XOR (eXclusive OR)`</ph> operation, as shown in the following example.</source>
          <target state="translated">Eine Möglichkeit, einen Hashcode zu generieren, kombinieren diese Felder mithilfe von ist ein <ph id="ph1">`XOR (eXclusive OR)`</ph> Vorgang, wie im folgenden Beispiel gezeigt.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</source>
          <target state="translated">Das vorherige Beispiel gibt den gleichen Hashcode für (n1, n2) und (n2 n1), und somit weitere Konflikte als erwünscht sind Aktivierungscode generieren.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A number of solutions are available so that hash codes in these cases are not identical.</source>
          <target state="translated">Eine Reihe von Lösungen sind verfügbar, sodass Hashcodes in diesen Fällen nicht identisch sind.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>One is to return the hash code of a <ph id="ph1">`Tuple`</ph> object that reflects the order of each field.</source>
          <target state="translated">Eine besteht darin, den Hashcode des Zurückgeben einer <ph id="ph1">`Tuple`</ph> -Objekt, das die Reihenfolge der jedes Feld entspricht.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The following example shows a possible implementation that uses the <ph id="ph1">&lt;xref:System.Tuple%602&gt;</ph> class.</source>
          <target state="translated">Das folgende Beispiel zeigt eine mögliche Implementierung, verwendet die <ph id="ph1">&lt;xref:System.Tuple%602&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Note, though, that the performance overhead of instantiating a <ph id="ph1">`Tuple`</ph> object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</source>
          <target state="translated">Beachten Sie jedoch, die die Beeinträchtigung der Systemleistung der Instanziierung einer <ph id="ph1">`Tuple`</ph> Objekt kann erhebliche Auswirkungen auf die allgemeine Leistung einer Anwendung, in der großen Anzahl von Objekten in Hashtabellen gespeichert.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</source>
          <target state="translated">Eine zweite alternative Lösung umfasst die Gewichtung der einzelnen Hashcodes von links-Verschiebung der Hashcodes von aufeinander folgenden Feldern von zwei oder mehr Bits.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded.</source>
          <target state="translated">Optimal, anstatt verworfen werden, Bits verschoben hinter Bit 31 umschließen soll statt verworfen werden.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</source>
          <target state="translated">Da von der Left Shift-Operatoren in c# und Visual Basic Bits verworfen werden, erfordert dies eine linke UMSCHALT-Wrap-Methode wie folgt erstellen:</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The following example then uses this shift-and-wrap method to compute the hash code of the <ph id="ph1">`Point`</ph> structure used in the previous examples.</source>
          <target state="translated">Im folgende Beispiel verwendet dann diese UMSCHALT-Wrap-Methode den Hashcode berechnet die <ph id="ph1">`Point`</ph> Struktur, die in den vorherigen Beispielen verwendet.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object.</source>
          <target state="translated">Eine Hashfunktion wird verwendet, um schnell eine Zahl (Hashcode) generieren, die auf den Wert eines Objekts entspricht.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input.</source>
          <target state="translated">Hashfunktionen für jeden Typ in der Regel spezifisch sind und für die Eindeutigkeit, müssen mindestens eines der Instanzfelder als Eingabe verwenden.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Hash codes should not be computed by using the values of static fields.</source>
          <target state="translated">Hashcodes sollten nicht mit den Werten von statischen Feldern berechnet werden.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For classes derived from <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>, the <ph id="ph2">&lt;see langword="GetHashCode" /&gt;</ph> method can delegate to the base class <ph id="ph3">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> implementation only if the derived class defines equality to be reference equality.</source>
          <target state="translated">Für Klassen abgeleitete <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>, <ph id="ph2">&lt;see langword="GetHashCode" /&gt;</ph> -Methode der Basisklasse delegieren kann <ph id="ph3">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> Implementierung nur, wenn die abgeleitete Klasse Gleichheit als Verweisgleichheit definiert.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The default implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> for reference types returns a hash code that is equivalent to the one returned by the <ph id="ph2">&lt;see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /&gt;</ph> method.</source>
          <target state="translated">Die standardmäßige Implementierung des <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> Referenzzwecken Typen zurückgibt einen Hashcode, der zurückgegeben wird, indem Sie entspricht der <ph id="ph2">&lt;see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You can override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> for immutable reference types.</source>
          <target state="translated">Sie können außer Kraft setzen <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> für unveränderliche Verweistypen.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In general, for mutable reference types, you should override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> only if:</source>
          <target state="translated">Im Allgemeinen für änderbare Referenztypen, Sie sollten eine Überschreibung <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> nur, wenn:</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You can compute the hash code from fields that are not mutable; or</source>
          <target state="translated">Sie können den Hashcode von Feldern zu berechnen, die nicht veränderbar sind; oder</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</source>
          <target state="translated">Sie können sicherstellen, dass der Hashcode des ein änderbares Objekt nicht ändert, während das Objekt in einer Auflistung enthalten ist, die abhängig von dessen Hashcode.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Otherwise, you might think that the mutable object is lost in the hash table.</source>
          <target state="translated">Andernfalls können Sie vorstellen, dass ein änderbare Objekt in der Hashtabelle verloren gegangen ist.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If you do choose to override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.</source>
          <target state="translated">Wenn Sie sich entschließen, überschreiben <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> für einen änderbaren Referenztyp Ihrer Dokumentation sollte unbedingt verdeutlicht werden, dass Benutzer Ihres Typs Objektwerte nicht ändern sollten, während das Objekt in einer Hashtabelle gespeichert ist.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For value types, <ph id="ph1">&lt;see cref="M:System.ValueType.GetHashCode" /&gt;</ph> provides a default hash code implementation that uses reflection.</source>
          <target state="translated">Bei Werttypen <ph id="ph1">&lt;see cref="M:System.ValueType.GetHashCode" /&gt;</ph> Hash Code stellt eine Standardimplementierung bereit, die Reflektion verwendet.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You should consider overriding it for better performance.</source>
          <target state="translated">Erwägen Sie, ob Sie es für eine bessere Leistung zu überschreiben.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For more information and examples that compute hash codes in a variety of ways, see the Examples section.</source>
          <target state="translated">Weitere Informationen und Beispiele, mit die eine Vielzahl von Möglichkeiten Hashcodes berechnet, finden Sie in Abschnitt "Beispiele".</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash function must have the following properties:</source>
          <target state="translated">Eine Hashfunktion muss die folgenden Eigenschaften aufweisen:</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If two objects compare as equal, the <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> method for each object must return the same value.</source>
          <target state="translated">Wenn zwei Objekte als gleich, vergleichen die <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> Methode für jedes Objekt muss den gleichen Wert zurück.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>However, if two objects do not compare as equal, the <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> methods for the two objects do not have to return different values.</source>
          <target state="translated">Jedoch, wenn die beiden Objekte nicht gleich, Vergleich der <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> Methoden für die beiden Objekte müssen keine unterschiedliche Werte zurückgeben.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's <bpt id="p1">[</bpt>System.Object.Equals<ept id="p1">](xref:System.Object.Equals*)</ept> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> Methode für ein Objekt muss immer zurückgeben, denselben Hashcode, solange es ist keine Änderung an der Zustand des Objekts, das den Rückgabewert, der des Objekts bestimmt <bpt id="p1">[</bpt>System.Object.Equals<ept id="p1">](xref:System.Object.Equals*)</ept> Methode.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.</source>
          <target state="translated">Beachten Sie, dass dies nur während der aktuellen Ausführung einer Anwendung "true" ist und ein anderen Hashcode zurückgegeben werden kann, wenn die Anwendung erneut ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered.</source>
          <target state="translated">Für die optimale Leistung sollte eine Hashfunktion generieren eine gleichmäßige Verteilung für alle Eingaben, einschließlich Eingabe, die stark gruppiert ist.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.</source>
          <target state="translated">Eine Folge ist, dass kleinere Änderungen an den Objektzustand in umfangreichen Änderungen an den resultierenden Hashcode für eine optimale Leistung der Hash-Tabelle führen soll.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Hash functions should be inexpensive to compute.</source>
          <target state="translated">Hashfunktionen sollten kostengünstigen berechnet werden.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> method should not throw exceptions.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> Methode sollte keine Ausnahmen auslösen.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For example, the implementation of the <ph id="ph1">&lt;see cref="M:System.String.GetHashCode" /&gt;</ph> method provided by the <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> class returns identical hash codes for identical string values.</source>
          <target state="translated">Z. B. die Implementierung von der <ph id="ph1">&lt;see cref="M:System.String.GetHashCode" /&gt;</ph> Methode bereitgestellt wird, indem Sie die <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> Klasse gibt identische Hashcodes für identische Zeichenfolgenwerte zurück.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Therefore, two <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects return the same hash code if they represent the same string value.</source>
          <target state="translated">Aus diesem Grund zwei <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> Objekte den gleichen Hashcode zurückgeben, wenn diese denselben Zeichenfolgenwert darstellen.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).</source>
          <target state="translated">Die Methode verwendet außerdem alle Zeichen in der Zeichenfolge verhältnismäßig zufällig verteilte Ausgabe zu generieren, auch wenn die Eingabe in bestimmten Bereichen gruppiert ist (z. B. möglicherweise viele Benutzer Zeichenfolgen, die nur die unteren 128 ASCII-Zeichen, obwohl enthalten ein Zeichenfolge kann die 65.535 Unicode-Zeichen enthalten).</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table.</source>
          <target state="translated">Bietet eine gute Hashfunktion für eine Klasse kann die Leistung dieser Objekte hinzugefügt. eine Hashtabelle spürbar verringern.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation).</source>
          <target state="translated">In einer Hashtabelle mit Schlüsseln, die eine gute Implementierung einer Hashfunktion bereitstellen, wird die Suche nach einem Element Konstanten Zeit (z. B. eine o(1)-Operation).</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of items in the hash table).</source>
          <target state="translated">In einer Hashtabelle durch eine schlechte Implementierung einer Hashfunktion, die Leistung einer Suche hängt die Anzahl der Elemente in der Hashtabelle (z. B. eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist die Anzahl der Elemente in der Hashtabelle).</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:</source>
          <target state="translated">Ein böswilliger Benutzer kann Daten einzugeben, die die Anzahl der Konflikte, vergrößert die deutlich die Leistung der Anwendung beeinträchtigen können, die abhängig von Hashtabellen in den folgenden Situationen:</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When hash functions produce frequent collisions.</source>
          <target state="translated">Wenn Hashfunktionen häufig Konflikte erzeugen.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.</source>
          <target state="translated">Wenn eine große Menge von Objekten in einer Hashtabelle Hashcodes, die gleich sind oder ungefähr gleich untereinander erzeugen.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When users input the data from which the hash code is computed.</source>
          <target state="translated">Wenn Benutzer die Eingabe der Daten aus denen berechnete Hashcode.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Derived classes that override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> must also override <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph> to guarantee that two objects considered equal have the same hash code; otherwise, the <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> type might not work correctly.</source>
          <target state="translated">Abgeleitete Klassen, die außer Kraft setzen <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> müssen auch überschreiben <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph> um sicherzustellen, dass zwei Objekte als gleich betrachtet, denselben Hashcode haben, andernfalls die <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> Typ funktionieren eventuell nicht richtig.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Object.GetType">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the current instance.</source>
          <target state="translated">Ruft den <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> der aktuellen Instanz ab.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Object.GetType">
          <source>The exact runtime type of the current instance.</source>
          <target state="translated">Der genaue Laufzeittyp der aktuellen Instanz.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Because <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> is the base class for all types in the .NET Framework type system, the <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> method can be used to return <ph id="ph3">&lt;xref:System.Type&gt;</ph> objects that represent all .NET Framework types.</source>
          <target state="translated">Da <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> ist die Basisklasse für alle Typen in der .NET Framework-Typsystem, das <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> Methode kann verwendet werden, um zurückgeben <ph id="ph3">&lt;xref:System.Type&gt;</ph> Objekte, die alle .NET Framework-Typen darstellen.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The .NET Framework recognizes the following five categories of types:</source>
          <target state="translated">.NET Framework erkennt die folgenden fünf Typkategorien:</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Classes, which are derived from <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>,</source>
          <target state="translated">Klassen, die abgeleitet sind <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>,</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Value types, which are derived from <ph id="ph1">&lt;xref:System.ValueType?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Werttypen abgeleitet sind <ph id="ph1">&lt;xref:System.ValueType?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Interfaces, which are derived from <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> starting with the .NET Framework 2.0.</source>
          <target state="translated">Schnittstellen, die abgeleitet sind <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> beginnend mit .NET Framework 2.0.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Enumerations, which are derived from <ph id="ph1">&lt;xref:System.Enum?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Enumerationen abgeleitet sind <ph id="ph1">&lt;xref:System.Enum?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Delegates, which are derived from <ph id="ph1">&lt;xref:System.MulticastDelegate?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Delegaten, die abgeleitet sind <ph id="ph1">&lt;xref:System.MulticastDelegate?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>For two objects <ph id="ph1">`x`</ph> and <ph id="ph2">`y`</ph> that have identical runtime types, <ph id="ph3">`Object.ReferenceEquals(x.GetType(),y.GetType())`</ph> returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Für zwei Objekte <ph id="ph1">`x`</ph> und <ph id="ph2">`y`</ph> identische-Runtime-Typen, deren <ph id="ph3">`Object.ReferenceEquals(x.GetType(),y.GetType())`</ph> gibt <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method with the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method to determine whether one numeric value is the same type as two other numeric values.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> Methode mit der <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> Methode, um zu bestimmen, ob eine numerische Wert als zwei numerische Werte desselben Typs ist.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</source>
          <target state="translated">Um zu bestimmen, ob ein Objekt eines bestimmten Typs ist, verwenden Sie Ihre Sprache Typ Vergleich Schlüsselwort oder zu erstellen.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>For example, you can use the <ph id="ph1">`TypeOf…Is`</ph> construct in Visual Basic or the <ph id="ph2">`is`</ph> keyword in C#.</source>
          <target state="translated">Beispielsweise können Sie die <ph id="ph1">`TypeOf…Is`</ph> in Visual Basic erstellen oder die <ph id="ph2">`is`</ph> -Schlüsselwort in c#.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method is inherited by all types that derive from <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> Methode wird von allen Typen, die abgeleitet geerbt <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>This means that, in addition to using your own language's comparison keyword, you can use the <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method to determine the type of a particular object, as the following example shows.</source>
          <target state="translated">Dies bedeutet, dass zusätzlich zur Verwendung Ihrer eigenen Sprache Vergleich-Schlüsselwort, das Sie verwenden können die <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> Methode, um den Typ eines bestimmten Objekts zu bestimmen, wie im folgenden Beispiel gezeigt.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object exposes the metadata associated with the class of the current <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekt macht die Klasse des aktuellen zugeordnete Metadaten <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The following code example demonstrates that <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> returns the runtime type of the current instance.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, dass <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> gibt den Laufzeittyp der aktuellen Instanz zurück.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Object.MemberwiseClone">
          <source>Creates a shallow copy of the current <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">Erstellt eine flache Kopie des aktuellen <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Object.MemberwiseClone">
          <source>A shallow copy of the current <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">Eine flache Kopie des aktuellen <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>The <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> Methode erstellt eine flache Kopie durch Erstellen eines neuen Objekts, und klicken Sie dann die nicht statische Felder des aktuellen Objekts in das neue Objekt kopiert.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>If a field is a value type, a bit-by-bit copy of the field is performed.</source>
          <target state="translated">Wenn ein Feld ein Werttyp ist, erfolgt eine Bit für Bit-Kopie des Felds.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</source>
          <target state="translated">Wenn ein Feld ein Verweistyp ist, wird der Verweis kopiert, aber das referenzierte Objekt ist nicht; das ursprüngliche Objekt und dessen Klon sich daher auf das gleiche Objekt beziehen.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</source>
          <target state="translated">Angenommen Sie, ein Objekt namens X, das auf die Objekte A und B, c References-Objekt Eine flache Kopie von X erstellt neue Objekt X2, das auch Objekte A und b verweist Im Gegensatz dazu eine tiefe Kopie von X erstellt ein neues Objekt X2, die verweist auf die neuen Objekte A2 und B2, die Kopien von A und b B2 verweist wiederum auf das neue Objekt C2, also eine Kopie des c Das Beispiel veranschaulicht den Unterschied zwischen einem flachen und eine tiefe Kopie-Vorgang.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method does not meet your needs.</source>
          <target state="translated">Es gibt zahlreiche Möglichkeiten, einen tiefe Kopie-Vorgang zu implementieren, wenn der flachen Kopie-durch Vorgangs die <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> Methode Ihren Anforderungen nicht erfüllt.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>These include the following:</source>
          <target state="translated">Hierzu gehört Folgendes:</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</source>
          <target state="translated">Rufen Sie einen Klassenkonstruktor des Objekts kopiert werden soll, um ein zweites Objekt mit Eigenschaftswerten, die das erste Objekt entnommen zu erstellen.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>This assumes that the values of an object are entirely defined by its class constructor.</source>
          <target state="translated">Dies setzt voraus, dass die Werte eines Objekts von den Klassenkonstruktor vollständig definiert werden.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Call the <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> Methode, um eine flache Kopie eines Objekts zu erstellen, und weisen Sie ihm anschließend neue Objekte, deren Werte identisch mit der ursprünglichen Objekt auf Eigenschaften oder Felder sind, deren Werte Referenztypen sind.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>The <ph id="ph1">`DeepCopy`</ph> method in the example illustrates this approach.</source>
          <target state="translated">Die <ph id="ph1">`DeepCopy`</ph> -Methode im Beispiel veranschaulicht diese Vorgehensweise.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</source>
          <target state="translated">Serialisiert das Objekt, um umfassende werden kopiert, und klicken Sie dann die serialisierten Daten zu einer anderen Objektvariable wiederherstellen.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Use reflection with recursion to perform the deep copy operation.</source>
          <target state="translated">Mithilfe der Reflektion zum Ausführen des Vorgangs tiefe Kopie mit Rekursion.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>It defines a <ph id="ph1">`ShallowCopy`</ph> method that calls the <ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method to perform a shallow copy operation on a <ph id="ph3">`Person`</ph> object.</source>
          <target state="translated">Definiert eine <ph id="ph1">`ShallowCopy`</ph> Methode, die aufgerufen der <ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> Methode zum eine flache Kopie eines Vorgangs auf ein <ph id="ph3">`Person`</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>It also defines a <ph id="ph1">`DeepCopy`</ph> method that performs a deep copy operation on a <ph id="ph2">`Person`</ph> object.</source>
          <target state="translated">Er definiert außerdem eine <ph id="ph1">`DeepCopy`</ph> -Methode, die eine tiefe Kopie-Operation für wird ein <ph id="ph2">`Person`</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>In this example, the <ph id="ph1">`Person.IdInfo`</ph> property returns an <ph id="ph2">`IdInfo`</ph> object.</source>
          <target state="translated">In diesem Beispiel wird die <ph id="ph1">`Person.IdInfo`</ph> -Eigenschaft gibt ein <ph id="ph2">`IdInfo`</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>As the output from the example shows, when a <ph id="ph1">`Person`</ph> object is cloned by calling the <ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method, the cloned <ph id="ph3">`Person`</ph> object is an independent copy of the original object, except that they share the same <ph id="ph4">`Person.IdInfo`</ph> object reference.</source>
          <target state="translated">Wie die Ausgabe des Beispiels zeigt Wenn ein <ph id="ph1">`Person`</ph> -Objekt geklont wird durch Aufrufen der <ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> -Methode, das die geklonte <ph id="ph3">`Person`</ph> Objekt ist eine unabhängige Kopie des ursprünglichen Objekts, mit dem Unterschied, dass sie dieselbe <ph id="ph4">`Person.IdInfo`</ph> -Objektverweis.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>As a result, modifying the clone's <ph id="ph1">`Person.IdInfo`</ph> property changes the original object's <ph id="ph2">`Person.IdInfo`</ph> property.</source>
          <target state="translated">Daher ändern Sie des Klons <ph id="ph1">`Person.IdInfo`</ph> eigenschaftsänderungen des ursprünglichen Objekts <ph id="ph2">`Person.IdInfo`</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>On the other hand, when a deep copy operation is performed, the cloned <ph id="ph1">`Person`</ph> object, including its <ph id="ph2">`Person.IdInfo`</ph> property, can be modified without affecting the original object.</source>
          <target state="translated">Wenn andererseits, ein tiefe Kopie-Vorgang ausgeführt wird, das die geklonte <ph id="ph1">`Person`</ph> Objekts, einschließlich seiner <ph id="ph2">`Person.IdInfo`</ph> -Eigenschaft, können ohne Auswirkungen auf das ursprüngliche Objekt geändert werden.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>The first object to compare.</source>
          <target state="translated">Das erste zu vergleichende Objekt.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>The second object  to compare.</source>
          <target state="translated">Das zweite zu vergleichende Objekt.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> instances are the same instance.</source>
          <target state="translated">Stellt fest, ob die angegebenen <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>-Instanzen dieselbe Instanz sind.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="objA" /&gt;</ph> is the same instance as <ph id="ph3">&lt;paramref name="objB" /&gt;</ph> or if both are <bpt id="p1">**</bpt>null<ept id="p1">**</ept>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="objA" /&gt;</ph> dieselbe Instanz wie <ph id="ph3">&lt;paramref name="objB" /&gt;</ph> ist oder beide <bpt id="p1">**</bpt>NULL<ept id="p1">**</ept> sind, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method and the equality operator, the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method cannot be overridden.</source>
          <target state="translated">Im Gegensatz zu den <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> -Methode und den Gleichheitsoperator, der <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> Methode kann nicht überschrieben werden.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>Because of this, if you want to test two object references for equality and you are unsure about the implementation of the <ph id="ph1">`Equals`</ph> method, you can call the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">Aus diesem Grund, wenn Sie testen möchten, zwei Objektverweise auf Gleichheit, und Sie zur Implementierung von nicht sicher sind, dass die <ph id="ph1">`Equals`</ph> -Methode, die Sie aufrufen können die <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>However, the return value of the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method may appear to be anomalous in these two scenarios:</source>
          <target state="translated">Allerdings den Rückgabewert der <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> Methode möglicherweise anomale in diesen zwei Szenarien:</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>When comparing value types.</source>
          <target state="translated">Bei Werttypen vergleichen zu können.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>If <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> are value types, they are boxed before they are passed to the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">Wenn <ph id="ph1">`objA`</ph> und <ph id="ph2">`objB`</ph> sind Werttypen, sie verschachtelt sind, vor der Übergabe an die <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>This means that if both <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> represent the same instance of a value type, the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method nevertheless returns <ph id="ph4">`false`</ph>, as the following example shows.</source>
          <target state="translated">Dies bedeutet, dass, wenn beide <ph id="ph1">`objA`</ph> und <ph id="ph2">`objB`</ph> derselben Instanz eines Werttyps darstellen der <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> trotzdem Methodenrückgabe <ph id="ph4">`false`</ph>, wie im folgende Beispiel gezeigt.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>For information on boxing value types, see <bpt id="p1">[</bpt>Boxing and Unboxing<ept id="p1">](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)</ept>.</source>
          <target state="translated">Informationen zu Boxing-Werttypen finden Sie unter <bpt id="p1">[</bpt>Boxing und Unboxing<ept id="p1">](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>When comparing strings.</source>
          <target state="translated">Beim Vergleichen von Zeichenfolgen.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>If <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> are strings, the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method returns <ph id="ph4">`true`</ph> if the string is interned.</source>
          <target state="translated">Wenn <ph id="ph1">`objA`</ph> und <ph id="ph2">`objB`</ph> sind Zeichenfolgen, die <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> -Methode zurückkehrt <ph id="ph4">`true`</ph> , wenn die Zeichenfolge intern gespeichert werden.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>It does not perform a test for value equality.</source>
          <target state="translated">Er führt einen Test keine Wertgleichheit.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>In the following example, <ph id="ph1">`s1`</ph> and <ph id="ph2">`s2`</ph> are equal because they are two instances of a single interned string.</source>
          <target state="translated">Im folgenden Beispiel <ph id="ph1">`s1`</ph> und <ph id="ph2">`s2`</ph> gleich sind, da sie zwei Instanzen von einer einzelnen Zeichenfolge für die im Internpool vorhanden sind.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>However, <ph id="ph1">`s3`</ph> and <ph id="ph2">`s4`</ph> are not equal, because although they are have identical string values, that string is not interned.</source>
          <target state="translated">Allerdings <ph id="ph1">`s3`</ph> und <ph id="ph2">`s4`</ph> ungleich sind, da auch sie werden identische Werte aufweisen, die Zeichenfolge nicht intern gespeichert werden.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>For more information about string interning, see <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zur Internalisierung finden Sie unter <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> to determine if two objects are the same instance.</source>
          <target state="translated">Im folgenden Beispiel wird <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> zu bestimmen, ob zwei Objekte dieselbe Instanz sind.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Object.ToString">
          <source>Returns a string that represents the current object.</source>
          <target state="translated">Gibt eine Zeichenfolge zurück, die das aktuelle Objekt darstellt.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Object.ToString">
          <source>A string that represents the current object.</source>
          <target state="translated">Eine Zeichenfolge, die das aktuelle Objekt darstellt.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> is the major formatting method in the .NET Framework.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> die Hauptversionsnummer, der-Methode in .NET Framework Formatierung.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It converts an object to its string representation so that it is suitable for display.</source>
          <target state="translated">Konvertiert ein Objekt in seine Zeichenfolgendarstellung, damit er für die Anzeige geeignet ist.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>(For information about formatting support in the .NET Framework, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.) Default implementations of the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method return the fully qualified name of the object's type.</source>
          <target state="translated">(Weitere Informationen zur Formatierung-Unterstützung in .NET Framework finden Sie unter <bpt id="p1">[</bpt>Formatierung von Typen<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.) Standardimplementierungen der der <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> Methode zurück, der vollqualifizierte Name, der den Typ des Objekts.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You may have reached this page by following the link from the member list of another type.</source>
          <target state="translated">Haben Sie möglicherweise auf dieser Seite erreicht, indem Sie die folgenden Links aus der Memberliste eines anderen Typs.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>That is because that type does not override <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Liegt darin, dass dieses Typs nicht überschreibt <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Instead, it inherits the functionality of the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Stattdessen erbt es die Funktionalität der <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Types frequently override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to provide a more suitable string representation of a particular type.</source>
          <target state="translated">Typen, die häufig überschreiben die <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> Methode, um ein geeigneter Zeichenfolgendarstellung eines bestimmten Typs bereitzustellen.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Types also frequently overload the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to provide support for format strings or culture-sensitive formatting.</source>
          <target state="translated">Typen auch häufig überladen der <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> Methode, um die Formatzeichenfolgen oder kulturabhängige Formatierung unterstützen.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>In this section:</source>
          <target state="translated">In diesem Abschnitt</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>The default Object.ToString() method<ept id="p1">](#Default)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Die Standard-Object.ToString()-Methode<ept id="p1">](#Default)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Overriding the Object.ToString() method<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Überschreiben der Object.ToString()-Methode<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Overloading the ToString method<ept id="p1">](#Overloading)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Überladen der ToString-Methode<ept id="p1">](#Overloading)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Extending the Object.ToString method<ept id="p1">](#Extending)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Erweitern Sie die Object.ToString-Methode<ept id="p1">](#Extending)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Notes for the Windows Runtime<ept id="p1">](#WinRT)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Hinweise für die Windows-Runtime<ept id="p1">](#WinRT)</ept></target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The default Object.ToString() method</source>
          <target state="translated">Die Standard-Object.ToString()-Methode</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The default implementation of the <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> method returns the fully qualified name of the type of the <ph id="ph2">&lt;xref:System.Object&gt;</ph>, as the following example shows.</source>
          <target state="translated">Die standardmäßige Implementierung des der <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> Methodenrückgabe der vollqualifizierte Name des Typs von der <ph id="ph2">&lt;xref:System.Object&gt;</ph>, wie im folgende Beispiel gezeigt.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Because <ph id="ph1">&lt;xref:System.Object&gt;</ph> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> method.</source>
          <target state="translated">Da <ph id="ph1">&lt;xref:System.Object&gt;</ph> ist die Basisklasse aller Verweistypen in .NET Framework wird dieses Verhalten von Verweistypen, die nicht außer Kraft setzen geerbt die <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example illustrates this.</source>
          <target state="translated">Dies wird anhand des folgenden Beispiels veranschaulicht.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It defines a class named <ph id="ph1">`Object1`</ph> that accepts the default implementation of all <ph id="ph2">&lt;xref:System.Object&gt;</ph> members.</source>
          <target state="translated">Definiert eine Klasse namens <ph id="ph1">`Object1`</ph> , akzeptiert die standardmäßige Implementierung aller <ph id="ph2">&lt;xref:System.Object&gt;</ph> Elemente.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Its <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> method returns the object's fully qualified type name.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> Methodenrückgabe voll qualifizierten Typnamen des Objekts.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overriding the Object.ToString() method</source>
          <target state="translated">Überschreiben der Object.ToString()-Methode</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Types commonly override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to return a string that represents the object instance.</source>
          <target state="translated">Überschreiben Sie die Typen im Allgemeinen die <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> Methode, um eine Zeichenfolge zurückzugeben, die die Objektinstanz darstellt.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For example, the base types such as <ph id="ph1">&lt;xref:System.Char&gt;</ph>, <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, and <ph id="ph3">&lt;xref:System.String&gt;</ph> provide <ph id="ph4">&lt;xref:System.Object.ToString%2A&gt;</ph> implementations that return the string form of the value that the object represents.</source>
          <target state="translated">Beispielsweise, wie z. B. die Basistypen <ph id="ph1">&lt;xref:System.Char&gt;</ph>, <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, und <ph id="ph3">&lt;xref:System.String&gt;</ph> bieten <ph id="ph4">&lt;xref:System.Object.ToString%2A&gt;</ph> Implementierungen, die den Wert der Form einer Zeichenfolge zurückgeben, die das Objekt darstellt.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example defines a class, <ph id="ph1">`Object2`</ph>, that overrides the <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> method to return the type name along with its value.</source>
          <target state="translated">Das folgende Beispiel definiert eine Klasse <ph id="ph1">`Object2`</ph>, überschreibt die <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> Methode, um den Typnamen zusammen mit seinen Wert zurückzugeben.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following table lists the type categories in the .NET Framework and indicates whether or not they override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die folgende Tabelle listet die Kategorien in .NET Framework und gibt an, und zwar unabhängig davon, ob sie überschreiben die <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Type category</source>
          <target state="translated">Typkategorie</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overrides Object.ToString()</source>
          <target state="translated">Overrides Object.ToString()</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Behavior</source>
          <target state="translated">Verhalten</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Class</source>
          <target state="translated">Klasse</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">n/v</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">n/v</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Structure</source>
          <target state="translated">Struktur</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Yes (<ph id="ph1">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph>)</source>
          <target state="translated">Ja (<ph id="ph1">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph>)</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Same as Object.ToString()</source>
          <target state="translated">Identisch mit Object.ToString()</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Enumeration</source>
          <target state="translated">Enumeration</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Yes (<ph id="ph1">&lt;xref:System.Enum.ToString?displayProperty=nameWithType&gt;</ph>)</source>
          <target state="translated">Ja (<ph id="ph1">&lt;xref:System.Enum.ToString?displayProperty=nameWithType&gt;</ph>)</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The member name</source>
          <target state="translated">Der Elementname</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Interface</source>
          <target state="translated">Interface</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">n/v</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Delegate</source>
          <target state="translated">delegate</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">n/v</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>See the Notes to Inheritors section for additional information on overriding <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>.</source>
          <target state="translated">Finden Sie unter Hinweise zu erben-Abschnitt, um weitere Informationen zum Überschreiben <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overloading the ToString method</source>
          <target state="translated">Überladen der ToString-Methode</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>In addition to overriding the parameterless <ph id="ph1">&lt;xref:System.Object.ToString?displayProperty=nameWithType&gt;</ph> method, many types overload the <ph id="ph2">`ToString`</ph> method to provide versions of the method that accept parameters.</source>
          <target state="translated">Zusätzlich zum Überschreiben der parameterlosen <ph id="ph1">&lt;xref:System.Object.ToString?displayProperty=nameWithType&gt;</ph> Methode, die viele Typen Überladen der <ph id="ph2">`ToString`</ph> Methode, um Versionen der Methode bereitzustellen, die Parameter akzeptieren.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</source>
          <target state="translated">In den meisten Fällen wird dadurch auch Variablen und kulturabhängige Formatierung unterstützen.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example overloads the <ph id="ph1">`ToString`</ph> method to return a result string that includes the value of various fields of an <ph id="ph2">`Automobile`</ph> class.</source>
          <target state="translated">Das folgende Beispiel Überladungen der <ph id="ph1">`ToString`</ph> Methode, um eine Ergebniszeichenfolge zurückzugeben, die den Wert der verschiedenen Felder des enthält eine <ph id="ph2">`Automobile`</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</source>
          <target state="translated">Es werden vier Formatzeichenfolgen definiert: G, den Modellnamen und Jahr zurück. D, die den Modellnamen, Jahr und Anzahl von Türen zurückgibt; C, die den Modellnamen, den Jahr und die Anzahl der Zylinder zurückgibt; und ein, die eine Zeichenfolge mit allen vier Feldwerte zurückgibt.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example calls the overloaded <ph id="ph1">&lt;xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method to display culture-sensitive formatting of a currency value.</source>
          <target state="translated">Das folgende Beispiel ruft den überladenen <ph id="ph1">&lt;xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> Methode, um kulturabhängige Formatierung, der einen Währungswert anzuzeigen.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For more information on format strings and culture-sensitive formatting, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu Formatzeichenfolgen und kulturabhängige Formatierung, finden Sie unter <bpt id="p1">[</bpt>Formatierung von Typen<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For the format strings supported by numeric values, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">Die Formatzeichenfolgen, die von numerischen Werten unterstützt, finden Sie unter <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> und <bpt id="p2">[</bpt>benutzerdefinierte Zahlenformatzeichenfolgen<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For the format strings supported by date and time values, see <bpt id="p1">[</bpt>Standard Date and Time Format Strings<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Date and Time Format Strings<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.</source>
          <target state="translated">Die Formatzeichenfolgen, die von Datums-und Uhrzeitwerte unterstützt, finden Sie unter <bpt id="p1">[</bpt>Standardformatbezeichner für Datum und Uhrzeit-Formatzeichenfolgen<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> und <bpt id="p2">[</bpt>benutzerdefinierte Datums- und Uhrzeit-Formatzeichenfolgen<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Extending the Object.ToString method</source>
          <target state="translated">Erweitern Sie die Object.ToString-Methode</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Because a type inherits the default <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method, you may find its behavior undesirable and want to change it.</source>
          <target state="translated">Da den Standardwert erbt <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> -Methode, können Sie finden Sie dessen Verhalten unerwünscht und ändern möchten.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>This is particularly true of arrays and collection classes.</source>
          <target state="translated">Dies gilt insbesondere dann von Arrays und Auflistungsklassen.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>While you may expect the <ph id="ph1">`ToString`</ph> method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</source>
          <target state="translated">Während Sie erwarten, dass möglicherweise die <ph id="ph1">`ToString`</ph> Methode ein Array- oder Auflistungselement Klasse zum Anzeigen der Werte von Membern, zeigt er stattdessen der vollqualifizierte Typname, wie im folgenden Beispiel gezeigt.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You have several options to produce the result string that you'd like.</source>
          <target state="translated">Sie haben mehrere Optionen für die resultierende Zeichenfolge zu erzeugen, die Sie möchten.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the type is an array, a collection object, or an object that implements the <ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interfaces, you can enumerate its elements by using the <ph id="ph3">`foreach`</ph> statement in C# or the <ph id="ph4">`For Each...Next`</ph> construct in Visual Basic.</source>
          <target state="translated">Wenn der Typ ist ein Array, ein Auflistungsobjekt oder ein Objekt, implementiert die <ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph> oder <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> Schnittstellen, Sie können die Elemente auflisten, mit der <ph id="ph3">`foreach`</ph> -Anweisung in c# oder der <ph id="ph4">`For Each...Next`</ph> in Visual Basic erstellen.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the class is not <ph id="ph1">`sealed`</ph> (in C#) or <ph id="ph2">`NotInheritable`</ph> (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method you want to customize.</source>
          <target state="translated">Wenn die Klasse nicht <ph id="ph1">`sealed`</ph> (in c#) oder <ph id="ph2">`NotInheritable`</ph> (in Visual Basic) entwickeln Sie eine Wrapperklasse, die von der Basisklasse, deren erbt <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> Methode, die Sie anpassen möchten.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>At a minimum, this requires that you do the following:</source>
          <target state="translated">Mindestens erfordert dies, dass Sie die folgenden Schritte aus:</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Implement any necessary constructors.</source>
          <target state="translated">Implementieren Sie keine Konstruktoren erforderlich.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Derived classes do not inherit their base class constructors.</source>
          <target state="translated">Abgeleitete Klassen erben nicht die Konstruktoren ihrer Basisklasse.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to return the result string that you'd like.</source>
          <target state="translated">Überschreiben Sie die <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> Methode, um die Ergebniszeichenfolge zurückzugeben, die Sie möchten.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example defines a wrapper class for the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class.</source>
          <target state="translated">Das folgende Beispiel definiert eine Wrapperklasse für die <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to display the value of each method of the collection rather than the fully qualified type name.</source>
          <target state="translated">Es überschreibt die <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> Methode, um den Wert der einzelnen Methoden der Auflistung und nicht den vollqualifizierten Typnamen anzuzeigen.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Develop an <bpt id="p1">[</bpt>extension method<ept id="p1">](~/docs/standard/design-guidelines/extension-methods.md)</ept> that returns the result string that you want.</source>
          <target state="translated">Entwickeln einer <bpt id="p1">[</bpt>Erweiterungsmethode<ept id="p1">](~/docs/standard/design-guidelines/extension-methods.md)</ept> , die die Ergebniszeichenfolge die gewünschten zurückgibt.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Note that you can't override the default <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named <ph id="ph2">`ToString`</ph> that is called in place of the original type's <ph id="ph3">`ToString`</ph> method.</source>
          <target state="translated">Beachten Sie, dass Sie die Standardeinstellung außer Kraft setzen können nicht <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> Methode auf diese Weise (d. h. der Erweiterungsklasse (in c#) oder des Moduls (in Visual Basic) sind keine parameterlose Methode, die mit dem Namen <ph id="ph2">`ToString`</ph> , die anstelle des ursprünglichen Typs aufgerufen wird <ph id="ph3">`ToString`</ph> Methode .</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You'll have to provide some other name for your parameterless <ph id="ph1">`ToString`</ph> replacement.</source>
          <target state="translated">Sie müssen einen anderen Namen für Ihre parameterlosen bieten <ph id="ph1">`ToString`</ph> Ersatz.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example defines two methods that extend the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class: a parameterless <ph id="ph2">`ToString2`</ph> method, and a <ph id="ph3">`ToString`</ph> method with a <ph id="ph4">&lt;xref:System.String&gt;</ph> parameter that represents a format string.</source>
          <target state="translated">Das folgende Beispiel definiert zwei Methoden, mit denen erweitert die <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> Klasse: eine parameterlose <ph id="ph2">`ToString2`</ph> -Methode, und ein <ph id="ph3">`ToString`</ph> Methode mit einer <ph id="ph4">&lt;xref:System.String&gt;</ph> Parameter, der eine Formatzeichenfolge darstellt.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">Hinweise für die <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>When you call the <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> method on a class in the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen der <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> Methode einer Klasse in der <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, es stellt das Standardverhalten für Klassen, die nicht außer Kraft setzen <ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">Dies ist Teil der Unterstützung von .NET Framework für die <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (siehe <bpt id="p1">[</bpt>.NET Framework Unterstützung für Windows Store-Apps und Windows-Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Classes in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id="ph2">&lt;xref:System.Object&gt;</ph>, and don’t always implement a <ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>.</source>
          <target state="translated">Klassen in der <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> erben nicht <ph id="ph2">&lt;xref:System.Object&gt;</ph>, und implementieren nicht immer eine <ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>However, they always appear to have <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</source>
          <target state="translated">Allerdings immer erscheinen haben <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, und <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> Methoden, wenn Sie in c# oder Visual Basic-Code werden verwendet, und die .NET Framework ein Standardverhalten für diese Methoden bietet.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>, the common language runtime will use <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> on a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object before falling back to the default implementation of <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>, verwendet die common Language Runtime <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> auf eine <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> Objekt vor dem Fallback auf die standardmäßige Implementierung des <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> Klassen, die in c# oder Visual Basic geschrieben sind, können außer Kraft setzen die <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> and the IStringable Interface</source>
          <target state="translated">Die <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> und der IStringable-Schnittstelle</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Starting with <ph id="ph1">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> includes an <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> interface whose single method, <bpt id="p2">[</bpt>IStringable.ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>, provides basic formatting support comparable to that provided by <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Beginnend mit <ph id="ph1">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> enthält ein <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> Schnittstelle, deren einzige Methode, <bpt id="p2">[</bpt>IStringable.ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>, eine grundlegende formatierungsunterstützung vergleichbar mit der bietet von bereitgestellten <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>To prevent ambiguity, you should not implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> on managed types.</source>
          <target state="translated">Sie sollten nicht implementieren, um Mehrdeutigkeit zu vermeiden, <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> auf verwalteten Typen.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>.</source>
          <target state="translated">Wenn verwaltete Objekte aufgerufen werden, vom systemeigenen Code oder durch Code, die in Sprachen wie JavaScript oder C++ geschriebene c++ / CX können sie anscheinend implementieren <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The common language runtime will automatically route calls from <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> to <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> in the event <bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> is not implemented on the managed object.</source>
          <target state="translated">Die common Language Runtime leitet die Aufrufe von automatisch <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> auf <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> im Ereignis <bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> nicht auf das verwaltete Objekt implementiert wird.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Because the common language runtime auto-implements <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> for all managed types in <ph id="ph1">[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]</ph> apps, we recommend that you do not provide your own <bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> implementation.</source>
          <target state="translated">Da die common Language Runtime automatisch-implementiert <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> für alle verwalteten Typen in <ph id="ph1">[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]</ph> apps, es wird empfohlen, dass Sie keine eigene haben <bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> Implementierung.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Implementing <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> may result in unintended behavior when calling <ph id="ph1">`ToString`</ph> from the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, C++/CX, or JavaScript.</source>
          <target state="translated">Implementieren von <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> führen möglicherweise zu unerwartetem Verhalten, beim Aufrufen <ph id="ph1">`ToString`</ph> aus der <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, C + c++ / CX oder JavaScript.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If you do choose to implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> in a public managed type that is exported in a <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> component, the following restrictions apply:</source>
          <target state="translated">Wenn Sie sich entschließen, implementieren <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> in einem öffentlich verwalteten Typ, der im exportiert wird eine <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> Komponente, gelten die folgenden Einschränkungen:</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You can define the <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> interface only in a "class implements" relationship, such as</source>
          <target state="translated">Sie können definieren, die <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> -Schnittstelle nur in einer "class Implements"-Beziehung, z. B.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>in C#, or</source>
          <target state="translated">in C# oder</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>in Visual Basic.</source>
          <target state="translated">in Visual Basic.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You cannot implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> on an interface.</source>
          <target state="translated">Sie können nicht implementieren <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> in einer Schnittstelle.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You cannot declare a parameter to be of type <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>.</source>
          <target state="translated">Einen Parameter vom Typ kann nicht deklariert werden <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> cannot be the return type of a method, property, or field.</source>
          <target state="translated"><bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> kann nicht der Rückgabetyp einer Methode, eine Eigenschaft oder ein Feld sein.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You cannot hide your <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> implementation from base classes by using a method definition such as the following:</source>
          <target state="translated">Sie können nicht ausgeblendet werden Ihre <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> Implementierung von Basisklassen mithilfe eine Methodendefinition wie die folgenden:</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Instead, the <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> implementation must always override the base class implementation.</source>
          <target state="translated">Stattdessen die <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> Implementierung muss die basisklassenimplementierung immer überschreiben.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You can hide a <ph id="ph1">`ToString`</ph> implementation only by invoking it on a strongly typed class instance.</source>
          <target state="translated">Sie können eine <ph id="ph1">`ToString`</ph>-Implementierung nur ausblenden, indem Sie sie auf einer stark typisierten Klasseninstanz aufrufen.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Note that under a variety of conditions, calls from native code to a managed type that implements <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> or hides its <bpt id="p2">[</bpt>ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> implementation can produce unexpected behavior.</source>
          <target state="translated">Beachten Sie, die unter bestimmten Bedingungen Aufrufe von systemeigenem Code zu einem verwalteten Typ, der implementiert <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> oder blendet Sie aus der <bpt id="p2">[</bpt>ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> Implementierung kann zu unerwartetem Verhalten führen.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>When you implement your own types, you should override the <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method to return values that are meaningful for those types.</source>
          <target state="translated">Wenn Sie Ihre eigenen Typen implementieren, sollten Sie überschreiben die <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> Methode, um Werte zurückzugeben, die für diese Typen von Bedeutung sind.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Derived classes that require more control over formatting than <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> provides can implement the <ph id="ph2">&lt;see cref="T:System.IFormattable" /&gt;</ph> interface.</source>
          <target state="translated">Abgeleitete Klassen, die mehr Kontrolle über die Formatierung als erfordern <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> bietet können implementieren die <ph id="ph2">&lt;see cref="T:System.IFormattable" /&gt;</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Its <ph id="ph1">&lt;see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /&gt;</ph> method enables you to define format strings that control formatting and to use an <ph id="ph2">&lt;see cref="T:System.IFormatProvider" /&gt;</ph> object that can provide for culture-specific formatting.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /&gt;</ph> Methode ermöglicht es Ihnen, Formatzeichenfolgen zu definieren, Steuern der Formatierung, und verwendet eine <ph id="ph2">&lt;see cref="T:System.IFormatProvider" /&gt;</ph> Objekt, das für kulturabhängige Formatierung bereitstellen kann.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overrides of the <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method should follow these guidelines:</source>
          <target state="translated">Der überschreibt die <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> Methode sollte die folgenden Richtlinien:</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The returned string should be friendly and readable by humans.</source>
          <target state="translated">Die zurückgegebene Zeichenfolge muss benutzerfreundliche und von Menschen lesbar.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The returned string should uniquely identify the value of the object instance.</source>
          <target state="translated">Die zurückgegebene Zeichenfolge muss den Wert der Objektinstanz eindeutig identifizieren.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The returned string should be as short as possible so that it is suitable for display by a debugger.</source>
          <target state="translated">Die zurückgegebene Zeichenfolge sollte so kurz wie möglich sein, damit er für die Anzeige von einem Debugger geeignet ist.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Your <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> override should not return <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> or a null string.</source>
          <target state="translated">Ihre <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> keine Außerkraftsetzung zurückgeben soll <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> oder eine null-Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Your <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> override should not throw an exception.</source>
          <target state="translated">Ihre <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> Außerkraftsetzung sollte keine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <ph id="ph1">&lt;see cref="T:System.IFormattable" /&gt;</ph> interface.</source>
          <target state="translated">Wenn die angegebene Zeichenfolgendarstellung einer Instanz kulturabhängig ist oder auf verschiedene Weise formatiert werden kann, implementieren die <ph id="ph1">&lt;see cref="T:System.IFormattable" /&gt;</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the returned string includes sensitive information, you should first demand an appropriate permission.</source>
          <target state="translated">Wenn die zurückgegebene Zeichenfolge vertrauliche Informationen enthält, sollten Sie zuerst über die entsprechende Berechtigung anfordern.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.</source>
          <target state="translated">Wenn die Anforderung erfolgreich ist, können Sie die vertrauliche Informationen zurückgegeben. Andernfalls sollten Sie eine Zeichenfolge zurückgeben, die die vertrauliche Informationen ausschließt.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Your <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> override should have no observable side effects to avoid complications in debugging.</source>
          <target state="translated">Ihre <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> überschreiben müssen keine Observable Nebeneffekte Komplikationen beim Debuggen zu vermeiden.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For example, a call to the <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method should not change the value of instance fields.</source>
          <target state="translated">Z. B. einen Aufruf der <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> Methode sollte nicht den Wert der Instanzfelder ändern.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If your type implements a parsing method (or <ph id="ph1">&lt;see langword="Parse" /&gt;</ph> or <ph id="ph2">&lt;see langword="TryParse" /&gt;</ph> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <ph id="ph3">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method can be converted to an object instance.</source>
          <target state="translated">Wenn der Typ eine Analysemethode implementiert (oder <ph id="ph1">&lt;see langword="Parse" /&gt;</ph> oder <ph id="ph2">&lt;see langword="TryParse" /&gt;</ph> -Methode, einen Konstruktor oder eine andere statische Methode, die eine Instanz des Typs aus einer Zeichenfolge instanziiert), Sie sollten sicherstellen, dass die zurückgegebene Zeichenfolge den <ph id="ph3">&lt;see cref="M:System.Object.ToString" /&gt;</ph> Methode kann Folgendes sein Konvertiert eine Objektinstanz.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>