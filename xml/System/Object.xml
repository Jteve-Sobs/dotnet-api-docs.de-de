<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cfdf20f498b9446fa1ef100b01c36257161f0c6c" /><Meta Name="ms.sourcegitcommit" Value="3efce15f3841385ee3ba24bd71ff0c0cf9a47815" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/03/2019" /><Meta Name="ms.locfileid" Value="58875072" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Unterstützt sämtliche Klassen in der Hierarchie von .NET Framework-Klassen und stellt abgeleiteten Klassen Low-Level-Dienste zur Verfügung. Dies ist die allen Klassen von .NET Framework übergeordnete Basisklasse und stellt den Stamm der Typhierarchie dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprachen erfordern in der Regel keine Klasse zur Deklaration der Vererbung von <xref:System.Object> , da die Vererbung implizit ist.  
  
 Da alle Klassen in .NET Framework abgeleitet sind <xref:System.Object>, jede Methode, die definiert, der <xref:System.Object> Klasse steht in alle Objekte im System. Abgeleitete Klassen, und führen Sie einige dieser Methoden, einschließlich überschreiben:  
  
-   <xref:System.Object.Equals%2A> -Unterstützt Vergleiche zwischen Objekten.  
  
-   <xref:System.Object.Finalize%2A> -Führt Bereinigungsvorgänge durch, bevor ein Objekt automatisch freigegeben wird.  
  
-   <xref:System.Object.GetHashCode%2A> -Generiert eine Zahl, die entsprechend dem Wert des Objekts, um die Verwendung einer Hashtabelle zu unterstützen.  
  
-   <xref:System.Object.ToString%2A> -Stellt eine lesbare Zeichenfolge, die eine Instanz der Klasse beschreibt.  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Wenn Sie eine Klasse, z. B. eine Auflistung, entwerfen, die alle Arten von Objekten behandelt werden müssen, erstellen Sie-Klasse, Elemente, die Instanzen akzeptieren die <xref:System.Object> Klasse. Der Prozess von Boxing und unboxing eines Typs trägt jedoch Kosten der Leistung. Wenn Sie wissen, dass die neue Klasse häufig bestimmte Werttypen behandelt können eine der beiden Taktiken Sie die Kosten von Boxing zu minimieren.  
  
-   Erstellen Sie eine allgemeine Methode, die akzeptiert eine <xref:System.Object> Typ und einen Satz von typspezifische methodenüberladungen, die jeden Typ Sie erwarten, die Klasse akzeptieren dass, um häufig behandeln. Wenn eine typspezifische-Methode vorhanden, der den Parametertyp des aufrufenden akzeptiert ist, keine Boxing-Konvertierung tritt ein, und die typspezifischen Methode wird aufgerufen. Ist keine Methodenargument, das dem aufrufenden Parametertyp übereinstimmt, wird der Parameter geschachtelt und die allgemeine Methode wird aufgerufen.  
  
-   Entwerfen Sie den Typ und ihre Member zum Verwenden von Generika. Die common Language Runtime erstellt einen geschlossenen generischen Typ, wenn Sie eine Instanz der Klasse erstellen, und geben Sie ein generisches Typargument. Die generische Methode ist typenspezifisch und ohne boxing von des aufrufenden Parameters aufgerufen werden kann.  
  
 Obwohl es manchmal erforderlich, um allgemeine Klassen entwickeln, die akzeptiert und zurückgegeben ist <xref:System.Object> Typen können Sie die Leistung verbessern, durch die Bereitstellung einer typspezifische-Klasse, um eine häufig verwendete Typ verarbeitet werden. Z. B. bereitstellen eine Klasse, die spezifisch für festlegen und Abrufen von booleschen Werten ist, werden die Kosten von Boxing und unboxing booleschen Werten entfällt.  
  
   
  
## Examples  
 Das folgende Beispiel definiert einen Point-Typ abgeleitet der <xref:System.Object> -Klasse und überschreibt Sie viele virtuelle Methoden von der <xref:System.Object> Klasse. Darüber hinaus gezeigt, wie viele der statischen aufrufen und Instanzenmethoden von der <xref:System.Object> Klasse.  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind threadsicher. Instanzmember sind nicht unbedingt threadsicher sein.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Object" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird von Konstruktoren in abgeleiteten Klassen aufgerufen, aber es kann auch verwendet, direkt zu eine Instanz von erstellen die <xref:System.Object> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stellt fest, ob zwei Objektinstanzen gleich sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, das mit dem aktuellen Objekt verglichen werden soll.</param>
        <summary>Bestimmt, ob das angegebene Objekt mit dem aktuellen Objekt identisch ist.</summary>
        <returns><see langword="true" /> wenn das angegebene Objekt und das aktuelle Objekt gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Vergleichs zwischen der aktuellen Instanz und die `obj` Parameter, hängt davon ab, ob die aktuelle Instanz ein Verweistyp oder ein Werttyp ist.  
  
-   Wenn die aktuelle Instanz einen Verweistyp handelt, ist die <xref:System.Object.Equals%28System.Object%29> Methode Tests hinsichtlich ihrer Verweisgleichheit und einem Aufruf von der <xref:System.Object.Equals%28System.Object%29> Methode ist gleichwertig mit einem Aufruf von der <xref:System.Object.ReferenceEquals%2A> Methode. Verweisgleichheit ist gegeben, dass der Objektvariablen, die verglichen werden auf das gleiche Objekt verweisen. Das folgende Beispiel veranschaulicht das Ergebnis von einem solchen Vergleich. Definiert eine `Person` -Klasse, die ein Verweistyp ist, und ruft die `Person` Klassenkonstruktor, um zwei neue instanziieren `Person` Objekte `person1a` und `person2`, die den gleichen Wert aufweisen. Er weist auch `person1a` auf einem anderen Objektvariablen `person1b`. Wie die Ausgabe des Beispiels zeigt `person1a` und `person1b` gleich sind, da sie das gleiche Objekt verweisen. Allerdings `person1a` und `person2` ungleich sind, obwohl sie den gleichen Wert haben.  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   Wenn die aktuelle Instanz eines Werttyps, ist die <xref:System.Object.Equals%28System.Object%29> Methode Wertgleichheit. Wertgleichheit bedeutet Folgendes:  
  
    -   Die beiden Objekte sind vom gleichen Typ. Wie im folgenden Beispiel wird gezeigt, eine <xref:System.Byte> -Objekt, das den Wert 12 hat entspricht keinem <xref:System.Int32> -Objekt, das den Wert 12, aufweist, da die beiden Objekte unterschiedliche Run-Time-Typen aufweisen.  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   Die Werte der öffentlichen und privaten Felder der beiden Objekte sind gleich. Das folgende Beispiel testet Wertgleichheit. Definiert eine `Person` -Struktur, die ein Werttyp ist, und ruft die `Person` Klassenkonstruktor, um zwei neue instanziieren `Person` Objekte `person1` und `person2`, die den gleichen Wert aufweisen. Die Ausgabe aus dem Beispiel zeigt auch die zwei Objektvariablen auf verschiedene Objekte verweisen, `person1` und `person2` sind gleich, da sie den gleichen Wert für die Private aufweisen `personName` Feld.  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 Da die <xref:System.Object> Klasse ist die Basisklasse für alle Typen in .NET Framework, die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Methode bietet die Standard-gleichheitsprüfung für alle anderen Datentypen. Typen jedoch häufig überschreiben die <xref:System.Object.Equals%2A> Methode zum Implementieren der Wertgleichheit. Weitere Informationen finden Sie unter die Anmerkungen zu dieser Version für Aufrufer und Hinweise für Vererber Abschnitte.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Anmerkungen zu dieser von der [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Beim Aufrufen der <xref:System.Object.Equals%28System.Object%29> methodenüberladung für eine Klasse in der [!INCLUDE[wrt](~/includes/wrt-md.md)], es ist das Standardverhalten für Klassen, die nicht außer Kraft setzen <xref:System.Object.Equals%28System.Object%29>. Dies ist Teil der Unterstützung von .NET Framework für die [!INCLUDE[wrt](~/includes/wrt-md.md)] (finden Sie unter [.NET Framework Unterstützung für Windows Store-Apps und Windows-Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Klassen in der [!INCLUDE[wrt](~/includes/wrt-md.md)] nicht erben <xref:System.Object>, und derzeit nicht implementiert eine <xref:System.Object.Equals%28System.Object%29> Methode. Allerdings haben sie anscheinend <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, und <xref:System.Object.GetHashCode%2A> Methoden ein, wenn Sie diese in Ihrem C#- oder Visual Basic-Code verwenden und .NET Framework das Standardverhalten für diese Methoden ist.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] Klassen, die geschrieben werden, in C# oder Visual Basic können außer Kraft setzen der <xref:System.Object.Equals%28System.Object%29> -methodenüberladung.  
  
## <a name="notes-for-callers"></a>Hinweise für Aufrufer  
 Abgeleitete Klassen überschreiben, die häufig den <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Methode zum Implementieren der Wertgleichheit. Darüber hinaus bieten Typen häufig auch eine zusätzliche stark typisierte Überladung für die `Equals` Methode, in der Regel durch die Implementierung der <xref:System.IEquatable%601> Schnittstelle. Beim Aufrufen der `Equals` Methode zum Testen auf Gleichheit, sollten Sie wissen, ob die aktuelle Instanz überschreibt <xref:System.Object.Equals%2A?displayProperty=nameWithType> und zu verstehen, wie ein bestimmter Aufruf einer `Equals` Methode wird aufgelöst. Andernfalls, Sie werden einen Test durchführen, Gleichheit, die von Ihnen gewünschte unterscheidet, und die Methode gibt möglicherweise einen unerwarteten Wert zurück.  
  
 Dies wird im folgenden Beispiel veranschaulicht. Es instanziiert drei <xref:System.Text.StringBuilder> Objekte mit identischer Zeichenfolgen und anschließend vier Aufrufe zu `Equals` Methoden. Der erste Methodenaufruf gibt `true`, und die verbleibenden drei Rückgabe `false`.  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 Im ersten Fall, den stark typisierten <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> methodenüberladung der Wertgleichheit getestet wird, wird aufgerufen. Da die beiden Zeichenfolgen zugewiesen <xref:System.Text.StringBuilder> Objekte gleich sind, gibt die Methode zurück `true`. Allerdings <xref:System.Text.StringBuilder> überschreibt nicht die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>. Aus diesem Grund bei der <xref:System.Text.StringBuilder> Objekt umgewandelt wird ein <xref:System.Object>, wenn eine <xref:System.Text.StringBuilder> Instanz einer Variablen des Typs zugewiesen <xref:System.Object>, und wann die <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> -Methode übergeben zwei <xref:System.Text.StringBuilder> Objekte, die Standardeinstellung <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>Methode wird aufgerufen. Da <xref:System.Text.StringBuilder> ein Verweistyp ist, dies entspricht dem Übergeben der beiden <xref:System.Text.StringBuilder> Objekte die <xref:System.Object.ReferenceEquals%2A> Methode. Obwohl alle drei <xref:System.Text.StringBuilder> Objekte enthalten identische Zeichenfolgen, die sie auf drei unterschiedliche Objekte verweisen. Daher diese drei Methodenaufrufe return `false`.  
  
 Sie können das aktuelle Objekt in ein anderes Objekt hinsichtlich ihrer Verweisgleichheit vergleichen, durch den Aufruf der <xref:System.Object.ReferenceEquals%2A> Methode. In Visual Basic können Sie auch die `is` Schlüsselwort (z. B. `If Me Is otherObject Then ...`).  
  
## <a name="notes-for-inheritors"></a>Hinweise für Vererber  
 Wenn Sie einen eigenen Typ definieren, erbt dieses Typs Funktionen, die definiert die `Equals` Methode des Basistyps. Die folgende Tabelle enthält die standardmäßige Implementierung der `Equals` -Methode für die Hauptkategorien der Typen in .NET Framework.  
  
|Typkategorie|Vom definierten Gleichheit|Kommentare|  
|-------------------|-------------------------|--------------|  
|Direkt von abgeleiteten Klasse <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Verweisgleichheit; entspricht dem Aufruf von <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.|  
|Struktur|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|Wertgleichheit; direkte Byte-pro-Byte-Vergleich oder Feld-nach-Feld-Vergleich mithilfe von Reflektion.|  
|Enumeration|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|Werte müssen den gleichen Enumerationstyp und den gleichen zugrunde liegenden Wert.|  
|delegate|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|Delegaten müssen den gleichen Typ mit identischen Aufruflisten.|  
|Interface|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Verweisgleichheit.|  
  
 Für einen Werttyp handelt, sollten Sie immer überschreiben <xref:System.Object.Equals%2A>, da prüft auf Gleichheit, die auf Reflektion beruhen auf eine schlechte Leistung bieten. Sie können auch die standardmäßige Implementierung des überschreiben <xref:System.Object.Equals%2A> für Verweistypen statt auf Verweisgleichheit Wertgleichheit prüfen und die genaue Bedeutung der Wertgleichheit definieren. Solche Implementierungen von <xref:System.Object.Equals%2A> zurückgeben `true` , wenn die beiden Objekte den gleichen Wert verfügen, auch wenn sie sich nicht um dieselbe Instanz sind. Der Implementierung des Typs entscheidet, was den Wert eines Objekts ist, aber es ist in der Regel einige oder alle der in Instanzvariablen gespeicherten Daten der des Objekts. Z. B. den Wert der ein <xref:System.String> Objekt basiert darauf, dass die Zeichen der Zeichenfolge die <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> methodenüberschreibungen der <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> -Methode zur Rückgabe `true` für eine beliebige Zeichenfolge zwei Instanzen, die dieselben Zeichen in der gleichen Reihenfolge enthalten.  
  
 Das folgende Beispiel veranschaulicht das Überschreiben der <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Methode auf Wertgleichheit prüfen. Es überschreibt die <xref:System.Object.Equals%2A> -Methode für die `Person` Klasse. Wenn `Person` akzeptiert die basisklassenimplementierung von Gleichheit, zwei `Person` Objekte wäre nur gleich, wenn sie ein einzelnes Objekt, auf die verwiesen wird. In diesem Fall jedoch zwei `Person` Objekte sind gleich, wenn sie den gleichen Wert für die `Person.Id` Eigenschaft.  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 Neben dem Außerkraftsetzen von <xref:System.Object.Equals%2A>, können Sie implementieren die <xref:System.IEquatable%601> Schnittstelle, um eine stark typisierte Test auf Gleichheit bereitzustellen.  
  
 Die folgenden Anweisungen müssen für alle Implementierungen von "true" werden die <xref:System.Object.Equals%28System.Object%29> Methode. In der Liste der `x`, `y`, und `z` darstellen von Objektverweisen, die nicht **null**.  
  
-   `x.Equals(x)` Gibt `true`, außer in Fällen, bei denen Gleitkomma-Datentypen. Finden Sie unter [ISO/IEC/IEEE 60559:2011, Technologie – Mikroprozessor Systeme der Gleitkommaarithmetik Informationen](https://www.iso.org/standard/57469.html).  
  
-   `x.Equals(y)` Gibt den gleichen Wert wie `y.Equals(x)`.  
  
-   `x.Equals(y)` Gibt `true` sowohl `x` und `y` sind `NaN`.  
  
-   Wenn `(x.Equals(y) && y.Equals(z))` gibt `true`, klicken Sie dann `x.Equals(z)` gibt `true`.  
  
-   Aufeinander folgende Aufrufe von `x.Equals(y)` zurück, der gleiche Wert, solange die Objekte verweist `x` und `y` werden nicht geändert.  
  
-   `x.Equals(null)` `false` wird zurückgegeben.  
  
 Implementierungen von <xref:System.Object.Equals%2A> darf keine Ausnahmen auslösen, sollten sie immer einen Wert zurück. Z. B. wenn `obj` ist `null`, <xref:System.Object.Equals%2A> Methode zurückgeben soll `false` statt einer <xref:System.ArgumentNullException>.  
  
 Beachten Sie Folgendes, wenn überschreiben <xref:System.Object.Equals%28System.Object%29>:  
  
-   Typen implementiert <xref:System.IComparable> müssen überschreiben <xref:System.Object.Equals%28System.Object%29>.  
  
-   Die Überschreibung Typen <xref:System.Object.Equals%28System.Object%29> müssen auch überschreiben <xref:System.Object.GetHashCode%2A>ist, andernfalls Hashtabellen funktionieren möglicherweise nicht korrekt.  
  
-   Sie sollten erwägen, implementieren die <xref:System.IEquatable%601> -Schnittstelle zur Unterstützung stark typisierte prüft auf Gleichheit. Ihre <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> Implementierung sollten Ergebnisse zurück, die konsistent mit sind <xref:System.Object.Equals%2A>.  
  
-   Wenn Ihre bevorzugte Programmiersprache unterstützt die Überladung von Operatoren und Überladen Sie den Gleichheitsoperator für einen bestimmten Typ, müssen Sie auch überschreiben die <xref:System.Object.Equals%28System.Object%29> Methode, um das gleiche Ergebnis wie der Gleichheitsoperator zurückzugeben. Dies trägt dazu bei, Klassenbibliothekscode, die verwendet <xref:System.Object.Equals%2A> (z. B. <xref:System.Collections.ArrayList> und <xref:System.Collections.Hashtable>) verhält sich in einer Weise, mit der Funktionsweise entspricht der Equality-Operator wird vom Anwendungscode verwendet.  
  
### <a name="guidelines-for-reference-types"></a>Richtlinien für Referenztypen  
 Die folgenden Richtlinien gelten für das Überschreiben <xref:System.Object.Equals%28System.Object%29> für einen Verweistyp handelt:  
  
-   Ziehen Sie das Überschreiben <xref:System.Object.Equals%2A> Wenn die Semantik des Typs basiert auf der Tatsache, dass der Typ einige Werte darstellt.  
  
-   Die meisten Referenztypen müssen nicht den Equality-Operator überladen, auch wenn sie außer Kraft setzen <xref:System.Object.Equals%2A>. Wenn Sie einen Verweistyp implementieren, der über Wertsemantik, z. B. eine komplexe Zahl-Typ verfügen soll müssen Sie jedoch den Gleichheitsoperator überschreiben.  
  
-   Sie sollten nicht überschreiben <xref:System.Object.Equals%2A> auf einen änderbaren Referenztyp. Dies ist daran, dass überschrieben <xref:System.Object.Equals%2A> erfordert, dass Sie auch überschreiben, die <xref:System.Object.GetHashCode%2A> -Methode, wie im vorherigen Abschnitt erläutert. Dies bedeutet, dass der Hashcode einer Instanz von einen änderbaren Referenztyp während seiner Lebensdauer ändern kann, die das Objekt, das verloren gehen, die in einer Hashtabelle führen kann.  
  
### <a name="guidelines-for-value-types"></a>Richtlinien für Werttypen  
 Die folgenden Richtlinien gelten für das Überschreiben <xref:System.Object.Equals%28System.Object%29> für einen Werttyp darstellt:  
  
-   Wenn Sie einen Werttyp definieren, die eine oder mehrere Felder enthält, deren Werte Verweistypen sind, sollten Sie überschreiben <xref:System.Object.Equals%28System.Object%29>. Die <xref:System.Object.Equals%28System.Object%29> -Implementierung von <xref:System.ValueType> führt Sie einen Byte-pro-Byte-Vergleich aus, für, deren Werttypen Felder sind alle Werttypen, aber er verwendet Reflektion, einen Feld-nach-Feld-Vergleich von Werttypen durchgeführt, deren Felder Verweistypen sind.  
  
-   Wenn Sie außer Kraft setzen <xref:System.Object.Equals%2A> und Ihre bevorzugte Programmiersprache unterstützt überladen werden, müssen Sie den Equality-Operator überladen.  
  
-   Implementieren Sie die <xref:System.IEquatable%601> Schnittstelle. Aufrufen von stark typisierten <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> Methode verhindert das Konvertieren der `obj` Argument.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine `Point` -Klasse, überschreibt die <xref:System.Object.Equals%2A> Methode zum Bereitstellen der Wertgleichheit, und ein `Point3D` abgeleitete ist `Point`. Da `Point` überschreibt <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> zum Prüfen auf Wertgleichheit, die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Methode wird nicht aufgerufen. Allerdings `Point3D.Equals` Aufrufe `Point.Equals` da `Point` implementiert <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in einer Weise, die Wertgleichheit bereitstellt.  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 Die `Point.Equals` Methode überprüft, um sicherzustellen, dass die `obj` Argument ist kein **null** und eine Instanz des gleichen Typs wie dieses Objekt verweist. Wenn bei entweder ein Fehler auftritt, wird der Methodenrückgabe `false`.  
  
 Die `Point.Equals` Methodenaufrufe der <xref:System.Object.GetType%2A> Methode, um zu bestimmen, ob die Runtime-Typen der beiden Objekte identisch sind. Wenn die Methode eine Überprüfung des Formulars verwendet `obj is Point` in c# oder `TryCast(obj, Point)` in Visual Basic die Überprüfung zurückgeben würde `true` in Fällen, in denen `obj` ist eine Instanz einer abgeleiteten Klasse der `Point`, auch wenn `obj` und der aktuelle Instanz sind nicht vom gleichen Typ zur Laufzeit. Wenn Sie überprüft haben, dass beide Objekte desselben Typs, die Methode Umwandlungen sind `obj` eingeben `Point` und das Ergebnis des Vergleichs die Instanzfelder der beiden Objekte zurückgegeben.  
  
 In `Point3D.Equals`, die geerbte `Point.Equals` -Methode, die überschreibt <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, wird aufgerufen, bevor alles abgeschlossen ist. Da `Point3D` ist eine versiegelte Klasse (`NotInheritable` in Visual Basic), eine Überprüfung in der Form `obj is Point` in c# oder `TryCast(obj, Point)` in Visual Basic ist ausreichend, um sicherzustellen, dass `obj` ist eine `Point3D` Objekt. Ist dies ein `Point3D` Objekt, der Umwandlung in einen `Point` -Objekt und übergeben Sie die basisklassenimplementierung von <xref:System.Object.Equals%2A>. Nur, wenn die geerbte `Point.Equals` Methodenrückgabe `true` ist die Methode vergleichen die `z` Instanzfelder, die in der abgeleiteten Klasse eingeführt.  
  
 Das folgende Beispiel definiert eine `Rectangle` Klasse, die ein Rechteck als zwei intern implementiert `Point` Objekte. Die `Rectangle` -Klasse auch überschreibt <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Wertgleichheit bereit.  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 Einige Sprachen wie c# und Visual Basic unterstützen das überladen. Wenn ein Typ, den Equality-Operator überlädt, muss er auch überschreiben die <xref:System.Object.Equals%28System.Object%29> Methode, um die gleiche Funktionalität bereitzustellen. Dies erfolgt in der Regel durch Schreiben der <xref:System.Object.Equals%28System.Object%29> Methode hinsichtlich des überladenen Gleichheitsoperators, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 Da `Complex` ein Werttyp ist, es kann nicht abgeleitet werden.  Aus diesem Grund die Außerkraftsetzung, mit <xref:System.Object.Equals%28System.Object%29> Methodenaufruf müssen nicht <xref:System.Object.GetType%2A> um zu bestimmen, die genaue Laufzeittyp der einzelnen Objekte, kann aber stattdessen verwenden die `is` -Operator in c# oder der `TypeOf` -Operator in Visual Basic zum Überprüfen des Typs, der die `obj` Parameter.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Das erste zu vergleichende Objekt.</param>
        <param name="objB">Das zweite zu vergleichende Objekt.</param>
        <summary>Stellt fest, ob die angegebenen Objektinstanzen als gleich betrachtet werden.</summary>
        <returns><see langword="true" /> wenn die Objekte als gleich betrachtet werden, andernfalls <see langword="false" />. Wenn sowohl <paramref name="objA" />, als auch <paramref name="objB" /> **NULL** sind, gibt diese Methode <see langword="true" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die statische <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> angibt, ob zwei Objekte, `objA` und `objB`, gleich sind. Außerdem können Sie Objekte zu testen, deren Wert **null** hinsichtlich ihrer Gleichheit. Es vergleicht `objA` und `objB` Gleichheit wie folgt:  
  
-   Es bestimmt, ob die beiden Objekte auf den gleichen Objektverweis darstellen. Wenn dies der Fall ist, wird der Methodenrückgabe `true`. Dieser Test entspricht dem Aufrufen der <xref:System.Object.ReferenceEquals%2A> Methode. Darüber hinaus, wenn beide `objA` und `objB` sind **null**, gibt die Methode zurück `true`.  
  
-   Bestimmt, ob entweder `objA` oder `objB` ist **null**. Wenn also zurückgegeben `false`.  
  
-   Wenn die beiden Objekte nicht den gleichen Objektverweis darstellen und keine ist **null**, ruft `objA`.`Equals` (`objB`) und das Ergebnis zurückgibt. Dies bedeutet, dass bei `objA` überschreibt die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Methode, diese Außerkraftsetzung wird aufgerufen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> Methode, und vergleicht ihn mit der <xref:System.Object.ReferenceEquals%2A> Methode.  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einem Objekt Gelegenheit zu dem Versuch, Ressourcen freizugeben und andere Bereinigungen durchzuführen, bevor es von der Garbage Collection freigegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Object.Finalize%2A> Methode wird verwendet, um Bereinigungsvorgänge für nicht verwaltete Ressourcen, die vom aktuellen Objekt gehalten werden, bevor das Objekt zerstört wird. Die Methode ist geschützt und daher nur über diese Klasse oder durch eine abgeleitete Klasse zugegriffen werden.  
  
 In diesem Abschnitt  
  
-   [Funktionsweise der Finalisierung](#How)  
  
-   [Hinweise für Implementierer](#Notes)  
  
-   [Die SafeHandle-Alternative](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>Funktionsweise der Finalisierung  
 Die <xref:System.Object> Klasse stellt keine Implementierung für die <xref:System.Object.Finalize%2A> -Methode, und der Garbage Collector von abgeleitete Typen nicht markiert <xref:System.Object> auf einen Abschluss warten, wenn sie außer Kraft setzen der <xref:System.Object.Finalize%2A> Methode.  
  
 Wenn ein Typ überschreibt die <xref:System.Object.Finalize%2A> -Methode der Garbage Collector Fügt einen Eintrag für jede Instanz des Typs internen Struktur einer Finalisierungswarteschlange. Die Finalisierungswarteschlange enthält Einträge für alle Objekte im verwalteten Heap, deren Finalisierungscode ausgeführt werden muss, bevor der Garbage Collector deren Speicher freigeben kann. Anschließend ruft der Garbage Collector die <xref:System.Object.Finalize%2A> Methode automatisch in den folgenden Situationen:  
  
-   Nachdem der Garbage Collector ermittelt hat, dass ein Objekt kann nicht zugegriffen werden, es sei denn, das Objekt durch einen Aufruf, von der Finalisierung ausgenommen wurden die <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> Methode.  
  
-   **In .NET Framework nur**, während des Herunterfahrens einer Anwendungsdomäne, es sei denn, das Objekt von der Finalisierung ausgeschlossen ist. Während des Herunterfahrens sind auch Objekte, die immer noch zugänglich sind abgeschlossen.  
  
 <xref:System.Object.Finalize%2A> automatisch nur einmal aufgerufen wird für eine bestimmte Instanz, es sei denn, das Objekt erneut registriert wird, wie z. B. mit einem Mechanismus <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> und <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> Methode nicht anschließend aufgerufen wurde.  
  
 <xref:System.Object.Finalize%2A> Vorgänge weisen die folgenden Einschränkungen:  
  
-   Die genaue Zeit, wann der Finalizer ausgeführt wird, ist nicht definiert. Um deterministische Freigabe von Ressourcen sicherzustellen, dass für Instanzen von Ihrer Klasse implementieren eine `Close` Methode, oder geben Sie einen <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> Implementierung.  
  
-   Der Finalizer von zwei Objekten sind Ausführung nicht garantiert in einer bestimmten Reihenfolge, selbst wenn ein Objekt in die andere verweist. D. h. wenn Objekt A verfügt über einen Verweis auf das Objekt B, und beide verfügen über Finalizer, Objekt B möglicherweise bereits beendet wurde zu Beginn der Finalizer des Objekts ein.  
  
-   Der Thread, der auf dem der Finalizer ausgeführt wird, ist nicht angegeben.  
  
 Die <xref:System.Object.Finalize%2A> Methode möglicherweise nicht bis zum Abschluss ausgeführt, oder möglicherweise nicht alle in den folgenden außergewöhnlichen Situationen ausgeführt:  
  
-   Wenn eine andere Finalizer auf unbestimmte Zeit blockiert (wird auf eine unendliche Schleife, versucht, eine Sperre kann nie zu erhalten und so weiter). Da die Runtime versucht, die Finalizer vollständig ausgeführt werden, möglicherweise andere Finalizer nicht wenn ein Finalizer blockiert auf unbestimmte Zeit aufgerufen werden.  
  
-   Wenn der Prozess beendet wird, ohne dass die Laufzeit eine Gelegenheit zum Bereinigen von. In diesem Fall ist die erste Benachrichtigung von der Runtime für Beendigung des Prozesses eine DLL_PROZESS_DETACH-Benachrichtigung.  
  
 Die Laufzeit weiterhin Threadobjekte während des Herunterfahrens, nur, während die Anzahl der finalisierbare Objekte weiter verringern.  
  
 Wenn <xref:System.Object.Finalize%2A> oder eine Überschreibung von <xref:System.Object.Finalize%2A> löst eine Ausnahme aus, und die Runtime nicht von einer Anwendung, die die Standardrichtlinie überschreibt gehostet wird, die Runtime beendet den Prozess und keine aktiven `try` / `finally` Blöcke oder Finalizer werden ausgeführt. Dadurch wird die Prozessintegrität sichergestellt, wenn der Finalizer nicht freigeben kann, oder Löschen von Ressourcen.  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Überschreiben der Finalize-Methode 
 Sie sollten überschreiben <xref:System.Object.Finalize%2A> für eine Klasse, die nicht verwaltete Ressourcen wie Dateihandles oder Verbindungen mit der Datenbank, die freigegeben werden müssen, wenn das verwaltete Objekt, das sie verwendet, während der Garbagecollection verworfen wird verwendet. Sie sollten nicht implementieren, eine <xref:System.Object.Finalize%2A> -Methode für verwaltete Objekte auf, da der Garbage Collector verwaltete Ressourcen automatisch freigibt.  
  
> [!IMPORTANT]
>  Wenn eine <xref:System.Runtime.InteropServices.SafeHandle> Objekt steht, die nicht verwaltete Ressource einschließt, die empfohlene Alternative ist das Implementieren des Dispose-Musters mit einem sicheren Handle und überschreiben Sie nicht <xref:System.Object.Finalize%2A>. Weitere Informationen finden Sie unter [die SafeHandle-Alternative](#SafeHandle) Abschnitt.  
  
 Die <xref:System.Object.Finalize%2A?displayProperty=nameWithType> Methode führt keine Aktion standardmäßig, jedoch sollten Sie überschreiben <xref:System.Object.Finalize%2A> nur dann, wenn erforderlich, und nur auf nicht verwaltete Ressourcen freizugeben. Freigeben von Arbeitsspeicher eher zu viel länger, wenn ein Vorgang für die Beendigung ausgeführt wird, da er mindestens zwei Garbage Collections erforderlich ist. Darüber hinaus sollten Sie überschreiben die <xref:System.Object.Finalize%2A> -Methode für den Verweis nur Typen. Die common Language Runtime finalisiert nur Verweistypen. Finalizer für Werttypen werden dabei ignoriert.  

Im Rahmen der <xref:System.Object.Finalize%2A?displayProperty=nameWithType> Methode `protected`. Sie sollten diesen eingeschränkten Gültigkeitsbereich beibehalten, wenn Sie die Methode in der Klasse überschreiben. Durch aufbewahren einer <xref:System.Object.Finalize%2A> -Methode geschützt ist, können Benutzer der Anwendung Aufrufen eines Objekts <xref:System.Object.Finalize%2A> -Methode direkt.
  
 Jede Implementierung von <xref:System.Object.Finalize%2A> in einem abgeleiteten Typ muss den Basistyp-Implementierung von Aufrufen <xref:System.Object.Finalize%2A>. Dies ist der einzige Fall, bei denen Code aufrufen, darf <xref:System.Object.Finalize%2A>. Ein Objekt des <xref:System.Object.Finalize%2A> Methode darf keine Methode für alle Objekte, die von der Basisklasse aufrufen. Der Grund hierfür ist, dass das aufrufende Objekt möglicherweise zur gleichen Zeit an die Garbage Collection übergeben wird wie die anderen aufgerufenen Objekte, z. B. wenn eine Common Language Runtime beendet wird. 
  
> [!NOTE]
>  Der C#-Compiler lässt nicht zu überschreiben, die <xref:System.Object.Finalize%2A> Methode. Stattdessen Sie einen Finalizer bereitstellen, durch die Implementierung einer [Destruktor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) für die Klasse. Ein C#-Destruktor ruft automatisch den Destruktor der Basisklasse.  
>   
>  Visual C++ stellt auch eine eigene Syntax bereit, für die Implementierung der <xref:System.Object.Finalize%2A> Methode. Weitere Informationen finden Sie im Abschnitt "Destruktoren und Finalizer" [Vorgehensweise: Definieren und Verarbeiten von Klassen und Strukturen (C++ / CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).  
  
 Da der Garbagecollection nicht deterministisch ist, wissen Sie nicht genau, wann der Garbage Collector Beendigung führt. Um Ressourcen freizugeben sofort, Sie können auch zum Implementieren der [dispose-Muster](~/docs/standard/garbage-collection/implementing-dispose.md) und <xref:System.IDisposable> Schnittstelle. Die <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> Implementierung aufgerufen werden kann, durch die Benutzer Ihrer Klasse, die nicht verwaltete Ressourcen freizugeben, und können Sie die <xref:System.Object.Finalize%2A> Methode, um nicht verwaltete Ressourcen freizugeben, die <xref:System.IDisposable.Dispose%2A> Methode wird nicht aufgerufen.  
  
 <xref:System.Object.Finalize%2A> dauert nahezu jede Aktion, z. B. kann zugänglich ein-Objekt (das das Objekt wieder zugänglich gemacht werden,) aus, nachdem es während der Garbagecollection bereinigt wurden. Allerdings kann das Objekt nur einmal wieder zugänglich gemacht werden; <xref:System.Object.Finalize%2A> kann nicht während der Garbagecollection wieder zugänglich gemachte Objekte aufgerufen werden. Es gibt eine Aktion, die Ihre Implementierung von <xref:System.Object.Finalize%2A> nie dauert: sollten sie nie eine Ausnahme auslösen. Bei Aufruf von Methoden ausgelösten Ausnahmen aus der <xref:System.Object.Finalize%2A> Methode werden nicht behandelt, durch die <xref:System.Object.Finalize%2A> -Methode, die Laufzeit geht davon aus, die die <xref:System.Object.Finalize%2A> Methode zurückgegeben, und rufen Sie weiterhin die <xref:System.Object.Finalize%2A> Methoden anderer Objekte. 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>Die SafeHandle-Alternative  
 Zuverlässige Finalizer ist oft schwierig, da Sie keine Annahmen über den Zustand Ihrer Anwendung vornehmen können, und Systemausnahmen wie z. B. nicht behandelte <xref:System.OutOfMemoryException> und <xref:System.StackOverflowException> den Finalizer zu beenden. Anstatt einen Finalizer für die Klasse zum Freigeben von nicht verwalteter Ressourcen zu implementieren, können Sie ein Objekt, das von abgeleitet ist die <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> Klasse, um die nicht verwalteten Ressourcen zu umschließen, und klicken Sie dann das Dispose-Muster ohne einen Finalizer zu implementieren. .NET Framework bietet die folgenden Klassen in der <xref:Microsoft.Win32?displayProperty=nameWithType> Namespace, der von abgeleitet werden <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> ist eine Wrapperklasse für ein Dateihandle.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> ist eine Wrapperklasse für Handles der Datei mit zugewiesenem Speicher.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> ist eine Wrapperklasse für ein Zeiger auf einen nicht verwalteten Speicherblock.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, und <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> Wrapperklassen für kryptografische verarbeitet werden.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> ist eine Wrapperklasse für Pipehandles.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> ist eine Wrapperklasse für ein Handle für einen Registrierungsschlüssel an.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> ist eine Wrapperklasse für ein Wait-Handle.  
  
 Im folgenden Beispiel wird die [dispose-Muster](~/docs/standard/garbage-collection/implementing-dispose.md) mit SafeHandles anstelle von der <xref:System.Object.Finalize%2A> Methode. Definiert eine `FileAssociation` -Klasse, die Informationen in der Registrierung über die Anwendung einschließt, die Dateien mit einer bestimmten Dateierweiterung behandelt. Die beiden Registrierungsschlüssel Handles als `out` Parameter nach Windows ["RegOpenKeyEx"](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) an Funktionsaufrufe übergeben werden die <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> Konstruktor. Der Typ der geschützte `Dispose` -Methode ruft dann die `SafeRegistryHandle.Dispose` Methode, um diese zwei Handles freizugeben.  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird überprüft, ob die <xref:System.Object.Finalize%2A> Methode wird aufgerufen, wenn ein Objekt, das überschreibt <xref:System.Object.Finalize%2A> zerstört wird. Beachten Sie, dass in einer produktionsanwendung die <xref:System.Object.Finalize%2A> Methode zum Freigeben von nicht verwalteter Ressourcen frei, die das Objekt überschrieben werden. Beachten Sie, dass der C#-Beispiel wird einen Destruktor anstelle von bietet die <xref:System.Object.Finalize%2A> Methode.  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 Ein weiteres Beispiel, das überschreibt die <xref:System.Object.Finalize%2A> -Methode finden Sie unter den <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fungiert als Standardhashfunktion.</summary>
        <returns>Ein Hashcode für das aktuelle Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Hashcode ist ein numerischer Wert, der zum Einfügen und identifizieren ein Objekt in einer Auflistung hashbasierten wie z. B. die <xref:System.Collections.Generic.Dictionary%602> -Klasse, die <xref:System.Collections.Hashtable> Klasse oder von abgeleiteten Typs der <xref:System.Collections.DictionaryBase> Klasse. Die <xref:System.Object.GetHashCode%2A> Methode enthält dieser Hashcode für Algorithmen, die schnelle Überprüfungen Objektgleichheit benötigen.  
  
> [!NOTE]
>  Informationen zur Verwendung von Hashcodes in Hashtabellen und einige zusätzliche Code Hashalgorithmen, finden Sie unter den [Hashfunktion](https://en.wikipedia.org/wiki/Hash_function) Eintrag in Wikipedia.  
  
 Zwei Objekte gleich return Hashcodes, die gleich sind. Das Gegenteil ist jedoch nicht "true": gleich Hashcodes implizieren keine Objektgleichheit, da verschiedene (ungleich) Objekte identische Hashcodes verfügen können. Darüber hinaus ist .NET Framework nicht die standardmäßige Implementierung des garantiert die <xref:System.Object.GetHashCode%2A> -Methode, und der Wert, der diese Methode gibt unterscheiden zwischen .NET Framework-Versionen und Plattformen wie 32-Bit- und 64-Bit-Plattformen. Aus diesen Gründen verwenden Sie nicht die Standardimplementierung dieser Methode als eine eindeutige Objekt-ID für hashing zu. Führen Sie die beiden aus diesem:  
  
-   Sie sollten nicht davon ausgehen, dass gleich Hashcodes Objektgleichheit implizieren.  
  
-   Sie sollten nie beibehalten oder einen Hashcode außerhalb der Anwendungsdomäne, in der es erstellt wurde, verwenden, da das gleiche Objekt über Anwendungsdomänen, Prozessen und Plattformen hash kann.  
  
> [!WARNING]
>  Ein Hashcode ist vorgesehen, für das effiziente Einfügen und Suche in Auflistungen, die auf eine Hash-Tabelle basieren. Ein Hashcode ist kein permanente Wert. Aus diesem Grund:  
>   
> -   Serialisieren Sie Hashwerte für Code zu und speichern Sie sie in Datenbanken nicht.  
> -   Verwenden Sie nicht den Hashcode als Schlüssel an, um ein Objekt über eine schlüsselgebundene Sammlung abzurufen.  
> -   Hashcodes werden nicht über Anwendungsdomänen oder Prozessen gesendet werden. In einigen Fällen können der Hashcodes pro Domäne pro Prozess oder pro Anwendung berechnet werden.  
> -   Verwenden Sie den Hash nicht anstelle eines Werts von einer kryptografischen Hashfunktion zurückgegeben wird, wenn Sie einen kryptographisch starken Hashwert benötigen. Für kryptografische Hashes, verwenden Sie eine von abgeleitete Klasse die <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> oder <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> Klasse.  
> -   Testen Sie nicht auf Gleichheit Hashcodes zu bestimmen, ob zwei Objekte gleich sind. (Ungleich Objekte können identische Hashcodes haben.) Um auf Gleichheit zu testen, rufen Sie die <xref:System.Object.ReferenceEquals%2A> oder <xref:System.Object.Equals%2A> Methode.  
  
 Die <xref:System.Object.GetHashCode%2A> Methode kann von einem abgeleiteten Typ überschrieben werden. Wenn <xref:System.Object.GetHashCode%2A> wird nicht überschrieben, Hashcodes für Verweistypen berechnet werden, durch den Aufruf der <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> -Methode der Basisklasse, die berechnet einen Hashcode basierend auf ein Objekt in der Referenz; Weitere Informationen, finden Sie unter <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>. Das heißt, zwei Objekte auf dem die <xref:System.Object.ReferenceEquals%2A> Methodenrückgabe `true` haben identische Hashcodes. Wenn Sie Werttypen nicht außer Kraft setzen <xref:System.Object.GetHashCode%2A>, <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> Methode der Basisklasse verwendet Reflektion, um den Hashcode anhand der Werte der Felder des Typs zu berechnen. Mit anderen Worten, müssen die Typen mit Werten, deren Felder gleiche Werte haben, gleich Hashcodes. Weitere Informationen zum Überschreiben der <xref:System.Object.GetHashCode%2A>, finden Sie im Abschnitt "Hinweise zur Vererbung".  
  
> [!WARNING]
>  Wenn Sie außer Kraft setzen der <xref:System.Object.GetHashCode%2A> -Methode, Sie sollten auch überschreiben <xref:System.Object.Equals%2A>, und umgekehrt. Wenn die überschriebene <xref:System.Object.Equals%2A> Methodenrückgabe `true` beim sind zwei Objekte hinsichtlich ihrer Gleichheit, die überschriebene testen <xref:System.Object.GetHashCode%2A> Methode muss den gleichen Wert für die beiden Objekte zurückgeben.  
  
 Wenn ein Objekt, das in einer Hashtabelle als Schlüssel verwendet wird, keine geeignete Implementierung von bietet <xref:System.Object.GetHashCode%2A>, Sie können einen Hashcode-Standardanbieter angeben, durch Angabe einer <xref:System.Collections.IEqualityComparer> Implementierung, die eine der Überladungen der der <xref:System.Collections.Hashtable> Klassenkonstruktor.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Anmerkungen zu dieser von der [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Beim Aufrufen der <xref:System.Object.GetHashCode%2A> Methode einer Klasse in der [!INCLUDE[wrt](~/includes/wrt-md.md)], es ist das Standardverhalten für Klassen, die nicht außer Kraft setzen <xref:System.Object.GetHashCode%2A>. Dies ist Teil der Unterstützung von .NET Framework für die [!INCLUDE[wrt](~/includes/wrt-md.md)] (finden Sie unter [.NET Framework Unterstützung für Windows Store-Apps und Windows-Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Klassen in der [!INCLUDE[wrt](~/includes/wrt-md.md)] nicht erben <xref:System.Object>, und derzeit nicht implementiert eine <xref:System.Object.GetHashCode%2A>. Allerdings haben sie anscheinend <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, und <xref:System.Object.GetHashCode%2A> Methoden ein, wenn Sie diese in Ihrem C#- oder Visual Basic-Code verwenden und .NET Framework das Standardverhalten für diese Methoden ist.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] Klassen, die geschrieben werden, in C# oder Visual Basic können außer Kraft setzen der <xref:System.Object.GetHashCode%2A> Methode.  
  
   
  
## Examples  
 Eine der einfachsten Möglichkeiten, um einen Hashcode für einen numerischen Wert zu berechnen, die den gleichen oder einen kleineren Bereich als hat die <xref:System.Int32> Typ ist, einfach diesen Wert zurückgeben. Das folgende Beispiel zeigt eine solche Implementierung für eine `Number` Struktur.  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 In vielen Fällen hat einen Typ mehrere Datenfelder, die beim Generieren des Hashcodes teilnehmen kann. Eine Möglichkeit, einen Hashcode zu generieren, kombinieren diese Felder mit wird ein `XOR (eXclusive OR)` -Operation, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 Das vorherige Beispiel gibt den gleichen Hashcode für (n1, n2) und (n2, n1), und um weitere Konflikte als wünschenswert sind, generieren kann. Eine Reihe von Lösungen sind verfügbar, sodass Hashcodes in diesen Fällen nicht identisch sind. Eine besteht darin, den Hashcode des Zurückgeben einer `Tuple` -Objekt, das die Reihenfolge der einzelnen Felder entspricht. Das folgende Beispiel zeigt eine mögliche Implementierung, die verwendet die <xref:System.Tuple%602> Klasse. Beachten Sie jedoch, die den Leistungsaufwand von Instanziieren einer `Tuple` Objekt kann erhebliche Auswirkungen auf die gesamtleistung einer Anwendung, die große Anzahl von Objekten in Hashtabellen speichert.  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 Eine zweite alternative Lösung umfasst die Gewichtung der Hashcodes für die einzelnen durch die Links-Umstellung der Hashcodes von aufeinander folgenden Feldern von zwei oder mehr Bits. Optimal, anstatt verworfen wird, verschoben nach Bit 31 Bits umschließen soll, anstatt verworfen werden. Da von der Left Shift-Operatoren in c# und Visual Basic Bits verworfen werden, dies ist erforderlich, erstellen eine linke UMSCHALT-Wrap-Methode wie folgt:  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 Im folgenden Beispiel wird dann diese UMSCHALT-Wrap-Methode berechnet den Hashcode der `Point` Struktur, die in den vorherigen Beispielen verwendet.  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Eine Hashfunktion wird verwendet, um eine Zahl (Hashcode) schnell zu generieren, die den Wert eines Objekts entspricht. Hash-Funktionen sind für jeden Typ in der Regel spezifisch und Eindeutigkeit, müssen mindestens eines der Instanzfelder als Eingabe verwenden. Hashcodes sollten nicht mit den Werten von statischen Feldern berechnet werden.  
  
Für die abgeleitete Klassen von <see cref="T:System.Object" />, <see langword="GetHashCode" /> Delegatmethode können auf die Basisklasse <see cref="M:System.Object.GetHashCode" /> Implementierung nur dann, wenn die abgeleitete Klasse auf Gleichheit als Verweisgleichheit definiert. Die standardmäßige Implementierung des <see cref="M:System.Object.GetHashCode" /> zu Referenzzwecken Typen zurückgibt einen Hashcode, der zurückgegeben werden, indem Sie entspricht der <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> Methode. Sie können außer Kraft setzen <see cref="M:System.Object.GetHashCode" /> für unveränderliche Verweistypen. Im Allgemeinen für änderbare Referenztypen, Sie sollten eine Überschreibung <see cref="M:System.Object.GetHashCode" /> nur, wenn: 
– Sie können den Hashcode aus Feldern berechnen, die nicht änderbar sind; oder 
– Sie können sicherstellen, dass es sich bei der Hashcode des ein änderbares Objekt nicht geändert wird, während das Objekt in einer Auflistung enthalten ist, die dessen Hashcode verwendet.  
  
Andernfalls könnte man denken, dass die änderbare Objekt in der Hashtabelle verloren geht. Wenn Sie außer Kraft setzen möchten, führen Sie <see cref="M:System.Object.GetHashCode" /> für einen änderbaren Referenztyp, der Dokumentation sollte es machen, klar, dass Benutzer des Typs Objektwerte nicht ändern sollten, während das Objekt in einer Hashtabelle gespeichert ist.  
  
Bei Werttypen <see cref="M:System.ValueType.GetHashCode" /> Hash-Code stellt eine Standardimplementierung bereit, der Reflektion verwendet. Sie sollten erwägen, überschreiben sie für eine bessere Leistung.  
  
 <block subset="none" type="note"><para>  
 Weitere Informationen und Beispiele, die Hashcodes in einer Vielzahl von Möglichkeiten zu berechnen, finden Sie unter dem Abschnitt "Beispiele".  
  
</para></block>  
  
 Eine Hashfunktion muss die folgenden Eigenschaften verfügen: 
– Wenn zwei Objekte als gleich verglichen werden soll. die <see cref="M:System.Object.GetHashCode" /> Methode für jedes Objekt muss den gleichen Wert zurückgeben. Jedoch, wenn zwei Objekte nicht als gleich verglichen werden die <see cref="M:System.Object.GetHashCode" /> Methoden für die beiden Objekte keine unterschiedliche Werte zurückgeben.  
  
– Die <see cref="M:System.Object.GetHashCode" /> -Methode für ein Objekt muss immer zurückgeben, die gleichen hash-Code so lange keine Änderung des Objektzustands, der den Rückgabewert des Objekts bestimmt [System.Object.Equals](xref:System.Object.Equals*) Methode. Beachten Sie, dass es sich bei "true" nur für die aktuelle Ausführung einer Anwendung und ein anderen Hash-Code zurückgegeben werden kann, wenn die Anwendung erneut ausgeführt wird.  
  
– Für die optimale Leistung sollte eine Hash-Funktion generieren eine gleichmäßige Verteilung für alle Eingaben, einschließlich Eingabe, die stark gruppiert ist. Ein Folge ist, dass kleinere Änderungen an den Objektstatus zu große Änderungen an der resultierende Hashcode für eine optimale Leistung der Hash-Tabelle führen soll.  
  
-Hashfunktionen sollte wenig Aufwand zu berechnen.  
  
– Die <see cref="M:System.Object.GetHashCode" /> Methode sollte keine Ausnahmen auslösen.  
  
Z. B. die Implementierung von der <see cref="M:System.String.GetHashCode" /> Methode bereitgestellt wird, durch die <see cref="T:System.String" /> -Klasse gibt identische Hashcodes für identische Zeichenfolgenwerte zurück. Aus diesem Grund zwei <see cref="T:System.String" /> Objekte den gleichen Hashcode zurückgeben, wenn sie den gleichen Zeichenfolgenwert darstellt. Die Methode verwendet außerdem alle Zeichen in der Zeichenfolge um verhältnismäßig zufällig verteilte Ausgabe zu generieren, selbst wenn die Eingabe in bestimmten Bereichen gruppiert ist (z. B. möglicherweise viele Benutzer Zeichenfolgen, die nur die unteren 128 ASCII-Zeichen, obwohl enthalten ein Zeichenfolge kann die 65.535 Unicode-Zeichen enthalten).  
  
Bereitstellen einer guten Hashfunktion für eine Klasse kann sich erheblich auf die Leistung des Hinzufügens von diesen Objekten in eine Hashtabelle beeinträchtigen. In einer Hashtabelle mit Schlüsseln, die einer guten einer Hashfunktion Implementierung, dauert sucht nach einem Element Konstanten Zeit (z. B. eine o(1)-Operation) aus. In einer Hashtabelle mit einer schlechten Implementierung einer Hashfunktion, die Leistung einer Suche hängt die Anzahl der Elemente in der Hashtabelle (z. B. eine O (`n`)-Vorgang, in denen `n` ist die Anzahl der Elemente in der Hashtabelle). Ein böswilliger Benutzer kann Daten einzugeben, die die Anzahl der Konflikte, vergrößert die erheblich die Leistung der Anwendung beeinträchtigen können, von die Hashtabellen, unter den folgenden Bedingungen abhängig: 
– Wenn Hashfunktionen häufige Konflikten führen.  
  
– Wenn ein Großteil der Objekte in einer Hashtabelle zum Erstellen der Hashcodes, die gleich sind oder anderen ungefähr gleich.  
  
– Wenn Benutzer die Daten eingeben, anhand, die derer der Hashcode berechnet wird.  
  
Abgeleitete Klassen, die außer Kraft setzen <see cref="M:System.Object.GetHashCode" /> müssen auch überschreiben <see cref="M:System.Object.Equals(System.Object)" /> um sicherzustellen, dass zwei Objekte als gleich betrachtet, die den gleichen Hashcode haben, andernfalls die <see cref="T:System.Collections.Hashtable" /> Typ funktioniert möglicherweise nicht ordnungsgemäß.</para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den <see cref="T:System.Type" /> der aktuellen Instanz ab.</summary>
        <returns>Der genaue Laufzeittyp der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da <xref:System.Object?displayProperty=nameWithType> ist die Basisklasse für alle Typen im .NET Framework-Typsystem, das <xref:System.Object.GetType%2A> Methode kann verwendet werden, um zurückgeben <xref:System.Type> Objekte, die alle .NET Framework-Typen darstellen. .NET Framework erkennt die folgenden fünf Typkategorien:  
  
-   Klassen, die von abgeleiteten <xref:System.Object?displayProperty=nameWithType>,  
  
-   Werttypen, die abgeleitet sind <xref:System.ValueType?displayProperty=nameWithType>.  
  
-   Schnittstellen, die von abgeleiteten <xref:System.Object?displayProperty=nameWithType> beginnend mit .NET Framework 2.0.  
  
-   Enumerationen abgeleitet sind <xref:System.Enum?displayProperty=nameWithType>.  
  
-   Delegaten, die von abgeleiteten <xref:System.MulticastDelegate?displayProperty=nameWithType>.  
  
 Für zwei Objekte `x` und `y` identische-Runtime-Typen, deren `Object.ReferenceEquals(x.GetType(),y.GetType())` gibt `true`. Im folgenden Beispiel wird die <xref:System.Object.GetType%2A> -Methode mit dem <xref:System.Object.ReferenceEquals%2A> Methode, um zu bestimmen, ob einen numerischer Wert der gleiche Typ wie die anderen zwei numerische Werte.  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  Um zu bestimmen, ob ein Objekt eines bestimmten Typs ist, verwenden Sie Ihre Sprache die Typ-Vergleich-Schlüsselwort oder zu erstellen. Beispielsweise können Sie die `TypeOf…Is` -Konstrukts in Visual Basic oder `is` -Schlüsselwort in c#.  
  
 Die <xref:System.Object.GetType%2A> Methode wird von allen Typen, die abgeleitet geerbt <xref:System.Object>. Dies bedeutet, dass zusätzlich zur Verwendung Ihrer eigenen Sprache des Vergleichs-Schlüsselwort, das Sie verwenden können die <xref:System.Object.GetType%2A> Methode, um den Typ eines bestimmten Objekts, zu bestimmen, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 Die <xref:System.Type> Objekt verfügbar macht, die die Klasse des aktuellen zugeordnete Metadaten <xref:System.Object>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dass <xref:System.Object.GetType%2A> gibt den Laufzeittyp der aktuellen Instanz.  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine flache Kopie des aktuellen <see cref="T:System.Object" />.</summary>
        <returns>Eine flache Kopie des aktuellen <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Object.MemberwiseClone%2A> Methode erstellt eine flache Kopie durch ein neues Objekt erstellt und anschließend die nicht statische Felder des aktuellen Objekts auf das neue Objekt kopiert. Wenn ein Feld eines Werttyps ist, erfolgt eine Bit für Bit-Kopie des Felds. Wenn ein Feld ein Verweistyp ist, wird der Verweis kopiert, aber das Objekt verwiesen wird, ist nicht; aus diesem Grund beziehen sich das ursprüngliche Objekt und dessen Klon auf dasselbe Objekt ein.  
  
 Betrachten Sie beispielsweise ein Objekt namens X dienen, die Objekte A und B, verweist wiederum auf verweist. Eine flache Kopie des X erstellt neues Objekt X2, das auch Objekte A und b verweist Im Gegensatz dazu eine tiefe Kopie des X-erstellt ein neues Objekt X2, die verweist auf die neuen Objekte A2 und B2, die Kopien von A und b B2, verweist wiederum auf das neue Objekt C2, wird eine Kopie des c Das Beispiel veranschaulicht den Unterschied zwischen einer flache und eine tiefe Kopie-Vorgang.  
  
 Es gibt zahlreiche Möglichkeiten, einen tiefe Kopie-Vorgang zu implementieren, wenn die flache Kopie-durch Vorgangs die <xref:System.Object.MemberwiseClone%2A> Methode Ihren Anforderungen nicht erfüllt. Hierzu gehört Folgendes:  
  
-   Rufen Sie den Konstruktor einer Klasse des Objekts, das kopiert werden, um ein zweites Objekt mit Eigenschaftswerten, die das erste Objekt entnommen zu erstellen. Dies setzt voraus, dass die Werte eines Objekts durch den Klassenkonstruktor vollständig definiert sind.  
  
-   Rufen Sie die <xref:System.Object.MemberwiseClone%2A> Methode, um eine flache Kopie eines Objekts zu erstellen, und weisen Sie dann auf neue Objekte, deren Werte identisch mit das ursprüngliche Objekt, um alle Eigenschaften oder Felder sind, deren Werte Verweistypen sind. Die `DeepCopy` -Methode in der das Beispiel veranschaulicht diese Vorgehensweise.  
  
-   Serialisiert das Objekt, um Tiefe kopiert, und die serialisierten Daten in einer anderen Variable wiederhergestellt werden.  
  
-   Mithilfe von Reflektion mit Rekursion zum Ausführen des Vorgangs tiefe Kopie.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Object.MemberwiseClone%2A> Methode. Definiert eine `ShallowCopy` Methode, die aufgerufen der <xref:System.Object.MemberwiseClone%2A> Methode, um eine flache Kopie-Vorgang ausgeführt eine `Person` Objekt. Sie definiert außerdem eine `DeepCopy` Methode, einen tiefe Kopie-Vorgang ausführt, auf, eine `Person` Objekt.  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 In diesem Beispiel die `Person.IdInfo` -Eigenschaft gibt ein `IdInfo` Objekt. Wie die Ausgabe des Beispiels zeigt Wenn eine `Person` -Objekt geklont wird durch Aufrufen der <xref:System.Object.MemberwiseClone%2A> -Methode, die geklonte `Person` Objekt ist eine unabhängige Kopie des ursprünglichen Objekts, mit dem Unterschied, dass sie dieselbe `Person.IdInfo` Objektverweis. Daher ändern des Klons `Person.IdInfo` eigenschaftsänderungen des ursprünglichen Objekts `Person.IdInfo` Eigenschaft. Wenn auf der anderen Seite ein tiefe Kopie-Vorgang ausgeführt wird, die geklonte `Person` Objekts, einschließlich der `Person.IdInfo` -Eigenschaft kann ohne Auswirkungen auf das ursprüngliche Objekt geändert werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Das erste zu vergleichende Objekt.</param>
        <param name="objB">Das zweite zu vergleichende Objekt.</param>
        <summary>Stellt fest, ob die angegebenen <see cref="T:System.Object" />-Instanzen dieselbe Instanz sind.</summary>
        <returns><see langword="true" /> wenn <paramref name="objA" /> dieselbe Instanz wie <paramref name="objB" /> ist oder beide **NULL** sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den <xref:System.Object.Equals%2A> -Methode und den Equality-Operator, der <xref:System.Object.ReferenceEquals%2A> Methode kann nicht überschrieben werden. Aus diesem Grund sollten Sie testen, zwei Objektverweise auf Gleichheit, und Sie sind nicht sicher sind, die Implementierung von der `Equals` -Methode, die Sie aufrufen können die <xref:System.Object.ReferenceEquals%2A> Methode.  
  
 Allerdings den Rückgabewert der <xref:System.Object.ReferenceEquals%2A> Methode scheint in diesen beiden Szenarien als anomal eingestuft haben:  
  
-   Wenn Sie Werttypen vergleichen zu können. Wenn `objA` und `objB` Werttypen sind, werden mittels Boxing gepackte vor der Übergabe an die <xref:System.Object.ReferenceEquals%2A> Methode. Dies bedeutet, dass, wenn beide `objA` und `objB` darstellen derselben Instanz eines Werttyps, der <xref:System.Object.ReferenceEquals%2A> dennoch Methodenrückgabe `false`, wie im folgende Beispiel gezeigt.  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     Weitere Informationen zu Boxing-Werttypen, finden Sie unter [Boxing und Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).  
  
-   Beim Vergleichen von Zeichenfolgen. Wenn `objA` und `objB` sind Zeichenfolgen, die <xref:System.Object.ReferenceEquals%2A> Methodenrückgabe `true` , wenn die Zeichenfolge internalisiert ist. Er führt einen Test keine Wertgleichheit.  Im folgenden Beispiel `s1` und `s2` gleich sind, da sie zwei Instanzen von einer einzelnen Zeichenfolge für die im Internpool vorhanden sind. Allerdings `s3` und `s4` ungleich sind, da auch sie werden identische Werte aufweisen, die diese Zeichenfolge nicht internalisiert ist.  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     Weitere Informationen zum Internalisieren von Zeichenfolgen finden Sie unter <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Object.ReferenceEquals%2A> zu bestimmen, ob zwei Objekte dieselbe Instanz sind.  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die das aktuelle Objekt darstellt.</summary>
        <returns>Eine Zeichenfolge, die das aktuelle Objekt darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> ist die wichtigsten-Methode in der .NET Framework formatieren. Konvertiert ein Objekt in seine Zeichenfolgendarstellung, damit es für die Anzeige geeignet ist. (Weitere Informationen zur Formatierung-Unterstützung in .NET Framework finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).) Standardimplementierungen der der <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode zurück, der vollqualifizierte Name, der den Typ des Objekts.  
  
> [!IMPORTANT]
>  Sie können diese Seite erreicht, über den Link aus der Memberliste eines anderen Typs. Dies liegt daran dieses Typs nicht überschreibt <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Stattdessen erbt es die Funktionalität der <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode.  
  
 Typen, die häufig überschreiben die <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode, um ein geeigneter Zeichenfolgendarstellung eines bestimmten Typs bereitzustellen. Typen auch häufig überladen der <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode, um die Formatzeichenfolgen oder kulturabhängige Formatierung zu unterstützen.  
  
 In diesem Abschnitt  
  
 [Die Standardmethode für die Object.ToString()](#Default)   
 [Überschreiben der Object.ToString()-Methode](#Overriding)   
 [Überladen die ToString-Methode](#Overloading)   
 [Erweitern Sie die Object.ToString-Methode](#Extending)   
 [Anmerkungen zu dieser Version für die Windows-Runtime](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>Die Standardmethode für die Object.ToString()  
 Die standardmäßige Implementierung des der <xref:System.Object.ToString%2A> Methode gibt den vollqualifizierten Namen des Typs von der <xref:System.Object>, wie im folgende Beispiel gezeigt.  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 Da <xref:System.Object> ist die Basisklasse aller Verweistypen in .NET Framework wird dieses Verhalten von Verweistypen, die nicht außer Kraft setzen geerbt der <xref:System.Object.ToString%2A> Methode. Dies wird anhand des folgenden Beispiels veranschaulicht. Es definiert eine Klasse namens `Object1` , akzeptiert die standardmäßige Implementierung aller <xref:System.Object> Member. Die <xref:System.Object.ToString%2A> Methode gibt den vollqualifizierten Typnamen des Objekts zurück.  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>Überschreiben der Object.ToString()-Methode  
 Überschreiben Sie die Typen im Allgemeinen die <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode, um eine Zeichenfolge zurückzugeben, die die Objektinstanz darstellt. Beispielsweise Basistypen wie z. B. <xref:System.Char>, <xref:System.Int32>, und <xref:System.String> bieten <xref:System.Object.ToString%2A> Implementierungen, die die Zeichenfolgendarstellung des Werts zurückzugeben, die das Objekt darstellt. Das folgende Beispiel definiert eine Klasse, `Object2`, überschreibt die <xref:System.Object.ToString%2A> Methode, um den Typnamen zusammen mit seinem Wert zurückzugeben.  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 Die folgende Tabelle listet die Kategorien in .NET Framework und gibt an, und zwar unabhängig davon, ob sie überschreiben die <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode.  
  
|Typkategorie|Außerkraftsetzungen Object.ToString()|Verhalten|  
|-------------------|-----------------------------------|--------------|  
|Klasse|n/v|n/v|  
|Struktur|Ja (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|Identisch mit Object.ToString()|  
|Enumeration|Ja (<xref:System.Enum.ToString?displayProperty=nameWithType>)|Den Namen des Members|  
|Interface|Nein|n/v|  
|delegate|Nein|n/v|  
  
 Finden Sie die Hinweise für Vererber-Abschnitt, um weitere Informationen zum Überschreiben <xref:System.Object.ToString%2A>.  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>Überladen die ToString-Methode  
 Zusätzlich zum Überschreiben der parameterlosen <xref:System.Object.ToString?displayProperty=nameWithType> Methode überladen, viele Arten der `ToString` Methode, um Versionen der-Methode bereitzustellen, die Parameter akzeptieren. Dies erfolgt in den meisten Fällen um für die Variable Formatierung und kulturabhängige Formatierung zu unterstützen.  
  
 Das folgende Beispiel überlädt die `ToString` Methode, um eine Ergebniszeichenfolge zurückzugeben, die den Wert verschiedener Felder dieses enthält ein `Automobile` Klasse. Er definiert vier Formatzeichenfolgen: G, die der Name des Modells und das Jahr zurückgibt; D, die den Modellnamen, Jahr und Anzahl von Türen zurückgibt; C, die den Modellnamen, Jahr und Anzahl der Zylinder zurückgibt; und ein, die eine Zeichenfolge mit allen vier Feldwerten zurückgibt.  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 Im folgenden Beispiel wird die überladene <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode, um anzuzeigen, kulturabhängige Formatierung, der einen Währungswert.  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 Weitere Informationen zu Formatzeichenfolgen und kulturabhängige Formatierung, finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md). Die Formatzeichenfolgen, die von numerischen Werten unterstützt, finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Die Formatzeichenfolgen, die von Datums-und Uhrzeitwerte unterstützt werden, finden Sie unter [Standardformatzeichenfolgen für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>Erweitern Sie die Object.ToString-Methode  
 Da der Standardwert erbt <xref:System.Object.ToString%2A?displayProperty=nameWithType> -Methode, Sie können finden Sie das Verhalten nicht erwünscht und ihn ändern möchten. Dies gilt insbesondere für Arrays und Auflistungsklassen. Während Sie erwarten, dass möglicherweise die `ToString` Methode ein Array oder eine Auflistung der Klasse zur Anzeige der Werte von Membern, stattdessen wird der vollqualifizierte Typname, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 Sie haben mehrere Optionen für die resultierende Zeichenfolge zu erzeugen, die Sie möchten.  
  
-   Wenn der Typ ist ein Array, ein Auflistungsobjekt oder ein Objekt, das implementiert der <xref:System.Collections.IEnumerable> oder <xref:System.Collections.Generic.IEnumerable%601> Schnittstellen, Sie können die Elemente auflisten, mit der `foreach` -Anweisung in c# oder die `For Each...Next` in Visual Basic erstellen.  
  
-   Wenn die Klasse nicht `sealed` (in c#) oder `NotInheritable` (in Visual Basic), können Sie eine Wrapperklasse, die von der Basisklasse, deren erbt entwickeln <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode, die Sie anpassen möchten. Mindestens erfordert dies, dass Sie die folgenden Schritte ausführen:  
  
    1.  Implementieren Sie alle erforderlichen Konstruktoren. Abgeleitete Klassen erben nicht die Konstruktoren ihrer Basisklasse.  
  
    2.  Überschreiben der <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode, um die Ergebniszeichenfolge zurückzugeben, die Sie möchten.  
  
     Das folgende Beispiel definiert eine Wrapperklasse für die <xref:System.Collections.Generic.List%601> Klasse. Es überschreibt die <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode, um den Wert der einzelnen Methoden von der Sammlung anstelle der vollqualifizierte Typname anzuzeigen.  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   Entwickeln einer [Erweiterungsmethode](~/docs/standard/design-guidelines/extension-methods.md) , die die Ergebniszeichenfolge, die Sie möchten zurückgibt. Beachten Sie, dass Sie die Standardeinstellung außer Kraft setzen können nicht <xref:System.Object.ToString%2A?displayProperty=nameWithType> -Methode in der auf diese Weise (d. h. der Erweiterungsklasse (in c#) oder dem Modul (in Visual Basic) sind keine parameterlose Methode namens `ToString` , der anstelle des ursprünglichen Typs aufgerufen `ToString` Methode . Sie müssen einen anderen Namen für Ihre parameterlosen bieten `ToString` Ersatz.  
  
     Das folgende Beispiel definiert zwei Methoden, die erweitert die <xref:System.Collections.Generic.List%601> Klasse: eine parameterlose `ToString2` -Methode, und ein `ToString` -Methode mit einer <xref:System.String> Parameter, der eine Formatzeichenfolge darstellt.  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Anmerkungen zu dieser von der [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Beim Aufrufen der <xref:System.Object.ToString%2A> Methode einer Klasse in der [!INCLUDE[wrt](~/includes/wrt-md.md)], es ist das Standardverhalten für Klassen, die nicht außer Kraft setzen <xref:System.Object.ToString%2A>. Dies ist Teil der Unterstützung von .NET Framework für die [!INCLUDE[wrt](~/includes/wrt-md.md)] (finden Sie unter [.NET Framework Unterstützung für Windows Store-Apps und Windows-Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Klassen in der [!INCLUDE[wrt](~/includes/wrt-md.md)] nicht erben <xref:System.Object>, und implementieren nicht immer eine <xref:System.Object.ToString%2A>. Allerdings sie immer anscheinend <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, und <xref:System.Object.GetHashCode%2A> Methoden ein, wenn Sie diese in Ihrem C#- oder Visual Basic-Code verwenden und .NET Framework ein Standardverhalten für diese Methoden bietet.  
  
 Beginnend mit der [!INCLUDE[net_v451](~/includes/net-v451-md.md)], verwendet die common Language Runtime [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) auf eine [!INCLUDE[wrt](~/includes/wrt-md.md)] Objekt vor dem Fallback auf die standardmäßige Implementierung des <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] Klassen, die geschrieben werden, in C# oder Visual Basic können außer Kraft setzen der <xref:System.Object.ToString%2A> Methode.  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>Die [!INCLUDE[wrt](~/includes/wrt-md.md)] und die IStringable-Schnittstelle  
 Beginnend mit [!INCLUDE[win81](~/includes/win81-md.md)], [!INCLUDE[wrt](~/includes/wrt-md.md)] enthält ein [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) Schnittstelle, deren einzige Methode, [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), eine grundlegende formatierungsunterstützung vergleichbar mit der bietet von bereitgestellten <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Sie sollten nicht implementieren, um Mehrdeutigkeit zu vermeiden, [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) für verwaltete Typen.  
  
 Wenn verwaltete Objekte heißen durch systemeigenen Code oder durch Code in Sprachen wie JavaScript oder C++ / CX können sie sich wie implementieren [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx). Die common Language Runtime leitet automatisch Aufrufe von [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) zu <xref:System.Object.ToString%2A?displayProperty=nameWithType> im [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) ist für das verwaltete Objekt nicht implementiert.  
  
> [!WARNING]
>  Da die common Language Runtime automatisch-implementiert [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) für alle verwalteten Typen im [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] -apps, es wird empfohlen, dass Sie keine eigene haben [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) Implementierung. Implementieren von [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) strafbar unerwartetem Verhalten beim Aufrufen von `ToString` aus der [!INCLUDE[wrt](~/includes/wrt-md.md)], C++ / CX oder JavaScript.  
  
 Wenn Sie sich entschließen, implementieren Sie [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in einem öffentlich verwalteten Typ, der im exportiert wird eine [!INCLUDE[wrt](~/includes/wrt-md.md)] -Komponente, die folgenden Einschränkungen gelten:  
  
-   Sie können definieren, die [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) -Schnittstelle nur in einer "class Implements"-Beziehung, z. B.  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     in C# oder  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     in Visual Basic.  
  
-   Sie können nicht implementieren [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) auf einer Schnittstelle.  
  
-   Sie können einen Parameter vom Typ nicht deklarieren [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).  
  
-   [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) darf nicht der Rückgabetyp einer Methode, eine Eigenschaft oder ein Feld sein.  
  
-   Sie können nicht ausgeblendet werden Ihre [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) Implementierung von Basisklassen mithilfe eine Methodendefinition wie die folgende:  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     Stattdessen die [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) Implementierung muss die basisklassenimplementierung immer überschreiben. Sie können eine `ToString`-Implementierung nur ausblenden, indem Sie sie auf einer stark typisierten Klasseninstanz aufrufen.  
  
 Beachten Sie, die unter einer Vielzahl von Bedingungen Aufrufe von nativem Code zu einem verwalteten Typ, der implementiert [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) oder blendet Sie aus der [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) Implementierung kann zu unerwartetem Verhalten führen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie Ihre eigenen Typen implementieren, sollten Sie Sie überschreiben die <see cref="M:System.Object.ToString" /> Methode zum Zurückgeben von Werten, die für diese Typen von Bedeutung sind. Abgeleitete Klassen, die mehr Kontrolle über die Formatierung als erfordern <see cref="M:System.Object.ToString" /> bietet können implementieren die <see cref="T:System.IFormattable" /> Schnittstelle. Die <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> Methode ermöglicht es Ihnen, die Formatzeichenfolgen zu definieren, die die Formatierung steuern und Verwenden einer <see cref="T:System.IFormatProvider" /> -Objekt, das für die kulturabhängige Formatierung bereitstellen kann.  
  
Der überschreibt die <see cref="M:System.Object.ToString" /> Methode sollte die folgenden Richtlinien: 
-Die zurückgegebene Zeichenfolge sollte benutzerfreundliche und von Menschen gelesen werden.  
  
-Die zurückgegebene Zeichenfolge sollte den Wert der Objektinstanz eindeutig identifizieren.  
  
-Die zurückgegebene Zeichenfolge sollte so kurz wie möglich sein, damit es für die Anzeige von einem Debugger geeignet ist.  
  
-Für Ihre <see cref="M:System.Object.ToString" /> außer Kraft setzen sollten keine zurückgeben <see cref="F:System.String.Empty" /> oder ein null-Zeichenfolge.  
  
-Für Ihre <see cref="M:System.Object.ToString" /> außer Kraft setzen sollte keine Ausnahme ausgelöst.  
  
– Wenn die angegebene Zeichenfolgendarstellung einer Instanz kulturabhängig ist oder auf verschiedene Weise formatiert werden kann, implementieren die <see cref="T:System.IFormattable" /> Schnittstelle.  
  
– Wenn die zurückgegebene Zeichenfolge vertrauliche Informationen enthält, sollten Sie zunächst eine entsprechende Berechtigung anfordern. Wenn die Anforderung erfolgreich ist, können Sie die vertrauliche Informationen zurückgegeben wird. Andernfalls sollten Sie eine Zeichenfolge zurückgeben, die vertrauliche Informationen ausschließt.  
  
-Für Ihre <see cref="M:System.Object.ToString" /> außer Kraft setzen müssen keine wahrnehmbaren Nebeneffekte zu schwierigkeiten beim Debuggen zu vermeiden. Z. B. einen Aufruf der <see cref="M:System.Object.ToString" /> Methode sollte den Wert der Instanzfelder nicht ändern.  
  
– Wenn der Typ eine Analysemethode implementiert (oder <see langword="Parse" /> oder <see langword="TryParse" /> -Methode, einen Konstruktor oder eine andere statische Methode, die eine Instanz des Typs aus einer Zeichenfolge instanziiert), Sie sollten sicherstellen, dass die zurückgegebene Zeichenfolge den <see cref="M:System.Object.ToString" /> Methode kann sein, Konvertiert eine Objektinstanz.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>
