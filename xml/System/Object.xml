<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="da1fbaa42d0c94f1887ea6f7dec24082afbc90af" /><Meta Name="ms.sourcegitcommit" Value="46b6829001d7a117b555e2b8cd81170b68efff08" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/18/2020" /><Meta Name="ms.locfileid" Value="79506475" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="System.Runtime" FromVersion="4.0.0.0" To="mscorlib" ToVersion="4.0.0.0" FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-1.2" />
  </TypeForwardingChain>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Unterstützt alle Klassen in der .NET-Klassenhierarchie und stellt abgeleiteten Klassen Low-Level-Dienste zur Verfügung. Dies ist die ultimative Basisklasse aller .NET-Klassen und stellt den Stamm der Typhierarchie dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel ist es nicht erforderlich, dass eine Klasse die Vererbung aus <xref:System.Object> deklariert, da die Vererbung implizit ist.  
  
 Da alle Klassen in .net von <xref:System.Object>abgeleitet sind, ist jede Methode, die in der <xref:System.Object>-Klasse definiert ist, in allen Objekten im System verfügbar. Abgeleitete Klassen können einige dieser Methoden außer Kraft setzen und überschreiben, einschließlich:  
  
-   <xref:System.Object.Equals%2A>: unterstützt Vergleiche zwischen Objekten.  
  
-   <xref:System.Object.Finalize%2A>: führt Bereinigungs Vorgänge aus, bevor ein Objekt automatisch freigegeben wird.  
  
-   <xref:System.Object.GetHashCode%2A>-generiert eine Zahl, die dem Wert des-Objekts entspricht, um die Verwendung einer Hash Tabelle zu unterstützen.  
  
-   <xref:System.Object.ToString%2A>: stellt eine lesbare Text Zeichenfolge her, die eine Instanz der-Klasse beschreibt.  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Wenn Sie eine Klasse entwerfen, z. b. eine Auflistung, die einen beliebigen Objekttyp verarbeiten muss, können Sie Klassenmember erstellen, die Instanzen der <xref:System.Object> Klasse akzeptieren. Der Vorgang zum Boxing und Unboxing eines Typs führt jedoch zu Leistungseinbußen. Wenn Sie wissen, dass Ihre neue Klasse häufig bestimmte Werttypen behandelt, können Sie eine von zwei Taktiken verwenden, um die Kosten des Boxens zu minimieren.  
  
-   Erstellen Sie eine allgemeine Methode, die einen <xref:System.Object> Typ akzeptiert, und einen Satz von typspezifischen Methoden Überladungen, die jeden Werttyp akzeptieren, der von der Klasse häufig verarbeitet wird. Wenn eine typspezifische Methode vorhanden ist, die den aufrufenden Parametertyp akzeptiert, erfolgt kein Boxing, und die typspezifische Methode wird aufgerufen. Wenn kein Methoden Argument vorhanden ist, das mit dem aufrufenden Parametertyp übereinstimmt, wird der-Parameter geachtelt, und die allgemeine-Methode wird aufgerufen.  
  
-   Entwerfen Sie Ihren Typ und seine Member, um Generika zu verwenden. Der Common Language Runtime erstellt einen geschlossenen generischen Typ, wenn Sie eine Instanz der Klasse erstellen und ein generisches Typargument angeben. Die generische Methode ist typspezifisch und kann aufgerufen werden, ohne den aufrufenden Parameter zu Boxing.  
  
 Obwohl es manchmal notwendig ist, allgemeine Klassen zu entwickeln, die <xref:System.Object> Typen akzeptieren und zurückgeben, können Sie die Leistung verbessern, indem Sie auch eine typspezifische Klasse zum Verarbeiten eines häufig verwendeten Typs bereitstellen. Wenn Sie beispielsweise eine Klasse angeben, die für das Festlegen und das erhalten von booleschen Werten spezifisch ist, werden die Kosten für das Boxing und das Unboxing von booleschen Werten vermieden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein von der <xref:System.Object>-Klasse abgeleiteter Punkttyp definiert, der viele der virtuellen Methoden der <xref:System.Object>-Klasse überschreibt. Außerdem wird im Beispiel gezeigt, wie viele der statischen Methoden und Instanzmethoden der <xref:System.Object> Klasse aufgerufen werden.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs" interactive="try-dotnet" id="snippet1":::
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp" id="snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb" id="snippet1":::
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind Thread sicher. Instanzmember sind nicht garantiert Thread sicher.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Object" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird von Konstruktoren in abgeleiteten Klassen aufgerufen, kann aber auch verwendet werden, um direkt eine Instanz der <xref:System.Object>-Klasse zu erstellen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ermittelt, ob die beiden Objektinstanzen identisch sind.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, das mit dem aktuellen Objekt verglichen werden soll.</param>
        <summary>Bestimmt, ob das angegebene Objekt gleich dem aktuellen Objekt ist.</summary>
        <returns><see langword="true" />, wenn das angegebene Objekt und das aktuelle Objekt gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Vergleichs zwischen der aktuellen Instanz und dem `obj`-Parameter hängt davon ab, ob es sich bei der aktuellen Instanz um einen Verweistyp oder einen Werttyp handelt.  

-   Wenn es sich bei der aktuellen Instanz um einen Verweistyp handelt, testet die <xref:System.Object.Equals%28System.Object%29>-Methode auf Verweis Gleichheit, und ein aufzurufende <xref:System.Object.Equals%28System.Object%29>-Methode entspricht einem-Rückruf der <xref:System.Object.ReferenceEquals%2A>-Methode. Verweis Gleichheit bedeutet, dass die zu vergleichenden Objektvariablen auf das gleiche Objekt verweisen. Das folgende Beispiel veranschaulicht das Ergebnis eines solchen Vergleichs. Es definiert eine `Person`-Klasse, die ein Verweistyp ist, und ruft den `Person`-Klassenkonstruktor auf, um zwei neue `Person`-Objekte zu instanziieren, `person1a` und `person2`, die denselben Wert aufweisen. Außerdem wird `person1a` einer anderen Objektvariablen zugewiesen, `person1b`. Wie die Ausgabe des Beispiels zeigt, sind `person1a` und `person1b` gleich, da Sie auf dasselbe Objekt verweisen. Allerdings sind `person1a` und `person2` nicht gleich, obwohl Sie denselben Wert aufweisen.  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   Wenn die aktuelle Instanz ein Werttyp ist, testet die <xref:System.Object.Equals%28System.Object%29>-Methode auf Wert Gleichheit. Wert Gleichheit bedeutet Folgendes:  
  
    -   Die beiden Objekte weisen denselben Typ auf. Wie im folgenden Beispiel gezeigt, entspricht ein <xref:System.Byte> Objekt mit dem Wert 12 nicht einem <xref:System.Int32> Objekt mit dem Wert 12, da die beiden-Objekte unterschiedliche Lauf Zeit Typen aufweisen.  
  
         [!code-csharp-interactive[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   Die Werte der öffentlichen und privaten Felder der beiden Objekte sind gleich. Im folgenden Beispiel wird auf Wert Gleichheit getestet. Er definiert eine `Person` Struktur, bei der es sich um einen Werttyp handelt, und ruft den `Person`-Klassenkonstruktor auf, um zwei neue `Person` Objekte zu instanziieren, `person1` und `person2`, die denselben Wert aufweisen. Wie die Ausgabe des Beispiels zeigt, obwohl die beiden Objektvariablen auf verschiedene Objekte verweisen, `person1` und `person2` gleich sind, da Sie den gleichen Wert für das Feld private `personName` haben.  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 Da die <xref:System.Object>-Klasse die Basisklasse für alle Typen in der .NET Framework ist, stellt die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>-Methode den Standard Gleichheits Vergleich für alle anderen Typen bereit. Typen überschreiben jedoch oft die <xref:System.Object.Equals%2A>-Methode, um Wert Gleichheit zu implementieren. Weitere Informationen finden Sie in den Abschnitten "Hinweise zu Aufrufern und Notizen für Vererbung".  
  
## <a name="notes-for-the-wrt"></a>Hinweise für den [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Wenn Sie die <xref:System.Object.Equals%28System.Object%29>-Methoden Überladung für eine Klasse im [!INCLUDE[wrt](~/includes/wrt-md.md)]aufrufen, stellt Sie das Standardverhalten für Klassen bereit, die <xref:System.Object.Equals%28System.Object%29>nicht überschreiben. Dies ist ein Teil der Unterstützung, die der .NET Framework für die [!INCLUDE[wrt](~/includes/wrt-md.md)] bietet (siehe [.NET Framework Support für Windows Store-Apps und Windows-Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Klassen im [!INCLUDE[wrt](~/includes/wrt-md.md)] erben <xref:System.Object>nicht und implementieren derzeit keine <xref:System.Object.Equals%28System.Object%29>-Methode. Sie scheinen jedoch <xref:System.Object.ToString%2A>-, <xref:System.Object.Equals%28System.Object%29>-und <xref:System.Object.GetHashCode%2A>-Methoden zu haben, wenn Sie Sie im C# -oder-Visual Basic Code verwenden, und das .NET Framework stellt das Standardverhalten für diese Methoden bereit.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] Klassen, die in C# oder Visual Basic geschrieben sind, können die <xref:System.Object.Equals%28System.Object%29>-Methoden Überladung überschreiben.  
  
## <a name="notes-for-callers"></a>Hinweise für Aufrufer  
 Abgeleitete Klassen überschreiben häufig die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>-Methode, um Wert Gleichheit zu implementieren. Außerdem bieten Typen häufig eine zusätzliche stark typisierte Überladung für die `Equals`-Methode, in der Regel durch Implementieren der <xref:System.IEquatable%601>-Schnittstelle. Wenn Sie die `Equals`-Methode zum Testen auf Gleichheit aufzurufen, sollten Sie wissen, ob die aktuelle Instanz <xref:System.Object.Equals%2A?displayProperty=nameWithType> außer Kraft setzt und verstehen, wie ein bestimmter Aufrufsatz einer `Equals` Methode aufgelöst wird. Andernfalls können Sie einen Test auf Gleichheit durchführen, der sich von der vorgesehenen Methode unterscheidet, und die Methode gibt möglicherweise einen unerwarteten Wert zurück.  
  
 Dies wird im folgenden Beispiel veranschaulicht. Er instanziiert drei <xref:System.Text.StringBuilder> Objekte mit identischen Zeichen folgen und führt dann vier Aufrufe an `Equals` Methoden aus. Der erste Methoden Aufrufwert gibt `true`zurück, und die restlichen drei Rückgabe `false`.  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 Im ersten Fall wird die stark typisierte <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType>-Methoden Überladung, die auf Wert Gleichheit testet, aufgerufen. Da die den zwei <xref:System.Text.StringBuilder> Objekten zugewiesenen Zeichen folgen gleich sind, gibt die Methode `true`zurück. Die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>wird von <xref:System.Text.StringBuilder> jedoch nicht überschrieben. Wenn das <xref:System.Text.StringBuilder> Objekt in eine <xref:System.Object>umgewandelt wird, wenn eine <xref:System.Text.StringBuilder> Instanz einer Variablen vom Typ <xref:System.Object>zugewiesen ist, und wenn die <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>-Methode zwei <xref:System.Text.StringBuilder> Objekten übermittelt wird, wird die standardmäßige <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>-Methode aufgerufen. Da <xref:System.Text.StringBuilder> ein Referenztyp ist, entspricht dies dem übergeben der beiden <xref:System.Text.StringBuilder>-Objekte an die <xref:System.Object.ReferenceEquals%2A>-Methode. Obwohl alle drei <xref:System.Text.StringBuilder> Objekte identische Zeichen folgen enthalten, verweisen Sie auf drei unterschiedliche Objekte. Folglich geben diese drei Methodenaufrufe `false`zurück.  
  
 Sie können das aktuelle-Objekt für Verweis Gleichheit mit einem anderen Objekt vergleichen, indem Sie die <xref:System.Object.ReferenceEquals%2A>-Methode aufrufen. In Visual Basic können Sie auch das Schlüsselwort `is` verwenden (z. b. `If Me Is otherObject Then ...`).  
  
## <a name="notes-for-inheritors"></a>Hinweise für Vererber  
 Wenn Sie einen eigenen Typ definieren, erbt dieser Typ die Funktionalität, die durch die `Equals`-Methode seines Basistyps definiert ist. In der folgenden Tabelle ist die Standard Implementierung der `Equals`-Methode für die Hauptkategorien von Typen in der .NET Framework aufgelistet.  
  
|Typkategorie|Gleichheit definiert durch|Kommentare|  
|-------------------|-------------------------|--------------|  
|Von <xref:System.Object> direkt abgeleitete Klasse|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Verweis Gleichheit Äquivalent zum Aufrufen von <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.|  
|Struktur|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|Wert Gleichheit; entweder direkter Byte-für-Byte-Vergleich oder Feld-für-Feld-Vergleich mithilfe von Reflektion.|  
|Enumeration|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|Werte müssen denselben Enumerationstyp und denselben zugrunde liegenden Wert aufweisen.|  
|Delegieren|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|Delegaten müssen denselben Typ mit identischen Aufruf Listen aufweisen.|  
|Schnittstelle|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Verweis Gleichheit.|  
  
 Bei einem Werttyp sollten Sie <xref:System.Object.Equals%2A>immer überschreiben, da Tests auf Gleichheit, die auf Reflektion basieren, eine schlechte Leistung bieten. Sie können auch die Standard Implementierung von <xref:System.Object.Equals%2A> für Verweis Typen überschreiben, um auf Wert Gleichheit anstelle der Verweis Gleichheit zu prüfen und die genaue Bedeutung von Wert Gleichheit zu definieren. Solche Implementierungen von <xref:System.Object.Equals%2A> geben `true` zurück, wenn die beiden Objekte denselben Wert aufweisen, auch wenn Sie nicht dieselbe Instanz sind. Der Implementierer des Typs entscheidet, was den Wert eines Objekts ausmacht, aber es handelt sich in der Regel um einige oder alle Daten, die in den Instanzvariablen des-Objekts gespeichert werden. Beispielsweise basiert der Wert eines <xref:System.String> Objekts auf den Zeichen der Zeichenfolge. die <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType>-Methode überschreibt die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>-Methode, um `true` für zwei Zeichen folgen Instanzen zurückzugeben, die die gleichen Zeichen in derselben Reihenfolge enthalten.  
  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>-Methode überschrieben wird, um auf Wert Gleichheit zu testen. Er überschreibt die <xref:System.Object.Equals%2A>-Methode für die `Person`-Klasse. Wenn `Person` die Basisklassen Implementierung von Gleichheit akzeptiert, sind zwei `Person` Objekte nur dann gleich, wenn Sie auf ein einzelnes Objekt verwiesen haben. In diesem Fall sind jedoch zwei `Person` Objekte gleich, wenn Sie über denselben Wert für die `Person.Id`-Eigenschaft verfügen.  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 Zusätzlich zum Überschreiben von <xref:System.Object.Equals%2A>können Sie die <xref:System.IEquatable%601>-Schnittstelle implementieren, um einen stark typisierten Test auf Gleichheit bereitzustellen.  
  
 Die folgenden-Anweisungen müssen für alle Implementierungen der <xref:System.Object.Equals%28System.Object%29>-Methode den Wert "true" aufweisen. In der Liste werden `x`, `y`und `z` Objekt Verweise darstellen, die nicht **null**sind.  
  
-   `x.Equals(x)` gibt `true`zurück, außer in Fällen, die Gleit Komma Typen einschließen. Siehe [ISO/IEC/IEEE 60559:2011, Informationstechnologie--Mikroprozessorsysteme--Gleit Komma Arithmetik](https://www.iso.org/standard/57469.html).  
  
-   `x.Equals(y)` gibt denselben Wert zurück wie `y.Equals(x)`.  
  
-   `x.Equals(y)` gibt `true` zurück, wenn `x` und `y` `NaN`sind.  
  
-   Wenn `(x.Equals(y) && y.Equals(z))` `true`zurückgibt, gibt `x.Equals(z)` `true`zurück.  
  
-   Aufeinander folgende Aufrufe von `x.Equals(y)` geben denselben Wert zurück, solange die Objekte, auf die von `x` und `y` verwiesen wird, nicht geändert werden.  
  
-   `x.Equals(null)` gibt `false` zurück.  
  
 Implementierungen von <xref:System.Object.Equals%2A> dürfen keine Ausnahmen auslösen. Sie sollten immer einen Wert zurückgeben. Wenn `obj` z. b. `null`ist, sollte die <xref:System.Object.Equals%2A>-Methode `false` zurückgeben, anstatt eine <xref:System.ArgumentNullException>auszulösen.  
  
 Beachten Sie beim Überschreiben von <xref:System.Object.Equals%28System.Object%29>die folgenden Richtlinien:  
  
-   Typen, die <xref:System.IComparable> implementieren, müssen <xref:System.Object.Equals%28System.Object%29>überschreiben.  
  
-   Typen, die <xref:System.Object.Equals%28System.Object%29> überschreiben, müssen auch <xref:System.Object.GetHashCode%2A>außer Kraft setzen. Andernfalls funktionieren Hash Tabellen möglicherweise nicht ordnungsgemäß.  
  
-   Sie sollten die <xref:System.IEquatable%601>-Schnittstelle implementieren, um stark typisierte Tests auf Gleichheit zu unterstützen. Die <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>-Implementierung sollte Ergebnisse zurückgeben, die <xref:System.Object.Equals%2A>entsprechen.  
  
-   Wenn Ihre Programmiersprache das Überladen von Operatoren unterstützt und Sie den Gleichheits Operator für einen bestimmten Typ überladen, müssen Sie auch die <xref:System.Object.Equals%28System.Object%29>-Methode überschreiben, um das gleiche Ergebnis wie der Gleichheits Operator zurückzugeben. Dadurch wird sichergestellt, dass der Klassen Bibliotheks Code, der <xref:System.Object.Equals%2A> verwendet (z. b. <xref:System.Collections.ArrayList> und <xref:System.Collections.Hashtable>), so verhält, dass er mit der Art und Weise konsistent ist, wie der Gleichheits Operator von Anwendungscode verwendet wird  
  
### <a name="guidelines-for-reference-types"></a>Richtlinien für Referenztypen  
 Die folgenden Richtlinien gelten für das Überschreiben von <xref:System.Object.Equals%28System.Object%29> für einen Referenztyp:  
  
-   Überschreiben Sie <xref:System.Object.Equals%2A>, wenn die Semantik des Typs auf der Tatsache basiert, dass der Typ einige Werte darstellt.  
  
-   Die meisten Verweis Typen dürfen den Gleichheits Operator nicht überladen, auch wenn Sie <xref:System.Object.Equals%2A>überschreiben. Wenn Sie jedoch einen Verweistyp implementieren, der eine Wert Semantik aufweisen soll (z. b. ein komplexer Nummertyp), müssen Sie den Gleichheits Operator überschreiben.  
  
-   Sie sollten <xref:System.Object.Equals%2A> nicht für einen änderbaren Referenztyp überschreiben. Dies liegt daran, dass das Überschreiben von <xref:System.Object.Equals%2A> erfordert, dass Sie auch die <xref:System.Object.GetHashCode%2A>-Methode überschreiben, wie im vorherigen Abschnitt erläutert wurde. Dies bedeutet, dass sich der Hashcode einer Instanz eines änderbaren Verweis Typs während seiner Lebensdauer ändern kann, was dazu führen kann, dass das Objekt in einer Hash Tabelle verloren geht.  
  
### <a name="guidelines-for-value-types"></a>Richtlinien für Werttypen  
 Die folgenden Richtlinien gelten für das Überschreiben von <xref:System.Object.Equals%28System.Object%29> für einen Werttyp:  
  
-   Wenn Sie einen Werttyp definieren, der ein oder mehrere Felder enthält, deren Werte Verweis Typen sind, sollten Sie <xref:System.Object.Equals%28System.Object%29>überschreiben. Die von <xref:System.ValueType> bereitgestellte <xref:System.Object.Equals%28System.Object%29> Implementierung führt einen Byte-pro-Byte-Vergleich für Werttypen durch, deren Felder alle Werttypen sind. Sie verwendet jedoch Reflektion, um einen Feld weisen Vergleich von Werttypen durchzuführen, deren Felder Verweis Typen enthalten.  
  
-   Wenn Sie <xref:System.Object.Equals%2A> überschreiben und die Entwicklungssprache das Überladen von Operatoren unterstützt, müssen Sie den Gleichheits Operator überladen.  
  
-   Sie sollten die <xref:System.IEquatable%601>-Schnittstelle implementieren. Wenn Sie die stark typisierte <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> Methode aufrufen, wird das Boxing des `obj` Arguments vermieden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine `Point` Klasse, die die <xref:System.Object.Equals%2A>-Methode überschreibt, um Wert Gleichheit und eine `Point3D`-Klasse zu überschreiben, die von `Point`abgeleitet ist. Da `Point` <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> überschreibt, um auf Wert Gleichheit zu testen, wird die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>-Methode nicht aufgerufen. `Point3D.Equals` ruft jedoch `Point.Equals` auf, da `Point` <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> auf eine Weise implementiert, die Wert Gleichheit bereitstellt.  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 Die `Point.Equals`-Methode überprüft, ob das `obj`-Argument nicht **null** ist und dass es auf eine Instanz des gleichen Typs wie dieses Objekt verweist. Wenn eine der beiden Überprüfungen fehlschlägt, gibt die Methode `false`zurück.  
  
 Die `Point.Equals`-Methode ruft die <xref:System.Object.GetType%2A>-Methode auf, um zu bestimmen, ob die Lauf Zeit Typen der beiden-Objekte identisch sind. Wenn die Methode eine Überprüfung der Formular `obj is Point` in C# oder `TryCast(obj, Point)` in Visual Basic verwendet hat, würde die Überprüfung `true` in Fällen zurückgeben, in denen `obj` eine Instanz einer abgeleiteten Klasse von `Point`ist, auch wenn `obj` und die aktuelle Instanz nicht denselben Lauf Zeittyp aufweisen. Nachdem überprüft wurde, ob beide Objekte denselben Typ aufweisen, wandelt die Methode `obj` in den Typ `Point` und gibt das Ergebnis des Vergleichs der Instanzfelder der beiden Objekte zurück.  
  
 In `Point3D.Equals`wird die geerbte `Point.Equals` Methode, die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>überschreibt, aufgerufen, bevor etwas anderes ausgeführt wird. Da `Point3D` eine versiegelte Klasse (`NotInheritable` in Visual Basic) ist, ist eine Überprüfung in der C# Form `obj is Point` in oder `TryCast(obj, Point)` Visual Basic ausreichend, um sicherzustellen, dass `obj` ein `Point3D` Objekt ist. Wenn es sich um ein `Point3D` Objekt handelt, wird es in ein `Point` Objekt umgewandelt und an die Basisklassen Implementierung von <xref:System.Object.Equals%2A>übermittelt. Nur wenn die geerbte `Point.Equals` Methode `true` zurückgibt, vergleicht die Methode die `z` Instanzfelder, die in der abgeleiteten Klasse eingeführt wurden.  
  
 Im folgenden Beispiel wird eine `Rectangle` Klasse definiert, die intern ein Rechteck als zwei `Point` Objekte implementiert. Die `Rectangle`-Klasse überschreibt auch <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, um Wert Gleichheit bereitzustellen.  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 Einige Sprachen, wie C# z. b. und Visual Basic Unterstützung der Operator Überladung Wenn ein Typ den Gleichheits Operator überlädt, muss er auch die <xref:System.Object.Equals%28System.Object%29>-Methode überschreiben, um die gleiche Funktionalität bereitzustellen. Dies wird in der Regel erreicht, indem die <xref:System.Object.Equals%28System.Object%29>-Methode in Bezug auf den überladenen Gleichheits Operator geschrieben wird, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 Da `Complex` ein Werttyp ist, kann er nicht von abgeleitet werden.  Daher muss die Methode zum Überschreiben von <xref:System.Object.Equals%28System.Object%29> <xref:System.Object.GetType%2A> nicht aufrufen, um den genauen Lauf Zeittyp der einzelnen Objekte zu bestimmen. stattdessen kann der `is`- C# Operator in oder der `TypeOf`-Operator in Visual Basic verwendet werden, um den Typ des `obj`-Parameters zu überprüfen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Das erste der zu vergleichenden Objekte.</param>
        <param name="objB">Das zweite der zu vergleichenden Objekte.</param>
        <summary>Stellt fest, ob die angegebenen Objektinstanzen als gleich betrachtet werden.</summary>
        <returns><see langword="true" />, wenn die Objekte als gleich betrachtet werden, andernfalls <see langword="false" />. Wenn sowohl <paramref name="objA" />, als auch <paramref name="objB" />**NULL** sind, gibt diese Methode <see langword="true" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die statische <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> Methode gibt an, ob zwei Objekte, `objA` und `objB`, gleich sind. Außerdem können Sie Objekte, deren Wert **null** ist, auf Gleichheit testen. Er vergleicht `objA` und `objB` auf Gleichheit wie folgt:  
  
-   Es bestimmt, ob die beiden-Objekte denselben Objekt Verweis darstellen. Wenn dies der Fall ist, gibt die Methode `true`zurück. Dieser Test entspricht dem Aufrufen der <xref:System.Object.ReferenceEquals%2A>-Methode. Außerdem gibt die Methode `true`zurück, wenn sowohl `objA` als auch `objB` **null**sind.  
  
-   Es bestimmt, ob entweder `objA` oder `objB` **null**ist. Wenn dies der Fall ist, wird `false`zurückgegeben.  
  
-   Wenn die beiden Objekte nicht denselben Objekt Verweis darstellen und keines von **null**ist, wird `objA`aufgerufen.`Equals`(`objB`) und gibt das Ergebnis zurück. Dies bedeutet Folgendes: Wenn `objA` die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>-Methode überschreibt, wird diese außer Kraft Setzung aufgerufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Object.Equals%28System.Object%2CSystem.Object%29>-Methode veranschaulicht und mit der <xref:System.Object.ReferenceEquals%2A>-Methode verglichen.  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Finalize() cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einem Objekt Gelegenheit zu dem Versuch, Ressourcen freizugeben und andere Bereinigungen durchzuführen, bevor es von der Garbage Collection freigegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Object.Finalize%2A>-Methode wird verwendet, um Bereinigungs Vorgänge für nicht verwaltete Ressourcen durchzuführen, die vom aktuellen-Objekt aufbewahrt werden, bevor das-Objekt zerstört wird. Die-Methode ist geschützt und kann daher nur über diese Klasse oder eine abgeleitete Klasse aufgerufen werden.  
  
 Inhalt dieses Abschnitts:  
  
-   [Funktionsweise der Finalisierung](#How)  
  
-   [Hinweise für Implementierer](#Notes)  
  
-   [Die SafeHandle-Alternative](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>Funktionsweise der Finalisierung  
 Die <xref:System.Object>-Klasse stellt keine Implementierung für die <xref:System.Object.Finalize%2A>-Methode bereit, und die Garbage Collector markiert keine Typen, die von <xref:System.Object> für den Abschluss abgeleitet sind, es sei denn, Sie überschreiben die <xref:System.Object.Finalize%2A>-Methode  
  
 Wenn ein Typ die <xref:System.Object.Finalize%2A> Methode überschreibt, fügt der Garbage Collector einen Eintrag für jede Instanz des Typs einer internen Struktur hinzu, die als Abschluss Queue bezeichnet wird. Die Finalisierungswarteschlange enthält Einträge für alle Objekte im verwalteten Heap, deren Finalisierungscode ausgeführt werden muss, bevor der Garbage Collector den Speicher freigeben kann. Der Garbage Collector ruft dann die <xref:System.Object.Finalize%2A>-Methode automatisch unter den folgenden Bedingungen auf:  
  
-   Nachdem der Garbage Collector ermittelt hat, dass auf ein Objekt nicht mehr zugegriffen werden kann, es sei denn, das Objekt wurde von der Finalisierung durch einen aufzurufenden <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> Methode ausgenommen.  
  
-   **Nur auf .NET Framework**, wenn eine Anwendungsdomäne heruntergefahren wird, es sei denn, das Objekt ist von der Finalisierung ausgenommen. Während des herunter Fahrens werden auch Objekte, die weiterhin zugänglich sind, fertiggestellt.  
  
 <xref:System.Object.Finalize%2A> wird automatisch nur einmal für eine bestimmte-Instanz aufgerufen, es sei denn, das Objekt wird mithilfe eines Mechanismus wie <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> neu registriert, und die <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>-Methode wurde nachfolgend nicht aufgerufen.  
  
 bei <xref:System.Object.Finalize%2A> Vorgängen gelten die folgenden Einschränkungen:  
  
-   Die genaue Zeit, zu der der Finalizer ausgeführt wird, ist nicht definiert. Um die deterministische Freigabe von Ressourcen für Instanzen Ihrer Klasse sicherzustellen, implementieren Sie eine `Close`-Methode, oder stellen Sie eine <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>-Implementierung bereit.  
  
-   Die Finalizer von zwei Objekten sind nicht garantiert, dass Sie in einer bestimmten Reihenfolge ausgeführt werden, auch wenn ein Objekt auf das andere Objekt verweist. Das heißt, wenn Objekt a einen Verweis auf Objekt b hat und beide über Finalizer verfügen, wurde Objekt B möglicherweise bereits abgeschlossen, wenn der Finalizer von Objekt A gestartet wird.  
  
-   Der Thread, auf dem der Finalizer ausgeführt wird, ist nicht angegeben.  
  
 Die <xref:System.Object.Finalize%2A>-Methode kann möglicherweise nicht vollständig ausgeführt werden oder unter den folgenden außergewöhnlichen Umständen überhaupt nicht ausgeführt werden:  
  
-   Wenn ein anderer Finalizer unbegrenzt blockiert wird (in eine Endlosschleife wechselt, versucht, eine Sperre zu erhalten, die er niemals abrufen kann usw.). Da die Laufzeit versucht, Finalizer für den Abschluss auszuführen, werden möglicherweise andere Finalizer nicht aufgerufen, wenn ein Finalizer unbegrenzt blockiert wird.  
  
-   , Wenn der Prozess beendet wird, ohne der Laufzeit die Möglichkeit zu geben, zu bereinigen. In diesem Fall ist die erste Benachrichtigung des Prozesses bei der Beendigung der Laufzeit eine DLL_PROCESS_DETACH Benachrichtigung.  
  
 Die Laufzeit setzt das Beenden von Objekten während des herunter Fahrens fort, während die Anzahl der finalisierbaren Objekte weiterhin abnimmt.  
  
 Wenn <xref:System.Object.Finalize%2A> oder eine außer Kraft Setzung von <xref:System.Object.Finalize%2A> eine Ausnahme auslöst und die Laufzeit nicht von einer Anwendung gehostet wird, die die Standard Richtlinie überschreibt, beendet die Laufzeit den Prozess, und es werden keine aktiven `try`/`finally` Blöcke oder Finalizer ausgeführt. Durch dieses Verhalten wird die Prozess Integrität sichergestellt, wenn der Finalizer Ressourcen nicht freigeben oder zerstören kann.  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Überschreiben der Finalize-Methode 
 Sie sollten <xref:System.Object.Finalize%2A> für eine Klasse überschreiben, die nicht verwaltete Ressourcen verwendet, z. b. Datei Handles oder Datenbankverbindungen, die freigegeben werden müssen, wenn das verwaltete Objekt, das Sie verwendet, während der Garbage Collection verworfen wird. Sie sollten keine <xref:System.Object.Finalize%2A> Methode für verwaltete Objekte implementieren, da die Garbage Collector verwaltete Ressourcen automatisch freigibt.  
  
> [!IMPORTANT]
>  Wenn ein <xref:System.Runtime.InteropServices.SafeHandle> Objekt verfügbar ist, das Ihre nicht verwaltete Ressource umschließt, empfiehlt es sich, das Lösch Muster mit einem sicheren Handle zu implementieren und <xref:System.Object.Finalize%2A>nicht zu überschreiben. Weitere Informationen finden Sie im Abschnitt " [SafeHandle-Alternative](#SafeHandle) ".  
  
 Die <xref:System.Object.Finalize%2A?displayProperty=nameWithType>-Methode führt standardmäßig keine Aktion aus, aber Sie sollten <xref:System.Object.Finalize%2A> nur bei Bedarf überschreiben und nur nicht verwaltete Ressourcen freigeben. Das Freigeben des Speichers dauert tendenziell viel länger, wenn ein Abschluss Vorgang ausgeführt wird, da er mindestens zwei Garbage Collections erfordert. Außerdem sollten Sie die <xref:System.Object.Finalize%2A>-Methode nur für Verweis Typen überschreiben. Der Common Language Runtime der nur Verweis Typen finalisiert. Finalizer werden für Werttypen ignoriert.  

Der Gültigkeitsbereich der <xref:System.Object.Finalize%2A?displayProperty=nameWithType> Methode ist `protected`. Sie sollten diesen eingeschränkten Gültigkeitsbereich beibehalten, wenn Sie die Methode in der Klasse überschreiben. Wenn Sie eine <xref:System.Object.Finalize%2A> Methode schützen, verhindern Sie, dass Benutzer Ihrer Anwendung die <xref:System.Object.Finalize%2A> Methode eines Objekts direkt aufrufen.
  
 Jede Implementierung von <xref:System.Object.Finalize%2A> in einem abgeleiteten Typ muss die Implementierung von <xref:System.Object.Finalize%2A>des Basistyps aufzurufen. Dies ist der einzige Fall, in dem Anwendungscode <xref:System.Object.Finalize%2A>aufgerufen werden darf. Die <xref:System.Object.Finalize%2A>-Methode eines Objekts sollte keine Methode für andere Objekte als die ihrer Basisklasse aufzurufen. Der Grund hierfür ist, dass das aufrufende Objekt möglicherweise zur gleichen Zeit an die Garbage Collection übergeben wird wie die anderen aufgerufenen Objekte, z. B. wenn eine Common Language Runtime beendet wird. 
  
> [!NOTE]
>  Der C# Compiler lässt nicht zu, dass Sie die <xref:System.Object.Finalize%2A>-Methode außer Kraft setzen. Stattdessen stellen Sie einen Finalizer bereit, indem Sie einen [debugtor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) für Ihre Klasse implementieren. Ein C# Dekonstruktor ruft automatisch den Dekonstruktor der Basisklasse auf.  
>   
>  Visual C++ bietet auch eine eigene Syntax für die Implementierung der <xref:System.Object.Finalize%2A>-Methode. Weitere Informationen finden Sie im Abschnitt "debugtoren und Finalizer" unter Gewusst [wie: definieren und Verarbeiten von Klassen und Strukturen (C++/CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).  
  
 Da Garbage Collection nicht deterministisch ist, wissen Sie nicht genau, wann der Garbage Collector die Finalisierung ausführt. Um Ressourcen sofort freizugeben, können Sie auch das Lösch [Muster](~/docs/standard/garbage-collection/implementing-dispose.md) und die <xref:System.IDisposable>-Schnittstelle implementieren. Die <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>-Implementierung kann von Consumern der-Klasse aufgerufen werden, um nicht verwaltete Ressourcen freizugeben, und Sie können die <xref:System.Object.Finalize%2A>-Methode verwenden, um nicht verwaltete Ressourcen freizugeben, wenn die <xref:System.IDisposable.Dispose%2A>-Methode nicht aufgerufen wird.  
  
 <xref:System.Object.Finalize%2A> können fast jede Aktion ausführen, einschließlich der Wiederherstellung eines Objekts (d. h., dass das Objekt erneut zugänglich ist), nachdem es während der Garbage Collection bereinigt wurde. Das Objekt kann jedoch nur einmal wieder auferstanden werden. <xref:System.Object.Finalize%2A> kann während Garbage Collection nicht für wiederbelebte Objekte aufgerufen werden.
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>Die SafeHandle-Alternative  
 Das Erstellen zuverlässiger Finalizer ist oft schwierig, da Sie keine Annahmen über den Zustand Ihrer Anwendung treffen können und weil nicht behandelte System Ausnahmen wie <xref:System.OutOfMemoryException> und <xref:System.StackOverflowException> den Finalizer beenden. Anstatt einen Finalizer für die-Klasse zu implementieren, um nicht verwaltete Ressourcen freizugeben, können Sie ein Objekt verwenden, das von der <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>-Klasse abgeleitet wird, um die nicht verwalteten Ressourcen zu umschließen, und dann das Lösch Muster ohne Finalizer zu implementieren. Der .NET Framework stellt die folgenden Klassen in den <xref:Microsoft.Win32?displayProperty=nameWithType>-Namespace bereit, die von <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>abgeleitet sind:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> ist eine Wrapper Klasse für ein Datei handle.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> ist eine Wrapper Klasse für im Speicher abgebildete Datei Handles.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> ist eine Wrapper Klasse für einen Zeiger auf einen Block von nicht verwaltetem Arbeitsspeicher.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>und <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> sind Wrapper Klassen für kryptografische Handles.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> ist eine Wrapper Klasse für Pipehandles.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> ist eine Wrapper Klasse für ein Handle für einen Registrierungsschlüssel.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> ist eine Wrapper Klasse für ein Wait-Handle.  
  
 Im folgenden Beispiel wird das Verwerfen- [Muster](~/docs/standard/garbage-collection/implementing-dispose.md) mit sicheren Handles verwendet, anstatt die <xref:System.Object.Finalize%2A>-Methode zu überschreiben. Es definiert eine `FileAssociation` Klasse, die Registrierungsinformationen zu der Anwendung umschließt, die Dateien mit einer bestimmten Dateierweiterung verarbeitet. Die beiden Registrierungs Handles, die von Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) -Funktionsaufrufen als `out`-Parameter zurückgegeben werden, werden an den <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>-Konstruktor übergeben. Die geschützte `Dispose`-Methode des Typs ruft dann die `SafeRegistryHandle.Dispose`-Methode auf, um diese beiden Handles freizugeben.  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird überprüft, ob die <xref:System.Object.Finalize%2A>-Methode aufgerufen wird, wenn ein Objekt, das <xref:System.Object.Finalize%2A> überschreibt, zerstört wird. Beachten Sie, dass die <xref:System.Object.Finalize%2A>-Methode in einer Produktionsanwendung außer Kraft gesetzt wird, um nicht verwaltete Ressourcen freizugeben, die vom-Objekt aufbewahrt werden. Beachten Sie außerdem, C# dass das Beispiel einen Dekonstruktor bereitstellt, anstatt die <xref:System.Object.Finalize%2A>-Methode zu überschreiben.  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 Ein weiteres Beispiel, das die <xref:System.Object.Finalize%2A>-Methode überschreibt, finden Sie unter der <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>-Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dient als die Standard-Hashfunktion</summary>
        <returns>Ein Hashcode für das aktuelle Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Hashcode ist ein numerischer Wert, mit dem ein Objekt in einer Hash basierten Auflistung, z. b. die <xref:System.Collections.Generic.Dictionary%602> Klasse, die <xref:System.Collections.Hashtable>-Klasse oder ein von der <xref:System.Collections.DictionaryBase>-Klasse abgeleiteter Typ, eingefügt und identifiziert werden kann. Die <xref:System.Object.GetHashCode%2A>-Methode stellt diesen Hashcode für Algorithmen bereit, die schnelle Überprüfungen der Objekt Gleichheit benötigen.  
  
> [!NOTE]
>  Informationen zur Verwendung von Hashcodes in Hash Tabellen und einige zusätzliche Hash Code Algorithmen finden Sie im Eintrag [Hash Function](https://en.wikipedia.org/wiki/Hash_function) in Wikipedia.  
  
 Zwei Objekte, die gleich sind, gleichmäßige Rückgabe Hashcodes sind gleich. Umgekehrt ist dies jedoch nicht der Fall: gleiche Hashcodes implizieren keine Objekt Gleichheit, da verschiedene (ungleich) Objekte identische Hashcodes aufweisen können. Außerdem garantiert .net nicht die Standard Implementierung der <xref:System.Object.GetHashCode%2A>-Methode, und der von dieser Methode zurückgegebene Wert kann sich zwischen .net-Implementierungen, wie z. b. verschiedenen Versionen von .NET Framework und .net Core, und Plattformen wie 32-Bit-und 64-Bit-Plattformen unterscheiden. Verwenden Sie aus diesen Gründen nicht die Standard Implementierung dieser Methode als eindeutigen Objekt Bezeichner für Hash Zwecke. Es folgen zwei Konsequenzen:  
  
-   Sie sollten nicht davon ausgehen, dass die gleichen Hashcodes Objekt Gleichheit implizieren.  
  
-   Sie sollten niemals einen Hashcode außerhalb der Anwendungsdomäne beibehalten oder verwenden, in der er erstellt wurde, da das gleiche Objekt über Anwendungs Domänen, Prozesse und Plattformen hinweg einen Hash durchführen kann.  
  
> [!WARNING]
>  Ein Hashcode ist für die effiziente Einfügung und Suche in Auflistungen vorgesehen, die auf einer Hash Tabelle basieren. Ein Hashcode ist kein dauerhafter Wert. Aus diesem Grund:  
>   
> -   Serialisieren Sie keine Hash Code Werte, oder speichern Sie Sie nicht in Datenbanken.  
> -   Verwenden Sie den Hashcode nicht als Schlüssel zum Abrufen eines Objekts aus einer Schlüssel gebundenen Auflistung.  
> -   Senden Sie keine Hashcodes über Anwendungs Domänen oder Prozesse hinweg. In einigen Fällen können Hashcodes pro Prozess oder pro Anwendungsdomäne berechnet werden.  
> -   Verwenden Sie nicht den Hashcode anstelle eines Werts, der von einer kryptografischen Hash Funktion zurückgegeben wird, wenn Sie einen kryptografisch starken Hash benötigen. Verwenden Sie für kryptografische Hashes eine Klasse, die von der <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> oder <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> Klasse abgeleitet ist.  
> -   Testen Sie nicht auf Gleichheit von Hashcodes, um zu bestimmen, ob zwei Objekte gleich sind. (Ungleiche Objekte können identische Hashcodes aufweisen.) Um auf Gleichheit zu prüfen, wenden Sie die Methode <xref:System.Object.ReferenceEquals%2A> oder <xref:System.Object.Equals%2A> an.  
  
 Die <xref:System.Object.GetHashCode%2A>-Methode kann von einem abgeleiteten Typ überschrieben werden. Wenn <xref:System.Object.GetHashCode%2A> nicht überschrieben wird, werden Hashcodes für Verweis Typen berechnet, indem die <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>-Methode der Basisklasse aufgerufen wird, die einen Hashcode basierend auf dem Verweis eines Objekts berechnet. Weitere Informationen finden Sie unter <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>. Das heißt, dass zwei Objekte, für die die <xref:System.Object.ReferenceEquals%2A> Methode `true` zurückgibt, über identische Hashcodes verfügen. Wenn Werttypen <xref:System.Object.GetHashCode%2A>nicht überschreiben, verwendet die <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType>-Methode der Basisklasse Reflektion, um den Hashcode basierend auf den Werten der Felder des Typs zu berechnen. Anders ausgedrückt: Werttypen, deren Felder gleich sind, haben gleiche Hashcodes. Weitere Informationen zum Überschreiben von <xref:System.Object.GetHashCode%2A>finden Sie im Abschnitt "Hinweise zu Vererbung".  
  
> [!WARNING]
>  Wenn Sie die <xref:System.Object.GetHashCode%2A>-Methode außer Kraft setzen, sollten Sie auch <xref:System.Object.Equals%2A>außer Kraft setzen und umgekehrt. Wenn die überschriebene <xref:System.Object.Equals%2A> Methode `true` zurückgibt, wenn zwei Objekte auf Gleichheit geprüft werden, muss die überschriebene <xref:System.Object.GetHashCode%2A> Methode den gleichen Wert für die beiden Objekte zurückgeben.  
  
 Wenn ein Objekt, das als Schlüssel in einer Hash Tabelle verwendet wird, keine nützliche Implementierung von <xref:System.Object.GetHashCode%2A>bereitstellt, können Sie einen Hashcode-Anbieter angeben, indem Sie eine <xref:System.Collections.IEqualityComparer>-Implementierung für eine der über Ladungen des <xref:System.Collections.Hashtable>-Klassenkonstruktors bereitstellen.  
  
## <a name="notes-for-the-wrt"></a>Hinweise für den [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Wenn Sie die <xref:System.Object.GetHashCode%2A>-Methode für eine Klasse in der [!INCLUDE[wrt](~/includes/wrt-md.md)]aufzurufen, wird das Standardverhalten für Klassen bereitstellt, die <xref:System.Object.GetHashCode%2A>nicht überschreiben. Dies ist ein Teil der Unterstützung, die der .NET Framework für die [!INCLUDE[wrt](~/includes/wrt-md.md)] bietet (siehe [.NET Framework Support für Windows Store-Apps und Windows-Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Klassen im [!INCLUDE[wrt](~/includes/wrt-md.md)] erben <xref:System.Object>nicht und implementieren derzeit keine <xref:System.Object.GetHashCode%2A>. Sie scheinen jedoch <xref:System.Object.ToString%2A>-, <xref:System.Object.Equals%28System.Object%29>-und <xref:System.Object.GetHashCode%2A>-Methoden zu haben, wenn Sie Sie im C# -oder-Visual Basic Code verwenden, und das .NET Framework stellt das Standardverhalten für diese Methoden bereit.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] Klassen, die in C# oder Visual Basic geschrieben sind, können die <xref:System.Object.GetHashCode%2A>-Methode überschreiben.  
  
   
  
## Examples  
 Eine der einfachsten Möglichkeiten, einen Hashcode für einen numerischen Wert zu berechnen, der denselben oder einen kleineren Bereich aufweist als der <xref:System.Int32> Typ, besteht darin, diesen Wert einfach zurückzugeben. Das folgende Beispiel zeigt eine solche Implementierung für eine `Number` Struktur.  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 Häufig verfügt ein Typ über mehrere Datenfelder, die an der Erstellung des Hashcodes beteiligt sein können. Eine Möglichkeit, einen Hashcode zu generieren, besteht darin, diese Felder mithilfe eines `XOR (eXclusive OR)` Vorgangs zu kombinieren, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 Im vorherigen Beispiel wird derselbe Hashcode für (N1, N2) und (N2, N1) zurückgegeben, sodass möglicherweise mehr Kollisionen generiert, als wünschenswert sind. Es stehen eine Reihe von Lösungen zur Verfügung, sodass Hashcodes in diesen Fällen nicht identisch sind. Eine besteht darin, den Hashcode eines `Tuple` Objekts zurückzugeben, das die Reihenfolge der einzelnen Felder widerspiegelt. Das folgende Beispiel zeigt eine mögliche Implementierung, die die <xref:System.Tuple%602>-Klasse verwendet. Beachten Sie jedoch, dass sich der Leistungs Aufwand beim Instanziieren eines `Tuple` Objekts erheblich auf die Gesamtleistung einer Anwendung auswirken kann, in der eine große Anzahl von Objekten in Hash Tabellen gespeichert wird.  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 Eine zweite Alternative Lösung besteht darin, die einzelnen Hashcodes zu gewichten, indem die Hashcodes aufeinander folgender Felder um zwei oder mehr Bits verschoben werden. Im Idealfall sollten Bits, die über Bit 31 hinaus verschoben werden, umschlossen werden, anstatt verworfen zu werden. Da Bits von den Left Shift-Operatoren sowohl C# in als auch Visual Basic verworfen werden, muss eine Left Shift-and-Wrap-Methode wie die folgende erstellt werden:  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 Im folgenden Beispiel wird dann diese Shift-and-Wrap-Methode verwendet, um den Hashcode der `Point` Struktur zu berechnen, die in den vorherigen Beispielen verwendet wurde.  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Eine Hash Funktion wird verwendet, um schnell eine Zahl (Hashcode) zu generieren, die dem Wert eines Objekts entspricht. Hash Funktionen sind in der Regel für jeden Typ spezifisch und müssen aus Gründen der Eindeutigkeit mindestens eines der Instanzfelder als Eingabe verwenden. Hashcodes sollten nicht mithilfe der Werte statischer Felder berechnet werden.  
  
Bei Klassen, die von <see cref="T:System.Object" />abgeleitet werden, kann die <see langword="GetHashCode" />-Methode nur an die Basisklasse <see cref="M:System.Object.GetHashCode" />-Implementierung delegieren, wenn die abgeleitete Klasse Gleichheit als Verweis Gleichheit definiert. Die Standard Implementierung von <see cref="M:System.Object.GetHashCode" /> für Verweis Typen gibt einen Hashcode zurück, der dem Wert entspricht, der von der <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />-Methode zurückgegeben wird. Sie können <see cref="M:System.Object.GetHashCode" /> für unveränderliche Verweis Typen überschreiben. Im Allgemeinen sollten Sie für änderbare Verweis Typen <see cref="M:System.Object.GetHashCode" /> nur dann überschreiben, wenn Folgendes: 
-Sie können den Hashcode aus Feldern berechnen, die nicht änderbar sind. noch 
-Sie können sicherstellen, dass sich der Hashcode eines änderbaren Objekts nicht ändert, während das Objekt in einer Auflistung enthalten ist, die auf seinem Hashcode basiert.  
  
Andernfalls denken Sie möglicherweise, dass das änderbare Objekt in der Hash Tabelle verloren geht. Wenn Sie <see cref="M:System.Object.GetHashCode" /> für einen änderbaren Referenztyp überschreiben möchten, sollte in der Dokumentation deutlich werden, dass die Benutzer des Typs Objektwerte nicht ändern sollten, während das Objekt in einer Hash Tabelle gespeichert wird.  
  
Für Werttypen bietet <see cref="M:System.ValueType.GetHashCode" /> eine standardmäßige Hash Code Implementierung, die Reflektion verwendet. Sie sollten diese überschreiben, um die Leistung zu verbessern.  
  
 <block subset="none" type="note"><para>  
 Weitere Informationen und Beispiele, in denen Hashcodes auf unterschiedlichste Weise berechnet werden, finden Sie im Abschnitt "Beispiele".  
  
</para></block>  
  
 Eine Hash Funktion muss über die folgenden Eigenschaften verfügen: 
Wenn zwei-Objekte als gleich verglichen werden, muss die <see cref="M:System.Object.GetHashCode" />-Methode für jedes-Objekt den gleichen Wert zurückgeben. Wenn jedoch zwei-Objekte nicht als gleich verglichen werden, müssen die <see cref="M:System.Object.GetHashCode" />-Methoden für die beiden-Objekte keine anderen Werte zurückgeben.  
  
-Die <see cref="M:System.Object.GetHashCode" />-Methode für ein Objekt muss den gleichen Hashcode immer wieder zurückgeben, solange keine Änderung des Objekt Zustands vorliegt, der den Rückgabewert der [System. Object. gleich](xref:System.Object.Equals*) -Methode des Objekts bestimmt. Beachten Sie, dass dies nur für die aktuelle Ausführung einer Anwendung gilt und dass ein anderer Hashcode zurückgegeben werden kann, wenn die Anwendung erneut ausgeführt wird.  
  
-Für eine optimale Leistung sollte eine Hash Funktion eine gleichmäßige Verteilung für alle Eingaben generieren, einschließlich der stark gruppierten Eingaben. Dies impliziert, dass kleine Änderungen am Objektzustand zu großen Änderungen am resultierenden Hashcode führen sollten, um die beste Leistung der Hash Tabelle zu erzielen.  
  
-Hash Funktionen sollten für die Berechnung günstig sein.  
  
-Die <see cref="M:System.Object.GetHashCode" /> Methode sollte keine Ausnahmen auslösen.  
  
Beispielsweise gibt die Implementierung der <see cref="M:System.String.GetHashCode" />-Methode, die von der <see cref="T:System.String" />-Klasse bereitgestellt wird, identische Hashcodes für identische Zeichen folgen Werte zurück. Daher geben zwei <see cref="T:System.String" />-Objekte denselben Hashcode zurück, wenn Sie denselben Zeichen folgen Wert darstellen. Außerdem verwendet die-Methode alle Zeichen in der Zeichenfolge, um eine relativ zufällig verteilte Ausgabe zu generieren, auch wenn die Eingabe in bestimmten Bereichen gruppiert ist (z. b. können viele Benutzer Zeichen folgen haben, die nur die unteren 128 ASCII-Zeichen enthalten, auch wenn eine die Zeichenfolge kann jedes der 65.535 Unicode-Zeichen enthalten.)  
  
Das Bereitstellen einer guten Hash Funktion für eine Klasse kann die Leistung beim Hinzufügen dieser Objekte zu einer Hash Tabelle erheblich beeinträchtigen. In einer Hash Tabelle mit Schlüsseln, die eine gute Implementierung einer Hash Funktion bereitstellen, benötigt das Suchen nach einem Element Konstante Zeit (z. b. ein O (1)-Vorgang). In einer Hash Tabelle, bei der die Implementierung einer Hash Funktion unzureichend ist, hängt die Leistung einer Suche von der Anzahl der Elemente in der Hash Tabelle ab (z. b. eines O (`n`)-Vorgangs, bei dem `n` die Anzahl der Elemente in der Hash Tabelle ist). Ein böswilliger Benutzer kann Daten eingeben, die die Anzahl der Konflikte erhöhen. Dies kann die Leistung von Anwendungen, die von Hash Tabellen abhängen, unter den folgenden Bedingungen erheblich beeinträchtigen: 
-Wenn Hash Funktionen häufige Konflikte verursachen.  
  
: Wenn ein großer Anteil von Objekten in einer Hash Tabelle Hashcodes erzeugt, die gleich oder ungefähr gleich zueinander sind.  
  
: Wenn Benutzer die Daten eingeben, aus denen der Hashcode berechnet wird.  
  
Abgeleitete Klassen, die <see cref="M:System.Object.GetHashCode" /> überschreiben, müssen auch <see cref="M:System.Object.Equals(System.Object)" /> überschreiben, um sicherzustellen, dass zwei als gleich betrachtet werden Andernfalls funktioniert der <see cref="T:System.Collections.Hashtable" /> Typ möglicherweise nicht ordnungsgemäß.</para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den <see cref="T:System.Type" /> der aktuellen Instanz ab.</summary>
        <returns>Der genaue Laufzeittyp der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da <xref:System.Object?displayProperty=nameWithType> die Basisklasse für alle Typen im .net-Typsystem ist, kann die <xref:System.Object.GetType%2A>-Methode verwendet werden, um <xref:System.Type>-Objekte zurückzugeben, die alle .NET-Typen darstellen. .Net erkennt die folgenden fünf Kategorien von Typen:  
  
-   Klassen, die von <xref:System.Object?displayProperty=nameWithType>abgeleitet sind,  
  
-   Werttypen, die von <xref:System.ValueType?displayProperty=nameWithType>abgeleitet werden.  
  
-   Schnittstellen, die von <xref:System.Object?displayProperty=nameWithType> abgeleitet werden, beginnend mit dem .NET Framework 2,0.  
  
-   Enumerationen, die von <xref:System.Enum?displayProperty=nameWithType>abgeleitet werden.  
  
-   Delegaten, die von <xref:System.MulticastDelegate?displayProperty=nameWithType>abgeleitet werden.  
  
 Bei zwei Objekten `x` und `y`, die identische Lauf Zeit Typen aufweisen, gibt `Object.ReferenceEquals(x.GetType(),y.GetType())` `true`zurück. Im folgenden Beispiel wird die <xref:System.Object.GetType%2A>-Methode mit der <xref:System.Object.ReferenceEquals%2A>-Methode verwendet, um zu bestimmen, ob ein numerischer Wert dem gleichen Typ wie zwei andere numerische Werte entspricht.  
  
 [!code-csharp-interactive[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  Um zu ermitteln, ob ein Objekt ein bestimmter Typ ist, können Sie das typvergleichs Schlüsselwort oder das Konstrukt ihrer Sprache verwenden. Beispielsweise können Sie das `TypeOf…Is`-Konstrukt in Visual Basic oder das `is`-Schlüsselwort C#in verwenden.  
  
 Die <xref:System.Object.GetType%2A>-Methode wird von allen Typen geerbt, die von <xref:System.Object>abgeleitet werden. Dies bedeutet, dass Sie zusätzlich zur Verwendung des Vergleichs Schlüsselworts ihrer eigenen Sprache die <xref:System.Object.GetType%2A>-Methode verwenden können, um den Typ eines bestimmten Objekts zu bestimmen, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp-interactive[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 Das <xref:System.Type>-Objekt macht die Metadaten verfügbar, die der-Klasse der aktuellen <xref:System.Object>zugeordnet sind.  
  
   
  
## Examples  

 Im folgenden Codebeispiel wird veranschaulicht, dass <xref:System.Object.GetType%2A> den Lauf Zeittyp der aktuellen Instanz zurückgibt.  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine flache Kopie des aktuellen <see cref="T:System.Object" />.</summary>
        <returns>Eine flache Kopie des aktuellen <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch die <xref:System.Object.MemberwiseClone%2A>-Methode wird eine flache Kopie erstellt, indem ein neues-Objekt erstellt und dann die nicht statischen Felder des aktuellen-Objekts in das neue-Objekt kopiert werden. Wenn ein Feld ein Werttyp ist, wird eine Bit-für-Bit-Kopie des Felds ausgeführt. Wenn ein Feld ein Referenztyp ist, wird der Verweis kopiert, aber das Objekt, auf das verwiesen wird, nicht. Daher verweisen das ursprüngliche Objekt und der zugehörige Klon auf dasselbe Objekt.  
  
 Angenommen, ein Objekt mit dem Namen X verweist auf die Objekte A und B. Object B wiederum verweist auf Objekt C. Eine flache Kopie von X erstellt ein neues Objekt x2, das auch auf die Objekte A und B verweist. Im Gegensatz dazu erstellt eine tiefe Kopie von X ein neues Objekt x2, das auf die neuen Objekte a2 und B2 verweist, die Kopien von a und B. B2 wiederum auf das neue Objekt C2, das eine Kopie von C ist. Das Beispiel veranschaulicht den Unterschied zwischen einem flachen und einem Deep Copy-Vorgang.  
  
 Es gibt zahlreiche Möglichkeiten, einen Deep Copy-Vorgang zu implementieren, wenn der flache Kopiervorgang, der von der <xref:System.Object.MemberwiseClone%2A>-Methode ausgeführt wird, nicht Ihren Anforderungen entspricht. Dabei handelt es sich z. B. um:  
  
-   Rufen Sie einen Klassenkonstruktor des Objekts auf, das kopiert werden soll, um ein zweites Objekt mit Eigenschafts Werten zu erstellen, die aus dem ersten Objekt entnommen werden Dabei wird davon ausgegangen, dass die Werte eines Objekts vollständig durch den Klassenkonstruktor definiert werden.  
  
-   Rufen Sie die <xref:System.Object.MemberwiseClone%2A>-Methode auf, um eine flache Kopie eines Objekts zu erstellen, und weisen Sie dann neue Objekte zu, deren Werte mit dem ursprünglichen Objekt identisch sind, und den Eigenschaften oder Feldern, deren Werte Verweis Typen sind. Diese Vorgehensweise wird durch die `DeepCopy`-Methode im Beispiel veranschaulicht.  
  
-   Serialisieren Sie das Objekt, das tief kopiert werden soll, und stellen Sie die serialisierten Daten dann in einer anderen Objektvariablen wieder her.  
  
-   Verwenden Sie Reflektion mit Rekursion, um den Deep Copy-Vorgang auszuführen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Object.MemberwiseClone%2A>-Methode veranschaulicht. Es definiert eine `ShallowCopy` Methode, die die <xref:System.Object.MemberwiseClone%2A>-Methode aufruft, um einen flachen Kopiervorgang für ein `Person`-Objekt auszuführen. Außerdem wird eine `DeepCopy` Methode definiert, die einen Deep Copy-Vorgang für ein `Person`-Objekt ausführt.  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 In diesem Beispiel gibt die `Person.IdInfo`-Eigenschaft ein `IdInfo`-Objekt zurück. Wie die Ausgabe des Beispiels zeigt, ist das geklonte `Person`-Objekt, wenn ein `Person` Objekt durch Aufrufen der <xref:System.Object.MemberwiseClone%2A>-Methode geklont wird, eine unabhängige Kopie des ursprünglichen-Objekts, mit dem Unterschied, dass Sie denselben `Person.IdInfo` Objekt Verweis gemeinsam verwenden. Folglich ändert das Ändern der `Person.IdInfo`-Eigenschaft des Klons die `Person.IdInfo` Eigenschaft des ursprünglichen Objekts. Wenn dagegen ein Deep Copy-Vorgang ausgeführt wird, kann das geklonte `Person` Objekt, einschließlich seiner `Person.IdInfo`-Eigenschaft, geändert werden, ohne dass sich dies auf das ursprüngliche Objekt auswirkt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Das erste der zu vergleichenden Objekte.</param>
        <param name="objB">Das zweite zu vergleichende Objekt.</param>
        <summary>Stellt fest, ob die angegebenen <see cref="T:System.Object" />-Instanzen dieselbe Instanz sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="objA" /> dieselbe Instanz wie <paramref name="objB" /> ist oder beide **NULL** sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anders als die <xref:System.Object.Equals%2A>-Methode und der Gleichheits Operator kann die <xref:System.Object.ReferenceEquals%2A>-Methode nicht überschrieben werden. Wenn Sie daher zwei Objekt Verweise auf Gleichheit testen möchten, und Sie sich nicht sicher sind, ob die `Equals`-Methode implementiert ist, können Sie die <xref:System.Object.ReferenceEquals%2A>-Methode aufzurufen.  
  
 Der Rückgabewert der <xref:System.Object.ReferenceEquals%2A>-Methode erscheint in den folgenden beiden Szenarien möglicherweise als anormale:  
  
-   Beim Vergleichen von Werttypen. Wenn `objA` und `objB` Werttypen sind, werden Sie vor der Übergabe an die <xref:System.Object.ReferenceEquals%2A>-Methode gekapselt. Dies bedeutet, dass, wenn sowohl `objA` als auch `objB` die gleiche Instanz eines Werttyps darstellen, die <xref:System.Object.ReferenceEquals%2A>-Methode trotzdem `false`zurückgibt, wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp-interactive[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     Informationen zu Boxing-Werttypen finden Sie unter [Boxing und Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).  
  
-   Beim Vergleichen von Zeichen folgen. Wenn `objA` und `objB` Zeichen folgen sind, gibt die <xref:System.Object.ReferenceEquals%2A>-Methode `true` zurück, wenn die Zeichenfolge interniert ist. Es wird kein Test auf Wert Gleichheit durchgeführt.  Im folgenden Beispiel sind `s1` und `s2` gleich, da es sich um zwei Instanzen einer einzelnen, Internpool vorhanden Zeichenfolge handelt. `s3` und `s4` sind jedoch nicht gleich, denn obwohl Sie identische Zeichen folgen Werte aufweisen, wird diese Zeichenfolge nicht interniert.  
  
     [!code-csharp-interactive[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     Weitere Informationen zum Zusammensetzen von Zeichen folgen finden Sie unter <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  

 Im folgenden Beispiel wird <xref:System.Object.ReferenceEquals%2A> verwendet, um zu bestimmen, ob zwei-Objekte dieselbe Instanz sind.  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp-interactive[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die das aktuelle Objekt darstellt.</summary>
        <returns>Eine Zeichenfolge, die das aktuelle Objekt darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> ist die wichtigste Formatierungs Methode im .NET Framework. Ein Objekt wird in seine Zeichen folgen Darstellung konvertiert, sodass es für die Anzeige geeignet ist. (Informationen zur Unterstützung von Formaten in der .NET Framework finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).) Standard Implementierungen der <xref:System.Object.ToString%2A?displayProperty=nameWithType>-Methode geben den voll qualifizierten Namen des Objekt Typs zurück.  
  
> [!IMPORTANT]
>  Sie haben diese Seite möglicherweise erreicht, indem Sie den Link aus der Mitglieds Liste eines anderen Typs befolgen. Dies liegt daran, dass der Typ <xref:System.Object.ToString%2A?displayProperty=nameWithType>nicht außer Kraft setzt. Stattdessen erbt Sie die Funktionalität der <xref:System.Object.ToString%2A?displayProperty=nameWithType>-Methode.  
  
 Typen überschreiben häufig die <xref:System.Object.ToString%2A?displayProperty=nameWithType>-Methode, um eine geeignetere Zeichen folgen Darstellung eines bestimmten Typs bereitzustellen. Typen überladen auch häufig die <xref:System.Object.ToString%2A?displayProperty=nameWithType>-Methode, um Unterstützung für Format Zeichenfolgen oder Kultur abhängige Formatierung bereitzustellen.  

 Inhalt dieses Abschnitts:  
  
 [Die standardmäßige Object. destring ()-Methode](#Default)   
 Überschreiben [der Object. destring ()-Methode](#Overriding)   
 [Überladen der Methode "destring](#Overloading) "   
 [Erweitern der Object. destring-Methode](#Extending)   
 [Hinweise für den Windows-Runtime](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>Die Default Object. destring ()-Methode  
 Die Standard Implementierung der <xref:System.Object.ToString%2A>-Methode gibt den voll qualifizierten Namen des <xref:System.Object>Typs zurück, wie im folgenden Beispiel gezeigt.  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp-interactive[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 Da <xref:System.Object> die Basisklasse aller Verweis Typen in der .NET Framework ist, wird dieses Verhalten von Verweis Typen geerbt, die die <xref:System.Object.ToString%2A>-Methode nicht überschreiben. Dies wird anhand des folgenden Beispiels veranschaulicht. Es definiert eine Klasse mit dem Namen `Object1`, die die Standard Implementierung aller <xref:System.Object> Member akzeptiert. Die <xref:System.Object.ToString%2A>-Methode gibt den voll qualifizierten Typnamen des Objekts zurück.  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>Überschreiben der Object. destring ()-Methode  
 Typen überschreiben häufig die <xref:System.Object.ToString%2A?displayProperty=nameWithType>-Methode, um eine Zeichenfolge zurückzugeben, die die Objektinstanz darstellt. Beispielsweise stellen die Basis Typen, z. b. <xref:System.Char>, <xref:System.Int32>und <xref:System.String>, <xref:System.Object.ToString%2A> Implementierungen bereit, die die Zeichen folgen Form des Werts zurückgeben, den das Objekt darstellt. Im folgenden Beispiel wird eine-Klasse definiert, `Object2`, die die <xref:System.Object.ToString%2A>-Methode überschreibt, um den Typnamen zusammen mit seinem Wert zurückzugeben.  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 In der folgenden Tabelle werden die Typkategorien in .NET aufgelistet, und es wird angegeben, ob die <xref:System.Object.ToString%2A?displayProperty=nameWithType>-Methode überschrieben wird.  
  
|Typkategorie|Überschreibt Object.-Zeichenfolge ()|Verhalten|  
|-------------------|-----------------------------------|--------------|  
|Klasse|–|–|  
|Struktur|Ja (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|Identisch mit `Object.ToString()`|  
|Enumeration|Ja (<xref:System.Enum.ToString?displayProperty=nameWithType>)|Der Elementname|  
|Schnittstelle|Nein|–|  
|Delegieren|Nein|–|  
  
 Weitere Informationen zum Überschreiben von <xref:System.Object.ToString%2A>finden Sie im Abschnitt "Hinweise zu Vererbung".  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>Über Laden der Methode "destring"  
 Neben dem Überschreiben der Parameter losen <xref:System.Object.ToString?displayProperty=nameWithType>-Methode überladen viele Typen die `ToString`-Methode, um Versionen der Methode bereitzustellen, die Parameter akzeptieren. In den meisten Fällen wird dies erreicht, um Unterstützung für Variablen Formatierung und Kultur abhängige Formatierung bereitzustellen.  
  
 Im folgenden Beispiel wird die `ToString`-Methode überladen, um eine Ergebnis Zeichenfolge zurückzugeben, die den Wert verschiedener Felder einer `Automobile` Klasse enthält. Es definiert vier Format Zeichenfolgen: G, die den Modellnamen und das Jahr zurückgibt. D: gibt den Modellnamen, das Jahr und die Anzahl der Türen zurück. C: gibt den Modellnamen, das Jahr und die Anzahl der Zylinder zurück. und eine, die eine Zeichenfolge mit allen vier Feldwerten zurückgibt.  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 Im folgenden Beispiel wird die überladene <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode aufgerufen, um die Kultur abhängige Formatierung eines Währungs Werts anzuzeigen.  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 Weitere Informationen zu Format Zeichenfolgen und der Kultur abhängigen Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md). Informationen zu den von numerischen Werten unterstützten Format Zeichenfolgen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md) Informationen zu den von Datums-und Uhrzeitwerten unterstützten Format Zeichenfolgen finden Sie unter Standard Format Zeichenfolgen für [Datum und Uhrzeit](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-date-and-time-format-strings.md)Format Zeichenfolgen  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>Erweitern der Object. destring-Methode  
 Da ein Typ die Standard <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode erbt, ist das Verhalten möglicherweise unerwünscht und soll geändert werden. Dies gilt insbesondere für Arrays und Auflistungs Klassen. Obwohl Sie möglicherweise erwarten, dass die `ToString`-Methode eines Arrays oder einer Auflistungs Klasse die Werte der zugehörigen Member anzeigt, zeigt Sie stattdessen den voll qualifizierten Typnamen des Typs an, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp-interactive[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 Sie haben mehrere Optionen, um die gewünschte Ergebnis Zeichenfolge zu erhalten.  
  
-   Wenn der Typ ein Array, ein Auflistungs Objekt oder ein Objekt ist, das die <xref:System.Collections.IEnumerable>-oder <xref:System.Collections.Generic.IEnumerable%601> Schnittstellen implementiert, können Sie seine Elemente mithilfe der `foreach`-Anweisung C# in oder dem `For Each...Next` Konstrukt in Visual Basic auflisten.  
  
-   Wenn die Klasse nicht `sealed` (in C#) oder `NotInheritable` (in Visual Basic) ist, können Sie eine Wrapper Klasse entwickeln, die von der Basisklasse erbt, deren <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode Sie anpassen möchten. Hierfür müssen Sie mindestens folgende Schritte ausführen:  
  
    1.  Implementieren Sie alle erforderlichen Konstruktoren. Abgeleitete Klassen erben nicht Ihre Basisklassenkonstruktoren.  
  
    2.  Überschreiben Sie die <xref:System.Object.ToString%2A?displayProperty=nameWithType>-Methode, um die gewünschte Ergebnis Zeichenfolge zurückzugeben.  
  
     Im folgenden Beispiel wird eine Wrapper Klasse für die <xref:System.Collections.Generic.List%601>-Klasse definiert. Er überschreibt die <xref:System.Object.ToString%2A?displayProperty=nameWithType>-Methode, um den Wert jeder Methode der Auflistung anstelle des voll qualifizierten Typnamens anzuzeigen.  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   Entwickeln Sie eine [Erweiterungsmethode](~/docs/standard/design-guidelines/extension-methods.md) , die die gewünschte Ergebnis Zeichenfolge zurückgibt. Beachten Sie, dass Sie die standardmäßige <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode nicht auf diese Weise überschreiben können (d. h C#., die Erweiterungs Klasse (in) oder das Modul (in Visual Basic) kann keine Parameter lose Methode mit dem Namen `ToString` aufweisen, die anstelle der `ToString`-Methode des ursprünglichen Typs aufgerufen wird. Sie müssen einen anderen Namen für die Parameter lose `ToString` Ersetzung angeben.  
  
     Im folgenden Beispiel werden zwei Methoden definiert, mit denen die <xref:System.Collections.Generic.List%601>-Klasse erweitert wird: eine parameterlose `ToString2`-Methode und eine `ToString`-Methode mit einem <xref:System.String> Parameter, der eine Format Zeichenfolge darstellt.  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-wrt"></a>Hinweise für den [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Wenn Sie die <xref:System.Object.ToString%2A>-Methode für eine Klasse in der [!INCLUDE[wrt](~/includes/wrt-md.md)]aufzurufen, wird das Standardverhalten für Klassen bereitstellt, die <xref:System.Object.ToString%2A>nicht überschreiben. Dies ist ein Teil der Unterstützung, die der .NET Framework für die [!INCLUDE[wrt](~/includes/wrt-md.md)] bietet (siehe [.NET Framework Support für Windows Store-Apps und Windows-Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Klassen im [!INCLUDE[wrt](~/includes/wrt-md.md)] erben <xref:System.Object>nicht und implementieren nicht immer eine <xref:System.Object.ToString%2A>. Allerdings scheinen Sie immer <xref:System.Object.ToString%2A>-, <xref:System.Object.Equals%28System.Object%29>-und <xref:System.Object.GetHashCode%2A>-Methoden zu haben, wenn Sie Sie C# im-oder-Visual Basic Code verwenden, und der .NET Framework stellt ein Standardverhalten für diese Methoden bereit.  
  
 Beginnend mit dem [!INCLUDE[net_v451](~/includes/net-v451-md.md)]verwendet das Common Language Runtime [istringable. Start String](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) für ein [!INCLUDE[wrt](~/includes/wrt-md.md)]-Objekt, bevor es auf die Standard Implementierung <xref:System.Object.ToString%2A?displayProperty=nameWithType>zurückfällt.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] Klassen, die in C# oder Visual Basic geschrieben sind, können die <xref:System.Object.ToString%2A>-Methode überschreiben.  
  
### <a name="the-wrt-and-the-istringable-interface"></a>Der [!INCLUDE[wrt](~/includes/wrt-md.md)] und die istringable-Schnittstelle  
 Beginnend mit [!INCLUDE[win81](~/includes/win81-md.md)]enthält die [!INCLUDE[wrt](~/includes/wrt-md.md)] eine [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) -Schnittstelle, deren einzige Methode, [istringable. destring](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), eine grundlegende Formatierungs Unterstützung bietet, die vergleichbar mit der von <xref:System.Object.ToString%2A?displayProperty=nameWithType>bereitgestellten ist. Um Mehrdeutigkeit zu vermeiden, sollten Sie [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) nicht für verwaltete Typen implementieren.  
  
 Wenn verwaltete Objekte von System eigenem Code oder von Code, der in Sprachen wie JavaScript oder C++/CX geschrieben ist, aufgerufen werden, scheinen Sie [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)zu implementieren. Der Common Language Runtime leitet automatisch Aufrufe von [istringable. destring](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) an <xref:System.Object.ToString%2A?displayProperty=nameWithType> in dem Ereignis, das [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) nicht für das verwaltete Objekt implementiert ist.  
  
> [!WARNING]
>  Da der Common Language Runtime die [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) -Schnittstelle für alle verwalteten Typen in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]-Apps automatisch implementiert, empfiehlt es sich, keine eigene [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) -Implementierung bereitzustellen. Die Implementierung von [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) kann beim Aufrufen von `ToString` aus [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX oder JavaScript zu unbeabsichtigtem Verhalten führen.  
  
 Wenn Sie [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in einem öffentlich verwalteten Typ implementieren möchten, der in eine [!INCLUDE[wrt](~/includes/wrt-md.md)] Komponente exportiert wird, gelten die folgenden Einschränkungen:  
  
-   Sie können die [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) -Schnittstelle nur in einer "Klasse implementiert"-Beziehung definieren, z. b.  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     in C# oder  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     in Visual Basic.  
  
-   Sie können [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) nicht in einer Schnittstelle implementieren.  
  
-   Sie können einen Parameter nicht als Typ [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)deklarieren.  
  
-   [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) kann nicht der Rückgabetyp einer Methode, einer Eigenschaft oder eines Felds sein.  
  
-   Sie können die [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) -Implementierung nicht aus Basisklassen ausblenden, indem Sie eine Methoden Definition wie die folgende verwenden:  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     Stattdessen muss die Implementierung [istringable. destring](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) die Basisklassen Implementierung immer überschreiben. Sie können eine `ToString`-Implementierung nur ausblenden, indem Sie sie auf einer stark typisierten Klasseninstanz aufrufen.  
  
 Beachten Sie, dass unter einer Vielzahl von Bedingungen Aufrufe von System eigenem Code zu einem verwalteten Typ, der [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementiert oder seine Implementierung von " [destring](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) " verbirgt, zu unerwartetem Verhalten führen können.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie eigene Typen implementieren, sollten Sie die <see cref="M:System.Object.ToString" />-Methode überschreiben, um Werte zurückzugeben, die für diese Typen von Bedeutung sind. Abgeleitete Klassen, die mehr Kontrolle über die Formatierung benötigen, als <see cref="M:System.Object.ToString" />, können die <see cref="T:System.IFormattable" />-Schnittstelle implementieren. Die <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" />-Methode ermöglicht Ihnen das Definieren von Format Zeichenfolgen, die die Formatierung steuern, und die Verwendung eines <see cref="T:System.IFormatProvider" /> Objekts, das die Kultur abhängige Formatierung bereitstellen kann.  
  
Für außer Kraft setzungen der <see cref="M:System.Object.ToString" /> Methode sollten folgende Richtlinien beachtet werden: 
-Die zurückgegebene Zeichenfolge sollte von Menschen benutzerfreundlich und lesbar sein.  
  
-Die zurückgegebene Zeichenfolge sollte den Wert der Objektinstanz eindeutig identifizieren.  
  
-Die zurückgegebene Zeichenfolge sollte so kurz wie möglich sein, damit Sie von einem Debugger angezeigt werden kann.  
  
-Die <see cref="M:System.Object.ToString" /> Überschreibung darf <see cref="F:System.String.Empty" /> oder eine NULL-Zeichenfolge nicht zurückgeben.  
  
-Die <see cref="M:System.Object.ToString" /> Überschreibung sollte keine Ausnahme auslösen.  
  
Wenn die Zeichen folgen Darstellung einer Instanz Kultur abhängig ist oder auf verschiedene Arten formatiert werden kann, implementieren Sie die <see cref="T:System.IFormattable" />-Schnittstelle.  
  
-Wenn die zurückgegebene Zeichenfolge vertrauliche Informationen enthält, sollten Sie zuerst eine entsprechende Berechtigung anfordern. Wenn die Anforderung erfolgreich ist, können Sie die vertraulichen Informationen zurückgeben. Andernfalls sollten Sie eine Zeichenfolge zurückgeben, in der die vertraulichen Informationen ausgeschlossen werden.  
  
-Die <see cref="M:System.Object.ToString" /> Außerkraftsetzung sollte keine beobachtbaren Nebeneffekte aufweisen, um Komplikationen beim Debuggen zu vermeiden. Beispielsweise sollte ein Aufrufder <see cref="M:System.Object.ToString" />-Methode nicht den Wert von Instanzfeldern ändern.  
  
-Wenn der Typ eine-Methode für die Methode implementiert (oder <see langword="Parse" /> oder <see langword="TryParse" /> Methode, einen Konstruktor oder eine andere statische Methode, die eine Instanz des Typs aus einer Zeichenfolge instanziiert), sollten Sie sicherstellen, dass die von der <see cref="M:System.Object.ToString" />-Methode zurückgegebene Zeichenfolge in eine Objektinstanz konvertiert werden kann.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>
