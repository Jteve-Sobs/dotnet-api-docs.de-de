<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6778182e96c45560805aa9f6c8cac64c818a8ff5" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70372790" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Unterstützt alle Klassen in der .NET-Klassenhierarchie und stellt abgeleiteten Klassen Low-Level-Dienste zur Verfügung. Dies ist die ultimative Basisklasse aller .NET-Klassen und stellt den Stamm der Typhierarchie dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen ist es in der Regel nicht erforderlich, eine <xref:System.Object> Klasse zu deklarieren, da die Vererbung implizit ist.  
  
 Da alle Klassen in .net von <xref:System.Object>abgeleitet sind, ist jede Methode, die in der <xref:System.Object> -Klasse definiert ist, in allen Objekten im System verfügbar. Abgeleitete Klassen können einige dieser Methoden außer Kraft setzen und überschreiben, einschließlich:  
  
-   <xref:System.Object.Equals%2A>: Unterstützt Vergleiche zwischen-Objekten.  
  
-   <xref:System.Object.Finalize%2A>: Führt Bereinigungs Vorgänge aus, bevor ein Objekt automatisch freigegeben wird.  
  
-   <xref:System.Object.GetHashCode%2A>-Generiert eine Zahl, die dem Wert des-Objekts entspricht, um die Verwendung einer Hash Tabelle zu unterstützen.  
  
-   <xref:System.Object.ToString%2A>: Stellt eine lesbare Text Zeichenfolge her, die eine Instanz der-Klasse beschreibt.  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Wenn Sie eine Klasse entwerfen, z. b. eine Auflistung, die einen beliebigen Objekttyp verarbeiten muss, können Sie Klassenmember erstellen, <xref:System.Object> die Instanzen der Klasse akzeptieren. Der Vorgang zum Boxing und Unboxing eines Typs führt jedoch zu Leistungseinbußen. Wenn Sie wissen, dass Ihre neue Klasse häufig bestimmte Werttypen behandelt, können Sie eine von zwei Taktiken verwenden, um die Kosten des Boxens zu minimieren.  
  
-   Erstellen Sie eine allgemeine Methode, die <xref:System.Object> einen-Typ akzeptiert, und einen Satz von typspezifischen Methoden Überladungen, die jeden Werttyp akzeptieren, der von der Klasse häufig verarbeitet wird. Wenn eine typspezifische Methode vorhanden ist, die den aufrufenden Parametertyp akzeptiert, erfolgt kein Boxing, und die typspezifische Methode wird aufgerufen. Wenn kein Methoden Argument vorhanden ist, das mit dem aufrufenden Parametertyp übereinstimmt, wird der-Parameter geachtelt, und die allgemeine-Methode wird aufgerufen.  
  
-   Entwerfen Sie Ihren Typ und seine Member, um Generika zu verwenden. Der Common Language Runtime erstellt einen geschlossenen generischen Typ, wenn Sie eine Instanz der Klasse erstellen und ein generisches Typargument angeben. Die generische Methode ist typspezifisch und kann aufgerufen werden, ohne den aufrufenden Parameter zu Boxing.  
  
 Obwohl es manchmal notwendig ist, allgemeine Klassen zu entwickeln, die Typen akzeptieren <xref:System.Object> und zurückgeben, können Sie die Leistung verbessern, indem Sie auch eine typspezifische Klasse zum Verarbeiten eines häufig verwendeten Typs bereitstellen. Wenn Sie beispielsweise eine Klasse angeben, die für das Festlegen und das erhalten von booleschen Werten spezifisch ist, werden die Kosten für das Boxing und das Unboxing von booleschen Werten vermieden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein von der <xref:System.Object> -Klasse abgeleiteter Punkttyp definiert, der viele der virtuellen Methoden <xref:System.Object> der-Klasse überschreibt. Außerdem wird im Beispiel gezeigt, wie viele statische Methoden und Instanzmethoden der <xref:System.Object> -Klasse aufgerufen werden.  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind Thread sicher. Instanzmember sind nicht garantiert Thread sicher.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Object" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird von Konstruktoren in abgeleiteten Klassen aufgerufen, kann aber auch verwendet werden, um direkt eine Instanz der <xref:System.Object> -Klasse zu erstellen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stellt fest, ob zwei Objektinstanzen gleich sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, das mit dem aktuellen Objekt verglichen werden soll.</param>
        <summary>Bestimmt, ob das angegebene Objekt mit dem aktuellen Objekt identisch ist.</summary>
        <returns><see langword="true" />, wenn das angegebene Objekt und das aktuelle Objekt gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Typ des Vergleichs zwischen der aktuellen Instanz und dem `obj` -Parameter hängt davon ab, ob es sich bei der aktuellen Instanz um einen Verweistyp oder einen Werttyp handelt.  
  
-   Wenn es sich bei der aktuellen Instanz um einen Verweistyp handelt, testet die <xref:System.Object.Equals%28System.Object%29> Methode auf Verweis Gleichheit, und ein Rückruf der <xref:System.Object.Equals%28System.Object%29> -Methode entspricht einem- <xref:System.Object.ReferenceEquals%2A> aufrufstyp. Verweis Gleichheit bedeutet, dass die zu vergleichenden Objektvariablen auf das gleiche Objekt verweisen. Das folgende Beispiel veranschaulicht das Ergebnis eines solchen Vergleichs. Es definiert eine `Person` -Klasse, bei der es sich um einen Verweistyp `Person` handelt, und ruft den-Klassenkonstruktor auf `person1a` , `person2`um zwei neue `Person` -Objekte, und, zu instanziieren, die denselben Wert aufweisen. Sie weist `person1a` auch einer anderen Objekt `person1b`Variablen () zu. Wie die Ausgabe des Beispiels zeigt, sind `person1a` und `person1b` gleich, da Sie auf dasselbe Objekt verweisen. `person1a` Und`person2` sind jedoch nicht gleich, obwohl Sie denselben Wert aufweisen.  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   Wenn die aktuelle Instanz ein Werttyp ist, <xref:System.Object.Equals%28System.Object%29> testet die Methode auf Wert Gleichheit. Wert Gleichheit bedeutet Folgendes:  
  
    -   Die beiden Objekte weisen denselben Typ auf. Wie im folgenden Beispiel gezeigt, ist <xref:System.Byte> ein-Objekt mit dem Wert 12 nicht mit einem <xref:System.Int32> Objekt identisch, das den Wert 12 aufweist, da die beiden-Objekte unterschiedliche Lauf Zeit Typen aufweisen.  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   Die Werte der öffentlichen und privaten Felder der beiden Objekte sind gleich. Im folgenden Beispiel wird auf Wert Gleichheit getestet. Er definiert eine `Person` -Struktur, bei der es sich um einen Werttyp handelt, und ruft den `Person` -Klassenkonstruktor `person1` auf `person2`, um zwei neue `Person` -Objekte, und, zu instanziieren. Wie die Ausgabe des Beispiels zeigt, sind die beiden Objektvariablen auf verschiedene Objekte verweisen, `person1` und `person2` sind gleich, da Sie den gleichen Wert für das private `personName` Feld aufweisen.  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 Da die <xref:System.Object> -Klasse die Basisklasse für alle Typen in der .NET Framework ist, <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> stellt die-Methode den Standard Gleichheits Vergleich für alle anderen Typen bereit. Typen überschreiben jedoch oft die <xref:System.Object.Equals%2A> -Methode, um Wert Gleichheit zu implementieren. Weitere Informationen finden Sie in den Abschnitten "Hinweise zu Aufrufern und Notizen für Vererbung".  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Hinweise zum[!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Wenn Sie die <xref:System.Object.Equals%28System.Object%29> -Methoden Überladung für eine Klasse [!INCLUDE[wrt](~/includes/wrt-md.md)]im aufrufen, stellt Sie das Standardverhalten für Klassen bereit, <xref:System.Object.Equals%28System.Object%29>die nicht überschreiben. Dies ist ein Teil der Unterstützung, die der .NET Framework für [!INCLUDE[wrt](~/includes/wrt-md.md)] bietet (siehe [.NET Framework-Unterstützung für Windows Store-Apps und Windows-Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Klassen in der [!INCLUDE[wrt](~/includes/wrt-md.md)] erben <xref:System.Object>nicht <xref:System.Object.Equals%28System.Object%29> und implementieren derzeit keine-Methode. Allerdings scheinen Sie die Methoden <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>und <xref:System.Object.GetHashCode%2A> zu haben, wenn Sie Sie im- C# oder-Visual Basic Code verwenden, und die .NET Framework stellt das Standardverhalten für diese Methoden bereit.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]Klassen, die in C# oder Visual Basic geschrieben sind, können <xref:System.Object.Equals%28System.Object%29> die-Methoden Überladung überschreiben.  
  
## <a name="notes-for-callers"></a>Hinweise für Aufrufer  
 Abgeleitete Klassen überschreiben <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> die-Methode häufig, um Wert Gleichheit zu implementieren. Außerdem stellen Typen häufig eine zusätzliche stark typisierte Überladung für die `Equals` -Methode bereit, in der Regel durch Implementieren der <xref:System.IEquatable%601> -Schnittstelle. Wenn Sie die `Equals` -Methode zum Testen auf Gleichheit aufzurufen, sollten Sie wissen, ob die aktuelle <xref:System.Object.Equals%2A?displayProperty=nameWithType> Instanz überschreibt und versteht, wie ein `Equals` bestimmter aufzurufende Methode aufgelöst wird. Andernfalls können Sie einen Test auf Gleichheit durchführen, der sich von der vorgesehenen Methode unterscheidet, und die Methode gibt möglicherweise einen unerwarteten Wert zurück.  
  
 Dies wird im folgenden Beispiel veranschaulicht. Es instanziiert drei <xref:System.Text.StringBuilder> -Objekte mit identischen Zeichen folgen und führt dann vier Aufrufe `Equals` von-Methoden aus. Der erste Methoden Rückruf gibt `true`zurück, und die restlichen drei `false`zurückgeben.  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 Im ersten Fall wird die stark typisierte <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> Methoden Überladung, die auf Wert Gleichheit testet, aufgerufen. Da die den zwei <xref:System.Text.StringBuilder> -Objekten zugewiesenen Zeichen folgen gleich sind, gibt die Methode zurück. `true` Allerdings wird von nicht <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>überschrieben. <xref:System.Text.StringBuilder> Dies geschieht, <xref:System.Text.StringBuilder> wenn das Objekt in eine <xref:System.Object>umgewandelt wird, wenn eine <xref:System.Text.StringBuilder> -Instanz einer Variablen vom Typ <xref:System.Object>zugewiesen wird und wenn der <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> Methode zwei <xref:System.Text.StringBuilder> Objekte übermittelt werden, der Standardwert <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>die Methode wird aufgerufen. Da <xref:System.Text.StringBuilder> ein Verweistyp ist, entspricht dies dem übergeben der beiden <xref:System.Text.StringBuilder> -Objekte an die <xref:System.Object.ReferenceEquals%2A> -Methode. Obwohl alle drei <xref:System.Text.StringBuilder> Objekte identische Zeichen folgen enthalten, verweisen Sie auf drei unterschiedliche Objekte. Folglich geben diese drei Methodenaufrufe zurück `false`.  
  
 Sie können das aktuelle-Objekt für Verweis Gleichheit mit einem anderen Objekt vergleichen, <xref:System.Object.ReferenceEquals%2A> indem Sie die-Methode aufrufen. In Visual Basic können Sie auch das `is` -Schlüsselwort verwenden ( `If Me Is otherObject Then ...`z. b.).  
  
## <a name="notes-for-inheritors"></a>Hinweise für Vererber  
 Wenn Sie einen eigenen Typ definieren, erbt dieser Typ die Funktionalität, die von `Equals` der-Methode seines Basistyps definiert wird. In der folgenden Tabelle ist die Standard Implementierung `Equals` der-Methode für die Hauptkategorien von Typen in der .NET Framework aufgeführt.  
  
|Typkategorie|Gleichheit definiert durch|Kommentare|  
|-------------------|-------------------------|--------------|  
|Direkt von abgeleitete Klasse<xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Verweis Gleichheit entspricht dem Aufrufen <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>von.|  
|Struktur|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|Wert Gleichheit; entweder direkter Byte-für-Byte-Vergleich oder Feld-für-Feld-Vergleich mithilfe von Reflektion.|  
|Enumeration|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|Werte müssen denselben Enumerationstyp und denselben zugrunde liegenden Wert aufweisen.|  
|delegate|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|Delegaten müssen denselben Typ mit identischen Aufruf Listen aufweisen.|  
|Interface|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Verweis Gleichheit.|  
  
 Für einen Werttyp sollten Sie immer über <xref:System.Object.Equals%2A>schreiben, da Tests auf Gleichheit, die auf Reflektion basieren, eine schlechte Leistung bieten. Sie können auch die Standard Implementierung von <xref:System.Object.Equals%2A> für Verweis Typen überschreiben, um auf Wert Gleichheit anstelle der Verweis Gleichheit zu testen und die genaue Bedeutung von Wert Gleichheit zu definieren. Solche Implementierungen von <xref:System.Object.Equals%2A> geben `true` zurück, wenn die beiden-Objekte denselben Wert aufweisen, auch wenn Sie nicht dieselbe Instanz sind. Der Implementierer des Typs entscheidet, was den Wert eines Objekts ausmacht, aber es handelt sich in der Regel um einige oder alle Daten, die in den Instanzvariablen des-Objekts gespeichert werden. Beispielsweise <xref:System.String> basiert der Wert eines-Objekts auf den Zeichen der Zeichenfolge. die <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> -Methode überschreibt die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> -Methode, um `true` für alle zwei Zeichen folgen Instanzen zurückzugeben, die die gleichen Zeichen in derselben Reihenfolge enthalten.  
  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> -Methode überschrieben wird, um auf Wert Gleichheit zu testen. Er überschreibt die <xref:System.Object.Equals%2A> -Methode für `Person` die-Klasse. Wenn `Person` die Basisklassen Implementierung von Gleichheit akzeptiert wird, `Person` sind zwei Objekte nur dann gleich, wenn Sie auf ein einzelnes Objekt verwiesen haben. In diesem Fall sind jedoch zwei `Person` -Objekte gleich, wenn Sie über denselben Wert für die `Person.Id` -Eigenschaft verfügen.  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 Zusätzlich zum über <xref:System.Object.Equals%2A>Schreiben von können Sie die <xref:System.IEquatable%601> -Schnittstelle implementieren, um einen stark typisierten Test auf Gleichheit bereitzustellen.  
  
 Die folgenden-Anweisungen müssen für alle Implementierungen der <xref:System.Object.Equals%28System.Object%29> -Methode den Wert "true" aufweisen. In `x`der Liste `y`stellen, und `z` Objekt Verweise dar, die nicht **null**sind.  
  
-   `x.Equals(x)`gibt `true`zurück, außer in Fällen, die Gleit Komma Typen einschließen. Siehe [ISO/IEC/IEEE 60559:2011, Informationstechnologie--Mikroprozessorsysteme--Gleit Komma Arithmetik](https://www.iso.org/standard/57469.html).  
  
-   `x.Equals(y)` gibt denselben Wert zurück wie `y.Equals(x)`.  
  
-   `x.Equals(y)`gibt `true` zurück, `x` Wenn `y` sowohl `NaN`als auch sind.  
  
-   Wenn `(x.Equals(y) && y.Equals(z))` zurück `true`gibt, `x.Equals(z)` gibt zurück`true`.  
  
-   Aufeinander folgende Aufrufe `x.Equals(y)` von geben denselben Wert zurück, solange die Objekte, auf `x` die `y` von und verwiesen wird, nicht geändert werden.  
  
-   `x.Equals(null)` gibt `false` zurück.  
  
 Implementierungen von <xref:System.Object.Equals%2A> dürfen keine Ausnahmen auslösen. Sie sollten immer einen Wert zurückgeben. Wenn `obj` <xref:System.Object.Equals%2A> `false` <xref:System.ArgumentNullException>beispielsweise den Wert hat,solltedieMethodezurückgeben,anstatteineauszulösen.`null`  
  
 Beachten Sie beim <xref:System.Object.Equals%28System.Object%29>überschreiben folgende Richtlinien:  
  
-   Typen, die <xref:System.IComparable> implementieren, <xref:System.Object.Equals%28System.Object%29>müssen überschreiben.  
  
-   Typen, die <xref:System.Object.Equals%28System.Object%29> überschreiben, <xref:System.Object.GetHashCode%2A>müssen ebenfalls überschreiben, andernfalls funktionieren Hash Tabellen möglicherweise nicht ordnungsgemäß.  
  
-   Sie sollten die <xref:System.IEquatable%601> -Schnittstelle implementieren, um stark typisierte Tests auf Gleichheit zu unterstützen. Ihre <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> Implementierung sollte Ergebnisse zurückgeben, die mit <xref:System.Object.Equals%2A>konsistent sind.  
  
-   Wenn Ihre Programmiersprache das Überladen von Operatoren unterstützt und Sie den Gleichheits Operator für einen bestimmten Typ überladen <xref:System.Object.Equals%28System.Object%29> , müssen Sie auch die-Methode überschreiben, um das gleiche Ergebnis wie der Gleichheits Operator zurückzugeben. Dadurch wird sichergestellt, dass sich der von <xref:System.Object.Equals%2A> verwendete Klassen Bibliotheks <xref:System.Collections.ArrayList> Code <xref:System.Collections.Hashtable>(z. b. und) so verhält, dass er mit der Art und Weise konsistent ist, wie der Gleichheits Operator von Anwendungscode verwendet wird.  
  
### <a name="guidelines-for-reference-types"></a>Richtlinien für Referenztypen  
 Die folgenden Richtlinien gelten <xref:System.Object.Equals%28System.Object%29> für die Überschreibung von für einen Verweistyp:  
  
-   Überschreiben Sie ggf., obdieSemantikdesTypsaufderTatsachebasiert,dassderTypeinigeWertedarstellt.<xref:System.Object.Equals%2A>  
  
-   Die meisten Verweis Typen dürfen den Gleichheits Operator nicht überladen, auch <xref:System.Object.Equals%2A>Wenn Sie überschreiben. Wenn Sie jedoch einen Verweistyp implementieren, der eine Wert Semantik aufweisen soll (z. b. ein komplexer Nummertyp), müssen Sie den Gleichheits Operator überschreiben.  
  
-   Sie sollten nicht für <xref:System.Object.Equals%2A> einen änderbaren Referenztyp überschreiben. Dies liegt daran <xref:System.Object.Equals%2A> , dass das Überschreiben von erfordert <xref:System.Object.GetHashCode%2A> , dass Sie auch die-Methode überschreiben, wie im vorherigen Abschnitt erläutert wurde. Dies bedeutet, dass sich der Hashcode einer Instanz eines änderbaren Verweis Typs während seiner Lebensdauer ändern kann, was dazu führen kann, dass das Objekt in einer Hash Tabelle verloren geht.  
  
### <a name="guidelines-for-value-types"></a>Richtlinien für Werttypen  
 Die folgenden Richtlinien gelten <xref:System.Object.Equals%28System.Object%29> für das Überschreiben für einen Werttyp:  
  
-   Wenn Sie einen Werttyp definieren, der ein oder mehrere Felder enthält, deren Werte Verweis Typen sind, sollten <xref:System.Object.Equals%28System.Object%29>Sie überschreiben. Die <xref:System.Object.Equals%28System.Object%29> von bereitgestellte <xref:System.ValueType> -Implementierung führt einen Byte-für-Byte-Vergleich für Werttypen durch, deren Felder alle Werttypen sind. Sie verwendet jedoch Reflektion, um einen Feld weisen Vergleich von Werttypen auszuführen, deren Felder Verweis Typen enthalten.  
  
-   Wenn Sie über <xref:System.Object.Equals%2A> schreiben und die Entwicklungssprache das Überladen von Operatoren unterstützt, müssen Sie den Gleichheits Operator überladen.  
  
-   Sie sollten die <xref:System.IEquatable%601> -Schnittstelle implementieren. Durch Aufrufen der stark <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> typisierten Methode wird `obj` das Boxing des Arguments vermieden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine `Point` -Klasse, die die <xref:System.Object.Equals%2A> -Methode überschreibt, um Wert Gleichheit `Point3D` bereitzustellen, und eine `Point`Klasse, die von abgeleitet wird. Da `Point` <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> überschreibt, umaufWertGleichheitzutesten,wirddie-Methodenichtaufgerufen.<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Allerdings `Point3D.Equals` wird `Point.Equals` von `Point` aufgerufen <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> , da in eine Weise implementiert, die Wert Gleichheit bereitstellt.  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 Die `Point.Equals` -Methode überprüft, ob das `obj` -Argument nicht **null** ist und verweist auf eine Instanz des gleichen Typs wie dieses Objekt. Wenn eine der beiden Überprüfungen fehlschlägt `false`, gibt die Methode zurück.  
  
 Die `Point.Equals` -Methode ruft <xref:System.Object.GetType%2A> die-Methode auf, um zu bestimmen, ob die Lauf Zeit Typen der beiden-Objekte identisch sind. Wenn die Methode eine über `obj is Point` Prüfung des Formulars in C# oder `TryCast(obj, Point)` Visual Basic verwendet hat, würde die Überprüfung `true` in Fällen zurück `obj` gegeben, in denen eine Instanz einer abgeleiteten Klasse von `obj` `Point`ist, obwohl und der die aktuelle Instanz ist nicht vom gleichen Lauf Zeittyp. Nachdem überprüft wurde, ob beide Objekte denselben Typ aufweisen, wandelt die Methode `obj` in den `Point` Typ um und gibt das Ergebnis des Vergleichs der Instanzfelder der beiden Objekte zurück.  
  
 In `Point3D.Equals`wird die geerbte `Point.Equals` Methode, die über <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>schreibt, aufgerufen, bevor etwas anderes ausgeführt wird. Da `Point3D` eine versiegelte Klasse (`NotInheritable` in Visual Basic) ist, ist eine Prüfung im `obj is Point` Formular C# in `TryCast(obj, Point)` oder in Visual Basic ausreichend, um sicher `obj` zustellen, `Point3D` dass ein-Objekt ist. Wenn es sich um `Point3D` ein-Objekt handelt, wird es `Point` in ein-Objekt umgewandelt und an die Basis <xref:System.Object.Equals%2A>Klassen Implementierung von übermittelt. Nur wenn die geerbte `Point.Equals` Methode zurückgibt `true` , vergleicht die `z` Methode die Instanzfelder, die in der abgeleiteten Klasse eingeführt wurden.  
  
 Im folgenden Beispiel wird eine `Rectangle` Klasse definiert, die intern ein Rechteck als `Point` zwei-Objekte implementiert. Die `Rectangle` -Klasse <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> überschreibt auch, um Wert Gleichheit bereitzustellen.  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 Einige Sprachen, wie C# z. b. und Visual Basic Unterstützung der Operator Überladung Wenn ein Typ den Gleichheits Operator überlädt, muss er auch die <xref:System.Object.Equals%28System.Object%29> -Methode überschreiben, um die gleiche Funktionalität bereitzustellen. Dies wird in der Regel erreicht, <xref:System.Object.Equals%28System.Object%29> indem die-Methode in Bezug auf den überladenen Gleichheits Operator geschrieben wird, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 Da `Complex` ein Werttyp ist, kann er nicht von abgeleitet werden.  Daher <xref:System.Object.Equals%28System.Object%29> muss die Außerkraftsetzungs Methode nicht aufgerufen <xref:System.Object.GetType%2A> werden, um den genauen Lauf Zeittyp der einzelnen Objekte zu bestimmen. stattdessen kann `is` der Operator C# in oder `TypeOf` der-Operator in Visual Basic verwendet werden, um den Typ der zu überprüfen. `obj` -Parameter.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Das erste zu vergleichende Objekt.</param>
        <param name="objB">Das zweite zu vergleichende Objekt.</param>
        <summary>Stellt fest, ob die angegebenen Objektinstanzen als gleich betrachtet werden.</summary>
        <returns><see langword="true" />, wenn die Objekte als gleich betrachtet werden, andernfalls <see langword="false" />. Wenn sowohl <paramref name="objA" />, als auch <paramref name="objB" /> **NULL** sind, gibt diese Methode <see langword="true" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die statische <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> -Methode gibt an, ob `objA` zwei `objB`-Objekte, und, gleich sind. Außerdem können Sie Objekte, deren Wert **null** ist, auf Gleichheit testen. Er vergleicht `objA` und `objB` auf Gleichheit wie folgt:  
  
-   Es bestimmt, ob die beiden-Objekte denselben Objekt Verweis darstellen. Wenn dies der Fall ist, gibt `true`die Methode zurück. Dieser Test entspricht dem Aufrufen der <xref:System.Object.ReferenceEquals%2A> -Methode. Wenn sowohl `objA` als auch `objB` **null**sind, gibt die Methode zurück `true`.  
  
-   Es bestimmt, ob `objA` entweder `objB` oder **null**ist. Wenn dies der Fall ist `false`, wird zurückgegeben.  
  
-   Wenn die beiden-Objekte nicht denselben Objekt Verweis darstellen und keines von **null**ist, wird aufgerufen `objA`.`Equals` (`objB`) und gibt das Ergebnis zurück. Dies bedeutet, dass `objA` diese außer Kraft <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Setzung aufgerufen wird, wenn die-Methode überschreibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> -Methode veranschaulicht und mit der <xref:System.Object.ReferenceEquals%2A> -Methode verglichen.  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Finalize() cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einem Objekt Gelegenheit zu dem Versuch, Ressourcen freizugeben und andere Bereinigungen durchzuführen, bevor es von der Garbage Collection freigegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Object.Finalize%2A> -Methode wird verwendet, um Bereinigungs Vorgänge für nicht verwaltete Ressourcen durchzuführen, die vom aktuellen-Objekt aufbewahrt werden, bevor das-Objekt zerstört wird. Die-Methode ist geschützt und kann daher nur über diese Klasse oder eine abgeleitete Klasse aufgerufen werden.  
  
 In diesem Abschnitt  
  
-   [Funktionsweise der Finalisierung](#How)  
  
-   [Hinweise für Implementierer](#Notes)  
  
-   [Die SafeHandle-Alternative](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>Funktionsweise der Finalisierung  
 Die <xref:System.Object> -Klasse stellt keine Implementierung für <xref:System.Object.Finalize%2A> die-Methode bereit, und die Garbage Collector markiert keine von <xref:System.Object> abgeleiteten Typen für die Finalisierung <xref:System.Object.Finalize%2A> , es sei denn, Sie überschreiben die Methode.  
  
 Wenn ein Typ die <xref:System.Object.Finalize%2A> -Methode überschreibt, fügt der Garbage Collector einen Eintrag für jede Instanz des Typs einer internen Struktur hinzu, die als Abschluss Queue bezeichnet wird. Die Finalisierungswarteschlange enthält Einträge für alle Objekte im verwalteten Heap, deren Finalisierungscode ausgeführt werden muss, bevor der Garbage Collector den Speicher freigeben kann. Der Garbage Collector Ruft die <xref:System.Object.Finalize%2A> Methode dann unter den folgenden Bedingungen automatisch auf:  
  
-   Nachdem der Garbage Collector ermittelt hat, dass auf ein Objekt nicht mehr zugegriffen werden kann, es sei denn, das Objekt wurde von der <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> Finalisierung durch einen-aufzurufenden aufgerufen.  
  
-   **Nur auf .NET Framework**, wenn eine Anwendungsdomäne heruntergefahren wird, es sei denn, das Objekt ist von der Finalisierung ausgenommen. Während des herunter Fahrens werden auch Objekte, die weiterhin zugänglich sind, fertiggestellt.  
  
 <xref:System.Object.Finalize%2A>wird automatisch nur einmal für eine bestimmte-Instanz aufgerufen, es sei denn, das Objekt wird mithilfe eines Mechanismus wie <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> neu registriert, und die <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> -Methode wurde nachfolgend nicht aufgerufen.  
  
 <xref:System.Object.Finalize%2A>für Vorgänge gelten die folgenden Einschränkungen:  
  
-   Die genaue Zeit, zu der der Finalizer ausgeführt wird, ist nicht definiert. Um die deterministische Freigabe von Ressourcen für Instanzen Ihrer Klasse sicherzustellen, implementieren `Close` Sie eine-Methode <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> , oder stellen Sie eine-Implementierung bereit.  
  
-   Die Finalizer von zwei Objekten sind nicht garantiert, dass Sie in einer bestimmten Reihenfolge ausgeführt werden, auch wenn ein Objekt auf das andere Objekt verweist. Das heißt, wenn Objekt a einen Verweis auf Objekt b hat und beide über Finalizer verfügen, wurde Objekt B möglicherweise bereits abgeschlossen, wenn der Finalizer von Objekt A gestartet wird.  
  
-   Der Thread, auf dem der Finalizer ausgeführt wird, ist nicht angegeben.  
  
 Die <xref:System.Object.Finalize%2A> Methode kann möglicherweise nicht vollständig ausgeführt werden oder unter den folgenden außergewöhnlichen Umständen überhaupt nicht ausgeführt werden:  
  
-   Wenn ein anderer Finalizer unbegrenzt blockiert wird (in eine Endlosschleife wechselt, versucht, eine Sperre zu erhalten, die er niemals abrufen kann usw.). Da die Laufzeit versucht, Finalizer für den Abschluss auszuführen, werden möglicherweise andere Finalizer nicht aufgerufen, wenn ein Finalizer unbegrenzt blockiert wird.  
  
-   , Wenn der Prozess beendet wird, ohne der Laufzeit die Möglichkeit zu geben, zu bereinigen. In diesem Fall ist die erste Benachrichtigung des Prozesses bei der Beendigung der Laufzeit eine DLL_PROCESS_DETACH-Benachrichtigung.  
  
 Die Laufzeit setzt das Beenden von Objekten während des herunter Fahrens fort, während die Anzahl der finalisierbaren Objekte weiterhin abnimmt.  
  
 Wenn <xref:System.Object.Finalize%2A> oder eine außer Kraft <xref:System.Object.Finalize%2A> Setzung von eine Ausnahme auslöst und die Laufzeit nicht von einer Anwendung gehostet wird, die die Standard Richtlinie überschreibt, beendet die Common Language Runtime den `try` Prozess und keine aktiven / `finally` Blöcke. Finalizer werden ausgeführt. Durch dieses Verhalten wird die Prozess Integrität sichergestellt, wenn der Finalizer Ressourcen nicht freigeben oder zerstören kann.  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Überschreiben der Finalize-Methode 
 Sie sollten für <xref:System.Object.Finalize%2A> eine Klasse außer Kraft setzen, die nicht verwaltete Ressourcen verwendet, z. b. Datei Handles oder Datenbankverbindungen, die freigegeben werden müssen, wenn das verwaltete Objekt, das Sie verwendet, während Garbage Collection verworfen wird. Sie sollten keine <xref:System.Object.Finalize%2A> Methode für verwaltete Objekte implementieren, da die Garbage Collector verwaltete Ressourcen automatisch freigibt.  
  
> [!IMPORTANT]
>  Wenn ein <xref:System.Runtime.InteropServices.SafeHandle> -Objekt verfügbar ist, das Ihre nicht verwaltete Ressource umschließt, empfiehlt es sich, das Lösch Muster mit einem sicheren Handle zu implementieren <xref:System.Object.Finalize%2A>und nicht überschreiben. Weitere Informationen finden Sie im Abschnitt " [SafeHandle-Alternative](#SafeHandle) ".  
  
 Die <xref:System.Object.Finalize%2A?displayProperty=nameWithType> -Methode führt standardmäßig keine Aktion aus, Sie <xref:System.Object.Finalize%2A> sollten jedoch nur bei Bedarf überschreiben und nur nicht verwaltete Ressourcen freigeben. Das Freigeben des Speichers dauert tendenziell viel länger, wenn ein Abschluss Vorgang ausgeführt wird, da er mindestens zwei Garbage Collections erfordert. Außerdem sollten Sie die <xref:System.Object.Finalize%2A> -Methode nur für Verweis Typen überschreiben. Der Common Language Runtime der nur Verweis Typen finalisiert. Finalizer werden für Werttypen ignoriert.  

Der Gültigkeitsbereich <xref:System.Object.Finalize%2A?displayProperty=nameWithType> der- `protected`Methode ist. Sie sollten diesen eingeschränkten Gültigkeitsbereich beibehalten, wenn Sie die Methode in der Klasse überschreiben. Wenn Sie eine <xref:System.Object.Finalize%2A> Methode schützen, verhindern Sie, dass Benutzer der Anwendung die- <xref:System.Object.Finalize%2A> Methode eines Objekts direkt aufrufen.
  
 Jede Implementierung von <xref:System.Object.Finalize%2A> in einem abgeleiteten Typ muss die Implementierung von des <xref:System.Object.Finalize%2A>Basistyps aufzurufen. Dies ist der einzige Fall, in dem Anwendungscode aufgerufen <xref:System.Object.Finalize%2A>werden darf. Die- <xref:System.Object.Finalize%2A> Methode eines Objekts sollte keine Methode für andere Objekte als die seiner Basisklasse aufzurufen. Der Grund hierfür ist, dass das aufrufende Objekt möglicherweise zur gleichen Zeit an die Garbage Collection übergeben wird wie die anderen aufgerufenen Objekte, z. B. wenn eine Common Language Runtime beendet wird. 
  
> [!NOTE]
>  Der C# Compiler lässt nicht zu, dass Sie die <xref:System.Object.Finalize%2A> -Methode überschreiben. Stattdessen stellen Sie einen Finalizer bereit, indem Sie einen [debugtor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) für Ihre Klasse implementieren. Ein C# Dekonstruktor ruft automatisch den Dekonstruktor der Basisklasse auf.  
>   
>  Visual C++ bietet auch eine eigene Syntax für die Implementierung <xref:System.Object.Finalize%2A> der-Methode. Weitere Informationen finden Sie im Abschnitt "debugtoren und Finalizer" unter [Gewusst wie: Definieren und Verarbeiten von Klassen und Strukturen (C++/CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).  
  
 Da Garbage Collection nicht deterministisch ist, wissen Sie nicht genau, wann der Garbage Collector die Finalisierung ausführt. Um Ressourcen sofort freizugeben, können Sie auch das Verwerfen- [Muster](~/docs/standard/garbage-collection/implementing-dispose.md) und die <xref:System.IDisposable> -Schnittstelle implementieren. Die <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> -Implementierung kann von Consumern der-Klasse aufgerufen werden, um nicht verwaltete Ressourcen freizugeben, und <xref:System.Object.Finalize%2A> Sie können die-Methode verwenden, um nicht verwaltete Ressourcen <xref:System.IDisposable.Dispose%2A> freizugeben, wenn die-Methode nicht aufgerufen wird.  
  
 <xref:System.Object.Finalize%2A>kann fast jede Aktion ausführen, einschließlich der Wiederaufnahme eines Objekts (d. h., das Objekt kann wieder zugänglich gemacht werden), nachdem es während der Garbage Collection bereinigt wurde. Das Objekt kann jedoch nur einmal wieder auferstanden werden. <xref:System.Object.Finalize%2A> kann nicht für wiederbelebte Objekte während Garbage Collection aufgerufen werden.
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>Die SafeHandle-Alternative  
 Das Erstellen zuverlässiger Finalizer ist oft schwierig, da Sie keine Annahmen über den Zustand der Anwendung treffen können und weil nicht behandelte System Ausnahmen wie <xref:System.OutOfMemoryException> und <xref:System.StackOverflowException> den Finalizer beenden. Anstatt einen Finalizer für die Klasse zu implementieren, um nicht verwaltete Ressourcen freizugeben, können Sie ein Objekt verwenden, das von <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> der-Klasse abgeleitet wird, um die nicht verwalteten Ressourcen zu umschließen, und dann das Lösch Muster ohne Finalizer implementieren. Der .NET Framework stellt die folgenden Klassen im <xref:Microsoft.Win32?displayProperty=nameWithType> -Namespace bereit, die von <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>abgeleitet sind:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>ist eine Wrapper Klasse für ein Datei handle.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>ist eine Wrapper Klasse für im Speicher abgebildete Datei Handles.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle>ist eine Wrapper Klasse für einen Zeiger auf einen Block von nicht verwaltetem Arbeitsspeicher.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle> und<xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> sind Wrapper Klassen für kryptografische Handles.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle>ist eine Wrapper Klasse für Pipehandles.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>ist eine Wrapper Klasse für ein Handle für einen Registrierungsschlüssel.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>ist eine Wrapper Klasse für ein Wait-Handle.  
  
 Im folgenden Beispiel wird das Verwerfen- [Muster](~/docs/standard/garbage-collection/implementing-dispose.md) mit sicheren Handles verwendet, anstatt <xref:System.Object.Finalize%2A> die-Methode zu überschreiben. Es definiert eine `FileAssociation` Klasse, die Registrierungsinformationen über die Anwendung umschließt, die Dateien mit einer bestimmten Dateierweiterung verarbeitet. Die beiden Registrierungs Handles, die `out` von Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) -Funktionsaufrufen als Parameter zurückgegeben <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> werden, werden an den-Konstruktor übergeben. Die geschützte `Dispose` -Methode des Typs ruft dann `SafeRegistryHandle.Dispose` die-Methode auf, um diese beiden Handles freizugeben.  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird überprüft, ob <xref:System.Object.Finalize%2A> die-Methode aufgerufen wird, wenn ein Objekt <xref:System.Object.Finalize%2A> , das überschreibt, zerstört wird. Beachten Sie, dass die <xref:System.Object.Finalize%2A> -Methode in einer Produktionsanwendung außer Kraft gesetzt wird, um nicht verwaltete Ressourcen freizugeben, die vom-Objekt aufbewahrt werden. Beachten Sie außerdem, C# dass das Beispiel einen Dekonstruktor bereitstellt <xref:System.Object.Finalize%2A> , anstatt die-Methode zu überschreiben.  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 Ein weiteres Beispiel, das die <xref:System.Object.Finalize%2A> -Methode überschreibt, finden Sie unter der <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> -Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fungiert als Standardhashfunktion.</summary>
        <returns>Ein Hashcode für das aktuelle Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Hashcode ist ein numerischer Wert, der verwendet wird, um ein Objekt in einer Hash basierten Auflistung (z. b <xref:System.Collections.Generic.Dictionary%602> . die- <xref:System.Collections.Hashtable> Klasse, die-Klasse oder einen von <xref:System.Collections.DictionaryBase> der-Klasse abgeleiteten Typ) einzufügen und zu identifizieren. Die <xref:System.Object.GetHashCode%2A> -Methode stellt diesen Hashcode für Algorithmen bereit, die schnelle Überprüfungen der Objekt Gleichheit benötigen.  
  
> [!NOTE]
>  Informationen zur Verwendung von Hashcodes in Hash Tabellen und einige zusätzliche Hash Code Algorithmen finden Sie im Eintrag [Hash Function](https://en.wikipedia.org/wiki/Hash_function) in Wikipedia.  
  
 Zwei Objekte, die gleich sind, gleichmäßige Rückgabe Hashcodes sind gleich. Umgekehrt ist dies jedoch nicht der Fall: gleiche Hashcodes implizieren keine Objekt Gleichheit, da verschiedene (ungleich) Objekte identische Hashcodes aufweisen können. Darüber hinaus garantiert .net nicht die Standard Implementierung <xref:System.Object.GetHashCode%2A> der-Methode, und der von dieser Methode zurückgegebene Wert kann sich zwischen .net-Implementierungen unterscheiden, wie z. b. unterschiedlichen Versionen von .NET Framework und .net Core und Plattformen wie 32 Bit und 64-Bit-Plattformen. Verwenden Sie aus diesen Gründen nicht die Standard Implementierung dieser Methode als eindeutigen Objekt Bezeichner für Hash Zwecke. Es folgen zwei Konsequenzen:  
  
-   Sie sollten nicht davon ausgehen, dass die gleichen Hashcodes Objekt Gleichheit implizieren.  
  
-   Sie sollten niemals einen Hashcode außerhalb der Anwendungsdomäne beibehalten oder verwenden, in der er erstellt wurde, da das gleiche Objekt über Anwendungs Domänen, Prozesse und Plattformen hinweg einen Hash durchführen kann.  
  
> [!WARNING]
>  Ein Hashcode ist für die effiziente Einfügung und Suche in Auflistungen vorgesehen, die auf einer Hash Tabelle basieren. Ein Hashcode ist kein dauerhafter Wert. Aus diesem Grund:  
>   
> -   Serialisieren Sie keine Hash Code Werte, oder speichern Sie Sie nicht in Datenbanken.  
> -   Verwenden Sie den Hashcode nicht als Schlüssel zum Abrufen eines Objekts aus einer Schlüssel gebundenen Auflistung.  
> -   Senden Sie keine Hashcodes über Anwendungs Domänen oder Prozesse hinweg. In einigen Fällen können Hashcodes pro Prozess oder pro Anwendungsdomäne berechnet werden.  
> -   Verwenden Sie nicht den Hashcode anstelle eines Werts, der von einer kryptografischen Hash Funktion zurückgegeben wird, wenn Sie einen kryptografisch starken Hash benötigen. Verwenden Sie für kryptografische Hashes eine Klasse, die von <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> der <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> -Klasse oder der-Klasse abgeleitet ist.  
> -   Testen Sie nicht auf Gleichheit von Hashcodes, um zu bestimmen, ob zwei Objekte gleich sind. (Ungleiche Objekte können identische Hashcodes aufweisen.) Um auf Gleichheit zu testen, müssen <xref:System.Object.ReferenceEquals%2A> Sie <xref:System.Object.Equals%2A> die-Methode oder die-Methode  
  
 Die <xref:System.Object.GetHashCode%2A> Methode kann durch einen abgeleiteten Typ überschrieben werden. Wenn <xref:System.Object.GetHashCode%2A> nicht überschrieben wird, werden Hashcodes für Verweis Typen berechnet, indem die <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> -Methode der Basisklasse aufgerufen wird, die einen Hashcode auf der Grundlage eines Objekt Verweises berechnet. Weitere Informationen finden <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>Sie unter. Mit anderen Worten, zwei Objekte, für die <xref:System.Object.ReferenceEquals%2A> die Methode `true` zurückgibt, haben identische Hashcodes. Wenn Werttypen nicht über <xref:System.Object.GetHashCode%2A>schreiben, <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> verwendet die-Methode der Basisklasse Reflektion, um den Hashcode basierend auf den Werten der Felder des Typs zu berechnen. Anders ausgedrückt: Werttypen, deren Felder gleich sind, haben gleiche Hashcodes. Weitere Informationen zum über <xref:System.Object.GetHashCode%2A>Schreiben von finden Sie im Abschnitt "Hinweise zu Vererbung".  
  
> [!WARNING]
>  Wenn Sie die <xref:System.Object.GetHashCode%2A> -Methode überschreiben, sollten Sie <xref:System.Object.Equals%2A>auch überschreiben und umgekehrt. Wenn die überschriebene <xref:System.Object.Equals%2A> Methode `true` zurückgibt, wenn zwei Objekte auf Gleichheit getestet werden, <xref:System.Object.GetHashCode%2A> muss die überschriebene Methode den gleichen Wert für die beiden Objekte zurückgeben.  
  
 Wenn ein Objekt, das als Schlüssel in einer Hash Tabelle verwendet wird, keine nützliche Implementierung von <xref:System.Object.GetHashCode%2A>bereitstellt, können Sie einen Hashcode-Anbieter angeben, indem Sie eine <xref:System.Collections.IEqualityComparer> -Implementierung für eine der über Ladungen <xref:System.Collections.Hashtable> des-Klassenkonstruktors bereitstellen.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Hinweise zum[!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Wenn Sie die <xref:System.Object.GetHashCode%2A> -Methode für eine Klasse in der [!INCLUDE[wrt](~/includes/wrt-md.md)]-Klasse aufzurufen, wird das Standardverhalten für Klassen <xref:System.Object.GetHashCode%2A>bereitstellt, die nicht überschreiben. Dies ist ein Teil der Unterstützung, die der .NET Framework für [!INCLUDE[wrt](~/includes/wrt-md.md)] bietet (siehe [.NET Framework-Unterstützung für Windows Store-Apps und Windows-Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Klassen in der [!INCLUDE[wrt](~/includes/wrt-md.md)] erben <xref:System.Object>nicht <xref:System.Object.GetHashCode%2A>und implementieren derzeit nicht. Allerdings scheinen Sie die Methoden <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>und <xref:System.Object.GetHashCode%2A> zu haben, wenn Sie Sie im- C# oder-Visual Basic Code verwenden, und die .NET Framework stellt das Standardverhalten für diese Methoden bereit.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]Klassen, die in C# oder Visual Basic geschrieben sind, können <xref:System.Object.GetHashCode%2A> die-Methode überschreiben.  
  
   
  
## Examples  
 Eine der einfachsten Möglichkeiten, einen Hashcode für einen numerischen Wert zu berechnen, der denselben oder einen kleineren Bereich aufweist als der <xref:System.Int32> -Typ, besteht darin, diesen Wert einfach zurückzugeben. Das folgende Beispiel zeigt eine solche Implementierung für eine `Number` -Struktur.  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 Häufig verfügt ein Typ über mehrere Datenfelder, die an der Erstellung des Hashcodes beteiligt sein können. Eine Möglichkeit, einen Hashcode zu generieren, besteht darin, diese Felder `XOR (eXclusive OR)` mithilfe eines-Vorgangs zu kombinieren, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 Im vorherigen Beispiel wird derselbe Hashcode für (N1, N2) und (N2, N1) zurückgegeben, sodass möglicherweise mehr Kollisionen generiert, als wünschenswert sind. Es stehen eine Reihe von Lösungen zur Verfügung, sodass Hashcodes in diesen Fällen nicht identisch sind. Eine besteht darin, den Hashcode eines `Tuple` -Objekts zurückzugeben, das die Reihenfolge der einzelnen Felder widerspiegelt. Das folgende Beispiel zeigt eine mögliche Implementierung, die die <xref:System.Tuple%602> -Klasse verwendet. Beachten Sie jedoch, dass sich der Leistungs Aufwand beim Instanziieren `Tuple` eines-Objekts erheblich auf die Gesamtleistung einer Anwendung auswirken kann, in der eine große Anzahl von Objekten in Hash Tabellen gespeichert wird.  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 Eine zweite Alternative Lösung besteht darin, die einzelnen Hashcodes zu gewichten, indem die Hashcodes aufeinander folgender Felder um zwei oder mehr Bits verschoben werden. Anstatt verworfen zu werden, sollten Bits, die über Bit 31 hinaus verschoben werden, umschlossen werden, anstatt verworfen zu werden. Da Bits von den Left Shift-Operatoren sowohl C# in als auch Visual Basic verworfen werden, muss eine Left Shift-and-Wrap-Methode wie die folgende erstellt werden:  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 Im folgenden Beispiel wird dann diese Shift-and-Wrap-Methode verwendet, um den Hashcode der `Point` Struktur zu berechnen, die in den vorherigen Beispielen verwendet wurde.  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Eine Hash Funktion wird verwendet, um schnell eine Zahl (Hashcode) zu generieren, die dem Wert eines Objekts entspricht. Hash Funktionen sind in der Regel für jeden Typ spezifisch und müssen aus Gründen der Eindeutigkeit mindestens eines der Instanzfelder als Eingabe verwenden. Hashcodes sollten nicht mithilfe der Werte statischer Felder berechnet werden.  
  
Bei Klassen, die <see cref="T:System.Object" />von abgeleitet <see langword="GetHashCode" /> werden, kann die-Methode nur <see cref="M:System.Object.GetHashCode" /> an die Basisklassen Implementierung delegieren, wenn die abgeleitete Klasse Gleichheit als Verweis Gleichheit definiert. Die Standard Implementierung von <see cref="M:System.Object.GetHashCode" /> für Verweis Typen gibt einen Hashcode zurück, der dem von der <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> -Methode zurückgegebenen Hashcode entspricht. Sie können für <see cref="M:System.Object.GetHashCode" /> unveränderliche Verweis Typen überschreiben. Im Allgemeinen sollten Sie für änderbare Verweis Typen nur Folgendes über <see cref="M:System.Object.GetHashCode" /> schreiben: 
-Sie können den Hashcode aus Feldern berechnen, die nicht änderbar sind. noch 
-Sie können sicherstellen, dass sich der Hashcode eines änderbaren Objekts nicht ändert, während das Objekt in einer Auflistung enthalten ist, die auf seinem Hashcode basiert.  
  
Andernfalls denken Sie möglicherweise, dass das änderbare Objekt in der Hash Tabelle verloren geht. Wenn Sie für einen änderbaren <see cref="M:System.Object.GetHashCode" /> Referenztyp überschreiben möchten, sollte in der Dokumentation deutlich werden, dass die Benutzer des Typs Objektwerte nicht ändern sollten, während das Objekt in einer Hash Tabelle gespeichert wird.  
  
Für Werttypen <see cref="M:System.ValueType.GetHashCode" /> stellt eine standardmäßige Hashcode-Implementierung bereit, die Reflektion verwendet. Sie sollten diese überschreiben, um die Leistung zu verbessern.  
  
 <block subset="none" type="note"><para>  
 Weitere Informationen und Beispiele, in denen Hashcodes auf unterschiedlichste Weise berechnet werden, finden Sie im Abschnitt "Beispiele".  
  
</para></block>  
  
 Eine Hash Funktion muss über die folgenden Eigenschaften verfügen: 
-Wenn zwei-Objekte als gleich verglichen werden <see cref="M:System.Object.GetHashCode" /> , muss die-Methode für jedes Objekt denselben Wert zurückgeben. Wenn jedoch zwei-Objekte nicht als gleich verglichen werden, müssen <see cref="M:System.Object.GetHashCode" /> die Methoden für die beiden-Objekte keine anderen Werte zurückgeben.  
  
-Die <see cref="M:System.Object.GetHashCode" /> -Methode für ein Objekt muss den gleichen Hashcode immer wieder zurückgeben, solange keine Änderung des Objekt Zustands vorliegt, der den Rückgabewert der [System. Object. gleich](xref:System.Object.Equals*) -Methode des Objekts bestimmt. Beachten Sie, dass dies nur für die aktuelle Ausführung einer Anwendung gilt und dass ein anderer Hashcode zurückgegeben werden kann, wenn die Anwendung erneut ausgeführt wird.  
  
-Für eine optimale Leistung sollte eine Hash Funktion eine gleichmäßige Verteilung für alle Eingaben generieren, einschließlich der stark gruppierten Eingaben. Dies impliziert, dass kleine Änderungen am Objektzustand zu großen Änderungen am resultierenden Hashcode führen sollten, um die beste Leistung der Hash Tabelle zu erzielen.  
  
-Hash Funktionen sollten für die Berechnung günstig sein.  
  
-Die <see cref="M:System.Object.GetHashCode" /> Methode sollte keine Ausnahmen auslösen.  
  
Beispielsweise gibt die Implementierung <see cref="M:System.String.GetHashCode" /> der-Methode, die von der <see cref="T:System.String" /> -Klasse bereitgestellt wird, identische Hashcodes für identische Zeichen folgen Werte zurück. Daher geben zwei <see cref="T:System.String" /> -Objekte denselben Hashcode zurück, wenn Sie denselben Zeichen folgen Wert darstellen. Außerdem verwendet die-Methode alle Zeichen in der Zeichenfolge, um eine relativ zufällig verteilte Ausgabe zu generieren, auch wenn die Eingabe in bestimmten Bereichen gruppiert ist (z. b. können viele Benutzer Zeichen folgen haben, die nur die unteren 128 ASCII-Zeichen enthalten, auch wenn eine die Zeichenfolge kann jedes der 65.535 Unicode-Zeichen enthalten.)  
  
Das Bereitstellen einer guten Hash Funktion für eine Klasse kann die Leistung beim Hinzufügen dieser Objekte zu einer Hash Tabelle erheblich beeinträchtigen. In einer Hash Tabelle mit Schlüsseln, die eine gute Implementierung einer Hash Funktion bereitstellen, benötigt das Suchen nach einem Element Konstante Zeit (z. b. ein O (1)-Vorgang). In einer Hash Tabelle, bei der die Implementierung einer Hash Funktion unzureichend ist, hängt die Leistung einer Suche von der Anzahl der Elemente in der Hash Tabelle ab (z. b.`n`einem O () `n` -Vorgang, wobei die Anzahl der Elemente in der Hash Tabelle ist). Ein böswilliger Benutzer kann Daten eingeben, die die Anzahl der Konflikte erhöhen. Dies kann die Leistung von Anwendungen, die von Hash Tabellen abhängen, unter den folgenden Bedingungen erheblich beeinträchtigen: 
-Wenn Hash Funktionen häufige Konflikte verursachen.  
  
: Wenn ein großer Anteil von Objekten in einer Hash Tabelle Hashcodes erzeugt, die gleich oder ungefähr gleich zueinander sind.  
  
: Wenn Benutzer die Daten eingeben, aus denen der Hashcode berechnet wird.  
  
Abgeleitete Klassen, <see cref="M:System.Object.GetHashCode" /> die überschreiben <see cref="M:System.Object.Equals(System.Object)" /> , müssen auch überschreiben, um sicherzustellen, dass zwei Objekte, die als <see cref="T:System.Collections.Hashtable" /> gleich betrachtet werden, denselben Hashcode aufweisen. andernfalls funktioniert der Typ möglicherweise nicht</para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den <see cref="T:System.Type" /> der aktuellen Instanz ab.</summary>
        <returns>Der genaue Laufzeittyp der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da <xref:System.Object?displayProperty=nameWithType> die Basisklasse für alle Typen im .net-Typsystem ist, kann <xref:System.Object.GetType%2A> die-Methode verwendet werden, <xref:System.Type> um-Objekte zurückzugeben, die alle .NET-Typen darstellen. .Net erkennt die folgenden fünf Kategorien von Typen:  
  
-   Klassen, die von <xref:System.Object?displayProperty=nameWithType>abgeleitet sind,  
  
-   Werttypen, die von <xref:System.ValueType?displayProperty=nameWithType>abgeleitet werden.  
  
-   Schnittstellen, die von <xref:System.Object?displayProperty=nameWithType> abgeleitet sind, beginnend mit dem .NET Framework 2,0.  
  
-   Enumerationen, die von <xref:System.Enum?displayProperty=nameWithType>abgeleitet werden.  
  
-   Delegaten, die von <xref:System.MulticastDelegate?displayProperty=nameWithType>abgeleitet werden.  
  
 Bei zwei- `x` `y` Objekten, die identische Lauf Zeit Typen `Object.ReferenceEquals(x.GetType(),y.GetType())` aufweisen `true`, wird zurückgegeben. Im folgenden Beispiel wird die <xref:System.Object.GetType%2A> -Methode mit <xref:System.Object.ReferenceEquals%2A> der-Methode verwendet, um zu bestimmen, ob ein numerischer Wert dem gleichen Typ wie zwei andere numerische Werte entspricht.  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  Um zu ermitteln, ob ein Objekt ein bestimmter Typ ist, können Sie das typvergleichs Schlüsselwort oder das Konstrukt ihrer Sprache verwenden. Beispielsweise können Sie das `TypeOf…Is` -Konstrukt in Visual Basic oder das `is` -Schlüsselwort C#in verwenden.  
  
 Die <xref:System.Object.GetType%2A> -Methode wird von allen Typen geerbt, die <xref:System.Object>von abgeleitet werden. Dies bedeutet, dass Sie zusätzlich zur Verwendung des Vergleichs Schlüsselworts ihrer eigenen Sprache die- <xref:System.Object.GetType%2A> Methode verwenden können, um den Typ eines bestimmten Objekts zu bestimmen, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 Das <xref:System.Type> -Objekt macht die Metadaten verfügbar, die der-Klasse <xref:System.Object>der aktuellen zugeordnet sind.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht <xref:System.Object.GetType%2A> , dass den Lauf Zeittyp der aktuellen Instanz zurückgibt.  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine flache Kopie des aktuellen <see cref="T:System.Object" />.</summary>
        <returns>Eine flache Kopie des aktuellen <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Object.MemberwiseClone%2A> -Methode erstellt eine flache Kopie, indem ein neues-Objekt erstellt und dann die nicht statischen Felder des aktuellen-Objekts in das neue-Objekt kopiert werden. Wenn ein Feld ein Werttyp ist, wird eine Bit-für-Bit-Kopie des Felds ausgeführt. Wenn ein Feld ein Referenztyp ist, wird der Verweis kopiert, aber das Objekt, auf das verwiesen wird, nicht. Daher verweisen das ursprüngliche Objekt und der zugehörige Klon auf dasselbe Objekt.  
  
 Angenommen, ein Objekt mit dem Namen X verweist auf die Objekte A und B. Object B wiederum verweist auf Objekt C. Eine flache Kopie von X erstellt ein neues Objekt x2, das auch auf die Objekte A und B verweist. Im Gegensatz dazu erstellt eine tiefe Kopie von X ein neues Objekt x2, das auf die neuen Objekte a2 und B2 verweist, die Kopien von a und B. B2 wiederum auf das neue Objekt C2, das eine Kopie von C ist. Das Beispiel veranschaulicht den Unterschied zwischen einem flachen und einem Deep Copy-Vorgang.  
  
 Es gibt zahlreiche Möglichkeiten, einen Deep Copy-Vorgang zu implementieren, wenn der flache Kopier <xref:System.Object.MemberwiseClone%2A> Vorgang, der von der-Methode ausgeführt wird, nicht Ihren Anforderungen entspricht. Hierzu gehört Folgendes:  
  
-   Rufen Sie einen Klassenkonstruktor des Objekts auf, das kopiert werden soll, um ein zweites Objekt mit Eigenschafts Werten zu erstellen, die aus dem ersten Objekt entnommen werden Dabei wird davon ausgegangen, dass die Werte eines Objekts vollständig durch den Klassenkonstruktor definiert werden.  
  
-   Rufen Sie <xref:System.Object.MemberwiseClone%2A> die-Methode auf, um eine flache Kopie eines Objekts zu erstellen, und weisen Sie dann neue Objekte zu, deren Werte mit dem ursprünglichen Objekt identisch sind, und zwar für alle Eigenschaften oder Felder, deren Werte Verweis Typen sind. Diese `DeepCopy` Vorgehensweise wird von der-Methode im Beispiel veranschaulicht.  
  
-   Serialisieren Sie das Objekt, das tief kopiert werden soll, und stellen Sie die serialisierten Daten dann in einer anderen Objektvariablen wieder her.  
  
-   Verwenden Sie Reflektion mit Rekursion, um den Deep Copy-Vorgang auszuführen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Object.MemberwiseClone%2A> -Methode veranschaulicht. Es definiert eine `ShallowCopy` Methode, die die <xref:System.Object.MemberwiseClone%2A> -Methode aufruft, um einen flachen Kopiervorgang `Person` für ein-Objekt auszuführen. Außerdem wird eine `DeepCopy` Methode definiert, die einen Deep Copy-Vorgang für `Person` ein-Objekt ausführt.  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 In diesem Beispiel gibt die `Person.IdInfo` -Eigenschaft ein `IdInfo` -Objekt zurück. Wie die Ausgabe des Beispiels zeigt, ist das `Person` geklonte `Person` Objekt, wenn ein- <xref:System.Object.MemberwiseClone%2A> Objekt durch Aufrufen der-Methode geklont wird, eine unabhängige Kopie des ursprünglichen-Objekts, mit dem `Person.IdInfo` Unterschied, dass Sie denselben Objekt Verweis gemeinsam verwenden. Dadurch ändert sich die- `Person.IdInfo` `Person.IdInfo` Eigenschaft des ursprünglichen-Objekts durch Ändern der-Eigenschaft des Klons. Wenn dagegen ein Deep Copy-Vorgang ausgeführt wird, kann das geklonte `Person` Objekt, einschließlich seiner `Person.IdInfo` -Eigenschaft, geändert werden, ohne dass sich dies auf das ursprüngliche Objekt auswirkt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Das erste zu vergleichende Objekt.</param>
        <param name="objB">Das zweite zu vergleichende Objekt.</param>
        <summary>Stellt fest, ob die angegebenen <see cref="T:System.Object" />-Instanzen dieselbe Instanz sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="objA" /> dieselbe Instanz wie <paramref name="objB" /> ist oder beide **NULL** sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anders als <xref:System.Object.Equals%2A> bei der-Methode und dem Gleichheits Operator kann die <xref:System.Object.ReferenceEquals%2A> -Methode nicht überschrieben werden. Wenn Sie daher zwei Objekt Verweise auf Gleichheit testen möchten, und Sie sich nicht sicher sind, welche Implementierung der `Equals` Methode Sie benötigen, können Sie die <xref:System.Object.ReferenceEquals%2A> -Methode aufzurufen.  
  
 Der Rückgabewert <xref:System.Object.ReferenceEquals%2A> der Methode erscheint in den folgenden beiden Szenarien möglicherweise als anormale:  
  
-   Beim Vergleichen von Werttypen. Wenn `objA` und `objB` Werttypen sind, werden Sie vor der Übergabe an die <xref:System.Object.ReferenceEquals%2A> -Methode gekapselt. Dies bedeutet Folgendes: Wenn `objA` sowohl `objB` als auch dieselbe Instanz eines Werttyps darstellen <xref:System.Object.ReferenceEquals%2A> , gibt die `false`Methode trotzdem zurück, wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     Informationen zu Boxing-Werttypen finden Sie unter [Boxing und Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).  
  
-   Beim Vergleichen von Zeichen folgen. Wenn `objA` <xref:System.Object.ReferenceEquals%2A> `true` und `objB` Zeichen folgen sind, gibt die Methode zurück, wenn die Zeichenfolge interniert ist. Es wird kein Test auf Wert Gleichheit durchgeführt.  Im folgenden Beispiel sind und `s1` `s2` gleich, da Sie zwei Instanzen einer einzelnen, Internpool vorhanden Zeichenfolge sind. `s3` Und`s4` sind jedoch nicht gleich, denn obwohl Sie identische Zeichen folgen Werte aufweisen, wird diese Zeichenfolge nicht interniert.  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     Weitere Informationen zum Interning von Zeichen folgen finden <xref:System.String.IsInterned%2A?displayProperty=nameWithType>Sie unter.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Object.ReferenceEquals%2A> verwendet, um zu bestimmen, ob zwei-Objekte dieselbe Instanz sind.  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolge zurück, die das aktuelle Objekt darstellt.</summary>
        <returns>Eine Zeichenfolge, die das aktuelle Objekt darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType>ist die Haupt Formatierungs Methode in der .NET Framework. Ein Objekt wird in seine Zeichen folgen Darstellung konvertiert, sodass es für die Anzeige geeignet ist. (Informationen zur Unterstützung von Formaten in der .NET Framework finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).) Standard Implementierungen der <xref:System.Object.ToString%2A?displayProperty=nameWithType> -Methode geben den voll qualifizierten Namen des Objekt Typs zurück.  
  
> [!IMPORTANT]
>  Sie haben diese Seite möglicherweise erreicht, indem Sie den Link aus der Mitglieds Liste eines anderen Typs befolgen. Dies liegt daran, dass der Typ nicht <xref:System.Object.ToString%2A?displayProperty=nameWithType>überschrieben wird. Stattdessen erbt Sie die Funktionalität <xref:System.Object.ToString%2A?displayProperty=nameWithType> der-Methode.  
  
 Typen überschreiben häufig <xref:System.Object.ToString%2A?displayProperty=nameWithType> die-Methode, um eine geeignetere Zeichen folgen Darstellung eines bestimmten Typs bereitzustellen. Typen überladen auch häufig <xref:System.Object.ToString%2A?displayProperty=nameWithType> die-Methode, um Unterstützung für Format Zeichenfolgen oder Kultur abhängige Formatierung bereitzustellen.  
  
 In diesem Abschnitt  
  
 [Die Default Object. destring ()-Methode](#Default)   
 [Überschreiben der Object. destring ()-Methode](#Overriding)   
 [Über Laden der Methode "destring"](#Overloading)   
 [Erweitern der Object. destring-Methode](#Extending)   
 [Hinweise für den Windows-Runtime](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>Die Default Object. destring ()-Methode  
 Die Standard Implementierung <xref:System.Object.ToString%2A> der-Methode gibt den voll qualifizierten Namen des Typs <xref:System.Object>von zurück, wie im folgenden Beispiel gezeigt.  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 Da <xref:System.Object> die Basisklasse aller Verweis Typen im .NET Framework ist, wird dieses Verhalten von Verweis Typen geerbt, die die <xref:System.Object.ToString%2A> -Methode nicht überschreiben. Dies wird anhand des folgenden Beispiels veranschaulicht. Es definiert eine Klasse mit `Object1` dem Namen, die die Standard Implementierung <xref:System.Object> aller Member akzeptiert. Die zugehörige-Methode gibt den voll qualifizierten Typnamen des-Objekts zurück. <xref:System.Object.ToString%2A>  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>Überschreiben der Object. destring ()-Methode  
 Typen überschreiben häufig <xref:System.Object.ToString%2A?displayProperty=nameWithType> die-Methode, um eine Zeichenfolge zurückzugeben, die die Objektinstanz darstellt. Beispielsweise stellen die Basis Typen <xref:System.Char>wie, <xref:System.Int32>und <xref:System.String> Implementierungen bereit <xref:System.Object.ToString%2A> , die die Zeichen folgen Form des Werts zurückgeben, den das-Objekt darstellt. Im folgenden Beispiel wird eine-Klasse `Object2`definiert, die die <xref:System.Object.ToString%2A> -Methode überschreibt, um den Typnamen zusammen mit seinem Wert zurückzugeben.  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 In der folgenden Tabelle werden die Typkategorien in .NET aufgelistet, und es wird angegeben, <xref:System.Object.ToString%2A?displayProperty=nameWithType> ob Sie die-Methode überschreiben.  
  
|Typkategorie|Überschreibt Object.-Zeichenfolge ()|Verhalten|  
|-------------------|-----------------------------------|--------------|  
|Klasse|n/v|n/v|  
|Struktur|Ja (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|Identisch mit `Object.ToString()`|  
|Enumeration|Ja (<xref:System.Enum.ToString?displayProperty=nameWithType>)|Der Elementname|  
|Interface|Nein|n/v|  
|delegate|Nein|n/v|  
  
 Weitere Informationen zum über <xref:System.Object.ToString%2A>schreiben finden Sie im Abschnitt "Hinweise zu Vererbung".  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>Über Laden der Methode "destring"  
 Neben dem Überschreiben der Parameter losen <xref:System.Object.ToString?displayProperty=nameWithType> -Methode überladen viele Typen die `ToString` -Methode, um Versionen der Methode bereitzustellen, die Parameter akzeptieren. In den meisten Fällen wird dies erreicht, um Unterstützung für Variablen Formatierung und Kultur abhängige Formatierung bereitzustellen.  
  
 Im folgenden Beispiel wird die `ToString` -Methode überladen, um eine Ergebnis Zeichenfolge zurückzugeben, die den Wert verschiedener Felder `Automobile` einer-Klasse enthält. Es definiert vier Format Zeichenfolgen: G: gibt den Modellnamen und das Jahr zurück. D: gibt den Modellnamen, das Jahr und die Anzahl der Türen zurück. C: gibt den Modellnamen, das Jahr und die Anzahl der Zylinder zurück. und eine, die eine Zeichenfolge mit allen vier Feldwerten zurückgibt.  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 Im folgenden Beispiel wird die überladene <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> -Methode aufgerufen, um die Kultur abhängige Formatierung eines Währungs Werts anzuzeigen.  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 Weitere Informationen zu Format Zeichenfolgen und der Kultur abhängigen Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md). Informationen zu den von numerischen Werten unterstützten Format Zeichenfolgen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md) Informationen zu den von Datums-und Uhrzeitwerten unterstützten Format Zeichenfolgen finden Sie unter Standard Format Zeichenfolgen für [Datum und Uhrzeit](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-date-and-time-format-strings.md)Format Zeichenfolgen  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>Erweitern der Object. destring-Methode  
 Da ein Typ die Standard <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode erbt, ist das Verhalten möglicherweise unerwünscht und möchte geändert werden. Dies gilt insbesondere für Arrays und Auflistungs Klassen. Obwohl Sie erwarten können, `ToString` dass die-Methode eines Arrays oder einer Auflistungs Klasse die Werte der zugehörigen Member anzeigt, wird stattdessen der voll qualifizierte Typname des Typs angezeigt, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 Sie haben mehrere Optionen, um die gewünschte Ergebnis Zeichenfolge zu erhalten.  
  
-   Wenn der Typ ein Array, ein Auflistungs Objekt oder ein Objekt ist, das <xref:System.Collections.IEnumerable> die <xref:System.Collections.Generic.IEnumerable%601> -Schnittstelle oder die-Schnittstelle implementiert, können `foreach` Sie die C# zugehörigen Elemente `For Each...Next` mithilfe der-Anweisung in oder dem-Konstrukt in Visual Basic auflisten.  
  
-   Wenn die-Klasse nicht `sealed` (in C#) oder `NotInheritable` (in Visual Basic) ist, können Sie eine Wrapper Klasse entwickeln, die von der Basisklasse erbt, deren <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode Sie anpassen möchten. Hierfür müssen Sie mindestens folgende Schritte ausführen:  
  
    1.  Implementieren Sie alle erforderlichen Konstruktoren. Abgeleitete Klassen erben nicht Ihre Basisklassenkonstruktoren.  
  
    2.  Überschreiben <xref:System.Object.ToString%2A?displayProperty=nameWithType> Sie die-Methode, um die gewünschte Ergebnis Zeichenfolge zurückzugeben.  
  
     Im folgenden Beispiel wird eine Wrapper Klasse für die <xref:System.Collections.Generic.List%601> -Klasse definiert. Er überschreibt die <xref:System.Object.ToString%2A?displayProperty=nameWithType> -Methode, um den Wert jeder Methode der Auflistung anstelle des voll qualifizierten Typnamens anzuzeigen.  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   Entwickeln Sie eine [Erweiterungsmethode](~/docs/standard/design-guidelines/extension-methods.md) , die die gewünschte Ergebnis Zeichenfolge zurückgibt. Beachten Sie, dass Sie die Standard <xref:System.Object.ToString%2A?displayProperty=nameWithType> Methode nicht auf diese Weise überschreiben können (d. h. C#, die Erweiterungs Klasse (in) oder das Modul (in Visual Basic) kann `ToString` nicht über eine Parameter lose Methode namens verfügen, die anstelle des ursprünglichen Typs `ToString`aufgerufenwird.-Methode. Sie müssen einen anderen Namen für die Parameter lose `ToString` Ersetzung angeben.  
  
     Im folgenden Beispiel werden zwei Methoden definiert, mit <xref:System.Collections.Generic.List%601> denen die-Klasse erweitert wird `ToString2` : eine Parameter lose `ToString` -Methode und <xref:System.String> eine-Methode mit einem-Parameter, der eine Format Zeichenfolge darstellt.  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Hinweise zum[!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Wenn Sie die <xref:System.Object.ToString%2A> -Methode für eine Klasse in der [!INCLUDE[wrt](~/includes/wrt-md.md)]-Klasse aufzurufen, wird das Standardverhalten für Klassen <xref:System.Object.ToString%2A>bereitstellt, die nicht überschreiben. Dies ist ein Teil der Unterstützung, die der .NET Framework für [!INCLUDE[wrt](~/includes/wrt-md.md)] bietet (siehe [.NET Framework-Unterstützung für Windows Store-Apps und Windows-Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Klassen in der [!INCLUDE[wrt](~/includes/wrt-md.md)] erben <xref:System.Object>nicht <xref:System.Object.ToString%2A>und implementieren nicht immer. Allerdings scheinen Sie immer die- <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>-und <xref:System.Object.GetHashCode%2A> -Methoden zu haben, wenn Sie C# Sie im-oder-Visual Basic Code verwenden, und die .NET Framework stellt ein Standardverhalten für diese Methoden bereit.  
  
 Beginnend mit [!INCLUDE[net_v451](~/includes/net-v451-md.md)]wird die-Common Language Runtime in einem [!INCLUDE[wrt](~/includes/wrt-md.md)] -Objekt vor dem Fallback auf die Standard Implementierung von <xref:System.Object.ToString%2A?displayProperty=nameWithType> [istringable.-Zeichenfolge](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) verwenden.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]Klassen, die in C# oder Visual Basic geschrieben sind, können <xref:System.Object.ToString%2A> die-Methode überschreiben.  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>[!INCLUDE[wrt](~/includes/wrt-md.md)] Und die istringable-Schnittstelle  
 [!INCLUDE[wrt](~/includes/wrt-md.md)] <xref:System.Object.ToString%2A?displayProperty=nameWithType>Ab enthält die eine [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) -Schnittstelle, deren einzige Methode, [istringable. destring](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), eine grundlegende Formatierungs Unterstützung bietet, die vergleichbar mit der von bereitgestellten ist. [!INCLUDE[win81](~/includes/win81-md.md)] Um Mehrdeutigkeit zu vermeiden, sollten Sie [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) nicht für verwaltete Typen implementieren.  
  
 Wenn verwaltete Objekte von System eigenem Code oder von Code, der in Sprachen wie JavaScript oder C++/CX geschrieben ist, aufgerufen werden, scheinen Sie [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)zu implementieren. Der Common Language Runtime leitet automatisch Aufrufe von [istringable. destring](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) an in <xref:System.Object.ToString%2A?displayProperty=nameWithType> das-Ereignis zurück, das [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) nicht für das verwaltete Objekt implementiert ist.  
  
> [!WARNING]
>  Da der Common Language Runtime die [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) -Schnittstelle für alle verwalteten Typen [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] in-Apps automatisch implementiert, empfiehlt es sich, keine eigene [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) -Implementierung bereitzustellen. `ToString` C++Die [](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) ImplementierungvonistringablekannbeimAufrufenvonvon,/CXoderJavaScriptzuunbeabsichtigtemVerhalten[!INCLUDE[wrt](~/includes/wrt-md.md)]führen.  
  
 Wenn Sie [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in einem öffentlich verwalteten Typ implementieren möchten, der in eine [!INCLUDE[wrt](~/includes/wrt-md.md)] -Komponente exportiert wird, gelten die folgenden Einschränkungen:  
  
-   Sie können die [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) -Schnittstelle nur in einer "Klasse implementiert"-Beziehung definieren, z. b.  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     in C# oder  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     in Visual Basic.  
  
-   Sie können [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) nicht in einer Schnittstelle implementieren.  
  
-   Sie können einen Parameter nicht als Typ [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)deklarieren.  
  
-   [Istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) kann nicht der Rückgabetyp einer Methode, einer Eigenschaft oder eines Felds sein.  
  
-   Sie können die [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) -Implementierung nicht aus Basisklassen ausblenden, indem Sie eine Methoden Definition wie die folgende verwenden:  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     Stattdessen muss die Implementierung [istringable. destring](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) die Basisklassen Implementierung immer überschreiben. Sie können eine `ToString`-Implementierung nur ausblenden, indem Sie sie auf einer stark typisierten Klasseninstanz aufrufen.  
  
 Beachten Sie, dass unter einer Vielzahl von Bedingungen Aufrufe von System eigenem Code zu einem verwalteten Typ, der [istringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementiert oder seine Implementierung von " [destring](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) " verbirgt, zu unerwartetem Verhalten führen können.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie eigene Typen implementieren, sollten Sie die <see cref="M:System.Object.ToString" /> -Methode überschreiben, um Werte zurückzugeben, die für diese Typen von Bedeutung sind. Abgeleitete Klassen, die mehr Kontrolle über die <see cref="M:System.Object.ToString" /> Formatierung benötigen, als <see cref="T:System.IFormattable" /> bereitstellt, können die-Schnittstelle implementieren Mit <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> der-Methode können Sie Format Zeichenfolgen definieren, die die Formatierung <see cref="T:System.IFormatProvider" /> steuern, und ein Objekt verwenden, das die kulturspezifische Formatierung bereitstellen kann.  
  
Für außer Kraft setzungen <see cref="M:System.Object.ToString" /> der Methode sollten folgende Richtlinien beachtet werden: 
-Die zurückgegebene Zeichenfolge sollte von Menschen benutzerfreundlich und lesbar sein.  
  
-Die zurückgegebene Zeichenfolge sollte den Wert der Objektinstanz eindeutig identifizieren.  
  
-Die zurückgegebene Zeichenfolge sollte so kurz wie möglich sein, damit Sie von einem Debugger angezeigt werden kann.  
  
-Ihre <see cref="M:System.Object.ToString" /> außer Kraft Setzung sollte <see cref="F:System.String.Empty" /> nicht oder eine NULL-Zeichenfolge zurückgeben.  
  
-Ihre <see cref="M:System.Object.ToString" /> außer Kraft Setzung sollte keine Ausnahme auslösen.  
  
Wenn die Zeichen folgen Darstellung einer Instanz Kultur abhängig ist oder auf verschiedene Arten formatiert werden kann, implementieren Sie die <see cref="T:System.IFormattable" /> -Schnittstelle.  
  
-Wenn die zurückgegebene Zeichenfolge vertrauliche Informationen enthält, sollten Sie zuerst eine entsprechende Berechtigung anfordern. Wenn die Anforderung erfolgreich ist, können Sie die vertraulichen Informationen zurückgeben. Andernfalls sollten Sie eine Zeichenfolge zurückgeben, in der die vertraulichen Informationen ausgeschlossen werden.  
  
-Ihre <see cref="M:System.Object.ToString" /> außer Kraft Setzung sollte keine beobachtbaren Nebeneffekte aufweisen, um Komplikationen beim Debuggen zu vermeiden. Beispielsweise sollte ein Aufrufe <see cref="M:System.Object.ToString" /> der-Methode nicht den Wert von Instanzfeldern ändern.  
  
-Wenn der Typ eine-Methode der Methode (oder <see langword="Parse" /> <see langword="TryParse" /> Methode, einen Konstruktor oder eine andere statische Methode implementiert, die eine Instanz des Typs aus einer Zeichenfolge instanziiert), sollten Sie sicherstellen, dass die von der <see cref="M:System.Object.ToString" /> -Methode zurückgegebene Zeichenfolge in eine Objektinstanz konvertiert.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>
