<Type Name="UnhandledExceptionEventArgs" FullName="System.UnhandledExceptionEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="619169ba92e150ece549e95ae8f32bfb58e04a73" /><Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/27/2018" /><Meta Name="ms.locfileid" Value="52379374" /></Metadata><TypeSignature Language="C#" Value="public class UnhandledExceptionEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UnhandledExceptionEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.UnhandledExceptionEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class UnhandledExceptionEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnhandledExceptionEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type UnhandledExceptionEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Daten für das Ereignis bereit, das ausgelöst wird, wenn eine Ausnahme von keiner Anwendungsdomäne behandelt wird.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UnhandledExceptionEventArgs> bietet Zugriff auf dem Ausnahmeobjekt und einem Flag zur Angabe, ob die common Language Runtime beendet wird. Die <xref:System.UnhandledExceptionEventArgs> ist eine der übergebenen Parameter <xref:System.UnhandledExceptionEventHandler> für die <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> Ereignis.  
  
 Weitere Informationen zu den Ereignishandlerdelegaten, finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
    </remarks>
    <altmember cref="E:System.AppDomain.UnhandledException" />
    <altmember cref="T:System.UnhandledExceptionEventHandler" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnhandledExceptionEventArgs (object exception, bool isTerminating);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object exception, bool isTerminating) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UnhandledExceptionEventArgs.#ctor(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (exception As Object, isTerminating As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnhandledExceptionEventArgs(System::Object ^ exception, bool isTerminating);" />
      <MemberSignature Language="F#" Value="new UnhandledExceptionEventArgs : obj * bool -&gt; UnhandledExceptionEventArgs" Usage="new System.UnhandledExceptionEventArgs (exception, isTerminating)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="exception" Type="System.Object" />
        <Parameter Name="isTerminating" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="exception">Die nicht behandelte Ausnahme.</param>
        <param name="isTerminating"><see langword="true" />, wenn die Laufzeit beendet wird, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.UnhandledExceptionEventArgs" />-Klasse mit dem Ausnahmeobjekt und einem Common Language Runtime-Beendigungsflag.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExceptionObject">
      <MemberSignature Language="C#" Value="public object ExceptionObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ExceptionObject" />
      <MemberSignature Language="DocId" Value="P:System.UnhandledExceptionEventArgs.ExceptionObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExceptionObject As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ExceptionObject { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExceptionObject : obj" Usage="System.UnhandledExceptionEventArgs.ExceptionObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das nicht behandelte Ausnahmeobjekt ab.</summary>
        <value>Das nicht behandelte Ausnahmeobjekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt ein Objekt vom Typ <xref:System.Object> anstelle einer Ableitung von <xref:System.Exception>. Obwohl die Common Language Specification erfordert, dass alle Typen abgeleitet <xref:System.Exception>, es ist möglich, dass Methoden zum Auslösen von Ausnahmen mit Objekten, die nicht von abgeleiteten <xref:System.Exception>. Sie können Folgendes für die Arbeit mit folgender Ausnahme:  
  
-   Anwenden der <xref:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute> -Attribut mit einem <xref:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute.WrapNonExceptionThrows%2A?displayProperty=nameWithType> Wert `true` auf die Assembly, die den Ereignishandler enthält. Dies dient als Wrapper für alle Ausnahmen, die nicht von abgeleiteten der <xref:System.Exception> -Klasse in eine <xref:System.Runtime.CompilerServices.RuntimeWrappedException> Objekt. Sie können dann problemlos umgewandelt (in c#) oder konvertieren (in Visual Basic), das von dieser Eigenschaft zurückgegebene Objekt eine <xref:System.Exception> Objekt aus, und rufen Sie das ursprüngliche Ausnahmeobjekt aus der <xref:System.Runtime.CompilerServices.RuntimeWrappedException.WrappedException%2A?displayProperty=nameWithType> Eigenschaft. Beachten Sie, dass einige Compiler, z. B. der C#- und Visual Basic-Compiler, die dieses Attribut automatisch anwenden.  
  
-   Wandeln Sie das Objekt zurückgegeben, die für diese Eigenschaft auf eine <xref:System.Exception> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.AppDomain.UnhandledException> Ereignis. Definiert einen Ereignishandler `MyHandler`, die aufgerufen wird, wenn eine nicht behandelte Ausnahme, in der Standardanwendungsdomäne ausgelöst wird. Klicken Sie dann zwei Ausnahmen ausgelöst. Die erste erfolgt durch eine **Try/Catch-** Block. Die zweite wird nicht behandelt, und ruft die `MyHandle` Routine, bevor die Anwendung beendet wird.  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute" />
        <altmember cref="T:System.Runtime.CompilerServices.RuntimeWrappedException" />
      </Docs>
    </Member>
    <Member MemberName="IsTerminating">
      <MemberSignature Language="C#" Value="public bool IsTerminating { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTerminating" />
      <MemberSignature Language="DocId" Value="P:System.UnhandledExceptionEventArgs.IsTerminating" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTerminating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTerminating { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTerminating : bool" Usage="System.UnhandledExceptionEventArgs.IsTerminating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob Common Language Runtime beendet wird.</summary>
        <value><see langword="true" />, wenn die Laufzeit beendet wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ab .NET Framework, Version 2.0 wird diese Eigenschaft gibt `true` für die meisten Ausnahmefehler, es sei denn, ein Anwendungskompatibilitätsflag verwendet wird, in das Verhalten der Versionen 1.0 und 1.1 zurückzukehren. Der Grund ist, dass die meisten nicht behandelte Ausnahmen in Threads, einschließlich der Threads im Threadpool, zulässig sind, natürlich fortgesetzt. Dies führt normalerweise Beenden der Anwendung. Weitere Informationen einschließlich einer Liste von Fällen, in dem die Common Language Runtime nicht beendet wird, finden Sie unter [Ausnahmen in verwalteten Threads](~/docs/standard/threading/exceptions-in-managed-threads.md).  
  
## <a name="version-information"></a>Versionsinformationen  
 Die folgenden Ausführungen gelten für die .NET Framework-Versionen 1.0 und 1.1: Diese Eigenschaft gibt `true` Wenn eine Ausnahme empfangen wird, aber nicht vom Hauptthread der Anwendung behandelt. Außerdem gibt diese Eigenschaft `true` Wenn ein nicht verwalteter Thread von verwaltetem Code Ausführung ist und eine nicht behandelte Ausnahme empfängt. Schließlich gibt diese Eigenschaft zurück `false` für Threads im Threadpool und verwalteten Threads, die von einer Anwendung erstellt, da Version 1.0 und 1.1 nicht behandelte Ausnahmen in Threads, die solche abfangen und werden ignoriert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>