<Type Name="UnhandledExceptionEventArgs" FullName="System.UnhandledExceptionEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9844a7a4b862eea91fa4b9b8f7427a473fa6d0b5" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69404540" /></Metadata><TypeSignature Language="C#" Value="public class UnhandledExceptionEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UnhandledExceptionEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.UnhandledExceptionEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class UnhandledExceptionEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnhandledExceptionEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type UnhandledExceptionEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Daten für das Ereignis bereit, das ausgelöst wird, wenn eine Ausnahme von keiner Anwendungsdomäne behandelt wird.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UnhandledExceptionEventArgs>bietet Zugriff auf das Ausnahme Objekt und ein Flag, das angibt, ob die Common Language Runtime beendet wird. Der <xref:System.UnhandledExceptionEventArgs> ist einer der Parameter, die <xref:System.UnhandledExceptionEventHandler> an für das <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> -Ereignis übermittelt werden.  
  
 Weitere Informationen zu Ereignishandlerdelegaten finden Sie unter [behandeln und Auswerfen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
    </remarks>
    <altmember cref="E:System.AppDomain.UnhandledException" />
    <altmember cref="T:System.UnhandledExceptionEventHandler" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnhandledExceptionEventArgs (object exception, bool isTerminating);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object exception, bool isTerminating) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UnhandledExceptionEventArgs.#ctor(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (exception As Object, isTerminating As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnhandledExceptionEventArgs(System::Object ^ exception, bool isTerminating);" />
      <MemberSignature Language="F#" Value="new UnhandledExceptionEventArgs : obj * bool -&gt; UnhandledExceptionEventArgs" Usage="new System.UnhandledExceptionEventArgs (exception, isTerminating)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="exception" Type="System.Object" />
        <Parameter Name="isTerminating" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="exception">Die nicht behandelte Ausnahme.</param>
        <param name="isTerminating"><see langword="true" />, wenn die Laufzeit beendet wird, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.UnhandledExceptionEventArgs" />-Klasse mit dem Ausnahmeobjekt und einem Common Language Runtime-Beendigungsflag.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExceptionObject">
      <MemberSignature Language="C#" Value="public object ExceptionObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ExceptionObject" />
      <MemberSignature Language="DocId" Value="P:System.UnhandledExceptionEventArgs.ExceptionObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExceptionObject As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ExceptionObject { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExceptionObject : obj" Usage="System.UnhandledExceptionEventArgs.ExceptionObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das nicht behandelte Ausnahmeobjekt ab.</summary>
        <value>Das nicht behandelte Ausnahmeobjekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt ein Objekt vom Typ <xref:System.Object> anstelle eines von <xref:System.Exception>abgeleiteten zurück. Obwohl die Common Language Specification erfordert, dass alle Ausnahme Typen von <xref:System.Exception>abgeleitet werden, können Methoden Ausnahmen mit Objekten auslösen, die nicht von <xref:System.Exception>abgeleitet sind. Sie können folgende Schritte ausführen, um mit dieser Ausnahme zu arbeiten:  
  
-   Wenden `true` Sie <xref:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute> das-Attribut <xref:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute.WrapNonExceptionThrows%2A?displayProperty=nameWithType> mit dem Wert auf die Assembly an, die den Ereignishandler enthält. Dies umschließt alle Ausnahmen, die nicht <xref:System.Exception> von der- <xref:System.Runtime.CompilerServices.RuntimeWrappedException> Klasse in einem-Objekt abgeleitet werden. Anschließend können Sie das von dieser Eigenschaft C#zurückgegebene Objekt sicher in ein <xref:System.Exception> Objekt umwandeln (in) oder konvertieren (in Visual Basic) und das ursprüngliche Ausnahme Objekt aus der <xref:System.Runtime.CompilerServices.RuntimeWrappedException.WrappedException%2A?displayProperty=nameWithType> -Eigenschaft abrufen. Beachten Sie, dass einige Compiler, z. C# b. die-und-Visual Basic Compiler, dieses Attribut automatisch anwenden.  
  
-   Wandelt das von dieser Eigenschaft zurückgegebene-Objekt <xref:System.Exception> in ein-Objekt um.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das <xref:System.AppDomain.UnhandledException> -Ereignis veranschaulicht. Er definiert einen Ereignishandler, `MyHandler`der aufgerufen wird, wenn in der Standard Anwendungsdomäne eine nicht behandelte Ausnahme ausgelöst wird. Anschließend werden zwei Ausnahmen ausgelöst. Der erste wird von einem **try/catch-** Block behandelt. Die zweite ist unbehandelt und ruft die `MyHandle` Routine auf, bevor die Anwendung beendet wird.  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute" />
        <altmember cref="T:System.Runtime.CompilerServices.RuntimeWrappedException" />
      </Docs>
    </Member>
    <Member MemberName="IsTerminating">
      <MemberSignature Language="C#" Value="public bool IsTerminating { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTerminating" />
      <MemberSignature Language="DocId" Value="P:System.UnhandledExceptionEventArgs.IsTerminating" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTerminating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTerminating { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTerminating : bool" Usage="System.UnhandledExceptionEventArgs.IsTerminating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob Common Language Runtime beendet wird.</summary>
        <value><see langword="true" />, wenn die Laufzeit beendet wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ab der .NET Framework Version 2,0 gibt diese Eigenschaft für die `true` meisten Ausnahme Fehler zurück, es sei denn, ein Anwendungskompatibilitäts-Flag wird verwendet, um das Verhalten der Versionen 1,0 und 1,1 wiederherzustellen. Der Grund hierfür ist, dass die meisten nicht behandelten Ausnahmen in Threads, einschließlich Threadpoolthreads, auf natürliche Weise fortgesetzt werden können. Dies führt normalerweise zu einer Beendigung der Anwendung. Weitere Informationen, einschließlich einer Liste der Fälle, in denen die Laufzeit nicht beendet wird, finden Sie unter [Ausnahmen in verwalteten Threads](~/docs/standard/threading/exceptions-in-managed-threads.md).  
  
## <a name="version-information"></a>Versionsinformationen  
 Folgendes gilt für die .NET Framework Versionen 1,0 und 1,1: Diese Eigenschaft gibt `true` zurück, wenn eine Ausnahme in einem Anwendungs Hauptthread empfangen, jedoch nicht behandelt wird. Diese Eigenschaft gibt auch `true` dann zurück, wenn ein nicht verwalteter Thread verwalteten Code ausführt und eine nicht behandelte Ausnahme empfängt. Schließlich gibt diese Eigenschaft für `false` Thread Pool-Threads und verwaltete Threads zurück, die von einer Anwendung erstellt werden, da die Versionen 1,0 und 1,1 nicht behandelte Ausnahmen in solchen Threads abfangen und Sie ignorieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
