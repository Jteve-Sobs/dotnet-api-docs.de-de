<Type Name="Array" FullName="System.Array">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1f1e5542ce17228b81ac98e22af0444d4203ab07" />
    <Meta Name="ms.sourcegitcommit" Value="ad09e88f48ca55b181e8d272cfc3742eadc3f939" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/08/2018" />
    <Meta Name="ms.locfileid" Value="35231189" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Methoden zum Erstellen, Bearbeiten, Durchsuchen und Sortieren von Arrays bereit und ist damit Basisklasse für alle Arrays in der Common Language Runtime.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> Klasse ist nicht Teil der <xref:System.Collections> Namespaces. Allerdings es dennoch als eine Sammlung, da er basiert die <xref:System.Collections.IList> Schnittstelle.  
  
 Die <xref:System.Array> Klasse ist die Basisklasse für Implementierungen von Sprache, die Arrays unterstützen. Allerdings nur die System- und die Compiler können explizit aus Ableiten der <xref:System.Array> Klasse. Benutzer sollten die Arraykonstrukte, die von der Sprache bereitgestellte einsetzen.  
  
 Ein Element ist ein Wert in einer <xref:System.Array>. Die Länge einer <xref:System.Array> ist die Gesamtanzahl von Elementen enthalten. Die untere Grenze einer <xref:System.Array> ist der Index des ersten darin enthaltenen Elements. Ein <xref:System.Array> können untere Grenze, aber es wurde eine Untergrenze von 0 (null), wird standardmäßig. Eine andere Untergrenze definiert werden können, beim Erstellen einer Instanz von der <xref:System.Array> -Klasse unter Verwendung <xref:System.Array.CreateInstance%2A>. Ein mehrdimensionales <xref:System.Array> können verschiedene Grenzen für jede Dimension haben. Ein Array kann maximal 32 Dimensionen aufweisen.  
  
 Im Gegensatz zu Klassen in der <xref:System.Collections> Namespaces <xref:System.Array> hat eine feste Kapazität. Um die Kapazität zu erhöhen, müssen Sie ein neues erstellen <xref:System.Array> -Objekt mit der erforderlichen Kapazität, kopieren Sie die Elemente aus der alten <xref:System.Array> Objekt in das neue Projekt, und löschen die alte <xref:System.Array>.  
  
 Standardmäßig ist die maximale Größe einer <xref:System.Array> beträgt 2 Gigabyte (GB). In einer 64-Bit-Umgebung können Sie die Größe Einschränkung vermeiden, indem die `enabled` Attribut des der [GcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) zu Konfigurationselement `true` in der Umgebung zur Laufzeit. Das Array wird jedoch weiterhin auf insgesamt 4 Milliarden Elemente, und klicken Sie auf eine maximale Index des 0X7FEFFFFF in den angegebenen Dimensionen (0X7FFFFFC7 für Bytearrays und Arrays von einzelbytestrukturen) beschränkt sein.  
  
 Eindimensionale Arrays implementieren die <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> und <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> generische Schnittstellen. Die Implementierungen sind für Arrays zur Laufzeit bereitgestellt und die generischen Schnittstellen werden daher nicht angezeigt, in der Syntax für Deklarationen für die <xref:System.Array> Klasse. Darüber hinaus stehen keine Referenzthemen für Schnittstellenmember, die nur durch Umwandlung einem Array mit den generischen Schnittstellentyp (explizite schnittstellenimplementierungen) zugegriffen werden kann. Wichtigster Punkt ist, achten Sie bei einem Array mit einer dieser Schnittstellen Umwandlung ist, dass Mitglieder, von denen hinzufügen, einfügen oder Entfernen von Elementen Throw <xref:System.NotSupportedException>.  
  
 <xref:System.Type> Objekte Aufschluss darüber geben Arraydeklarationen-Typ. <xref:System.Array> Objekte mit der gleichen Arraytyp verwenden dieselbe <xref:System.Type> Objekt.  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType> und <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> möglicherweise nicht die erwarteten Ergebnisse mit zurück <xref:System.Array> da ein Array, in den Typ umgewandelt wird <xref:System.Array>, das Ergebnis ist ein Objekt, das kein Array. D. h. `typeof(System.Array).IsArray` gibt `false`, und `typeof(System.Array).GetElementType` gibt `null`.  
  
 Die <xref:System.Array.Copy%2A?displayProperty=nameWithType> Methode kopiert die Elemente, die nicht nur zwischen Arrays mit den gleichen Typ, sondern auch zwischen standard Arrays mit verschiedenen Typen; sie Typumwandlung von Elementen automatisch behandelt.  
  
 Einige Methoden, wie z. B. <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A>, und <xref:System.Array.SetValue%2A>, geben Sie die Überladungen, die 64-Bit-Ganzzahlen als Parameter für die Kapazität Arrays gerecht zu akzeptieren. <xref:System.Array.LongLength%2A> und <xref:System.Array.GetLongLength%2A> 64-Bit-Ganzzahlen, die die Länge des Arrays zurück.  
  
 Die <xref:System.Array> ist nicht garantiert werden.  Sie sortieren, müssen die <xref:System.Array> vor dem Ausführen von Vorgängen (z. B. <xref:System.Array.BinarySearch%2A>), erfordern die <xref:System.Array> sortiert werden.  
  
 Mithilfe einer <xref:System.Array> Objekt von Zeigern in systemeigenem Code wird nicht unterstützt und löst eine <xref:System.NotSupportedException> für mehrere Methoden.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt, wie <xref:System.Array.Copy%2A?displayProperty=nameWithType> kopiert die Elemente zwischen ein Array vom Typ Integer und ein Array vom Typ <xref:System.Object>.  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 Im folgenden Codebeispiel wird erstellt und initialisiert ein <xref:System.Array> und seine Eigenschaften und Elemente angezeigt.  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind threadsicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.  Diese Implementierung bietet keinen synchronisierten (threadsicheren) Wrapper für ein <see cref="T:System.Array" />jedoch .NET Framework-Klassen basierend auf <see cref="T:System.Array" /> bieten eigene synchronisierte Version der Auflistung mithilfe der <see cref="P:System.Array.SyncRoot" /> Eigenschaft.  Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das eindimensionale, nullbasierte Array, das mit einem schreibgeschützten <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />-Wrapper umschlossen werden soll.</param>
        <summary>Gibt einen schreibgeschützten Wrapper für das angegebene Array zurück.</summary>
        <returns>Ein schreibgeschützter <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />-Wrapper für das angegebene Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu verhindern, dass die Änderungen an das Array verfügbar zu machen das Array nur über diesen Wrapper.  
  
 Eine Auflistung, die schreibgeschützt ist, ist eine Auflistung mit einem Wrapper, der verhindert, dass die Auflistung ändern; Wenn Änderungen an der zugrunde liegenden Auflistung vorgenommen werden, spiegelt die schreibgeschützte Auflistung daher diese Änderungen wider.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgende Beispiel umschließt ein Array in eine schreibgeschützte <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Durchsucht ein sortiertes eindimensionales <see cref="T:System.Array" /> mithilfe eines binären Suchalgorithmus nach einem Wert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende sortierte eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <summary>Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der <see cref="T:System.IComparable" />-Schnittstelle, die von jedem Element des Arrays und durch das angegebene Objekt implementiert wird, nach einem bestimmten Element.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt keine Suchen von Arrays, die negative Indizes enthalten. `array` muss vor dem Aufrufen dieser Methode sortiert werden.  
  
 Wenn die <xref:System.Array> enthält keinen den angegebenen Wert gibt die Methode eine negative ganze Zahl zurück. Sie können die bitweiser Komplementoperator anwenden (~ in c# `Not` in Visual Basic) auf das Ergebnis negativ, um einen Index zu erzeugen. Wenn dieser Index einer ist größer als die obere Grenze des Arrays, es sind keine Elemente größer als `value` im Array. Andernfalls ist der Index des ersten Elements, das größer ist als `value`.  
  
 Entweder `value` oder jedes Element des `array` implementieren müssen die <xref:System.IComparable> -Schnittstelle, die für Vergleiche verwendet wird. Die Elemente der `array` muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden die <xref:System.IComparable> Implementierung; anderenfalls das Ergebnis möglicherweise nicht korrekt.  
  
> [!NOTE]
>  Wenn`value` implementiert nicht die <xref:System.IComparable> Schnittstelle, die Elemente der `array` nicht getestet werden <xref:System.IComparable> vor Beginn der Suche. Eine Ausnahme wird ausgelöst, wenn die Suche ein Element gefunden wird, die nicht implementiert <xref:System.IComparable>.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> enthält mehr als ein Element gleich `value`, die Methode gibt den Index nur ein vorkommen, aber nicht unbedingt das erste Schema zurück.  
  
 `null` kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit `null` eine Ausnahme nicht generiert.  
  
> [!NOTE]
>  Für jedes Element getestet `value` übergeben wird, an die entsprechende <xref:System.IComparable> -Implementierung, auch wenn `value` ist `null`. D. h. die <xref:System.IComparable> Implementierung bestimmt, wie ein angegebenes Element zu vergleicht `null`.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Array.BinarySearch%2A> zum Suchen eines bestimmten Objekts in ein <xref:System.Array>.  
  
> [!NOTE]
>  Das Array wird mit seiner Elemente in aufsteigender Reihenfolge erstellt. Die <xref:System.Array.BinarySearch%2A> Methode erfordert das Array in aufsteigender Reihenfolge sortiert werden.  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> implementiert nicht die <see cref="T:System.IComparable" />-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende sortierte eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  Oder:  <see langword="null" />, um die <see cref="T:System.IComparable" />-Implementierung jedes Elements zu nutzen.</param>
        <summary>Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der angegebenen <see cref="T:System.Collections.IComparer" />-Schnittstelle nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt keine Suchen von Arrays, die negative Indizes enthalten. `array` muss vor dem Aufrufen dieser Methode sortiert werden.  
  
 Wenn die <xref:System.Array> enthält keinen den angegebenen Wert gibt die Methode eine negative ganze Zahl zurück. Sie können die bitweiser Komplementoperator anwenden (~ in c# `Not` in Visual Basic) auf das Ergebnis negativ, um einen Index zu erzeugen. Wenn dieser Index einer ist größer als die obere Grenze des Arrays, es sind keine Elemente größer als `value` im Array. Andernfalls ist der Index des ersten Elements, das größer ist als `value`.  
  
 Der Vergleich wird bestimmt, wie die Elemente verglichen werden. Beispielsweise können Sie eine <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> als Vergleich Groß-/Kleinschreibung Zeichenfolgensuche ausführen.  
  
 Wenn `comparer` nicht `null`, die Elemente der `array` verglichen werden, auf den angegebenen Wert mit dem angegebenen <xref:System.Collections.IComparer> Implementierung. Die Elemente der `array` muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden `comparer`ist, andernfalls das Ergebnis möglicherweise nicht korrekt.  
  
 Wenn`comparer` ist `null`, der Vergleich erfolgt mithilfe der <xref:System.IComparable> Implementierung, die durch das Element selbst oder durch den angegebenen Wert bereitgestellt. Die Elemente der `array` muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden die <xref:System.IComparable> Implementierung; anderenfalls das Ergebnis möglicherweise nicht korrekt.  
  
> [!NOTE]
>  Wenn `comparer` ist `null` und `value` implementiert nicht die <xref:System.IComparable> Schnittstelle, die Elemente der `array` nicht getestet werden <xref:System.IComparable> vor Beginn der Suche. Eine Ausnahme wird ausgelöst, wenn die Suche ein Element gefunden wird, die nicht implementiert <xref:System.IComparable>.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> enthält mehr als ein Element gleich `value`, die Methode gibt den Index nur ein vorkommen, aber nicht unbedingt das erste Schema zurück.  
  
 `null` kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit `null` eine Ausnahme nicht generiert.  
  
> [!NOTE]
>  Für jedes Element getestet `value` übergeben wird, an die entsprechende <xref:System.IComparable> -Implementierung, auch wenn `value` ist `null`. D. h. die <xref:System.IComparable> Implementierung bestimmt, wie ein angegebenes Element zu vergleicht `null`.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> ist <see langword="null" /> und <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> ist<see langword="null" />, <paramref name="value" /> implementiert nicht die <see cref="T:System.IComparable" />-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende sortierte eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu durchsuchenden Bereichs.</param>
        <param name="length">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <summary>Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der <see cref="T:System.IComparable" />-Schnittstelle, die von jedem Element des Arrays und durch den angegebenen Wert implementiert wird, nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt keine Suchen von Arrays, die negative Indizes enthalten. `array` muss vor dem Aufrufen dieser Methode sortiert werden.  
  
 Wenn die <xref:System.Array> enthält keinen den angegebenen Wert gibt die Methode eine negative ganze Zahl zurück. Sie können die bitweiser Komplementoperator anwenden (~ in c# `Not` in Visual Basic) auf das Ergebnis negativ, um einen Index zu erzeugen. Wenn dieser Index einer ist größer als die obere Grenze des Arrays, es sind keine Elemente größer als `value` im Array. Andernfalls ist der Index des ersten Elements, das größer ist als `value`.  
  
 Entweder `value` oder jedes Element des `array` implementieren müssen die <xref:System.IComparable> -Schnittstelle, die für Vergleiche verwendet wird. Die Elemente der `array` muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden die <xref:System.IComparable> Implementierung; anderenfalls das Ergebnis möglicherweise nicht korrekt.  
  
> [!NOTE]
>  Wenn `value` implementiert nicht die <xref:System.IComparable> Schnittstelle, die Elemente der `array` nicht getestet werden <xref:System.IComparable> vor Beginn der Suche. Eine Ausnahme wird ausgelöst, wenn die Suche ein Element gefunden wird, die nicht implementiert <xref:System.IComparable>.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> enthält mehr als ein Element gleich `value`, die Methode gibt den Index nur ein vorkommen, aber nicht unbedingt das erste Schema zurück.  
  
 `null` kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit `null` eine Ausnahme nicht generiert.  
  
> [!NOTE]
>  Für jedes Element getestet `value` übergeben wird, an die entsprechende <xref:System.IComparable> -Implementierung, auch wenn `value` ist `null`. D. h. die <xref:System.IComparable> Implementierung bestimmt, wie ein angegebenes Element zu vergleicht `null`.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in dem `n` ist `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  Oder:  <paramref name="length" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  Oder:  <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> implementiert nicht die <see cref="T:System.IComparable" />-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende sortierte eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu durchsuchenden Bereichs.</param>
        <param name="length">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  Oder:  <see langword="null" />, um die <see cref="T:System.IComparable" />-Implementierung jedes Elements zu nutzen.</param>
        <summary>Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der angegebenen <see cref="T:System.Collections.IComparer" />-Schnittstelle nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt keine Suchen von Arrays, die negative Indizes enthalten. `array` muss vor dem Aufrufen dieser Methode sortiert werden.  
  
 Wenn die <xref:System.Array> enthält keinen den angegebenen Wert gibt die Methode eine negative ganze Zahl zurück. Sie können die bitweiser Komplementoperator anwenden (~ in c# `Not` in Visual Basic) auf das Ergebnis negativ, um einen Index zu erzeugen. Wenn dieser Index einer ist größer als die obere Grenze des Arrays, es sind keine Elemente größer als `value` im Array. Andernfalls ist der Index des ersten Elements, das größer ist als `value`.  
  
 Der Vergleich wird bestimmt, wie die Elemente verglichen werden. Beispielsweise können Sie eine <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> als Vergleich Groß-/Kleinschreibung Zeichenfolgensuche ausführen.  
  
 Wenn `comparer` nicht `null`, die Elemente der `array` verglichen werden, auf den angegebenen Wert mit dem angegebenen <xref:System.Collections.IComparer> Implementierung. Die Elemente der `array` muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden `comparer`ist, andernfalls das Ergebnis möglicherweise nicht korrekt.  
  
 Wenn `comparer` ist `null`, der Vergleich erfolgt mithilfe der <xref:System.IComparable> Implementierung, die durch das Element selbst oder durch den angegebenen Wert bereitgestellt. Die Elemente der `array` muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden die <xref:System.IComparable> Implementierung; anderenfalls das Ergebnis möglicherweise nicht korrekt.  
  
> [!NOTE]
>  Wenn `comparer` ist `null` und `value` implementiert nicht die <xref:System.IComparable> Schnittstelle, die Elemente der `array` nicht getestet werden <xref:System.IComparable> vor Beginn der Suche. Eine Ausnahme wird ausgelöst, wenn die Suche ein Element gefunden wird, die nicht implementiert <xref:System.IComparable>.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> enthält mehr als ein Element gleich `value`, die Methode gibt den Index nur ein vorkommen, aber nicht unbedingt das erste Schema zurück.  
  
 `null` kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit `null` eine Ausnahme nicht generiert, bei Verwendung von <xref:System.IComparable>.  
  
> [!NOTE]
>  Für jedes Element getestet `value` übergeben wird, an die entsprechende <xref:System.IComparable> -Implementierung, auch wenn `value` ist `null`. D. h. die <xref:System.IComparable> Implementierung bestimmt, wie ein angegebenes Element zu vergleicht `null`.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in dem `n` ist `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  Oder:  <paramref name="length" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  Oder:  <paramref name="comparer" /> ist <see langword="null" />, und <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> ist<see langword="null" />, <paramref name="value" /> implementiert nicht die <see cref="T:System.IComparable" />-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende sortierte eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <summary>Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der generischen <see cref="T:System.IComparable`1" />-Schnittstelle, die von jedem Element des <see cref="T:System.Array" /> und vom angegebenen Objekt implementiert wird, nach einem bestimmten Element.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt keine Suchen von Arrays, die negative Indizes enthalten. `array` muss vor dem Aufrufen dieser Methode sortiert werden.  
  
 Wenn `array` enthält keinen den angegebenen Wert gibt die Methode eine negative ganze Zahl zurück. Sie können die bitweiser Komplementoperator anwenden (~ in c# `Not` in Visual Basic) auf das Ergebnis negativ, um einen Index zu erzeugen. Wenn dieser Index gleich der Größe des Arrays ist, befinden sich keine Elemente größer als `value` im Array. Andernfalls ist der Index des ersten Elements, das größer ist als `value`.  
  
 `T` Implementieren Sie müssen die <xref:System.IComparable%601> generische Schnittstellen, die für Vergleiche verwendet wird. Die Elemente der `array` muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden die <xref:System.IComparable%601> Implementierung; anderenfalls das Ergebnis möglicherweise nicht korrekt.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> enthält mehr als ein Element gleich `value`, die Methode gibt den Index nur ein vorkommen, aber nicht unbedingt das erste Schema zurück.  
  
 `null` kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit `null` eine Ausnahme nicht generiert.  
  
> [!NOTE]
>  Für jedes Element getestet `value` übergeben wird, an die entsprechende <xref:System.IComparable%601> -Implementierung, auch wenn `value` ist `null`. D. h. die <xref:System.IComparable%601> Implementierung bestimmt, wie ein angegebenes Element zu vergleicht `null`.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> generischen methodenüberladung und die <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generischen methodenüberladung. Ein Array von Zeichenfolgen wird erstellt, ohne bestimmte Reihenfolge.  
  
 Das Array wird angezeigt, sortiert und erneut angezeigt. Arrays müssen sortiert werden, um mithilfe der <xref:System.Array.BinarySearch%2A> Methode.  
  
> [!NOTE]
>  Die Aufrufe an die <xref:System.Array.Sort%2A> und <xref:System.Array.BinarySearch%2A> generische Methoden nicht suchen alle Aufrufe an ihre nicht generischen Entsprechungen unterscheiden, da Visual Basic, c# und C++ den Typ des vom Typ des ersten Arguments der generischen Typparameter abgeleitet werden. Bei Verwendung der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 Die <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generischen methodenüberladung wird dann verwendet, um zwei Zeichenfolgen zu suchen, ist eine, die nicht in das Array und eine ist. Das Array und den Rückgabewert der <xref:System.Array.BinarySearch%2A> an die Methode übergeben werden die `ShowWhere` generische Methode, die den Indexwert zeigt an, wenn die Zeichenfolge gefunden wird, und andernfalls die Elemente die Suchzeichenfolge fallen würde zwischen wären im Array. Der Index ist negativ, wenn die Zeichenfolge nicht im Array wird also die `ShowWhere` Methode nimmt das bitweise Komplement (die ~ Operator in c# und Visual C++ `Xor`-1 in Visual Basic) um den Index des ersten Elements in der Liste zu erhalten, die größer ist als bei einer Suche str Ing.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die generische <see cref="T:System.IComparable`1" />-Schnittstelle wird von <paramref name="T" /> nicht implementiert.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende sortierte eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  Oder:  <see langword="null" />, um die <see cref="T:System.IComparable`1" />-Implementierung jedes Elements zu nutzen.</param>
        <summary>Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der angegebenen generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt keine Suchen von Arrays, die negative Indizes enthalten. `array` muss vor dem Aufrufen dieser Methode sortiert werden.  
  
 Wenn die <xref:System.Array> enthält keinen den angegebenen Wert gibt die Methode eine negative ganze Zahl zurück. Sie können die bitweiser Komplementoperator anwenden (~ in c# `Not` in Visual Basic) auf das Ergebnis negativ, um einen Index zu erzeugen. Wenn dieser Index gleich der Größe des Arrays ist, befinden sich keine Elemente größer als `value` im Array. Andernfalls ist der Index des ersten Elements, das größer ist als `value`.  
  
 Der Vergleich wird bestimmt, wie die Elemente verglichen werden. Beispielsweise können Sie eine <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> als Vergleich Groß-/Kleinschreibung Zeichenfolgensuche ausführen.  
  
 Wenn `comparer` nicht `null`, die Elemente der `array` verglichen werden, auf den angegebenen Wert mit dem angegebenen <xref:System.Collections.Generic.IComparer%601> generische Implementierung. Die Elemente der `array` muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden `comparer`ist, andernfalls das Ergebnis möglicherweise nicht korrekt.  
  
 Wenn `comparer` ist `null`, der Vergleich erfolgt mithilfe der <xref:System.IComparable%601> generische Implementierung von bereitgestellten `T`. Die Elemente der `array` muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden die <xref:System.IComparable%601> Implementierung; anderenfalls das Ergebnis möglicherweise nicht korrekt.  
  
> [!NOTE]
>  Wenn `comparer` ist `null` und `value` implementiert nicht die <xref:System.IComparable%601> generische Schnittstelle, die Elemente der `array` nicht getestet werden <xref:System.IComparable%601> vor Beginn der Suche. Eine Ausnahme wird ausgelöst, wenn die Suche ein Element gefunden wird, die nicht implementiert <xref:System.IComparable%601>.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> enthält mehr als ein Element gleich `value`, die Methode gibt den Index nur ein vorkommen, aber nicht unbedingt das erste Schema zurück.  
  
 `null` kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit `null` eine Ausnahme nicht generiert.  
  
> [!NOTE]
>  Für jedes Element getestet `value` übergeben wird, an die entsprechende <xref:System.IComparable%601> -Implementierung, auch wenn `value` ist `null`. D. h. die <xref:System.IComparable%601> Implementierung bestimmt, wie ein angegebenes Element zu vergleicht `null`.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung und die <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung.  
  
 Im Codebeispiel wird einen alternativer Vergleich für Zeichenfolgen, die mit dem Namen definiert `ReverseCompare`, implementiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich ruft die <xref:System.String.CompareTo%28System.String%29> -Methode, die Reihenfolge der verglichenen Elemente umkehren, sodass Zeichenfolgen hoch zu niedrig anstelle von niedrig zu hoch sortieren.  
  
 Das Array wird angezeigt, sortiert und erneut angezeigt. Arrays müssen sortiert werden, um mithilfe der <xref:System.Array.BinarySearch%2A> Methode.  
  
> [!NOTE]
>  Die Aufrufe an die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> und <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden nicht suchen alle Aufrufe an ihre nicht generischen Entsprechungen unterscheiden, da Visual Basic, c# und C++ den Typ des vom Typ des ersten Arguments der generischen Typparameter abgeleitet werden. Bei Verwendung der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 Die <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung wird dann verwendet, um zwei Zeichenfolgen zu suchen, ist eine, die nicht in das Array und eine ist. Das Array und den Rückgabewert der <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> an die Methode übergeben werden die `ShowWhere` generische Methode, die den Indexwert zeigt an, wenn die Zeichenfolge gefunden wird, und andernfalls die Elemente die Suchzeichenfolge fallen würde zwischen wären im Array. Der Index ist negativ, wenn die Zeichenfolge nicht n ist das Array daher die `ShowWhere` Methode nimmt das bitweise Komplement (den ~ Operator in c# und Visual C++ `Xor` -1 in Visual Basic) um den Index des ersten Elements in der Liste zu erhalten, die größer ist als die Suche d NG.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> ist <see langword="null" /> und <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> ist <see langword="null" /> und <paramref name="T" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende sortierte eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu durchsuchenden Bereichs.</param>
        <param name="length">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <summary>Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der generischen <see cref="T:System.IComparable`1" />-Schnittstelle, die von jedem Element des <see cref="T:System.Array" /> und vom angegebenen Wert implementiert wird, nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt keine Suchen von Arrays, die negative Indizes enthalten. `array` muss vor dem Aufrufen dieser Methode sortiert werden.  
  
 Wenn das Array nicht den angegebenen Wert enthält, gibt die Methode eine negative ganze Zahl zurück. Sie können die bitweiser Komplementoperator anwenden (~ in c# `Not` in Visual Basic) auf das Ergebnis negativ, um einen Index zu erzeugen. Wenn dieser Index gleich der Größe des Arrays ist, befinden sich keine Elemente größer als `value` im Array. Andernfalls ist der Index des ersten Elements, das größer ist als `value`.  
  
 `T` Implementieren Sie müssen die <xref:System.IComparable%601> generische Schnittstellen, die für Vergleiche verwendet wird. Die Elemente der `array` muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden die <xref:System.IComparable%601> Implementierung; anderenfalls das Ergebnis möglicherweise nicht korrekt.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> enthält mehr als ein Element gleich `value`, die Methode gibt den Index nur ein vorkommen, aber nicht unbedingt das erste Schema zurück.  
  
 `null` kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit `null` eine Ausnahme nicht generiert.  
  
> [!NOTE]
>  Für jedes Element getestet `value` übergeben wird, an die entsprechende <xref:System.IComparable%601> -Implementierung, auch wenn `value` ist `null`. D. h. die <xref:System.IComparable%601> Implementierung bestimmt, wie ein angegebenes Element zu vergleicht `null`.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in dem `n` ist `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  Oder:  <paramref name="length" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  Oder:  <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException">Die generische <see cref="T:System.IComparable`1" />-Schnittstelle wird von <paramref name="T" /> nicht implementiert.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende sortierte eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu durchsuchenden Bereichs.</param>
        <param name="length">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  Oder:  <see langword="null" />, um die <see cref="T:System.IComparable`1" />-Implementierung jedes Elements zu nutzen.</param>
        <summary>Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der angegebenen generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt keine Suchen von Arrays, die negative Indizes enthalten. `array` muss vor dem Aufrufen dieser Methode sortiert werden.  
  
 Wenn das Array nicht den angegebenen Wert enthält, gibt die Methode eine negative ganze Zahl zurück. Sie können die bitweiser Komplementoperator anwenden (~ in c# `Not` in Visual Basic) auf das Ergebnis negativ, um einen Index zu erzeugen. Wenn dieser Index gleich der Größe des Arrays ist, befinden sich keine Elemente größer als `value` im Array. Andernfalls ist der Index des ersten Elements, das größer ist als `value`.  
  
 Der Vergleich wird bestimmt, wie die Elemente verglichen werden. Beispielsweise können Sie eine <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> als Vergleich Groß-/Kleinschreibung Zeichenfolgensuche ausführen.  
  
 Wenn `comparer` nicht `null`, die Elemente der `array` verglichen werden, auf den angegebenen Wert mit dem angegebenen <xref:System.Collections.Generic.IComparer%601> generische Implementierung. Die Elemente der `array` muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden `comparer`ist, andernfalls das Ergebnis möglicherweise nicht korrekt.  
  
 Wenn `comparer` ist `null`, der Vergleich erfolgt mithilfe der <xref:System.IComparable%601> generische Implementierung für Typ bereitgestellten `T`. Die Elemente der `array` muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden die <xref:System.IComparable%601> Implementierung; anderenfalls das Ergebnis möglicherweise nicht korrekt.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> enthält mehr als ein Element gleich `value`, die Methode gibt den Index nur ein vorkommen, aber nicht unbedingt das erste Schema zurück.  
  
 `null` kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit `null` eine Ausnahme nicht generiert, bei Verwendung von <xref:System.IComparable%601>.  
  
> [!NOTE]
>  Für jedes Element getestet `value` übergeben wird, an die entsprechende <xref:System.IComparable%601> -Implementierung, auch wenn `value` ist `null`. D. h. die <xref:System.IComparable%601> Implementierung bestimmt, wie ein angegebenes Element zu vergleicht `null`.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in dem `n` ist `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  Oder:  <paramref name="length" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  Oder:  <paramref name="comparer" /> ist <see langword="null" />, und <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> ist <see langword="null" />, und <paramref name="T" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das Array, dessen Elemente gelöscht werden sollen.</param>
        <param name="index">Der Startindex für den Bereich der zu löschenden Elemente.</param>
        <param name="length">Die Anzahl der zu löschenden Elemente.</param>
        <summary>Legt einen Bereich von Elementen in einem Array mit dem Standardwert der einzelnen Elementtypen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode setzt auf den Elementtyp Standardwert jedes Element in einem Array zurück. Elemente von Verweistypen wird (einschließlich <xref:System.String> Elemente), `null`, und Elemente von Werttypen, die in der folgenden Tabelle aufgeführten Standardwerte festgelegt.  
  
|Typ|Wert|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|Alle numerischen Ganzzahl- und Gleitkommatyps Point-Typen|0 (null)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|Andere Werttypen|Standardwert, der die Felder des Typs|  
  
 Des Bereichs von Elementen Wrap deaktiviert von Zeile zu Zeile, in ein mehrdimensionales Array.  
  
 Diese Methode löscht nur die Werte der Elemente. die Elemente selbst werden nicht gelöscht. Ein Array hat eine feste Größe; Daher können nicht Elemente hinzugefügt oder entfernt werden soll.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Array.Clear%2A> Methode, um ganzzahlige Werte in ein eindimensionales, zweidimensionalen und dreidimensionale Array zurückzusetzen.  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 Das folgende Beispiel definiert eine `TimeZoneTime` -Struktur, die umfasst eine <xref:System.TimeZoneInfo> Feld und einem <xref:System.DateTimeOffset> Feld. Er ruft dann die <xref:System.Array.Clear%2A> Methode, um ein Element in ein Array von zwei Elementen deaktivieren `TimeZoneTime` Werte. Die Methode wird der Wert des gelöschten Elements auf den Standardwert einer <xref:System.TimeZoneInfo> Objekt, das `null`, und der Standardwert von einer <xref:System.DateTimeOffset> Objekt, das <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  Oder:  <paramref name="length" /> ist kleiner als 0 (null).  Oder:  Die Summe von <paramref name="index" /> und <paramref name="length" /> ist größer als die Größe von <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine flache Kopie von <see cref="T:System.Array" />.</summary>
        <returns>Eine flache Kopie von <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine flache Kopie von einer <xref:System.Array> kopiert nur die Elemente von der <xref:System.Array>, ob sie Verweis- oder Werttypen sind, aber die Objekte, die auf die verwiesen wird nicht kopiert. Die Verweise in der neuen <xref:System.Array> zeigen auf dieselben Objekte, die Verweise in der ursprünglichen <xref:System.Array> zeigen Sie auf.  
  
 Im Gegensatz dazu eine tiefe Kopie von einer <xref:System.Array> kopiert die Elemente und alles, was auf die Elemente direkt oder indirekt verweist.  
  
 Der Klon hat die gleiche <xref:System.Type> wie beim ursprünglichen <xref:System.Array>.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Array.Length%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird codeklone ein <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> array erstellt und veranschaulicht das Verhalten von eine flache Kopie.  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="sourceIndex">Eine 32-Bit-Ganzzahl, die den Index im <c>sourceArray</c> angibt, ab dem kopiert werden soll.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="destinationIndex">Eine 32-Bit-Ganzzahl, die den Index im <c>destinationArray</c> angibt, ab dem gespeichert werden soll.</param>
        <param name="length">Eine 32-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt.</param>
        <summary>Kopiert einen beim angegebenen Quellindex beginnenden Elementbereich aus einem <see cref="T:System.Array" /> und fügt ihn ab dem angegebenen Zielindex in ein anderes <see cref="T:System.Array" /> ein.  Stellt sicher, dass alle Änderungen rückgängig gemacht werden, wenn der Kopiervorgang nicht vollständig abgeschlossen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `sourceArray` und `destinationArray` Parameter müssen die gleiche Anzahl von Dimensionen aufweisen.  Der `sourceArray` Typ identisch sein müssen oder abgeleitet wurde. der `destinationArray` handelt, andernfalls ein <xref:System.ArrayTypeMismatchException> ausgelöst.  Im Gegensatz zu <xref:System.Array.Copy%2A>, <xref:System.Array.ConstrainedCopy%2A> überprüft die Kompatibilität der Arraytypen vor dem Ausführen von Vorgängen.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, in denen Zeilen (oder Spalten) konzeptionell End-to-End-angeordnet sind. Wenn ein Array drei Zeilen (oder Spalten) mit vier Elementen, Kopieren von sechs Elementen vom Anfang des Arrays würde beispielsweise alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopieren. Zu kopierende aus dem zweiten Element der dritten Zeile (oder Spalte) `sourceIndex` muss die obere Grenze der ersten Zeile (oder Spalte) plus 2 plus die Länge der zweiten Zeile (oder Spalte) sein.  
  
 Wenn `sourceArray` und `destinationArray` überschneiden, die diese Methode verhält sich wie die ursprünglichen Werte der `sourceArray` beibehalten wurden, in ein temporäres Verzeichnis vor `destinationArray` überschrieben wird.  
  
 [C++]  
  
 Diese Methode entspricht der C/C++-Standardfunktion `memmove`, nicht `memcpy`.  
  
 Die Arrays können Verweistyp-Arrays oder Werttyp Arrays sein.  Wenn `sourceArray` und `destinationArray` Verweistyp-Arrays sind oder werden beide Arrays des Typs <xref:System.Object>, eine flache Kopie ausgeführt wird. Eine flache Kopie von einer <xref:System.Array> ist ein neues <xref:System.Array> enthält Verweise auf die gleichen Elemente wie die ursprüngliche <xref:System.Array>. Die Elemente selbst oder einem beliebigen Element verwiesen wird, durch die Elemente werden nicht kopiert. Im Gegensatz dazu eine tiefe Kopie von einer <xref:System.Array> kopiert die Elemente und alles, was auf die Elemente direkt oder indirekt verweist.  
  
 Wenn diese Methode eine während des Kopiervorgangs Ausnahme der `destinationArray` unverändert; deshalb <xref:System.Array.ConstrainedCopy%2A> innerhalb einer eingeschränkten Ausführungsbereich verwendet werden kann (<xref:System.Runtime.ConstrainedExecution.Cer>).  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> ist <see langword="null" />.  Oder:  <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Der <paramref name="sourceArray" />-Typ entspricht weder dem <paramref name="destinationArray" />-Typ, noch wird er von diesem abgeleitet.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im <paramref name="sourceArray" /> kann nicht in den Typ des <paramref name="destinationArray" />s umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> ist kleiner als die untere Grenze der ersten Dimension von <paramref name="sourceArray" />.  Oder:  <paramref name="destinationIndex" /> ist kleiner als die untere Grenze der ersten Dimension von <paramref name="destinationArray" />.  Oder:  <paramref name="length" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="sourceIndex" /> bis zum Ende des <paramref name="sourceArray" />s.  Oder:  <paramref name="length" /> ist größer als die Anzahl der Elemente von <paramref name="destinationIndex" /> bis zum Ende von <paramref name="destinationArray" />.</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Der Typ der Elemente des Quellarrays.</typeparam>
        <typeparam name="TOutput">Der Typ der Elemente des Zielarrays.</typeparam>
        <param name="array">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das in einen Zieltyp konvertiert werden soll.</param>
        <param name="converter">Ein <see cref="T:System.Converter`2" />, der jedes Element von einem Typ in einen anderen Typ konvertiert.</param>
        <summary>Konvertiert ein Array des einen Typs in ein Array eines anderen Typs.</summary>
        <returns>Ein Array des Zieltyps, das die konvertierten Elemente aus dem Quellarray enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Converter%602> ist ein Delegat für eine Methode, die ein Objekt in den Zieltyp konvertiert.  Die Elemente der `array` einzeln übergeben werden, um die <xref:System.Converter%602>, und die konvertierten Elemente im neuen Array gespeichert werden.  
  
 Die Quelle `array` bleibt unverändert.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Das folgende Codebeispiel definiert eine Methode namens `PointFToPoint` , konvertiert ein <xref:System.Drawing.PointF> -Struktur in eine <xref:System.Drawing.Point> Struktur. Im Beispiel wird ein Array von erstellt <xref:System.Drawing.PointF> um Datenstrukturen handelt, erstellt eine `Converter<PointF, Point>` delegieren (`Converter(Of PointF, Point)` in Visual Basic) zur Darstellung der `PointFToPoint` -Methode, und übergibt den Delegaten an die <xref:System.Array.ConvertAll%2A> Methode. Die <xref:System.Array.ConvertAll%2A> Methode übergibt jedes Element der Eingabeliste an die `PointFToPoint` Methode und legt die konvertierten Elemente in eine neue Liste mit <xref:System.Drawing.Point> Strukturen. Beide Listen werden angezeigt.  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.  Oder:  <paramref name="converter" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert einen Bereich von Elementen eines <see cref="T:System.Array" /> in ein anderes <see cref="T:System.Array" /> und führt ggf. Typumwandlungen und Boxing durch.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="length">Eine 32-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt.</param>
        <summary>Kopiert einen mit dem ersten Element beginnenden Elementbereich eines <see cref="T:System.Array" /> und fügt ihn ab dem ersten Element in ein anderes <see cref="T:System.Array" /> ein. Die Länge wird als 32-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `sourceArray` und `destinationArray` Parameter müssen die gleiche Anzahl von Dimensionen aufweisen. Darüber hinaus `destinationArray` muss bereits haben wurde dimensioniert und muss eine ausreichende Anzahl von Elementen, die die kopierten Daten aufzunehmen.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, in denen Zeilen (oder Spalten) konzeptionell End-to-End angeordnet sind. Wenn ein Array drei Zeilen (oder Spalten) mit vier Elementen, Kopieren von sechs Elementen vom Anfang des Arrays würde beispielsweise alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopieren.  
  
 Wenn `sourceArray` und `destinationArray` überschneiden, die diese Methode verhält sich wie die ursprünglichen Werte der `sourceArray` beibehalten wurden, in ein temporäres Verzeichnis vor `destinationArray` überschrieben wird.  
  
 [C++]  
  
 Diese Methode entspricht der C/C++-Standardfunktion `memmove`, nicht `memcpy`.  
  
 Die Arrays können Verweistyp-Arrays oder Werttyp Arrays sein. Es erfolgt eine Umwandlung des Typs, wie erforderlich.  
  
-   Beim Kopieren von einem Referenztyp Array in ein Array von Werttyp wird jedes Element mittels Unboxing zurückkonvertiert und kopiert. Wenn von einem Werttyp Array in ein Array von Verweistypen zu kopieren, wird jedes Element geschachtelt und kopiert.  
  
-   Beim Kopieren aus einem Array-Verweistyp oder Werttyp in einen <xref:System.Object> Array, ein <xref:System.Object> erstellt, um jeden Wert oder Verweis aufzunehmen und anschließend kopiert wird. Beim Kopieren aus einer <xref:System.Object> Array in ein Array-Verweistyp oder Werttyp und die Zuweisung ist nicht möglich, eine <xref:System.InvalidCastException> ausgelöst wird.  
  
-   Wenn `sourceArray` und `destinationArray` Verweistyp-Arrays sind oder werden beide Arrays des Typs <xref:System.Object>, eine flache Kopie ausgeführt wird. Eine flache Kopie von einer <xref:System.Array> ist ein neues <xref:System.Array> enthält Verweise auf die gleichen Elemente wie die ursprüngliche <xref:System.Array>. Die Elemente selbst oder einem beliebigen Element verwiesen wird, durch die Elemente werden nicht kopiert. Im Gegensatz dazu eine tiefe Kopie von einer <xref:System.Array> kopiert die Elemente und alles, was auf die Elemente direkt oder indirekt verweist.  
  
 Ein <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn die Arrays von inkompatiblen Typen sind. Typkompatibilität ist wie folgt definiert:  
  
-   Ein Typ ist mit sich selbst kompatibel.  
  
-   Ein Werttyp ist kompatibel mit <xref:System.Object> und mit einem Schnittstellentyp, der durch diesen Werttyp implementiert. Ein Werttyp gilt nur, wenn sie diese Schnittstelle, direkt implementiert mit einer Schnittstelle verbunden. Nicht verbundene Typen sind nicht kompatibel.  
  
-   Zwei systeminterne (vordefinierte) Werttypen sind kompatibel, wenn kopieren aus einer Datenquelle in den Zieltyp eine erweiternde Konvertierung ist. Nie eine erweiternde Konvertierung verliert Informationen an, während eine einschränkende Konvertierung Informationen verloren gehen kann. Z. B. eine erweiternde Konvertierung ist eine 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen zu konvertieren, und konvertieren eine 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen ist eine einschränkende Konvertierung. Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
-   Ein systeminterner (Benutzerdefiniert) Werttyp ist nur mit sich selbst kompatibel.  
  
-   Enumerationen verfügen über eine implizite Konvertierung in <xref:System.Enum> und ihren zugrunde liegenden Typ.  
  
 Wenn jedes Element in `sourceArray` eine Umwandlung erfordert (z. B. von einer Basisklasse in einer abgeleiteten Klasse oder von einer Schnittstelle zu einem Objekt) und einem oder mehreren Elementen können nicht in den entsprechenden Typ umgewandelt werden `destinationArray`, wird eine <xref:System.InvalidCastException> ausgelöst wird.  
  
 Wenn diese Methode eine Ausnahme während des Kopiervorgangs, des Status des `destinationArray` ist nicht definiert.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> ist <see langword="null" />.  Oder:  <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> und <paramref name="destinationArray" /> weisen inkompatible Typen auf.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element in <paramref name="sourceArray" /> kann nicht in den <paramref name="destinationArray" />-Typ umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="sourceArray" />.  Oder:  <paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="length">Eine 64-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt. Die Ganzzahl muss zwischen 0 (null) und einschließlich <see cref="F:System.Int32.MaxValue" /> liegen.</param>
        <summary>Kopiert einen mit dem ersten Element beginnenden Elementbereich eines <see cref="T:System.Array" /> und fügt ihn ab dem ersten Element in ein anderes <see cref="T:System.Array" /> ein. Die Länge wird als 64-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `sourceArray` und `destinationArray` Parameter müssen die gleiche Anzahl von Dimensionen aufweisen. Darüber hinaus `destinationArray` muss bereits haben wurde dimensioniert und muss eine ausreichende Anzahl von Elementen, die die kopierten Daten aufzunehmen.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, in denen Zeilen (oder Spalten) konzeptionell End-to-End angeordnet sind. Wenn ein Array drei Zeilen (oder Spalten) mit vier Elementen, Kopieren von sechs Elementen vom Anfang des Arrays würde beispielsweise alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopieren.  
  
 Wenn `sourceArray` und `destinationArray` überschneiden, die diese Methode verhält sich wie die ursprünglichen Werte der `sourceArray` beibehalten wurden, in ein temporäres Verzeichnis vor `destinationArray` überschrieben wird.  
  
 [C++]  
  
 Diese Methode entspricht der C/C++-Standardfunktion `memmove`, nicht `memcpy`.  
  
 Die Arrays können Verweistyp-Arrays oder Werttyp Arrays sein. Es erfolgt eine Umwandlung des Typs, wie erforderlich.  
  
-   Beim Kopieren von einem Referenztyp Array in ein Array von Werttyp wird jedes Element mittels Unboxing zurückkonvertiert und kopiert. Wenn von einem Werttyp Array in ein Array von Verweistypen zu kopieren, wird jedes Element geschachtelt und kopiert.  
  
-   Beim Kopieren aus einem Array-Verweistyp oder Werttyp in einen <xref:System.Object> Array, ein <xref:System.Object> erstellt, um jeden Wert oder Verweis aufzunehmen und anschließend kopiert wird. Beim Kopieren aus einer <xref:System.Object> Array in ein Array-Verweistyp oder Werttyp und die Zuweisung ist nicht möglich, eine <xref:System.InvalidCastException> ausgelöst wird.  
  
-   Wenn `sourceArray` und `destinationArray` Verweistyp-Arrays sind oder werden beide Arrays des Typs <xref:System.Object>, eine flache Kopie ausgeführt wird. Eine flache Kopie von einer <xref:System.Array> ist ein neues <xref:System.Array> enthält Verweise auf die gleichen Elemente wie die ursprüngliche <xref:System.Array>. Die Elemente selbst oder einem beliebigen Element verwiesen wird, durch die Elemente werden nicht kopiert. Im Gegensatz dazu eine tiefe Kopie von einer <xref:System.Array> kopiert die Elemente und alles, was auf die Elemente direkt oder indirekt verweist.  
  
 Ein <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn die Arrays von inkompatiblen Typen sind. Typkompatibilität ist wie folgt definiert:  
  
-   Ein Typ ist mit sich selbst kompatibel.  
  
-   Ein Werttyp ist kompatibel mit <xref:System.Object> und mit einem Schnittstellentyp, der durch diesen Werttyp implementiert. Ein Werttyp gilt nur, wenn sie diese Schnittstelle, direkt implementiert mit einer Schnittstelle verbunden. Nicht verbundene Typen sind nicht kompatibel.  
  
-   Zwei systeminterne (vordefinierte) Werttypen sind kompatibel, wenn kopieren aus einer Datenquelle in den Zieltyp eine erweiternde Konvertierung ist. Nie eine erweiternde Konvertierung verliert Informationen an, während eine einschränkende Konvertierung Informationen verloren gehen kann. Z. B. eine erweiternde Konvertierung ist eine 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen zu konvertieren, und konvertieren eine 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen ist eine einschränkende Konvertierung. Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
-   Ein systeminterner (Benutzerdefiniert) Werttyp ist nur mit sich selbst kompatibel.  
  
-   Enumerationen verfügen über eine implizite Konvertierung in <xref:System.Enum> und ihren zugrunde liegenden Typ.  
  
 Wenn jedes Element in `sourceArray` eine Umwandlung erfordert (z. B. von einer Basisklasse in einer abgeleiteten Klasse oder von einer Schnittstelle zu einem Objekt) und einem oder mehreren Elementen können nicht in den entsprechenden Typ umgewandelt werden `destinationArray`, wird eine <xref:System.InvalidCastException> ausgelöst wird.  
  
 Wenn diese Methode eine Ausnahme während des Kopiervorgangs, des Status des `destinationArray` ist nicht definiert.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> ist <see langword="null" />.  Oder:  <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> und <paramref name="destinationArray" /> weisen inkompatible Typen auf.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im <paramref name="sourceArray" /> kann nicht in den Typ des <paramref name="destinationArray" />s umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> ist kleiner als 0 oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="sourceArray" />.  Oder:  <paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="sourceIndex">Eine 32-Bit-Ganzzahl, die den Index im <c>sourceArray</c> angibt, ab dem kopiert werden soll.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="destinationIndex">Eine 32-Bit-Ganzzahl, die den Index im <c>destinationArray</c> angibt, ab dem gespeichert werden soll.</param>
        <param name="length">Eine 32-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt.</param>
        <summary>Kopiert einen beim angegebenen Quellindex beginnenden Elementbereich aus einem <see cref="T:System.Array" /> und fügt ihn ab dem angegebenen Zielindex in ein anderes <see cref="T:System.Array" /> ein. Die Länge und die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `sourceArray` und `destinationArray` Parameter müssen die gleiche Anzahl von Dimensionen aufweisen. Darüber hinaus `destinationArray` muss bereits haben wurde dimensioniert und muss eine ausreichende Anzahl von Elementen, beginnend mit der `destinationIndex` Position, um die kopierten Daten aufzunehmen.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, in denen Zeilen (oder Spalten) konzeptionell End-to-End-angeordnet sind. Wenn ein Array drei Zeilen (oder Spalten) mit vier Elementen, Kopieren von sechs Elementen vom Anfang des Arrays würde beispielsweise alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopieren. Zu kopierende aus dem zweiten Element der dritten Zeile (oder Spalte) `sourceIndex` muss die obere Grenze der ersten Zeile (oder Spalte) plus 2 plus die Länge der zweiten Zeile (oder Spalte) sein.  
  
 Wenn `sourceArray` und `destinationArray` überschneiden, die diese Methode verhält sich wie die ursprünglichen Werte der `sourceArray` beibehalten wurden, in ein temporäres Verzeichnis vor `destinationArray` überschrieben wird.  
  
 [C++]  
  
 Diese Methode entspricht der C/C++-Standardfunktion `memmove`, nicht `memcpy`.  
  
 Die Arrays können Verweistyp-Arrays oder Werttyp Arrays sein. Es erfolgt eine Umwandlung des Typs, wie erforderlich.  
  
-   Beim Kopieren von einem Referenztyp Array in ein Array von Werttyp wird jedes Element mittels Unboxing zurückkonvertiert und kopiert. Wenn von einem Werttyp Array in ein Array von Verweistypen zu kopieren, wird jedes Element geschachtelt und kopiert.  
  
-   Beim Kopieren aus einem Array-Verweistyp oder Werttyp in einen <xref:System.Object> Array, ein <xref:System.Object> erstellt, um jeden Wert oder Verweis aufzunehmen und anschließend kopiert wird. Beim Kopieren aus einer <xref:System.Object> Array in ein Array-Verweistyp oder Werttyp und die Zuweisung ist nicht möglich, eine <xref:System.InvalidCastException> ausgelöst wird.  
  
-   Wenn `sourceArray` und `destinationArray` Verweistyp-Arrays sind oder werden beide Arrays des Typs <xref:System.Object>, eine flache Kopie ausgeführt wird. Eine flache Kopie von einer <xref:System.Array> ist ein neues <xref:System.Array> enthält Verweise auf die gleichen Elemente wie die ursprüngliche <xref:System.Array>. Die Elemente selbst oder einem beliebigen Element verwiesen wird, durch die Elemente werden nicht kopiert. Im Gegensatz dazu eine tiefe Kopie von einer <xref:System.Array> kopiert die Elemente und alles, was auf die Elemente direkt oder indirekt verweist.  
  
 Ein <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn die Arrays von inkompatiblen Typen sind. Typkompatibilität ist wie folgt definiert:  
  
-   Ein Typ ist mit sich selbst kompatibel.  
  
-   Ein Werttyp ist kompatibel mit <xref:System.Object> und mit einem Schnittstellentyp, der durch diesen Werttyp implementiert. Ein Werttyp gilt nur, wenn sie diese Schnittstelle, direkt implementiert mit einer Schnittstelle verbunden. Nicht verbundene Typen sind nicht kompatibel.  
  
-   Zwei systeminterne (vordefinierte) Werttypen sind kompatibel, wenn kopieren aus einer Datenquelle in den Zieltyp eine erweiternde Konvertierung ist. Nie eine erweiternde Konvertierung verliert Informationen an, während eine einschränkende Konvertierung Informationen verloren gehen kann. Z. B. eine erweiternde Konvertierung ist eine 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen zu konvertieren, und konvertieren eine 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen ist eine einschränkende Konvertierung. Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
-   Ein systeminterner (Benutzerdefiniert) Werttyp ist nur mit sich selbst kompatibel.  
  
-   Enumerationen verfügen über eine implizite Konvertierung in <xref:System.Enum> und ihren zugrunde liegenden Typ.  
  
 Wenn jedes Element in `sourceArray` eine Umwandlung erfordert (z. B. von einer Basisklasse in einer abgeleiteten Klasse oder von einer Schnittstelle zu einem Objekt) und einem oder mehreren Elementen können nicht in den entsprechenden Typ umgewandelt werden `destinationArray`, wird eine <xref:System.InvalidCastException> ausgelöst wird.  
  
 Wenn diese Methode eine Ausnahme während des Kopiervorgangs, des Status des `destinationArray` ist nicht definiert.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie von einem kopieren <xref:System.Array> des Typs <xref:System.Object> in eine andere <xref:System.Array> vom Typ Integer.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> ist <see langword="null" />.  Oder:  <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> und <paramref name="destinationArray" /> weisen inkompatible Typen auf.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im <paramref name="sourceArray" /> kann nicht in den Typ des <paramref name="destinationArray" />s umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> ist kleiner als die untere Grenze der ersten Dimension von <paramref name="sourceArray" />.  Oder:  <paramref name="destinationIndex" /> ist kleiner als die untere Grenze der ersten Dimension von <paramref name="destinationArray" />.  Oder:  <paramref name="length" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="sourceIndex" /> bis zum Ende des <paramref name="sourceArray" />s.  Oder:  <paramref name="length" /> ist größer als die Anzahl der Elemente von <paramref name="destinationIndex" /> bis zum Ende von <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="sourceIndex">Eine 64-Bit-Ganzzahl, die den Index im <c>sourceArray</c> angibt, ab dem kopiert werden soll.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="destinationIndex">Eine 64-Bit-Ganzzahl, die den Index im <c>destinationArray</c> angibt, ab dem gespeichert werden soll.</param>
        <param name="length">Eine 64-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt. Die Ganzzahl muss zwischen 0 (null) und einschließlich <see cref="F:System.Int32.MaxValue" /> liegen.</param>
        <summary>Kopiert einen beim angegebenen Quellindex beginnenden Elementbereich aus einem <see cref="T:System.Array" /> und fügt ihn ab dem angegebenen Zielindex in ein anderes <see cref="T:System.Array" /> ein. Die Länge und die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `sourceArray` und `destinationArray` Parameter müssen die gleiche Anzahl von Dimensionen aufweisen. Darüber hinaus `destinationArray` muss bereits haben wurde dimensioniert und muss eine ausreichende Anzahl von Elementen, beginnend mit der `destinationIndex` Position, um die kopierten Daten aufzunehmen.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, in denen Zeilen (oder Spalten) konzeptionell End-to-End-angeordnet sind. Wenn ein Array drei Zeilen (oder Spalten) mit vier Elementen, Kopieren von sechs Elementen vom Anfang des Arrays würde beispielsweise alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopieren. Zu kopierende aus dem zweiten Element der dritten Zeile (oder Spalte) `sourceIndex` muss die obere Grenze der ersten Zeile (oder Spalte) plus 2 plus die Länge der zweiten Zeile (oder Spalte) sein.  
  
 Wenn `sourceArray` und `destinationArray` überschneiden, die diese Methode verhält sich wie die ursprünglichen Werte der `sourceArray` beibehalten wurden, in ein temporäres Verzeichnis vor `destinationArray` überschrieben wird.  
  
 [C++]  
  
 Diese Methode entspricht der C/C++-Standardfunktion `memmove`, nicht `memcpy`.  
  
 Die Arrays können Verweistyp-Arrays oder Werttyp Arrays sein. Es erfolgt eine Umwandlung des Typs, wie erforderlich.  
  
-   Beim Kopieren von einem Referenztyp Array in ein Array von Werttyp wird jedes Element mittels Unboxing zurückkonvertiert und kopiert. Wenn von einem Werttyp Array in ein Array von Verweistypen zu kopieren, wird jedes Element geschachtelt und kopiert.  
  
-   Beim Kopieren aus einem Array-Verweistyp oder Werttyp in einen <xref:System.Object> Array, ein <xref:System.Object> erstellt, um jeden Wert oder Verweis aufzunehmen und anschließend kopiert wird. Beim Kopieren aus einer <xref:System.Object> Array in ein Array-Verweistyp oder Werttyp und die Zuweisung ist nicht möglich, eine <xref:System.InvalidCastException> ausgelöst wird.  
  
-   Wenn `sourceArray` und `destinationArray` Verweistyp-Arrays sind oder werden beide Arrays des Typs <xref:System.Object>, eine flache Kopie ausgeführt wird. Eine flache Kopie von einer <xref:System.Array> ist ein neues <xref:System.Array> enthält Verweise auf die gleichen Elemente wie die ursprüngliche <xref:System.Array>. Die Elemente selbst oder einem beliebigen Element verwiesen wird, durch die Elemente werden nicht kopiert. Im Gegensatz dazu eine tiefe Kopie von einer <xref:System.Array> kopiert die Elemente und alles, was auf die Elemente direkt oder indirekt verweist.  
  
 Ein <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn die Arrays von inkompatiblen Typen sind. Typkompatibilität ist wie folgt definiert:  
  
-   Ein Typ ist mit sich selbst kompatibel.  
  
-   Ein Werttyp ist kompatibel mit <xref:System.Object> und mit einem Schnittstellentyp, der durch diesen Werttyp implementiert. Ein Werttyp gilt nur, wenn sie diese Schnittstelle, direkt implementiert mit einer Schnittstelle verbunden. Nicht verbundene Typen sind nicht kompatibel.  
  
-   Zwei systeminterne (vordefinierte) Werttypen sind kompatibel, wenn kopieren aus einer Datenquelle in den Zieltyp eine erweiternde Konvertierung ist. Nie eine erweiternde Konvertierung verliert Informationen an, während eine einschränkende Konvertierung Informationen verloren gehen kann. Z. B. eine erweiternde Konvertierung ist eine 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen zu konvertieren, und konvertieren eine 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen ist eine einschränkende Konvertierung. Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
-   Ein systeminterner (Benutzerdefiniert) Werttyp ist nur mit sich selbst kompatibel.  
  
-   Enumerationen verfügen über eine implizite Konvertierung in <xref:System.Enum> und ihren zugrunde liegenden Typ.  
  
 Wenn jedes Element in `sourceArray` eine Umwandlung erfordert (z. B. von einer Basisklasse in einer abgeleiteten Klasse oder von einer Schnittstelle zu einem Objekt) und einem oder mehreren Elementen können nicht in den entsprechenden Typ umgewandelt werden `destinationArray`, wird eine <xref:System.InvalidCastException> ausgelöst wird.  
  
 Wenn diese Methode eine Ausnahme während des Kopiervorgangs, des Status des `destinationArray` ist nicht definiert.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie von einem kopieren <xref:System.Array> des Typs <xref:System.Object> in eine andere <xref:System.Array> vom Typ Integer.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> ist <see langword="null" />.  Oder:  <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> und <paramref name="destinationArray" /> weisen inkompatible Typen auf.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im <paramref name="sourceArray" /> kann nicht in den Typ des <paramref name="destinationArray" />s umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <paramref name="sourceArray" />.  Oder:  <paramref name="destinationIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="destinationArray" />.  Oder:  <paramref name="length" /> ist kleiner als 0 (null) oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="sourceIndex" /> bis zum Ende des <paramref name="sourceArray" />s.  Oder:  <paramref name="length" /> ist größer als die Anzahl der Elemente von <paramref name="destinationIndex" /> bis zum Ende von <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert alle Elemente des aktuellen eindimensionalen Arrays in das angegebene eindimensionale Array.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Array, das das Ziel der aus dem aktuellen Array kopierten Elemente ist.</param>
        <param name="index">Eine 32-Bit-Ganzzahl, die den Index im <c>array</c> angibt, ab dem kopiert werden soll.</param>
        <summary>Kopiert alle Elemente des aktuellen eindimensionalen Arrays in das angegebene eindimensionale Array, beginnend am angegebenen Index des Zielarrays. Der Index wird als 32-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert alle Elemente der aktuellen Arrayinstanz mit den `array` Zielarray, beginnend am Index `index`. Die `array` Zielarray muss bereits haben wurde dimensioniert und muss eine ausreichende Anzahl von Elementen, die der kopierten Elemente aufzunehmen. Andernfalls löst die Methode eine Ausnahme aus.  
  
 Diese Methode unterstützt die <xref:System.Collections.ICollection?displayProperty=nameWithType> Schnittstelle. Wenn implementieren <xref:System.Collections.ICollection?displayProperty=nameWithType> wird nicht explizit erforderlich ist, verwenden <xref:System.Array.Copy%2A> um einen zusätzlichen Dereferenzierung zu vermeiden.  
  
 Wenn diese Methode eine Ausnahme während des Kopiervorgangs, des Status des `array` ist nicht definiert.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Array.Length%2A>. Sie führt nur eine flache Kopie.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Kopieren einer <xref:System.Array> in eine andere <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 Das folgende Codebeispiel veranschaulicht das Kopieren einer <xref:System.Array> in eine andere <xref:System.Array> und eine Untergrenze ungleich NULL. Beachten Sie, dass die gesamte Quelle <xref:System.Array> kopiert wird, einschließlich leere Elemente, die vorhandenen Elemente in das Ziel überschrieben <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> ist mehrdimensional.  Oder:  Die Anzahl der Elemente im Quellarray ist größer als die verfügbare Anzahl der Elemente von <paramref name="index" /> bis zum Ende des Ziel-<paramref name="array" />.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Der Typ der Quell-<see cref="T:System.Array" /> kann nicht automatisch in den Typ des Ziel-<paramref name="array" /> umgewandelt werden.</exception>
        <exception cref="T:System.RankException">Das Quellarray ist mehrdimensional.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im Quell-<see cref="T:System.Array" /> kann nicht in den Typ des Ziel<paramref name="array" />s umgewandelt werden.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Array, das das Ziel der aus dem aktuellen Array kopierten Elemente ist.</param>
        <param name="index">Eine 64-Bit-Ganzzahl, die den Index im <c>array</c> angibt, ab dem kopiert werden soll.</param>
        <summary>Kopiert alle Elemente des aktuellen eindimensionalen Arrays in das angegebene eindimensionale Array, beginnend am angegebenen Index des Zielarrays. Der Index wird als 64-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert alle Elemente der aktuellen Arrayinstanz mit den `array` Zielarray, beginnend am Index `index`. Die `array` Zielarray muss bereits haben wurde dimensioniert und muss eine ausreichende Anzahl von Elementen, die der kopierten Elemente aufzunehmen. Andernfalls löst die Methode eine Ausnahme aus.  
  
 Diese Methode unterstützt die <xref:System.Collections.ICollection?displayProperty=nameWithType> Schnittstelle. Wenn implementieren <xref:System.Collections.ICollection?displayProperty=nameWithType> wird nicht explizit erforderlich ist, verwenden <xref:System.Array.Copy%2A> um einen zusätzlichen Dereferenzierung zu vermeiden.  
  
 Wenn diese Methode eine Ausnahme während des Kopiervorgangs, des Status des `array` ist nicht definiert.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Array.Length%2A>. Sie führt nur eine flache Kopie.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Kopieren einer <xref:System.Array> in eine andere <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 Das folgende Codebeispiel veranschaulicht das Kopieren einer <xref:System.Array> in eine andere <xref:System.Array> und eine Untergrenze ungleich NULL. Beachten Sie, dass die gesamte Quelle <xref:System.Array> kopiert wird, einschließlich leere Elemente, die vorhandenen Elemente in das Ziel überschrieben <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> ist mehrdimensional.  Oder:  Die Anzahl der Elemente im Quellarray ist größer als die verfügbare Anzahl der Elemente von <paramref name="index" /> bis zum Ende des Ziel-<paramref name="array" />.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Der Typ der Quell-<see cref="T:System.Array" /> kann nicht automatisch in den Typ des Ziel-<paramref name="array" /> umgewandelt werden.</exception>
        <exception cref="T:System.RankException">Das Quell-<see cref="T:System.Array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im Quell-<see cref="T:System.Array" /> kann nicht in den Typ des Ziel<paramref name="array" />s umgewandelt werden.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Array" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length">Die Größe des zu erstellenden <see cref="T:System.Array" />.</param>
        <summary>Erstellt ein eindimensionales <see cref="T:System.Array" /> der angegebenen Länge und vom angegebenen <see cref="T:System.Type" /> mit nullbasierter Indizierung.</summary>
        <returns>Ein neues eindimensionales <see cref="T:System.Array" /> der angegebenen Länge und vom angegebenen <see cref="T:System.Type" /> mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen <xref:System.Array> bietet die <xref:System.Array.CreateInstance%2A> -Methode, statt öffentliche Konstruktoren, um spät gebundener Zugriff zu ermöglichen.  
  
 Verweistyp-Elemente werden mit initialisiert `null`. Werttyp Elemente werden mit 0 (null) initialisiert.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie erstellt und initialisiert ein eindimensionales <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  Oder:  <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="lengths">Ein Array von 32-Bit-Ganzzahlen, das die Größe der einzelnen Dimensionen des zu erstellenden <see cref="T:System.Array" /> darstellt.</param>
        <summary>Erstellt ein mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung. Die Längen der Dimension werden in einem Array von 32-Bit-Ganzzahlen angegeben.</summary>
        <returns>Ein neues mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen <xref:System.Array> bietet die <xref:System.Array.CreateInstance%2A> -Methode, statt öffentliche Konstruktoren, um spät gebundener Zugriff zu ermöglichen.  
  
 Die Anzahl der Elemente in der `lengths` Array muss gleich der Anzahl der Dimensionen im neuen <xref:System.Array>. Jedes Element der `lengths` Array muss die Länge der entsprechenden Dimension angeben, in der neuen <xref:System.Array>.  
  
 Verweistyp-Elemente werden mit initialisiert `null`. Werttyp Elemente werden mit 0 (null) initialisiert.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist das Produkt aller Werte in `lengths`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen und initialisieren Sie ein mehrdimensionales <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> ist <see langword="null" />.  Oder:  <paramref name="lengths" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.  Oder:  Das <paramref name="lengths" />-Array enthält weniger als ein Element.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  Oder:  <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Irgendein Wert in <paramref name="lengths" /> ist kleiner als 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="lengths">Ein Array von 64-Bit-Ganzzahlen, das die Größe der einzelnen Dimensionen des zu erstellenden <see cref="T:System.Array" /> darstellt. Jede Ganzzahl im Array muss zwischen 0 (null) und <see cref="F:System.Int32.MaxValue" /> (einschließlich) liegen.</param>
        <summary>Erstellt ein mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung. Die Längen der Dimension werden in einem Array von 64-Bit-Ganzzahlen angegeben.</summary>
        <returns>Ein neues mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen <xref:System.Array> bietet die <xref:System.Array.CreateInstance%2A> -Methode, statt öffentliche Konstruktoren, um spät gebundener Zugriff zu ermöglichen.  
  
 Die Anzahl der Elemente in der `lengths` Array muss gleich der Anzahl der Dimensionen im neuen <xref:System.Array>. Jedes Element der `lengths` Array muss die Länge der entsprechenden Dimension angeben, in der neuen <xref:System.Array>.  
  
 Verweistyp-Elemente werden mit initialisiert `null`. Werttyp Elemente werden mit 0 (null) initialisiert.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist das Produkt aller Werte in `lengths`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen und initialisieren Sie ein mehrdimensionales <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> ist <see langword="null" />.  Oder:  <paramref name="lengths" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.  Oder:  Das <paramref name="lengths" />-Array enthält weniger als ein Element.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  Oder:  <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Jeder Wert in <paramref name="lengths" /> ist kleiner als 0 (null) oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length1">Die Größe der ersten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length2">Die Größe der zweiten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <summary>Erstellt ein zweidimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</summary>
        <returns>Ein neues zweidimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen <xref:System.Array> bietet die <xref:System.Array.CreateInstance%2A> -Methode, statt öffentliche Konstruktoren, um spät gebundener Zugriff zu ermöglichen.  
  
 Verweistyp-Elemente werden mit initialisiert `null`. Werttyp Elemente werden mit 0 (null) initialisiert.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist das Produkt der `length1` und `length2`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen und initialisieren Sie ein zweidimensionales <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  Oder:  <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> ist kleiner als Null.  Oder:  <paramref name="length2" /> ist kleiner als 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="lengths">Ein eindimensionales Array mit den Größen aller Dimensionen des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="lowerBounds">Ein eindimensionales Array mit der unteren Grenze (Startindex) für jede Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <summary>Erstellt ein mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und Untergrenze.</summary>
        <returns>Ein neues mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und Untergrenze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen <xref:System.Array> bietet die <xref:System.Array.CreateInstance%2A> -Methode, statt öffentliche Konstruktoren, um spät gebundener Zugriff zu ermöglichen.  
  
 Die `lengths` und `lowerBounds` Arrays müssen die gleiche Anzahl von Elementen aufweisen. Die Anzahl der Elemente in der `lengths` Array muss gleich der Anzahl der Dimensionen im neuen <xref:System.Array>.  
  
 Jedes Element der `lengths` Array muss die Länge der entsprechenden Dimension angeben, in der neuen <xref:System.Array>.  
  
 Jedes Element der `lowerBounds` Array muss die untere Grenze der entsprechenden Dimension angeben, in der neuen <xref:System.Array>. Der .NET Framework-Klassenbibliothek und viele Programmiersprachen unterstützen im Allgemeinen nicht von ungleich unteren Grenzen.  
  
 Verweistyp-Elemente werden mit initialisiert `null`. Werttyp Elemente werden mit 0 (null) initialisiert.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist das Produkt aller Werte in `lengths`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen und initialisieren Sie ein mehrdimensionales <xref:System.Array> mit der angegebenen Untergrenze.  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> ist <see langword="null" />.  Oder:  <paramref name="lengths" /> ist <see langword="null" />.  Oder:  <paramref name="lowerBounds" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.  Oder:  Das <paramref name="lengths" />-Array enthält weniger als ein Element.  Oder:  Das <paramref name="lengths" />- und das <paramref name="lowerBounds" />-Array enthalten nicht dieselbe Anzahl von Elementen.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  Oder:  <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Irgendein Wert in <paramref name="lengths" /> ist kleiner als 0 (null).  Oder:  Jeder Wert in <paramref name="lowerBounds" /> ist sehr groß, sodass die Summe aus Untergrenze und Länge einer Dimension größer ist als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length1">Die Größe der ersten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length2">Die Größe der zweiten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length3">Die Größe der dritten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <summary>Erstellt ein dreidimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</summary>
        <returns>Ein neues dreidimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen <xref:System.Array> bietet die <xref:System.Array.CreateInstance%2A> -Methode, statt öffentliche Konstruktoren, um spät gebundener Zugriff zu ermöglichen.  
  
 Verweistyp-Elemente werden mit initialisiert `null`. Werttyp Elemente werden mit 0 (null) initialisiert.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist das Produkt der `length1`, `length2`, und `length3`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen und initialisieren Sie ein dreidimensionales <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  Oder:  <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> ist kleiner als Null.  Oder:  <paramref name="length2" /> ist kleiner als 0 (null).  Oder:  <paramref name="length3" /> ist kleiner als 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <summary>Gibt ein leeres Array zurück.</summary>
        <returns>Gibt ein leeres <see cref="T:System.Array" /> zurück.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für die Elemente definiert, nach denen gesucht werden soll.</param>
        <summary>Bestimmt, ob das angegebene Array Elemente enthält, die mit den vom angegebenen Prädikat definierten Bedingungen übereinstimmen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="array" /> mindestens ein Element enthält, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente der `array` einzeln übergeben werden, um die <xref:System.Predicate%601>, und die Verarbeitung wird beendet, wenn eine Übereinstimmung gefunden wird.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die <xref:System.Predicate%601> explizit zu delegieren. Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die übereinstimmungsbedingungen für die <xref:System.Array.Exists%2A> Methode Usinglambda Ausdrücke, um zu überprüfen, ob ein Planet mit einem bestimmten Buchstaben beginnt, oder gibt an, ob der Planet auf dem angegebenen Array gefunden wird.  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 Im folgenden Beispiel wird die <xref:System.Array.Exists%2A> Methode, um anzugeben, ob alle Namen in einem Zeichenfolgenarray mit dem angegebenen Zeichen beginnen. Im Beispiel wird instanziiert einen `StringSearcher` Objekt, indem Sie die zu suchende Zeichenfolge an den Klassenkonstruktor übergeben. Die `StringSearcher.StartsWith` Methode hat die gleiche Signatur wie die <xref:System.Predicate%601> delegieren. Wenn die <xref:System.Array.Exists%2A> -Methode aufgerufen wird, wird jedes Element des Arrays an den Delegaten übergeben, bis zurückgegeben `true` oder alle Elemente im Array durchläuft.  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 Sie können auch einen Lambda-Ausdruck verwenden, anstatt explizit definiert eine Methode, deren Signatur entspricht, der den Delegaten. Im folgende Beispiel ersetzt die `StringSearcher` Klasse und ihre `StartsWith` Methode mit einem Lambdaausdruck.  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.  Oder:  <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte Array.</param>
        <param name="match">Das Prädikat, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt das erste Vorkommen im gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Das erste Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, sofern vorhanden, andernfalls der Standardwert für den Typ <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode oder einen Lambda-Ausdruck, der zurückgibt `true` an das Objekt übergeben sie die Bedingungen der Delegat oder Lambda-Ausdruck übereinstimmt.  Die Elemente der `array` einzeln übergeben werden, um die <xref:System.Predicate%601>, beginnend mit dem ersten Element und endend mit dem letzten Element.  Die Verarbeitung wird beendet, wenn eine Übereinstimmung gefunden wird.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Predicate%601> mit Delegieren der <xref:System.Array.Find%2A> generischen Methode ein Array von Suchen <xref:System.Drawing.Point> Strukturen. Die Methode, die der Delegat darstellt, `ProductGT10`, gibt `true` , wenn das Produkt der X- und Y-Felder größer als 100.000 ist. Die <xref:System.Array.Find%2A> Methode ruft den Delegaten für jedes Element des Arrays zurückgeben des ersten Punkts, der die testbedingung erfüllt.  
  
> [!NOTE]
>  Visual Basic- und C#-Benutzer keine explizit den Delegaten zu erstellen, oder geben Sie das Typargument der aufgerufenen generischen Methode. Die Compiler bestimmen die erforderlichen Typen über die Argumente der Methode, die Sie angeben.  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 Anstatt explizit definiert eine Methode mit der Signatur, Instanziieren einer <xref:System.Predicate%601> delegieren und das Übergeben der Delegat, der die <xref:System.Array.Find%2A> -Methode, ist es üblich, einen Lambda-Ausdruck verwenden. Das folgende Beispiel ist identisch mit der vorherigen Ansicht identisch, jedoch einen Lambdaausdruck als verwendet den `match` Argument.  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.  Oder:  <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für die Elemente definiert, nach denen gesucht werden soll.</param>
        <summary>Ruft alle Elemente ab, die die vom angegebenen Prädikat definierten Bedingungen erfüllen.</summary>
        <returns>Ein <see cref="T:System.Array" /> mit allen Elementen, die die durch das angegebene Prädikat angegebenen Bedingungen erfüllen, sofern gefunden, andernfalls ein leeres <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente der `array` einzeln übergeben werden, um die <xref:System.Predicate%601>, und Elemente, die Bedingungen erfüllen, werden im zurückgegebenen Array gespeichert.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein Array von 50 zufälligen Zahlen mit Werten, die zwischen 0 und 1000 liegen können. Er ruft dann die <xref:System.Array.FindAll%2A> Methode mit einem Lambda-Ausdruck, der die Werte von 300 auf 600 dieses Bereichs zurückgibt. Beachten Sie, dass der Lambda-Ausdruck einen Parameter namens übergeben wird `x`;  Dies stellt der einzelnen Arraymember, die an die <xref:System.Predicate%601>. Beachten Sie, dass die lokale `lBound` und `uBound` Variablen innerhalb der Lambda-Ausdruck zugegriffen werden.  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, und <xref:System.Array.FindAll%2A> generische Methoden. Ein Array von Zeichenfolgen wird erstellt, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden. Das Codebeispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.  
  
 Die <xref:System.Array.Find%2A> generische Methode durchläuft das Array von Anfang an und übergibt die einzelnen Elemente an die `EndsWithSaurus` Methode. Die Suche angehalten wird, wenn die `EndsWithSaurus` -Methode zurückkehrt `true` für das Element "Amargasaurus".  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.  
  
 Die <xref:System.Array.FindLast%2A> generische Methode wird verwendet, um das Array aus dem Ende rückwärts zu suchen. Es sucht nach dem Element "Dilophosaurus" an Position 5. Die <xref:System.Array.FindAll%2A> generische Methode wird verwendet, um ein Array mit allen Elementen, die auf "Saurus" enden zurückgeben. Die Elemente werden angezeigt.  
  
 Im Codebeispiel wird veranschaulicht, die auch die <xref:System.Array.Exists%2A> und <xref:System.Array.TrueForAll%2A> generische Methoden.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.  Oder:  <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat angegebenen Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens in einem <see cref="T:System.Array" /> oder einem Teil daraus zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens im gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> vorwärts beginnend mit dem ersten Element und endet beim letzten Element durchsucht wird.  
  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente der `array` einzeln übergeben werden, um die <xref:System.Predicate%601>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, alle drei Überladungen, der die <xref:System.Array.FindIndex%2A> generische Methode. Ein Array von Zeichenfolgen wird erstellt, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden. Das Codebeispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.  
  
 Die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung durchläuft das Array von Anfang an und übergibt die einzelnen Elemente an die `EndsWithSaurus` Methode. Die Suche angehalten wird, wenn die `EndsWithSaurus` -Methode zurückkehrt `true` für das Element an der Position 1.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.  
  
 Die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung wird verwendet, um das Array, beginnend an Position 2 und bis zum Ende des Arrays zu fortfahren zu suchen. Er findet das Element an Position 5. Schließlich die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung dient zum Suchen des Bereichs von drei Elementen, die an Position 2 ab. Es gibt-1 zurück, da es sind keine Dinosauriernamen in diesem Bereich an, die mit "Saurus" enden.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.  Oder:  <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Suche.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der vom angegebenen Index bis zum letzten Element reicht.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> vorwärts beginnenden durchsucht `startIndex` beginnt und mit dem letzten Element.  
  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente der `array` einzeln übergeben werden, um die <xref:System.Predicate%601>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die Anzahl von Elementen aus `startIndex` bis zum Ende des `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, alle drei Überladungen, der die <xref:System.Array.FindIndex%2A> generische Methode. Ein Array von Zeichenfolgen wird erstellt, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden. Das Codebeispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.  
  
 Die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung durchläuft das Array von Anfang an und übergibt die einzelnen Elemente an die `EndsWithSaurus` Methode. Die Suche angehalten wird, wenn die `EndsWithSaurus` -Methode zurückkehrt `true` für das Element an der Position 1.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.  
  
 Die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung wird verwendet, um das Array, beginnend an Position 2 und bis zum Ende des Arrays zu fortfahren zu suchen. Er findet das Element an Position 5. Schließlich die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung dient zum Suchen des Bereichs von drei Elementen, die an Position 2 ab. Es gibt-1 zurück, da es sind keine Dinosauriernamen in diesem Bereich an, die mit "Saurus" enden.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.  Oder:  <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Suche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der am angegebenen Index beginnt und die angegebene Anzahl von Elementen umfasst.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> vorwärts beginnenden durchsucht `startIndex` und endet bei `startIndex` plus `count` minus 1, wenn `count` ist größer als 0.  
  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente der `array` einzeln übergeben werden, um die <xref:System.Predicate%601>.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist `count`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, alle drei Überladungen, der die <xref:System.Array.FindIndex%2A> generische Methode. Ein Array von Zeichenfolgen wird erstellt, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden. Das Codebeispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.  
  
 Die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung durchläuft das Array von Anfang an und übergibt die einzelnen Elemente an die `EndsWithSaurus` Methode. Die Suche angehalten wird, wenn die `EndsWithSaurus` -Methode zurückkehrt `true` für das Element an der Position 1.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.  
  
 Die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung wird verwendet, um das Array, beginnend an Position 2 und bis zum Ende des Arrays zu fortfahren zu suchen. Er findet das Element an Position 5. Schließlich die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung dient zum Suchen des Bereichs von drei Elementen, die an Position 2 ab. Es gibt-1 zurück, da es sind keine Dinosauriernamen in diesem Bereich an, die mit "Saurus" enden.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.  Oder:  <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  Oder:  <paramref name="count" /> ist kleiner als 0 (null).  Oder:  <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in <paramref name="array" /> an.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt das letzte Vorkommen im gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Das letzte Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, sofern vorhanden, andernfalls der Standardwert für den Typ <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente der `array` werden einzeln an übergeben der <xref:System.Predicate%601>, die Navigation rückwärts in die <xref:System.Array>, beginnend mit dem letzten Element und endend mit dem ersten Element.  Die Verarbeitung wird beendet, wenn eine Übereinstimmung gefunden wird.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, und <xref:System.Array.FindAll%2A> generische Methoden. Ein Array von Zeichenfolgen wird erstellt, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden. Das Codebeispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.  
  
 Die <xref:System.Array.Find%2A> generische Methode durchläuft das Array von Anfang an und übergibt die einzelnen Elemente an die `EndsWithSaurus` Methode. Die Suche angehalten wird, wenn die `EndsWithSaurus` -Methode zurückkehrt `true` für das Element "Amargasaurus".  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die`Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.  
  
 Die <xref:System.Array.FindLast%2A> generische Methode wird verwendet, um das Array aus dem Ende rückwärts zu suchen. Es sucht nach dem Element "Dilophosaurus" an Position 5. Die <xref:System.Array.FindAll%2A> generische Methode wird verwendet, um ein Array mit allen Elementen, die auf "Saurus" enden zurückgeben. Die Elemente werden angezeigt.  
  
 Im Codebeispiel wird veranschaulicht, die auch die <xref:System.Array.Exists%2A> und <xref:System.Array.TrueForAll%2A> generische Methoden.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.  Oder:  <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat angegebenen Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens in einem <see cref="T:System.Array" /> oder einem Teil daraus zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens im gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> rückwärts beginnend mit dem letzten Element und endet mit dem ersten Element gesucht wird.  
  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente der `array` einzeln übergeben werden, um die <xref:System.Predicate%601>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, alle drei Überladungen, der die <xref:System.Array.FindLastIndex%2A> generische Methode. Ein Array von Zeichenfolgen wird erstellt, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden. Das Codebeispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.  
  
 Die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung durchläuft das Array, die nach hinten vom Ende, übergibt jedes Element an der `EndsWithSaurus` Methode. Die Suche angehalten wird, wenn die `EndsWithSaurus` -Methode zurückkehrt `true` für das Element an Position 5.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.  
  
 Die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung wird verwendet, um das Array, beginnend an Position 4 und zu fortfahren rückwärts zum Anfang des Arrays zu suchen. Er findet das Element an der Position 1. Schließlich die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung wird verwendet, um den Bereich von drei Elementen beginnend an Position 4 und rückwärts arbeiten (d. h. die Elemente 4, 3 und 2) suchen. Es gibt-1 zurück, da es sind keine Dinosauriernamen in diesem Bereich an, die mit "Saurus" enden.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.  Oder:  <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der vom ersten Element bis zum angegeben Index reicht.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> ist der gesuchte Rückwärtsrichtung `startIndex` beginnt und mit dem ersten Element.  
  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente der `array` einzeln übergeben werden, um die <xref:System.Predicate%601>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die Anzahl der Elemente vom Anfang des `array` auf `startIndex`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, alle drei Überladungen, der die <xref:System.Array.FindLastIndex%2A> generische Methode. Ein Array von Zeichenfolgen wird erstellt, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden. Das Codebeispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.  
  
 Die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung durchläuft das Array, die nach hinten vom Ende, übergibt jedes Element an der `EndsWithSaurus` Methode. Die Suche angehalten wird, wenn die `EndsWithSaurus` -Methode zurückkehrt `true` für das Element an Position 5.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.  
  
 Die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung wird verwendet, um das Array, beginnend an Position 4 und zu fortfahren rückwärts zum Anfang des Arrays zu suchen. Er findet das Element an der Position 1. Schließlich die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung wird verwendet, um den Bereich von drei Elementen beginnend an Position 4 und rückwärts arbeiten (d. h. die Elemente 4, 3 und 2) suchen. Es gibt-1 zurück, da es sind keine Dinosauriernamen in diesem Bereich an, die mit "Saurus" enden.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.  Oder:  <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der die angegebene Anzahl von Elementen umfasst und am angegebenen Index endet.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> ist der gesuchte Rückwärtsrichtung `startIndex` und endet bei `startIndex` minus `count` plus 1, wenn `count` ist größer als 0.  
  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt `true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente der `array` einzeln übergeben werden, um die <xref:System.Predicate%601>.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist `count`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, alle drei Überladungen, der die <xref:System.Array.FindLastIndex%2A> generische Methode. Ein Array von Zeichenfolgen wird erstellt, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden. Das Codebeispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.  
  
 Die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung durchläuft das Array, die nach hinten vom Ende, übergibt jedes Element an der `EndsWithSaurus` Methode. Die Suche angehalten wird, wenn die `EndsWithSaurus` -Methode zurückkehrt `true` für das Element an Position 5.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.  
  
 Die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung wird verwendet, um das Array, beginnend an Position 4 und zu fortfahren rückwärts zum Anfang des Arrays zu suchen. Er findet das Element an der Position 1. Schließlich die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung wird verwendet, um den Bereich von drei Elementen beginnend an Position 4 und rückwärts arbeiten (d. h. die Elemente 4, 3 und 2) suchen. Es gibt-1 zurück, da es sind keine Dinosauriernamen in diesem Bereich an, die mit "Saurus" enden.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.  Oder:  <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  Oder:  <paramref name="count" /> ist kleiner als 0 (null).  Oder:  <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in <paramref name="array" /> an.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das eindimensionale nullbasierte <see cref="T:System.Array" />, für dessen Elemente die Aktion ausgeführt werden soll.</param>
        <param name="action">Die <see cref="T:System.Action`1" />, die für jedes Element von <c>array</c> ausgeführt werden soll.</param>
        <summary>Führt die angegebene Aktion für jedes Element des angegebenen Arrays aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Action%601> ein Delegaten an eine Methode, die eine Aktion, für das Objekt ausführt übergeben wird.  Die Elemente der `array` einzeln übergeben werden, um die <xref:System.Action%601>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie <xref:System.Array.ForEach%2A> Quadrate der jedes Element in ein Array von Ganzzahlen angezeigt.  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.  Oder:  <paramref name="action" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.Collections.IEnumerator" /> für das <see cref="T:System.Array" /> zurück.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" /> für das <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, c#]  
  
 Die `foreach` -Anweisung der Programmiersprache c# (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist <xref:System.Collections.IEnumerator.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.IEnumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.IEnumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> übergibt am Ende der Auflistung der Enumerator hinter dem letzten Element in der Auflistung positioniert ist und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false`. Wenn der Enumerator ist an dieser Position ist nachfolgende Aufrufe <xref:System.Collections.IEnumerator.MoveNext%2A> auch zurückgeben `false`. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung. Daher ist die Enumeration einer Auflistung systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Array.GetEnumerator%2A> zum Auflisten der Elemente eines Arrays.  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Eine nullbasierte Dimension des <see cref="T:System.Array" />, deren Länge bestimmt werden soll.</param>
        <summary>Ruft eine 32-Bit-Ganzzahl ab, die die Anzahl der Elemente in der angegebenen Dimension des <see cref="T:System.Array" /> angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl, die die Anzahl der Elemente in der angegebenen Dimension angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Beispiel für <xref:System.Array.GetLength%2A> ist `GetLength(0)`, womit die Anzahl der Elemente in der ersten Dimension von der <xref:System.Array>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie <xref:System.Array.GetLength%2A> anzuzeigenden Dimensionen von zwei Arrays mit unterschiedlichem Rang.  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> ist kleiner als Null.  Oder:  <paramref name="dimension" /> ist gleich oder größer als <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Eine nullbasierte Dimension des <see cref="T:System.Array" />, deren Länge bestimmt werden soll.</param>
        <summary>Ruft eine 64-Bit-Ganzzahl ab, die die Anzahl der Elemente in der angegebenen Dimension des <see cref="T:System.Array" /> angibt.</summary>
        <returns>Eine 64-Bit-Ganzzahl, die die Anzahl der Elemente in der angegebenen Dimension angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Beispiel für <xref:System.Array.GetLongLength%2A> ist `GetLongLength(0)`, womit die Anzahl der Elemente in der ersten Dimension von der <xref:System.Array>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> ist kleiner als Null.  Oder:  <paramref name="dimension" /> ist gleich oder größer als <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Eine nullbasierte Dimension des Arrays, dessen Startindex bestimmt werden soll.</param>
        <summary>Ruft den Index des ersten Elements der angegebenen Dimension im Array ab.</summary>
        <returns>Der Index des ersten Elements der angegebenen Dimension im Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)` Der Startindex der ersten Dimension des Arrays zurückgibt und `GetLowerBound(Rank - 1)` gibt den Startindex der letzten Dimension des Arrays zurück.  
  
 Die <xref:System.Array.GetLowerBound%2A> -Methode wird immer einen Wert, der der Index, der die untere Grenze des Arrays, gibt zurück, selbst wenn das Array leer ist.  
  
 Beachten Sie, dass, obwohl die meisten Arrays in .NET Framework nullbasiert sind (d. h. die <xref:System.Array.GetLowerBound%2A> Methode gibt 0 (null) für jede Dimension eines Arrays zurück), .NET Framework unterstützt Arrays, die nicht nullbasiert sind. Solche Arrays erstellt werden können, mit der <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> -Methode, und auch von nicht verwaltetem Code zurückgegeben werden kann.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden, um die Grenzen eines eindimensionale und zweidimensionale Arrays anzuzeigen und um die Werte der entsprechenden Arrayelemente anzuzeigen.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> ist kleiner als Null.  Oder:  <paramref name="dimension" /> ist gleich oder größer als <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Eine nullbasierte Dimension des Arrays, dessen obere Grenze bestimmt werden soll.</param>
        <summary>Ruft den Index des letzten Elements der angegebenen Dimension im Array ab.</summary>
        <returns>Der Index des letzten Elements in der angegebenen Dimension im Array oder -1, wenn die angegebene Dimension leer ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)` den letzten Index der ersten Dimension des Arrays zurückgibt und `GetUpperBound(Rank - 1)` den letzten Index der letzten Dimension des Arrays zurückgibt.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden, um die Grenzen eines eindimensionale und zweidimensionale Arrays anzuzeigen und um die Werte der entsprechenden Arrayelemente anzuzeigen.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> ist kleiner als Null.  Oder:  <paramref name="dimension" /> ist gleich oder größer als <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Wert des angegebenen Elements im aktuellen <see cref="T:System.Array" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Eine 32-Bit-Ganzzahl, die die Position des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des eindimensionalen <see cref="T:System.Array" /> ab. Der Index wird als 32-Bit-Ganzzahl angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des eindimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob der Wert des `index` ist außerhalb des gültigen Bereichs.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau eine Dimension.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Ein eindimensionales Array von 32-Bit-Ganzzahlen, das die Indizes darstellt, die die Position des abzurufenden <see cref="T:System.Array" />-Elements angeben.</param>
        <summary>Ruft den Wert an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als ein Array von 32-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Elemente im `indices` muss gleich der Anzahl der Dimensionen in der <xref:System.Array>. Alle Elemente in der `indices` Array geben muss zusammen die Position des gewünschten Elements des mehrdimensionalen <xref:System.Array>.  
  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Dimensionen im aktuellen <see cref="T:System.Array" /> ist nicht gleich der Anzahl der Elemente von <paramref name="indices" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Ein Element von <paramref name="indices" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">Eine 64-Bit-Ganzzahl, die die Position des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des eindimensionalen <see cref="T:System.Array" /> ab. Der Index wird als 64-Bit-Ganzzahl angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des eindimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob der Wert des `index` ist außerhalb des gültigen Bereichs.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau eine Dimension.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Ein eindimensionales Array von 64-Bit-Ganzzahlen, das die Indizes darstellt, die die Position des abzurufenden <see cref="T:System.Array" />-Elements angeben.</param>
        <summary>Ruft den Wert an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als ein Array von 64-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Elemente im `indices` muss gleich der Anzahl der Dimensionen in der <xref:System.Array>. Alle Elemente in der `indices` Array geben muss zusammen die Position des gewünschten Elements des mehrdimensionalen <xref:System.Array>.  
  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Dimensionen im aktuellen <see cref="T:System.Array" /> ist nicht gleich der Anzahl der Elemente von <paramref name="indices" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein Element von <paramref name="indices" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau zwei Dimensionen.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> oder <paramref name="index2" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau zwei Dimensionen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> oder <paramref name="index2" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index3">Eine 32-Bit-Ganzzahl, die den Index für die dritte Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau drei Dimensionen.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" />, <paramref name="index2" /> oder <paramref name="index3" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index3">Eine 64-Bit-Ganzzahl, die den Index für die dritte Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau drei Dimensionen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" />, <paramref name="index2" /> oder <paramref name="index3" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht das angegebene Objekt und gibt den Index seines ersten Auftretens in einem eindimensionalen Array oder in einem Elementbereich im Array zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale Array.</param>
        <param name="value">Das in <c>array</c> zu suchende Objekt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des ersten Vorkommens in einem eindimensionalen Array zurück.</summary>
        <returns>Der Index des ersten Vorkommens von <paramref name="value" /> in <paramref name="array" />, sofern gefunden, andernfalls die untere Grenze des Arrays minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht alle Elemente in einem eindimensionalen Arrayfor `value`. Um zu bestimmen, ob `value` vorhanden ist, `array`, die Methode führt einen Gleichheitsvergleich durch Aufrufen des Elements `Equals` Methode, bis eine Übereinstimmung gefunden wird. Dies bedeutet, dass, wenn das Element überschreibt die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Methode, die Außerkraftsetzung wird aufgerufen.  
  
 Da die meisten Arrays auf eine unteren Grenze von 0 (null) haben, in der Regel bei Rückgabe dieser Methode – 1`value` nicht gefunden. In dem seltenen Fall, die die untere Grenze des Arrays entspricht <xref:System.Int32.MinValue?displayProperty=nameWithType>(0 x 80000000) und `value` nicht gefunden wird, gibt diese Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im Beispiel wird die folgenden drei Überladungen der <xref:System.Array.IndexOf%2A> Methode, um den Index einer Zeichenfolge in einem Zeichenfolgenarray zu ermitteln:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in ein Zeichenfolgenarray.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in das vierte an die letzten Elemente eines Zeichenfolgenarrays.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in einer Zeichenfolge array, aus dem Element, das am Ende des Arrays die letzte erfolgreiche Übereinstimmung folgt.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale Array.</param>
        <param name="value">Das in <c>array</c> zu suchende Objekt.</param>
        <param name="startIndex">Der Startindex für die Suche. 0 (null) ist in einem leeren Array gültig.</param>
        <summary>Sucht das angegebene Objekt in einem Elementbereich eines eindimensionalen Arrays und gibt den Index seines ersten Auftretens zurück. Der Bereich erstreckt sich von einem angegebenen Index bis zum Ende des Arrays.</summary>
        <returns>Der Index des ersten Vorkommens von <paramref name="value" />, sofern gefunden, innerhalb des Bereichs von Elementen in <paramref name="array" />, der sich von <paramref name="startIndex" /> bis zum letzten Element erstreckt, andernfalls die untere Grenze des Arrays minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht ein eindimensionales Array, aus dem Element am Index `startIndex` bis zum letzten Element. Um zu bestimmen, ob `value` vorhanden ist, `array`, die Methode führt einen Gleichheitsvergleich durch Aufrufen der `Equals` Methode jedes Elements, bis eine Übereinstimmung gefunden wird. Dies bedeutet, dass, wenn das Element überschreibt die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Methode, die Außerkraftsetzung wird aufgerufen.  
  
 Da die meisten Arrays auf eine unteren Grenze von 0 (null) haben, in der Regel bei Rückgabe dieser Methode – 1 `value` nicht gefunden. In dem seltenen Fall, die die untere Grenze des Arrays entspricht <xref:System.Int32.MinValue?displayProperty=nameWithType>(0 x 80000000) und `value` nicht gefunden wird, gibt diese Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Wenn `startIndex` gleich <xref:System.Array.Length%2A?displayProperty=nameWithType>, die Methode gibt-1 zurück. Wenn `startIndex` ist größer als <xref:System.Array.Length%2A?displayProperty=nameWithType>, löst die Methode eine <xref:System.ArgumentOutOfRangeException>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die Anzahl von Elementen aus `startIndex` bis zum Ende des `array`.  
  
   
  
## Examples  
 Im Beispiel wird die folgenden drei Überladungen der <xref:System.Array.IndexOf%2A> Methode, um den Index einer Zeichenfolge in einem Zeichenfolgenarray zu ermitteln:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in ein Zeichenfolgenarray.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in das vierte an die letzten Elemente eines Zeichenfolgenarrays.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in einer Zeichenfolge array, aus dem Element, das am Ende des Arrays die letzte erfolgreiche Übereinstimmung folgt.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale Array.</param>
        <param name="value">Das in <c>array</c> zu suchende Objekt.</param>
        <param name="startIndex">Der Startindex für die Suche. 0 (null) ist in einem leeren Array gültig.</param>
        <param name="count">Die Anzahl der zu suchenden Elemente.</param>
        <summary>Sucht das angegebene Objekt in einem Bereich von Elementen eines eindimensionalen Arrays und gibt den Index des ersten Vorkommens zurück. Der Bereich erstreckt sich von einem angegebenen Index für eine angegebene Anzahl von Elementen.</summary>
        <returns>Der Index des ersten Vorkommens von <paramref name="value" />, sofern gefunden im <paramref name="array" /> vom <paramref name="startIndex" />-Index bis <paramref name="startIndex" /> + <paramref name="count" /> – 1; andernfalls die untere Grenze des Arrays minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht die Elemente einer eindimensionalen Arrayfrom `startIndex` auf `startIndex` plus `count` minus 1, wenn `count` ist größer als 0. Um zu bestimmen, ob `value` vorhanden ist, `array`, die Methode führt einen Gleichheitsvergleich durch Aufrufen der `Equals` Methode jedes Elements, bis eine Übereinstimmung gefunden wird. Dies bedeutet, dass, wenn das Element überschreibt die <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode, die Außerkraftsetzung wird aufgerufen.  
  
 Becausemost Arrays haben eine untere Grenze von 0 (null), gibt diese Methode in der Regel – 1 bei `value` nicht gefunden. In dem seltenen Fall, die die untere Grenze des Arrays entspricht <xref:System.Int32.MinValue?displayProperty=nameWithType> (0 x 80000000) und `value` nicht gefunden wird, gibt diese Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Wenn `startindex` gleich <xref:System.Array.Length%2A?displayProperty=nameWithType>, die Methode gibt-1 zurück. Wenn `startIndex` ist größer als <xref:System.Array.Length%2A?displayProperty=nameWithType>, löst die Methode eine <xref:System.ArgumentOutOfRangeException>.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist `count`.  
  
   
  
## Examples  
 Im Beispiel wird die folgenden drei Überladungen der <xref:System.Array.IndexOf%2A> Methode, um den Index einer Zeichenfolge in einem Zeichenfolgenarray zu ermitteln:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in ein Zeichenfolgenarray.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in das vierte an die letzten Elemente eines Zeichenfolgenarrays.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in einer Zeichenfolge array, aus dem Element, das am Ende des Arrays die letzte erfolgreiche Übereinstimmung folgt. Zum Bestimmen des Werts von der `count` Argument, es subtrahiert die obere Grenze des Arrays aus den startIndex und hinzugefügt.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  Oder:  <paramref name="count" /> ist kleiner als 0 (null).  Oder:  <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in <paramref name="array" /> an.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte Array.</param>
        <param name="value">Das in <c>array</c> zu suchende Objekt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des ersten Vorkommens in einem eindimensionalen Array zurück.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="value" /> im gesamten <paramref name="array" />, sofern gefunden, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht alle Elemente eines eindimensionalen Arrays für `value`. Um zu bestimmen, ob `value` vorhanden ist, `array`, die Methode führt einen Gleichheitsvergleich durch Aufrufen der `T.Equals` -Methode für jedes Element. Dies bedeutet, dass bei `T` überschreibt die <xref:System.Object.Equals%2A> Methode, die Außerkraftsetzung wird aufgerufen.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei generische Überladung von der <xref:System.Array.IndexOf%2A> Methode. Ein Array von Zeichenfolgen wird mit einem Eintrag erstellt, die an die Indexposition 0 und Indexposition 5 zweimal angezeigt wird. Die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> -methodenüberladung, durchsucht das Array ab und sucht das erste Vorkommen der Zeichenfolge. Die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> methodenüberladung wird verwendet, um das Array, beginnend mit Indexposition 3 und bis zum Ende des Arrays zu fortfahren zu suchen, und sucht das zweite Vorkommen der Zeichenfolge. Schließlich die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> methodenüberladung wird verwendet, um einen Bereich mit zwei Einträgen, beginnend bei Indexposition zwei suchen; es gibt-1 zurück, da keine Instanzen der Suchzeichenfolge in diesem Bereich vorhanden sind.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte Array.</param>
        <param name="value">Das in <c>array</c> zu suchende Objekt.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Suche. 0 (null) ist in einem leeren Array gültig.</param>
        <summary>Sucht das angegebene Objekt in einem Bereich von Elementen eines eindimensionalen Arrays und gibt den Index des ersten Vorkommens zurück. Der Bereich erstreckt sich von einem angegebenen Index bis zum Ende des Arrays.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen in <paramref name="array" />, der sich von <paramref name="startIndex" /> bis zum letzten Element erstreckt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht ein eindimensionales Array, aus das Element am `startIndex` bis zum Ende des Arrays. Um zu bestimmen, ob `value` vorhanden ist, `array`, die Methode führt einen Gleichheitsvergleich durch Aufrufen der `T.Equals` -Methode für jedes Element. Dies bedeutet, dass bei `T` überschreibt die <xref:System.Object.Equals%2A> Methode, die Außerkraftsetzung wird aufgerufen.  
  
 Wenn `startIndex` gleich <xref:System.Array.Length%2A>, der Methodenrückgabe - 1.If `startIndex` ist größer als <xref:System.Array.Length%2A?displayProperty=nameWithType>, löst die Methode eine <xref:System.ArgumentOutOfRangeException>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die Anzahl von Elementen aus `startIndex` bis zum Ende des `array`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei generische Überladung von der <xref:System.Array.IndexOf%2A> Methode. Ein Array von Zeichenfolgen wird mit einem Eintrag erstellt, die an die Indexposition 0 und Indexposition 5 zweimal angezeigt wird. Die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> -methodenüberladung, durchsucht das Array ab und sucht das erste Vorkommen der Zeichenfolge. Die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> methodenüberladung wird verwendet, um das Array, beginnend mit Indexposition 3 und bis zum Ende des Arrays zu fortfahren zu suchen, und sucht das zweite Vorkommen der Zeichenfolge. Schließlich die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> methodenüberladung wird verwendet, um einen Bereich mit zwei Einträgen, beginnend bei Indexposition zwei suchen; es gibt-1 zurück, da keine Instanzen der Suchzeichenfolge in diesem Bereich vorhanden sind.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte Array.</param>
        <param name="value">Das in <c>array</c> zu suchende Objekt.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Suche. 0 (null) ist in einem leeren Array gültig.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht das angegebene Objekt in einem Elementbereich eines eindimensionalen Arrays und gibt den Index seines ersten Auftretens zurück. Der Bereich erstreckt sich von einem angegebenen Index für eine angegebene Anzahl von Elementen.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen in <paramref name="array" />, der am <paramref name="startIndex" /> beginnt und die durch <paramref name="count" /> angegebene Anzahl von Elementen enthält, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode Searchesthe Elemente eines eindimensionalen Arrays von `startIndex` auf `startIndex` plus `count` minus 1, wenn `count` ist größer als 0. Um zu bestimmen, ob `value` vorhanden ist, `array`, die Methode führt einen Gleichheitsvergleich durch Aufrufen der `T.Equals` -Methode für jedes Element. Dies bedeutet, dass bei `T` überschreibt die <xref:System.Object.Equals%2A> Methode, die Außerkraftsetzung wird aufgerufen.  
  
 Wenn `startIndex` gleich <xref:System.Array.Length%2A?displayProperty=nameWithType>, die Methode gibt-1 zurück.  Wenn `startIndex` ist größer als <xref:System.Array.Length%2A?displayProperty=nameWithType>, löst die Methode eine <xref:System.ArgumentOutOfRangeException>.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist `count`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei generische Überladung von der <xref:System.Array.IndexOf%2A> Methode. Ein Array von Zeichenfolgen wird mit einem Eintrag erstellt, die an die Indexposition 0 und Indexposition 5 zweimal angezeigt wird. Die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> -methodenüberladung, durchsucht das Array ab und sucht das erste Vorkommen der Zeichenfolge. Die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> methodenüberladung wird verwendet, um das Array, beginnend mit Indexposition 3 und bis zum Ende des Arrays zu fortfahren zu suchen, und sucht das zweite Vorkommen der Zeichenfolge. Schließlich die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> methodenüberladung wird verwendet, um einen Bereich mit zwei Einträgen, beginnend bei Indexposition zwei suchen; es gibt-1 zurück, da keine Instanzen der Suchzeichenfolge in diesem Bereich vorhanden sind.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  Oder:  <paramref name="count" /> ist kleiner als 0 (null).  Oder:  <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in <paramref name="array" /> an.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialisiert jedes Element des Werttyp-<see cref="T:System.Array" /> durch einen Aufruf des Standardkonstruktors für den Werttyp.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode soll helfen, Compiler Werttyp Arrays unterstützen; Die meisten Benutzer benötigen diese Methode nicht. Es muss nicht auf den Verweistyp-Arrays verwendet werden.  
  
 Wenn die <xref:System.Array> ist es sich nicht um ein Werttyp <xref:System.Array> oder der Werttyp keinen Standardkonstruktor besitzt die <xref:System.Array> wird nicht geändert.  
  
 Der Werttyp <xref:System.Array> untere Grenze und eine beliebige Anzahl von Dimensionen aufweisen.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Array.Length%2A>.  
  
> [!CAUTION]
>  Sie können diese Methode nur für Werttypen, die über Konstruktoren verfügen. jedoch sind Werttypen, die vom einheitlichen Modus zum c# sind keine Konstruktoren aufweisen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Array" /> eine feste Größe aufweist.</summary>
        <value>Diese Eigenschaft ist für alle Arrays immer <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementiert die <xref:System.Array.IsFixedSize%2A> Eigenschaft, da er erforderlich ist der <xref:System.Collections.IList?displayProperty=nameWithType> Schnittstelle.  
  
 Ein Array mit fester Größe lässt das Hinzufügen oder Entfernen von Elementen nach dem das Array erstellt wird, die Änderung von vorhandenen Elementen können jedoch nicht zu.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Array" /> schreibgeschützt ist.</summary>
        <value>Diese Eigenschaft ist für alle Arrays immer <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementiert die <xref:System.Array.IsReadOnly%2A> Eigenschaft, da er erforderlich ist der <xref:System.Collections.IList?displayProperty=nameWithType> Schnittstelle. Ein Array, das ist schreibgeschützt und lässt das Hinzufügen, entfernen oder Ändern von Elementen nach dem wird das Array erstellt nicht zu.  
  
 Wenn Sie eine schreibgeschützte Auflistung benötigen, verwenden Sie eine <xref:System.Collections> Klasse, die implementiert die <xref:System.Collections.IList?displayProperty=nameWithType> Schnittstelle.  
  
 Wenn Sie umgewandelt oder ein Array konvertiert, ein <xref:System.Collections.IList> Schnittstellenobjekt, die <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> -Eigenschaft gibt `false`. Jedoch umgewandelt oder konvertiert ein Array an eine <xref:System.Collections.Generic.IList%601> -Schnittstelle, die `IsReadOnly` -Eigenschaft gibt `true`.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Array" /> synchronisiert (threadsicher) ist.</summary>
        <value>Diese Eigenschaft ist für alle Arrays immer <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementiert die <xref:System.Array.IsSynchronized%2A> Eigenschaft, da er erforderlich ist der <xref:System.Collections.ICollection?displayProperty=nameWithType> Schnittstelle.  
  
 .NET Framework-Klassen basierend auf <xref:System.Array> bieten eigene synchronisierte Version der Auflistung unter Verwendung der <xref:System.Array.SyncRoot%2A> Eigenschaft.  
  
 Klassen, die Arrays verwenden, können auch implementieren ihre eigenen Synchronisierung über die <xref:System.Array.SyncRoot%2A> Eigenschaft. Im Synchronisierungscode führen Vorgänge für die `SyncRoot` der Auflistung, nicht direkt für die Auflistung. Dies gewährleistet die einwandfreie Funktion von Auflistungen, die von anderen Objekten abgeleitet sind. Insbesondere verwaltet er die ordnungsgemäße Synchronisierung mit anderen Threads, die gleichzeitig die Auflistung eventuell. Beachten Sie, dass einige Implementierungen von <xref:System.Array.SyncRoot%2A> möglicherweise zurück, die <xref:System.Array> selbst.  
  
 Einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein Array während der gesamten Enumeration sperren, mit der <xref:System.Array.SyncRoot%2A> Eigenschaft.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Index des letzten Vorkommens eines Werts in einem eindimensionalen <see cref="T:System.Array" /> oder in einem Teil des <see cref="T:System.Array" /> zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das in <c>array</c> zu suchende Objekt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des gesamten eindimensionalen <see cref="T:System.Array" /> zurück.</summary>
        <returns>Der Index des letzten Vorkommens von <paramref name="value" /> im gesamten <paramref name="array" />, sofern gefunden, andernfalls die untere Grenze des Arrays - 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das eindimensionale <xref:System.Array> rückwärts beginnend mit dem letzten Element und endet mit dem ersten Element gesucht wird.  
  
 Die Elemente mit dem angegebenen Wert verglichen werden die <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode. Wenn der Elementtyp ein systeminterner (Benutzerdefiniert) handelt, ist die `Equals` Implementierung dieses Typs verwendet.  
  
 Da die meisten Arrays mit eine unteren Grenze von 0 (null) hat, würden diese Methode in der Regel bei – 1 zurück `value` wurde nicht gefunden. In dem seltenen Fall, die die untere Grenze des Arrays entspricht <xref:System.Int32.MinValue?displayProperty=nameWithType> und `value` nicht gefunden wird, gibt diese Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType>, also `System.Int32.MinValue - 1`.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
 In .NET Framework, Version 2.0, diese Methode verwendet die <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> Methoden der <xref:System.Array> um zu bestimmen, ob der <xref:System.Object> gemäß der `value` Parameter vorhanden ist. In früheren Versionen von .NET Framework-diese Entscheidung wurde versucht, mithilfe der <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> Methoden die `value` <xref:System.Object> selbst.  
  
 <xref:System.IComparable.CompareTo%2A> Methoden der `item` Parameter für die Objekte in der Auflistung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Index des letzten Vorkommens eines angegebenen Elements in einem Array zu bestimmen.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das in <c>array</c> zu suchende Objekt.</param>
        <param name="startIndex">Der Startindex für die Rückwärtssuche.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im eindimensionalen <see cref="T:System.Array" /> zurück, der sich vom ersten Element bis zum angegebenen Index erstreckt.</summary>
        <returns>Der Index des letzten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen in <paramref name="array" />, der sich vom ersten Element bis zu <paramref name="startIndex" /> erstreckt, sofern gefunden, andernfalls die untere Grenze des Arrays - 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das eindimensionale <xref:System.Array> ist der gesuchte Rückwärtsrichtung `startIndex` beginnt und mit dem ersten Element.  
  
 Die Elemente mit dem angegebenen Wert verglichen werden die <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode. Wenn der Elementtyp ein systeminterner (Benutzerdefiniert) handelt, ist die `Equals` Implementierung dieses Typs verwendet.  
  
 Da die meisten Arrays mit eine unteren Grenze von 0 (null) hat, würden diese Methode in der Regel bei – 1 zurück `value` wurde nicht gefunden. In dem seltenen Fall, die die untere Grenze des Arrays entspricht <xref:System.Int32.MinValue?displayProperty=nameWithType> und `value` nicht gefunden wird, gibt diese Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType>, also `System.Int32.MinValue - 1`.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die Anzahl der Elemente vom Anfang des `array` auf `startIndex`.  
  
 In .NET Framework, Version 2.0, diese Methode verwendet die <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> Methoden der <xref:System.Array> um zu bestimmen, ob der <xref:System.Object> gemäß der `value` Parameter vorhanden ist. In früheren Versionen von .NET Framework-diese Entscheidung wurde versucht, mithilfe der <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> Methoden die `value` <xref:System.Object> selbst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Index des letzten Vorkommens eines angegebenen Elements in einem Array zu bestimmen.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das in <c>array</c> zu suchende Objekt.</param>
        <param name="startIndex">Der Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im eindimensionalen <see cref="T:System.Array" /> zurück, der die angegebene Anzahl von Elementen enthält und am angegebenen Index endet.</summary>
        <returns>Der Index des letzten Vorkommens von <paramref name="value" /> im Bereich von Elementen in <paramref name="array" />, der die durch <paramref name="count" /> angegebene Anzahl von Elementen enthält und sich bis zu <paramref name="startIndex" /> erstreckt, sofern gefunden, andernfalls die untere Grenze des Arrays - 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das eindimensionale <xref:System.Array> ist der gesuchte Rückwärtsrichtung `startIndex` und endet bei `startIndex` minus `count` plus 1, wenn `count` ist größer als 0.  
  
 Die Elemente mit dem angegebenen Wert verglichen werden die <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode. Wenn der Elementtyp ein systeminterner (Benutzerdefiniert) handelt, ist die`Equals` Implementierung dieses Typs verwendet.  
  
 Da die meisten Arrays mit eine unteren Grenze von 0 (null) hat, würden diese Methode in der Regel bei – 1 zurück `value` wurde nicht gefunden. In dem seltenen Fall, die die untere Grenze des Arrays entspricht <xref:System.Int32.MinValue?displayProperty=nameWithType> und `value` nicht gefunden wird, gibt diese Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType>, also `System.Int32.MinValue - 1`.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist `count`.  
  
 In .NET Framework, Version 2.0, diese Methode verwendet die <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> Methoden der <xref:System.Array> um zu bestimmen, ob der <xref:System.Object> gemäß der `value` Parameter vorhanden ist. In früheren Versionen von .NET Framework-diese Entscheidung wurde versucht, mithilfe der <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> Methoden die `value` <xref:System.Object> selbst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Index des letzten Vorkommens eines angegebenen Elements in einem Array zu bestimmen. Beachten Sie, dass die <xref:System.Array.LastIndexOf%2A> Methode ist eine Rückwärtssuche daher `count` muss kleiner als oder gleich sein (`startIndex` minus die untere Grenze des Arrays plus 1).  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  Oder:  <paramref name="count" /> ist kleiner als 0 (null).  Oder:  <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in <paramref name="array" /> an.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das in <c>array</c> zu suchende Objekt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="value" /> in der gesamten <paramref name="array" />, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> rückwärts beginnend mit dem letzten Element und endet mit dem ersten Element gesucht wird.  
  
 Die Elemente mit dem angegebenen Wert verglichen werden die <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode. Wenn der Elementtyp ein systeminterner (Benutzerdefiniert) handelt, ist die `Equals` Implementierung dieses Typs verwendet.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, alle drei generische Überladung von der <xref:System.Array.LastIndexOf%2A> Methode. Ein Array von Zeichenfolgen wird mit einem Eintrag erstellt, die an die Indexposition 0 und Indexposition 5 zweimal angezeigt wird. Die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> methodenüberladung sucht das gesamte Array vom Ende aus, und sucht das zweite Vorkommen der Zeichenfolge. Die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> methodenüberladung wird verwendet, um die Abwärtskompatibilität Array, beginnend mit Indexposition 3 und auf den Anfang des Arrays zu fortfahren durchsuchen und sucht das erste Vorkommen der Zeichenfolge. Schließlich die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> methodenüberladung wird verwendet, um einen Bereich von vier Einträge, beginnend bei Indexposition 4 und rückwärts erweitern suchen (d. h. er sucht die Elemente an Stellen 4, 3, 2 und 1); diese Suche wird – 1 zurückgegeben, da keine Instanzen der Suche vorhanden sind die Zeichenfolge in diesem Bereich.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das in <c>array</c> zu suchende Objekt.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der sich vom ersten Element bis zum angegebenen Index erstreckt.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen in <paramref name="array" />, der sich vom ersten Element bis zu <paramref name="startIndex" /> erstreckt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> ist der gesuchte Rückwärtsrichtung `startIndex` beginnt und mit dem ersten Element.  
  
 Die Elemente mit dem angegebenen Wert verglichen werden die <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode. Wenn der Elementtyp ein systeminterner (Benutzerdefiniert) handelt, ist die `Equals` Implementierung dieses Typs verwendet.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die Anzahl der Elemente vom Anfang des `array` auf `startIndex`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, alle drei generische Überladung von der <xref:System.Array.LastIndexOf%2A> Methode. Ein Array von Zeichenfolgen wird mit einem Eintrag erstellt, die an die Indexposition 0 und Indexposition 5 zweimal angezeigt wird. Die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> methodenüberladung sucht das gesamte Array vom Ende aus, und sucht das zweite Vorkommen der Zeichenfolge. Die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> methodenüberladung wird verwendet, um die Abwärtskompatibilität Array, beginnend mit Indexposition 3 und auf den Anfang des Arrays zu fortfahren durchsuchen und sucht das erste Vorkommen der Zeichenfolge. Schließlich die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> methodenüberladung wird verwendet, um einen Bereich von vier Einträge, beginnend bei Indexposition 4 und rückwärts erweitern suchen (d. h. er sucht die Elemente an Stellen 4, 3, 2 und 1); diese Suche wird – 1 zurückgegeben, da keine Instanzen der Suche vorhanden sind die Zeichenfolge in diesem Bereich.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das in <c>array</c> zu suchende Objekt.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der die angegebene Anzahl von Elementen enthält und am angegebenen Index endet.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen in der <paramref name="array" />, der die durch <paramref name="count" /> angegebene Anzahl von Elementen enthält und am <paramref name="startIndex" /> endet, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> ist der gesuchte Rückwärtsrichtung `startIndex` und endet bei `startIndex` minus `count` plus 1, wenn `count` ist größer als 0.  
  
 Die Elemente mit dem angegebenen Wert verglichen werden die <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode. Wenn der Elementtyp ein systeminterner (Benutzerdefiniert) handelt, ist die `Equals` Implementierung dieses Typs verwendet.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist `count`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, alle drei generische Überladung von der <xref:System.Array.LastIndexOf%2A> Methode. Ein Array von Zeichenfolgen wird mit einem Eintrag erstellt, die an die Indexposition 0 und Indexposition 5 zweimal angezeigt wird. Die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> methodenüberladung sucht das gesamte Array vom Ende aus, und sucht das zweite Vorkommen der Zeichenfolge. Die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> methodenüberladung wird verwendet, um die Abwärtskompatibilität Array, beginnend mit Indexposition 3 und auf den Anfang des Arrays zu fortfahren durchsuchen und sucht das erste Vorkommen der Zeichenfolge. Schließlich die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> methodenüberladung wird verwendet, um einen Bereich von vier Einträge, beginnend bei Indexposition 4 und rückwärts erweitern suchen (d. h. er sucht die Elemente an Stellen 4, 3, 2 und 1); diese Suche wird – 1 zurückgegeben, da keine Instanzen der Suche vorhanden sind die Zeichenfolge in diesem Bereich.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  Oder:  <paramref name="count" /> ist kleiner als 0 (null).  Oder:  <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in <paramref name="array" /> an.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtanzahl der Elemente in allen Dimensionen im <see cref="T:System.Array" /> ab.</summary>
        <value>Die Gesamtanzahl der Elemente in allen Dimensionen die <see cref="T:System.Array" />; 0 (null), wenn keine Elemente im Array vorhanden sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Array.Length%2A> Eigenschaft, um die Gesamtanzahl der Elemente in einem Array abzurufen. Darüber hinaus verwendet die <xref:System.Array.GetUpperBound%2A> Methode, um die Anzahl der Elemente in jeder Dimension eines mehrdimensionalen Arrays festzulegen.  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Das Array ist mehrdimensional und enthält mehr als <see cref="F:System.Int32.MaxValue" />-Elemente.</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine 64-Bit-Ganzzahl ab, die die Gesamtanzahl der Elemente in allen Dimensionen des <see cref="T:System.Array" /> angibt.</summary>
        <value>Eine 64-Bit-Ganzzahl, die die Gesamtanzahl der Elemente in allen Dimensionen des <see cref="T:System.Array" /> angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft der Rang (Anzahl der Dimensionen) des <see cref="T:System.Array" /> ab. Ein eindimensionales Array gibt z. B. 1 zurück, ein zweidimensionales Array gibt 2 zurück usw.</summary>
        <value>Der Rang (Anzahl der Dimensionen) des <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Z. B. Visual Basic-code  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 und der C#-code  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 erstellt ein Array von drei Dimensionen mit einer <xref:System.Array.Rank%2A> Eigenschaft, deren Wert 3.  
  
 Ein verzweigtes Array (ein Array aus Arrays) ist ein eindimensionales Array. der Wert von dessen <xref:System.Array.Rank%2A> Eigenschaft ist 1.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel initialisiert ein eindimensionales Array, ein zweidimensionales Array und ein verzweigtes Array und ruft die <xref:System.Array.Rank%2A> jeder Eigenschaft.  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]&amp;" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das eindimensionale nullbasierte Array, dessen Größe geändert werden soll, oder <see langword="null" />, um ein neues Array mit der angegebenen Größe zu erstellen.</param>
        <param name="newSize">Die Größe des neuen Arrays.</param>
        <summary>Ändert die Anzahl der Elemente eines eindimensionalen Arrays in die angegebene neue Größe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode weist ein neues Array mit der angegebenen Größe, Elemente aus dem alten Array in das neue Projekt kopiert und ersetzt dann das alte Array mit den neuen Wert. `array` ein eindimensionales Array muss sein.  
  
 Wenn `array` ist `null`, diese Methode erstellt ein neues Array mit der angegebenen Größe.  
  
 Wenn `newSize` ist größer als die <xref:System.Array.Length%2A> des alten Arrays wird ein neues Array zugeordnet und alle Elemente werden aus dem alten Array in das neue Projekt kopiert.  Wenn `newSize` ist kleiner als das <xref:System.Array.Length%2A> des alten Arrays wird ein neues Array zugeordnet und Elemente werden aus dem alten Array in das neue Projekt kopiert, bis das neue Array aufgefüllt wird; die übrigen Elemente im alten Array werden ignoriert.  Wenn `newSize` ist gleich der <xref:System.Array.Length%2A> des alten Arrays wird diese Methode keine Aktion ausgeführt.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist `newSize`.  
  
 Die <xref:System.Array.Resize%2A> Methode wird nur ein eindimensionales Array. Die <xref:System.Array> Klasse eine Methode zum Ändern der Größe von mehrdimensionalen Arrays nicht einschließt. Zu diesem Zweck müssen Sie Ihren eigenen Code bereitstellen oder eine spezielle Methode in einer Bibliothek eines Drittanbieters aufrufen. Das folgende Codebeispiel veranschaulicht eine mögliche Implementierung für eine Methode, ein Array von der Größe der *n* Dimensionen.  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Ändern der Größe des Arrays auswirkt.  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newSize" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kehrt die Reihenfolge der Elemente in einem eindimensionalen <see cref="T:System.Array" /> oder in einen Teil des <see cref="T:System.Array" /> um.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Das umzukehrende eindimensionale <see cref="T:System.Array" />.</param>
        <summary>Kehrt die Reihenfolge der Elemente im gesamten eindimensionalen <see cref="T:System.Array" /> um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem Aufruf dieser Methode das Element am `myArray[i]`, wobei `i` ein Index im Array ist, verschiebt `myArray[j]`, wobei `j` gleich `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
 Wie im folgenden Beispiel wird gezeigt, die <xref:System.Array.Reverse%2A> Methode kann verwendet werden, um ein verzweigtes Array umzukehren. Initialisiert ein verzweigtes Array mit einem Element für jeden Monat des aktuellen Jahrs in der aktuellen Kultur dar. Jedes Element enthält ein Array mit beliebig viele Elemente, die diesen Monat Tage hat. Das Beispiel zeigt den Inhalt des Arrays, ruft die <xref:System.Array.Reverse%2A> -Methode, und dann den Inhalt des umgekehrten Arrays.  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Reihenfolge der Werte in umgekehrt ein <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ist mehrdimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das umzukehrende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des umzukehrenden Abschnitts.</param>
        <param name="length">Die Anzahl der Elemente im umzukehrenden Abschnitt.</param>
        <summary>Kehrt die Reihenfolge der Elemente in einem Bereich von Elementen im eindimensionalen <see cref="T:System.Array" /> um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem Aufruf dieser Methode das Element am `myArray[i]`, wobei `i` ein Index im Array ist, verschiebt `myArray[j]`, wobei `j` gleich `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 Die <xref:System.Array.Reverse%2A> Methode kann verwendet werden, um ein verzweigtes Array umzukehren.  
  
 Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Sortierreihenfolge der Werte in einem Bereich der Elemente im umzukehrenden ein <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  Oder:  <paramref name="length" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt das angegebene Element im aktuellen <see cref="T:System.Array" /> auf den angegebenen Wert fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index">Eine 32-Bit-Ganzzahl, die die Position des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des eindimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Der Index wird als 32-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob der Wert des `index` ist außerhalb des gültigen Bereichs.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> zugewiesen `null` auf ein Element eines Arrays von Werttypen, werden alle Felder des Elements auf 0 (null) initialisiert. Der Wert des Elements ist kein null-Verweis und kann nicht durch Suchen nach einem null-Verweis gefunden werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau eine Dimension.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="indices">Ein eindimensionales Array von 32-Bit-Ganzzahlen, das die Indizes darstellt, die die Position des festzulegenden Elements angeben.</param>
        <summary>Legt das Element an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als ein Array von 32-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Elemente im `indices` muss gleich der Anzahl der Dimensionen in der <xref:System.Array>. Alle Elemente in der `indices` Array geben muss zusammen die Position des gewünschten Elements des mehrdimensionalen <xref:System.Array>.  
  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob die Werte in der `indices` Array ist außerhalb des gültigen Bereichs.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> zugewiesen `null` auf ein Element eines Arrays von Werttypen, werden alle Felder des Elements auf 0 (null) initialisiert. Der Wert des Elements ist kein null-Verweis und kann nicht durch Suchen nach einem null-Verweis gefunden werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Dimensionen im aktuellen <see cref="T:System.Array" /> ist nicht gleich der Anzahl der Elemente von <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Ein Element von <paramref name="indices" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index">Eine 64-Bit-Ganzzahl, die die Position des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des eindimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Der Index wird als 64-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob der Wert des `index` ist außerhalb des gültigen Bereichs.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> zugewiesen `null` auf ein Element eines Arrays von Werttypen, werden alle Felder des Elements auf 0 (null) initialisiert. Der Wert des Elements ist kein null-Verweis und kann nicht durch Suchen nach einem null-Verweis gefunden werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau eine Dimension.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="indices">Ein eindimensionales Array von 64-Bit-Ganzzahlen, das die Indizes darstellt, die die Position des festzulegenden Elements angeben.</param>
        <summary>Legt das Element an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als ein Array von 64-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Elemente im `indices` muss gleich der Anzahl der Dimensionen in der <xref:System.Array>. Alle Elemente in der `indices` Array geben muss zusammen die Position des gewünschten Elements des mehrdimensionalen <xref:System.Array>.  
  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob die Werte in der `indices` Array ist außerhalb des gültigen Bereichs.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> zugewiesen `null` auf ein Element eines Arrays von Werttypen, werden alle Felder des Elements auf 0 (null) initialisiert. Der Wert des Elements ist kein null-Verweis und kann nicht durch Suchen nach einem null-Verweis gefunden werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Dimensionen im aktuellen <see cref="T:System.Array" /> ist nicht gleich der Anzahl der Elemente von <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein Element von <paramref name="indices" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index1">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> zugewiesen `null` auf ein Element eines Arrays von Werttypen, werden alle Felder des Elements auf 0 (null) initialisiert. Der Wert des Elements ist kein null-Verweis und kann nicht durch Suchen nach einem null-Verweis gefunden werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau zwei Dimensionen.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> oder <paramref name="index2" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index1">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> zugewiesen `null` auf ein Element eines Arrays von Werttypen, werden alle Felder des Elements auf 0 (null) initialisiert. Der Wert des Elements ist kein null-Verweis und kann nicht durch Suchen nach einem null-Verweis gefunden werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau zwei Dimensionen.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> oder <paramref name="index2" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index1">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index3">Eine 32-Bit-Ganzzahl, die den Index für die dritte Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> zugewiesen `null` auf ein Element eines Arrays von Werttypen, werden alle Felder des Elements auf 0 (null) initialisiert. Der Wert des Elements ist kein null-Verweis und kann nicht durch Suchen nach einem null-Verweis gefunden werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau drei Dimensionen.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" />, <paramref name="index2" /> oder <paramref name="index3" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index1">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index3">Eine 64-Bit-Ganzzahl, die den Index für die dritte Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> zugewiesen `null` auf ein Element eines Arrays von Werttypen, werden alle Felder des Elements auf 0 (null) initialisiert. Der Wert des Elements ist kein null-Verweis und kann nicht durch Suchen nach einem null-Verweis gefunden werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau drei Dimensionen.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" />, <paramref name="index2" /> oder <paramref name="index3" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortiert die Elemente in einem eindimensionalen Array.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Das zu sortierende eindimensionale <see cref="T:System.Array" />.</param>
        <summary>Sortiert die Elemente in einem ganzen eindimensionalen <see cref="T:System.Array" /> mithilfe der <see cref="T:System.IComparable" />-Implementierung jedes Elements des <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element der `array` implementieren müssen die <xref:System.IComparable> Schnittstelle kann Vergleiche mit jedem anderen Element im `array`.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine [einfügen sortieren](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Protokoll `n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Sortieren der Werte in einer <xref:System.Array> mithilfe des Standardcomparers und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt. Beachten Sie, die das Ergebnis, abhängig von der aktuellen variieren kann <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens ein Element in <paramref name="array" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys">Das eindimensionale <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale <see cref="T:System.Array" /> mit den Elementen, die den jeweiligen Schlüsseln im <c>keys</c><see cref="T:System.Array" /> entsprechen.  Oder:  <see langword="null" />, um nur die <c>Schlüssel</c><see cref="T:System.Array" /> zu sortieren.</param>
        <summary>Sortiert ein Paar von eindimensionalen <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die <see cref="T:System.IComparable" />-Implementierung jedes Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array>. Wenn ein Schlüssel positioniert wird, bei der Sortierung, des entsprechenden Elements in der `items` <xref:System.Array> auf ähnliche Weise neu angeordnet. Aus diesem Grund die `items` <xref:System.Array> sortiert wird, gemäß der Anordnung der entsprechenden Schlüssel in der `keys` <xref:System.Array>.  
  
 Jeder Schlüssel in der `keys` <xref:System.Array> implementieren müssen die <xref:System.IComparable> Schnittstelle, um mit jedem anderen Schlüssel verglichen werden kann.  
  
 Sie können sortieren, wenn es mehr Elemente als Schlüssel sind, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert. Wenn es sich um mehrere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies einen <xref:System.ArgumentException>.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine [einfügen sortieren](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Protokoll `n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `keys`.  
  
   
  
## Examples  
 Im folgende Beispiel wird das Sortieren von zwei verknüpften Arrays, wobei das erste Array enthält die Schlüssel und das zweite Array enthält die Werte, veranschaulicht. Sortierungen erfolgen mithilfe des Standardcomparers und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt. Beachten Sie, die das Ergebnis, abhängig von der aktuellen variieren kann <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Das <paramref name="keys" /><see cref="T:System.Array" /> ist mehrdimensional.  Oder:  Das <paramref name="items" /><see cref="T:System.Array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens ein Element im <paramref name="keys" /><see cref="T:System.Array" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Das zu sortierende eindimensionale Array.</param>
        <param name="comparer">Die Implementierung, die beim Vergleich von Elementen verwendet werden soll.  Oder:  <see langword="null" />, um die <see cref="T:System.IComparable" />-Implementierung jedes Elements zu nutzen.</param>
        <summary>Sortiert die Elemente in einem eindimensionalen <see cref="T:System.Array" /> mithilfe des angegebenen <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` ist `null`, jedes Element der `array` implementieren müssen die <xref:System.IComparable> Schnittstelle kann Vergleiche mit jedem anderen Element im `array`.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine [einfügen sortieren](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Protokoll `n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
 .NET Framework enthält vordefinierte <xref:System.Collections.IComparer> Implementierungen in der folgenden Tabelle aufgeführt.  
  
|Implementierung|Beschreibung |  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Vergleicht zwei Objekte, jedoch führt einen Vergleich Groß-/Kleinschreibung der Zeichenfolgen.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Vergleicht zwei Objekte mithilfe der Sortierkonventionen der aktuellen Kultur an.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Vergleicht zwei Objekte mithilfe der Sortierkonventionen der invarianten Kultur.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Vergleicht zwei Objekte des Typs `T` mithilfe von Standard-Sortierreihenfolge des Typs.|  
  
 Sie können auch benutzerdefinierte Vergleiche unterstützen, indem Sie eine eigene Instanz bereitgestellt <xref:System.Collections.IComparer> -Implementierung, die die `comparer` Parameter. Im Beispiel wird dies durch die Definition einer `ReverseComparer` -Klasse, die die Standardsortierreihenfolge für kehrt Instanzen eines Typs und Zeichenfolgenvergleich führt.  
  
   
  
## Examples  
 Das folgende Beispiel sortiert die Werte in einer Zeichenfolge Arrayby mithilfe des Standardcomparers. Er definiert außerdem eine benutzerdefinierte <xref:System.Collections.IComparer> -Implementierung mit dem Namen `ReverseComparer` , die ein Objekt Standard-Sortierreihenfolge beim Ausführen einer eines Zeichenfolgenvergleichs kehrt. Beachten Sie, dass die Ausgabe abhängig von der aktuellen Kultur variieren kann.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> ist <see langword="null" />, und mindestens ein Element in <paramref name="array" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <block subset="none" type="usage">
          <para>Der .NET Framework 4 und früheren Versionen wird nur den Quicksort-Algorithmus verwendet. QuickSort identifiziert ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, ein <see cref="T:System.IndexOutOfRangeException" /> Ausnahme und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer. Beginnend mit dem [! Include[net_v45](~/Includes/NET-V45-MD.MD)], es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <see cref="T:System.ArgumentException" /> eine Ausnahme wird nicht ausgelöst werden, da die Einfügung sortieren und Heapsort Algorithmen ein ungültiger Vergleich nicht erkennen. Dies gilt meistens, für Arrays mit weniger als 16 Elementen.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">Das eindimensionale <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale <see cref="T:System.Array" /> mit den Elementen, die den jeweiligen Schlüsseln im <c>keys</c><see cref="T:System.Array" /> entsprechen.  Oder:  <see langword="null" />, um nur die <c>Schlüssel</c><see cref="T:System.Array" /> zu sortieren.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  Oder:  <see langword="null" />, um die <see cref="T:System.IComparable" />-Implementierung jedes Elements zu nutzen.</param>
        <summary>Sortiert ein Paar von eindimensionalen <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei den angegebenen <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array>. Wenn ein Schlüssel positioniert wird, bei der Sortierung, des entsprechenden Elements in der `items` <xref:System.Array> auf ähnliche Weise neu angeordnet. Aus diesem Grund die `items` <xref:System.Array> sortiert wird, gemäß der Anordnung der entsprechenden Schlüssel in der `keys` <xref:System.Array>.  
  
 Wenn `comparer` ist `null`, die jeweils-Schlüssel in der `keys` <xref:System.Array> implementieren müssen die <xref:System.IComparable> Schnittstelle, um mit jedem anderen Schlüssel verglichen werden kann.  
  
 Sie können sortieren, wenn es mehr Elemente als Schlüssel sind, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert. Wenn es sich um mehrere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies einen <xref:System.ArgumentException>.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 .NET Framework enthält vordefinierte <xref:System.Collections.IComparer> Implementierungen in der folgenden Tabelle aufgeführt.  
  
|Implementierung|Beschreibung |  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Vergleicht zwei Objekte, jedoch führt einen Vergleich Groß-/Kleinschreibung der Zeichenfolgen.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Vergleicht zwei Objekte mithilfe der Sortierkonventionen der aktuellen Kultur an.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Vergleicht zwei Objekte mithilfe der Sortierkonventionen der invarianten Kultur.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Vergleicht zwei Objekte des Typs `T` mithilfe von Standard-Sortierreihenfolge des Typs.|  
  
 Sie können auch benutzerdefinierte Vergleiche unterstützen, indem Sie eine eigene Instanz bereitgestellt <xref:System.Collections.IComparer> -Implementierung, die die `comparer` Parameter. Im Beispiel wird dies durch die Definition einer <xref:System.Collections.IComparer> Implementierung, kehrt die Standardsortierreihenfolge und Zeichenfolgenvergleich ausführt.  
  
 Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine [einfügen sortieren](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Protokoll `n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `keys`.  
  
   
  
## Examples  
 Im folgende Beispiel wird das Sortieren von zwei verknüpften Arrays, wobei das erste Array enthält die Schlüssel und das zweite Array enthält die Werte, veranschaulicht. Sortierungen erfolgen mithilfe des Standardcomparers und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt. Beachten Sie, die das Ergebnis, abhängig von der aktuellen variieren kann <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Das <paramref name="keys" /><see cref="T:System.Array" /> ist mehrdimensional.  Oder:  Das <paramref name="items" /><see cref="T:System.Array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  Oder:  Die Implementierung von <paramref name="comparer" /> hat während der Sortierung einen Fehler verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> ist <see langword="null" />, und mindestens ein Element im <paramref name="keys" /><see cref="T:System.Array" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <block subset="none" type="usage">
          <para>Der .NET Framework 4 und früheren Versionen wird nur den Quicksort-Algorithmus verwendet. QuickSort identifiziert ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, ein <see cref="T:System.IndexOutOfRangeException" /> Ausnahme und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer. Beginnend mit dem [! Include[net_v45](~/Includes/NET-V45-MD.MD)], es ist möglich, diese Previouslythrew für Sortiervorgänge <see cref="T:System.ArgumentException" /> eine Ausnahme wird nicht ausgelöst werden, da die Einfügung sortieren und Heapsort Algorithmen ein ungültiger Vergleich nicht erkennen. Dies gilt meistens, für Arrays mit weniger als 16 Elementen.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu sortierende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen in einem eindimensionalen <see cref="T:System.Array" /> mithilfe der <see cref="T:System.IComparable" />-Implementierung jedes Elements des <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element innerhalb des angegebenen Bereichs von Elementen in `array` implementieren müssen die <xref:System.IComparable> Schnittstelle kann Vergleiche mit jedem anderen Element im `array`.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine [einfügen sortieren](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Protokoll `n`) Vorgang, wobei `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Sortieren der Werte in einer <xref:System.Array> mithilfe des Standardcomparers und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt. Beachten Sie, die das Ergebnis, abhängig von der aktuellen variieren kann <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  Oder:  <paramref name="length" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens ein Element in <paramref name="array" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys">Das eindimensionale <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale <see cref="T:System.Array" /> mit den Elementen, die den jeweiligen Schlüsseln im <c>keys</c><see cref="T:System.Array" /> entsprechen.  Oder:  <see langword="null" />, um nur die <c>Schlüssel</c><see cref="T:System.Array" /> zu sortieren.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <summary>Sortiert einen Bereich von Elementen in einem Paar von eindimensionalen <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die <see cref="T:System.IComparable" />-Implementierung jedes Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array>. Wenn ein Schlüssel positioniert wird, bei der Sortierung, des entsprechenden Elements in der `items` <xref:System.Array> auf ähnliche Weise neu angeordnet. Aus diesem Grund die `items` <xref:System.Array> sortiert wird, gemäß der Anordnung der entsprechenden Schlüssel in der `keys` <xref:System.Array>.  
  
 Jeder Schlüssel innerhalb des angegebenen Bereichs von Elementen in der `keys` <xref:System.Array> implementieren müssen die <xref:System.IComparable> Schnittstelle, um mit jedem anderen Schlüssel verglichen werden kann.  
  
 Sie können sortieren, wenn es mehr Elemente als Schlüssel sind, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert. Wenn es sich um mehrere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies einen <xref:System.ArgumentException>.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine [einfügen sortieren](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Protokoll `n`) Vorgang, wobei `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Sortieren von zwei verknüpften Arrays, wobei das erste Array enthält die Schlüssel und das zweite Array enthält die Werte, veranschaulicht. Sortierungen erfolgen mithilfe des Standardcomparers und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt. Beachten Sie, die das Ergebnis, abhängig von der aktuellen variieren kann <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Das <paramref name="keys" /><see cref="T:System.Array" /> ist mehrdimensional.  Oder:  Das <paramref name="items" /><see cref="T:System.Array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als die untere <paramref name="keys" />-Grenze.  Oder:  <paramref name="length" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  Oder:  <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich in <paramref name="keys" /><see cref="T:System.Array" /> an.  Oder:  <paramref name="items" /> ist nicht gleich <see langword="null" />, und <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich in <paramref name="items" /><see cref="T:System.Array" /> an.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens ein Element im <paramref name="keys" /><see cref="T:System.Array" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Das zu sortierende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  Oder:  <see langword="null" />, um die <see cref="T:System.IComparable" />-Implementierung jedes Elements zu nutzen.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen in einem eindimensionalen <see cref="T:System.Array" /> mithilfe dem angegebenen <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` ist `null`, jedes Element innerhalb des angegebenen Bereichs von Elementen in `array` implementieren müssen die <xref:System.IComparable> Schnittstelle kann Vergleiche mit jedem anderen Element im `array`.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 .NET Framework enthält vordefinierte <xref:System.Collections.IComparer> Implementierungen in der folgenden Tabelle aufgeführt.  
  
|Implementierung|Beschreibung |  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Vergleicht zwei Objekte, jedoch führt einen Vergleich Groß-/Kleinschreibung der Zeichenfolgen.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Vergleicht zwei Objekte mithilfe der Sortierkonventionen der aktuellen Kultur an.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Vergleicht zwei Objekte mithilfe der Sortierkonventionen der invarianten Kultur.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Vergleicht zwei Objekte des Typs `T` mithilfe von Standard-Sortierreihenfolge des Typs.|  
  
 Sie können auch benutzerdefinierte Vergleiche unterstützen, indem Sie eine eigene Instanz bereitgestellt <xref:System.Collections.IComparer> -Implementierung, die die `comparer` Parameter. Im Beispiel wird dies durch die Definition einer `ReverseComparer` -Klasse, die die Standardsortierreihenfolge für kehrt Instanzen eines Typs und Zeichenfolgenvergleich führt.  
  
 Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine [einfügen sortieren](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Protokoll `n`) Vorgang, wobei `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Sortieren der Werte in einer <xref:System.Array> mithilfe des Standardcomparers und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt. Beachten Sie, die das Ergebnis, abhängig von der aktuellen variieren kann <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  Oder:  <paramref name="length" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  Oder:  Die Implementierung von <paramref name="comparer" /> hat während der Sortierung einen Fehler verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> ist <see langword="null" />, und mindestens ein Element in <paramref name="array" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <block subset="none" type="usage">
          <para>Der .NET Framework 4 und früheren Versionen wird nur den Quicksort-Algorithmus verwendet. QuickSort identifiziert ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, ein <see cref="T:System.IndexOutOfRangeException" /> Ausnahme und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer. Beginnend mit dem [! Include[net_v45](~/Includes/NET-V45-MD.MD)], es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <see cref="T:System.ArgumentException" /> eine Ausnahme wird nicht ausgelöst werden, da die Einfügung sortieren und Heapsort Algorithmen ein ungültiger Vergleich nicht erkennen. Dies gilt meistens, für Arrays mit weniger als 16 Elementen.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">Das eindimensionale <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale <see cref="T:System.Array" /> mit den Elementen, die den jeweiligen Schlüsseln im <c>keys</c><see cref="T:System.Array" /> entsprechen.  Oder:  <see langword="null" />, um nur die <c>Schlüssel</c><see cref="T:System.Array" /> zu sortieren.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  Oder:  <see langword="null" />, um die <see cref="T:System.IComparable" />-Implementierung jedes Elements zu nutzen.</param>
        <summary>Sortiert einen Bereich von Elementen in einem Paar von eindimensionalen <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei den angegebenen <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array>. Wenn ein Schlüssel positioniert wird, bei der Sortierung, des entsprechenden Elements in der `items` <xref:System.Array> auf ähnliche Weise neu angeordnet. Aus diesem Grund die `items` <xref:System.Array> sortiert wird, gemäß der Anordnung der entsprechenden Schlüssel in der `keys` <xref:System.Array>.  
  
 Wenn `comparer` ist `null`, jeden Schlüssel innerhalb des angegebenen Bereichs von Elementen in der `keys` <xref:System.Array> implementieren müssen die <xref:System.IComparable> Schnittstelle, um mit jedem anderen Schlüssel verglichen werden kann.  
  
 Sie können sortieren, wenn es mehr Elemente als Schlüssel sind, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert. Wenn es sich um mehrere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies einen <xref:System.ArgumentException>.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 .NET Framework enthält vordefinierte <xref:System.Collections.IComparer> Implementierungen in der folgenden Tabelle aufgeführt.  
  
|Implementierung|Beschreibung |  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Vergleicht zwei Objekte, jedoch führt einen Vergleich Groß-/Kleinschreibung der Zeichenfolgen.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Vergleicht zwei Objekte mithilfe der Sortierkonventionen der aktuellen Kultur an.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Vergleicht zwei Objekte mithilfe der Sortierkonventionen der invarianten Kultur.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Vergleicht zwei Objekte des Typs `T` mithilfe von Standard-Sortierreihenfolge des Typs.|  
  
 Sie können auch benutzerdefinierte Vergleiche unterstützen, indem Sie eine eigene Instanz bereitgestellt <xref:System.Collections.IComparer> -Implementierung, die die `comparer` Parameter. Im Beispiel wird dies durch die Definition einer benutzerdefiniertes <xref:System.Collections.IComparer> Implementierung, kehrt die Standardsortierreihenfolge und Zeichenfolgenvergleich ausführt.  
  
 Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine [einfügen sortieren](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Protokoll `n`) Vorgang, wobei `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Sortieren von zwei verknüpften Arrays, wobei das erste Array enthält die Schlüssel und das zweite Array enthält die Werte, veranschaulicht. Sortierungen erfolgen mithilfe des Standardcomparers und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt. Beachten Sie, die das Ergebnis, abhängig von der aktuellen variieren kann <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Das <paramref name="keys" /><see cref="T:System.Array" /> ist mehrdimensional.  Oder:  Das <paramref name="items" /><see cref="T:System.Array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als die untere <paramref name="keys" />-Grenze.  Oder:  <paramref name="length" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> ist nicht <see langword="null" />, und die untere Grenze von <paramref name="keys" /> entspricht nicht der unteren Grenze von <paramref name="items" />.  Oder:  <paramref name="items" /> ist nicht <see langword="null" />, und <paramref name="keys" /> ist länger als <paramref name="items" />.  Oder:  <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich in <paramref name="keys" /><see cref="T:System.Array" /> an.  Oder:  <paramref name="items" /> ist nicht gleich <see langword="null" />, und <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich in <paramref name="items" /><see cref="T:System.Array" /> an.  Oder:  Die Implementierung von <paramref name="comparer" /> hat während der Sortierung einen Fehler verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> ist <see langword="null" />, und mindestens ein Element im <paramref name="keys" /><see cref="T:System.Array" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <block subset="none" type="usage">
          <para>Der .NET Framework 4 und früheren Versionen wird nur den Quicksort-Algorithmus verwendet. QuickSort identifiziert ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, ein <see cref="T:System.IndexOutOfRangeException" /> Ausnahme und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer. Beginnend mit dem [! Include[net_v45](~/Includes/NET-V45-MD.MD)], es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <see cref="T:System.ArgumentException" /> eine Ausnahme wird nicht ausgelöst werden, da die Einfügung sortieren und Heapsort Algorithmen ein ungültiger Vergleich nicht erkennen. Dies gilt meistens, für Arrays mit weniger als 16 Elementen.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <summary>Sortiert die Elemente in einem ganzen <see cref="T:System.Array" /> mithilfe der Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle jedes Elements des <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element der `array` implementieren müssen die <xref:System.IComparable%601> generische Schnittstelle kann Vergleiche mit jedem anderen Element im `array`.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine [einfügen sortieren](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Protokoll `n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> generischen methodenüberladung und die <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generischen methodenüberladung. Ein Array von Zeichenfolgen wird erstellt, ohne bestimmte Reihenfolge.  
  
 Das Array wird angezeigt, sortiert und erneut angezeigt.  
  
> [!NOTE]
>  Die Aufrufe an die <xref:System.Array.Sort%2A> und <xref:System.Array.BinarySearch%2A> generische Methoden nicht suchen alle Aufrufe an ihre nicht generischen Entsprechungen unterscheiden, da Visual Basic, c# und C++ den Typ des vom Typ des ersten Arguments der generischen Typparameter abgeleitet werden. Bei Verwendung der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 Die <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generischen methodenüberladung wird dann verwendet, um zwei Zeichenfolgen zu suchen, ist eine, die nicht in das Array und eine ist. Das Array und den Rückgabewert der <xref:System.Array.BinarySearch%2A> an die Methode übergeben werden die `ShowWhere` generische Methode, die den Indexwert zeigt an, wenn die Zeichenfolge gefunden wird, und andernfalls die Elemente die Suchzeichenfolge fallen würde zwischen wären im Array. Der Index ist negativ, wenn die Zeichenfolge nicht n ist das Array daher die `ShowWhere` Methode nimmt das bitweise Komplement (den ~ Operator in c# und Visual C++ `Xor` -1 in Visual Basic) um den Index des ersten Elements in der Liste zu erhalten, die größer ist als die Suche d NG.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens ein Element in <paramref name="array" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <see langword="null" />, um die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle der einzelnen Elemente zu verwenden.</param>
        <summary>Sortiert die Elementen in einem <see cref="T:System.Array" /> mit der angegebenen generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` ist `null`, jedes Element der `array` implementieren müssen die <xref:System.IComparable%601> generische Schnittstelle kann Vergleiche mit jedem anderen Element im `array`.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine [einfügen sortieren](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Protokoll `n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung und die <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung.  
  
 Im Codebeispiel wird einen alternativer Vergleich für Zeichenfolgen, die mit dem Namen definiert `ReverseCompare`, implementiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich ruft die <xref:System.String.CompareTo%28System.String%29> -Methode, die Reihenfolge der verglichenen Elemente umkehren, sodass Zeichenfolgen hoch zu niedrig anstelle von niedrig zu hoch sortieren.  
  
 Das Array wird angezeigt, sortiert und erneut angezeigt. Arrays müssen sortiert werden, um mithilfe der <xref:System.Array.BinarySearch%2A> Methode.  
  
> [!NOTE]
>  Die Aufrufe an die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> und <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden nicht suchen alle Aufrufe an ihre nicht generischen Entsprechungen unterscheiden, da Visual Basic, c# und C++ den Typ des vom Typ des ersten Arguments der generischen Typparameter abgeleitet werden. Bei Verwendung der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 Die <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung wird dann verwendet, um zwei Zeichenfolgen zu suchen, ist eine, die nicht in das Array und eine ist. Das Array und den Rückgabewert der <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> an die Methode übergeben werden die `ShowWhere` generische Methode, die den Indexwert zeigt an, wenn die Zeichenfolge gefunden wird, und andernfalls die Elemente die Suchzeichenfolge fallen würde zwischen wären im Array. Der Index ist negativ, wenn die Zeichenfolge nicht n ist das Array daher die `ShowWhere` Methode nimmt das bitweise Komplement (den ~ Operator in c# und Visual C++ `Xor` -1 in Visual Basic) um den Index des ersten Elements in der Liste zu erhalten, die größer ist als die Suche d NG.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> ist <see langword="null" />, und mindestens ein Element in <paramref name="array" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <block subset="none" type="usage">
          <para>Der .NET Framework 4 und früheren Versionen wird nur den Quicksort-Algorithmus verwendet. QuickSort identifiziert ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, ein <see cref="T:System.IndexOutOfRangeException" /> Ausnahme und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer. Beginnend mit dem [! Include[net_v45](~/Includes/NET-V45-MD.MD)], es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <see cref="T:System.ArgumentException" /> eine Ausnahme wird nicht ausgelöst werden, da die Einfügung sortieren und Heapsort Algorithmen ein ungültiger Vergleich nicht erkennen. Dies gilt meistens, für Arrays mit weniger als 16 Elementen.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="comparison">Die <see cref="T:System.Comparison`1" />, die beim Vergleich von Elementen verwendet werden soll.</param>
        <summary>Sortiert die Elemente in einem <see cref="T:System.Array" /> mithilfe der angegebenen <see cref="T:System.Comparison`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet introspective Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine [einfügen sortieren](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Protokoll `n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> -methodenüberladung.  
  
 Das Codebeispiel definiert eine alternative Vergleichsmethode für Zeichenfolgen, die mit dem Namen `CompareDinosByLength`. Diese Methode funktioniert wie folgt: zunächst die Comparandsare getestet für`null`, und ein null-Verweis als kleiner als ein Wert ungleich Null behandelt wird. Zweitens die Zeichenfolgenlängen verglichen werden, und die Zeichenfolge längere ist als größer werden. Wenn die Länge gleich sind, wird im dritten gewöhnliche Zeichenfolgenvergleich verwendet.  
  
 Ein Array von Zeichenfolgen erstellt und mit vier Zeichenfolgen ohne bestimmte Reihenfolge aufgefüllt. Die Liste enthält auch eine leere Zeichenfolge und ein null-Verweis. Die Liste wird angezeigt, sortiert, mit einem <xref:System.Comparison%601> generischer Delegat darstellt der `CompareDinosByLength` -Methode, und erneut angezeigt.  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.  Oder:  <paramref name="comparison" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparison" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparison" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <block subset="none" type="usage">
          <para>Der .NET Framework 4 und früheren Versionen wird nur den Quicksort-Algorithmus verwendet. QuickSort identifiziert ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, ein <see cref="T:System.IndexOutOfRangeException" /> Ausnahme und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer. Beginnend mit dem [! Include[net_v45](~/Includes/NET-V45-MD.MD)], es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <see cref="T:System.ArgumentException" /> eine Ausnahme wird nicht ausgelöst werden, da die Einfügung sortieren und Heapsort Algorithmen ein ungültiger Vergleich nicht erkennen. Dies gilt meistens, für Arrays mit weniger als 16 Elementen.</para>
        </block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen in einem <see cref="T:System.Array" /> mithilfe der Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle jedes Elements des <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element innerhalb des angegebenen Bereichs von Elementen in `array` implementieren müssen die <xref:System.IComparable%601> generische Schnittstelle kann Vergleiche mit jedem anderen Element im `array`.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine [einfügen sortieren](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Protokoll `n`) Vorgang, wobei `n` ist `length`.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generischen methodenüberladung und die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung für einen Bereich in einem Array zu sortieren.  
  
 Im Codebeispiel wird einen alternativer Vergleich für Zeichenfolgen, die mit dem Namen definiert `ReverseCompare`, implementiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich ruft die <xref:System.String.CompareTo%28System.String%29> -Methode, die Reihenfolge der verglichenen Elemente umkehren, sodass Zeichenfolgen hoch zu niedrig anstelle von niedrig zu hoch sortieren.  
  
 Das Codebeispiel erstellt und zeigt ein Array von Dinosauriernamen, drei Pflanzenfresser und drei Fleischfresser (Tyrannosaurids, um genau zu sein). Die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generischen methodenüberladung wird verwendet, um die letzten drei Elemente im Array zu sortieren, der dann angezeigt wird. Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung wird verwendet, mit `ReverseCompare` die letzten drei Elemente in umgekehrter Reihenfolge sortiert. Gründlich zu verwechseln Dinosaurier werden erneut angezeigt.  
  
> [!NOTE]
>  Die Aufrufe an die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> und <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden nicht suchen alle Aufrufe an ihre nicht generischen Entsprechungen unterscheiden, da Visual Basic, c# und C++ den Typ des vom Typ des ersten Arguments der generischen Typparameter abgeleitet werden. Bei Verwendung der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  Oder:  <paramref name="length" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens ein Element in <paramref name="array" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <see langword="null" />, um die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle der einzelnen Elemente zu verwenden.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen in der <see cref="T:System.Array" /> mithilfe der angegebenen generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` ist `null`, jedes Element innerhalb des angegebenen Bereichs von Elementen in `array` implementieren müssen die <xref:System.IComparable%601> generische Schnittstelle kann Vergleiche mit jedem anderen Element im `array`.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine [einfügen sortieren](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Protokoll `n`) Vorgang, wobei `n` ist `length`.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generischen methodenüberladung und die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung für einen Bereich in einem Array zu sortieren.  
  
 Im Codebeispiel wird einen alternativer Vergleich für Zeichenfolgen, die mit dem Namen definiert `ReverseCompare`, implementiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich ruft die <xref:System.String.CompareTo%28System.String%29> -Methode, die Reihenfolge der verglichenen Elemente umkehren, sodass Zeichenfolgen hoch zu niedrig anstelle von niedrig zu hoch sortieren.  
  
 Das Codebeispiel erstellt und zeigt ein Array von Dinosauriernamen, drei Pflanzenfresser und drei Fleischfresser (Tyrannosaurids, um genau zu sein). Die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generischen methodenüberladung wird verwendet, um die letzten drei Elemente im Array zu sortieren, der dann angezeigt wird. Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung wird verwendet, mit `ReverseCompare` die letzten drei Elemente in umgekehrter Reihenfolge sortiert. Gründlich zu verwechseln Dinosaurier werden erneut angezeigt.  
  
> [!NOTE]
>  Die Aufrufe an die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> und <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden nicht suchen alle Aufrufe an ihre nicht generischen Entsprechungen unterscheiden, da Visual Basic, c# und C++ den Typ des vom Typ des ersten Arguments der generischen Typparameter abgeleitet werden. Bei Verwendung der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  Oder:  <paramref name="length" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  Oder:  Die Implementierung von <paramref name="comparer" /> hat während der Sortierung einen Fehler verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> ist <see langword="null" />, und mindestens ein Element in <paramref name="array" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <block subset="none" type="usage">
          <para>Der .NET Framework 4 und früheren Versionen wird nur den Quicksort-Algorithmus verwendet. QuickSort identifiziert ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, ein <see cref="T:System.IndexOutOfRangeException" /> Ausnahme und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer. Beginnend mit dem [! Include[net_v45](~/Includes/NET-V45-MD.MD)], es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <see cref="T:System.ArgumentException" /> eine Ausnahme wird nicht ausgelöst werden, da die Einfügung sortieren und Heapsort Algorithmen ein ungültiger Vergleich nicht erkennen. Dies gilt meistens, für Arrays mit weniger als 16 Elementen.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Der Typ der Elemente des Schlüsselarrays.</typeparam>
        <typeparam name="TValue">Der Typ der Elemente des Elementarrays.</typeparam>
        <param name="keys">Das eindimensionale nullbasierte <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das die den Schlüsseln in <c>keys</c> entsprechenden Elemente enthält, oder <see langword="null" />, um nur <c>keys</c> zu sortieren.</param>
        <summary>Sortiert ein Paar von <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle jedes Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array>. Wenn ein Schlüssel positioniert wird, bei der Sortierung, des entsprechenden Elements in der `items` <xref:System.Array> auf ähnliche Weise neu angeordnet. Aus diesem Grund die `items` <xref:System.Array> sortiert wird, gemäß der Anordnung der entsprechenden Schlüssel in der `keys` <xref:System.Array>.  
  
 Jeder Schlüssel in der `keys` <xref:System.Array> implementieren müssen die <xref:System.IComparable%601> generischen Schnittstelle, die mit jedem anderen Schlüssel verglichen werden kann.  
  
 Sie können sortieren, wenn es mehr Elemente als Schlüssel sind, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert. Wenn es sich um mehrere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies einen <xref:System.ArgumentException>.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine [einfügen sortieren](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Protokoll `n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, und <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladungen der generischen Methode, für die Sortierung von Paaren von Arrays, die Schlüssel und Werte darstellen.  
  
 Im Codebeispiel wird einen alternativer Vergleich für Zeichenfolgen, die mit dem Namen definiert `ReverseCompare`, implementiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich ruft die <xref:System.String.CompareTo%28System.String%29> -Methode, die Reihenfolge der verglichenen Elemente umkehren, sodass Zeichenfolgen hoch zu niedrig anstelle von niedrig zu hoch sortieren.  
  
 Das Codebeispiel erstellt und zeigt ein Array von Dinosauriernamen (Schlüssel) und ein Array von ganzen Zahlen, die die maximale Länge der einzelnen Dinosaurier in Metern (Werten) darstellt. Die Arrays werden dann sortiert und mehrmals angezeigt:  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Überladung wird verwendet, um beide Arrays in der Reihenfolge der Dinosauriernamen im ersten Array zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladung und einer Instanz von `ReverseCompare` werden verwendet, um die Sortierreihenfolge der gepaarten Arrays umzukehren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um die letzten drei Elemente beider Arrays, zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladung wird verwendet, um die letzten drei Elemente beider Arrays in umgekehrter Reihenfolge zu sortieren.  
  
> [!NOTE]
>  Die Aufrufe an den generischen Methoden suchen nicht anders als die Aufrufe an ihre nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters vom Typ der ersten beiden Argumente abgeleitet werden. Bei Verwendung der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> ist nicht <see langword="null" />, und die untere Grenze von <paramref name="keys" /> entspricht nicht der unteren Grenze von <paramref name="items" />.  Oder:  <paramref name="items" /> ist nicht <see langword="null" />, und <paramref name="keys" /> ist länger als <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens ein Element im <paramref name="keys" /><see cref="T:System.Array" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Der Typ der Elemente des Schlüsselarrays.</typeparam>
        <typeparam name="TValue">Der Typ der Elemente des Elementarrays.</typeparam>
        <param name="keys">Das eindimensionale nullbasierte <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das die den Schlüsseln in <c>keys</c> entsprechenden Elemente enthält, oder <see langword="null" />, um nur <c>keys</c> zu sortieren.</param>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <see langword="null" />, um die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle der einzelnen Elemente zu verwenden.</param>
        <summary>Sortiert ein Paar von <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die angegebene generische <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array>. Wenn ein Schlüssel positioniert wird, bei der Sortierung, des entsprechenden Elements in der `items` <xref:System.Array> auf ähnliche Weise neu angeordnet. Aus diesem Grund die `items` <xref:System.Array> sortiert wird, gemäß der Anordnung der entsprechenden Schlüssel in der `keys` <xref:System.Array>.  
  
 Wenn `comparer` ist `null`, die jeweils-Schlüssel in der `keys` <xref:System.Array> implementieren müssen die <xref:System.IComparable%601> generischen Schnittstelle, die mit jedem anderen Schlüssel verglichen werden kann.  
  
 Sie können sortieren, wenn es mehr Elemente als Schlüssel sind, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert. Wenn es sich um mehrere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies einen <xref:System.ArgumentException>.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine [einfügen sortieren](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Protokoll `n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, und <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladungen der generischen Methode, für die Sortierung von Paaren von Arrays, die Schlüssel und Werte darstellen.  
  
 Im Codebeispiel wird einen alternativer Vergleich für Zeichenfolgen, die mit dem Namen definiert `ReverseCompare`, implementiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich ruft die <xref:System.String.CompareTo%28System.String%29> -Methode, die Reihenfolge der verglichenen Elemente umkehren, sodass Zeichenfolgen hoch zu niedrig anstelle von niedrig zu hoch sortieren.  
  
 Das Codebeispiel erstellt und zeigt ein Array von Dinosauriernamen (Schlüssel) und ein Array von ganzen Zahlen, die die maximale Länge der einzelnen Dinosaurier in Metern (Werten) darstellt. Die Arrays werden dann sortiert und mehrmals angezeigt:  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Überladung wird verwendet, um beide Arrays in der Reihenfolge der Dinosauriernamen im ersten Array zu sortieren.  
  
-   Die [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > Überladung und einer Instanz von `ReverseCompare` werden verwendet, um die Sortierreihenfolge umzukehren der paarweise zugeordneten Arrays.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um die letzten drei Elemente beider Arrays, zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladung wird verwendet, um die letzten drei Elemente beider Arrays in umgekehrter Reihenfolge zu sortieren.  
  
> [!NOTE]
>  Die Aufrufe an den generischen Methoden suchen nicht anders als die Aufrufe an ihre nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters vom Typ der ersten beiden Argumente abgeleitet werden. Bei Verwendung der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> ist nicht <see langword="null" />, und die untere Grenze von <paramref name="keys" /> entspricht nicht der unteren Grenze von <paramref name="items" />.  Oder:  <paramref name="items" /> ist nicht <see langword="null" />, und <paramref name="keys" /> ist länger als <paramref name="items" />.  Oder:  Die Implementierung von <paramref name="comparer" /> hat während der Sortierung einen Fehler verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> ist <see langword="null" />, und mindestens ein Element im <paramref name="keys" /><see cref="T:System.Array" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <block subset="none" type="usage">
          <para>Der .NET Framework 4 und früheren Versionen wird nur den Quicksort-Algorithmus verwendet. QuickSort identifiziert ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, ein <see cref="T:System.IndexOutOfRangeException" /> Ausnahme und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer. Beginnend mit dem [! Include[net_v45](~/Includes/NET-V45-MD.MD)], es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <see cref="T:System.ArgumentException" /> eine Ausnahme wird nicht ausgelöst werden, da die Einfügung sortieren und Heapsort Algorithmen ein ungültiger Vergleich nicht erkennen. Dies gilt meistens, für Arrays mit weniger als 16 Elementen.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Der Typ der Elemente des Schlüsselarrays.</typeparam>
        <typeparam name="TValue">Der Typ der Elemente des Elementarrays.</typeparam>
        <param name="keys">Das eindimensionale nullbasierte <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das die den Schlüsseln in <c>keys</c> entsprechenden Elemente enthält, oder <see langword="null" />, um nur <c>keys</c> zu sortieren.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <summary>Sortiert einen Bereich von Elementen in einem Paar von <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle jedes Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array>. Wenn ein Schlüssel positioniert wird, bei der Sortierung, des entsprechenden Elements in der `items` <xref:System.Array> auf ähnliche Weise neu angeordnet. Aus diesem Grund die `items` <xref:System.Array> sortiert wird, gemäß der Anordnung der entsprechenden Schlüssel in der `keys` <xref:System.Array>.  
  
 Jeder Schlüssel innerhalb des angegebenen Bereichs von Elementen in der `keys` <xref:System.Array> implementieren müssen die <xref:System.IComparable%601> generischen Schnittstelle, die mit jedem anderen Schlüssel verglichen werden kann.  
  
 Sie können sortieren, wenn es mehr Elemente als Schlüssel sind, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert. Wenn es sich um mehrere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies einen <xref:System.ArgumentException>.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine [einfügen sortieren](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Protokoll `n`) Vorgang, wobei `n` ist `length`.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >, und <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische methodenüberladungen zum Sortieren von Paaren von Arrays, die Schlüssel und Werte darstellen.  
  
 Im Codebeispiel wird einen alternativer Vergleich für Zeichenfolgen, die mit dem Namen definiert `ReverseCompare`, implementiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich ruft die <xref:System.String.CompareTo%28System.String%29> -Methode, die Reihenfolge der verglichenen Elemente umkehren, sodass Zeichenfolgen hoch zu niedrig anstelle von niedrig zu hoch sortieren.  
  
 Das Codebeispiel erstellt und zeigt ein Array von Dinosauriernamen (Schlüssel) und ein Array von ganzen Zahlen, die die maximale Länge der einzelnen Dinosaurier in Metern (Werten) darstellt. Die Arrays werden dann sortiert und mehrmals angezeigt:  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Überladung wird verwendet, um beide Arrays in der Reihenfolge der Dinosauriernamen im ersten Array zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladung und einer Instanz von `ReverseCompare` werden verwendet, um die Sortierreihenfolge der gepaarten Arrays umzukehren.  
  
-   Die [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > Überladung wird verwendet, um die letzten drei Elemente beider Arrays, zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladung wird verwendet, um die letzten drei Elemente beider Arrays in umgekehrter Reihenfolge zu sortieren.  
  
> [!NOTE]
>  Die Aufrufe an den generischen Methoden suchen nicht anders als die Aufrufe an ihre nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters vom Typ der ersten beiden Argumente abgeleitet werden. Bei Verwendung der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als die untere <paramref name="keys" />-Grenze.  Oder:  <paramref name="length" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> ist nicht <see langword="null" />, und die untere Grenze von <paramref name="keys" /> entspricht nicht der unteren Grenze von <paramref name="items" />.  Oder:  <paramref name="items" /> ist nicht <see langword="null" />, und <paramref name="keys" /> ist länger als <paramref name="items" />.  Oder:  <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich in <paramref name="keys" /><see cref="T:System.Array" /> an.  Oder:  <paramref name="items" /> ist nicht gleich <see langword="null" />, und <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich in <paramref name="items" /><see cref="T:System.Array" /> an.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens ein Element im <paramref name="keys" /><see cref="T:System.Array" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Der Typ der Elemente des Schlüsselarrays.</typeparam>
        <typeparam name="TValue">Der Typ der Elemente des Elementarrays.</typeparam>
        <param name="keys">Das eindimensionale nullbasierte <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das die den Schlüsseln in <c>keys</c> entsprechenden Elemente enthält, oder <see langword="null" />, um nur <c>keys</c> zu sortieren.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <see langword="null" />, um die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle der einzelnen Elemente zu verwenden.</param>
        <summary>Sortiert einen Bereich von Elementen in einem Paar von <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die angegebene generische <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array>. Wenn ein Schlüssel positioniert wird, bei der Sortierung, des entsprechenden Elements in der `items` <xref:System.Array> auf ähnliche Weise neu angeordnet. Aus diesem Grund die `items` <xref:System.Array> sortiert wird, gemäß der Anordnung der entsprechenden Schlüssel in der `keys` <xref:System.Array>.  
  
 Wenn `comparer` ist `null`, jeden Schlüssel innerhalb des angegebenen Bereichs von Elementen in der `keys` <xref:System.Array> implementieren müssen die <xref:System.IComparable%601> generischen Schnittstelle, die mit jedem anderen Schlüssel verglichen werden kann.  
  
 Sie können sortieren, wenn es mehr Elemente als Schlüssel sind, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert. Wenn es sich um mehrere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies einen <xref:System.ArgumentException>.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine [einfügen sortieren](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, verwendet er eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls wird eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Protokoll `n`) Vorgang, wobei `n` ist `length`.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, und [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32% 2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > Überladungen der generischen Methode, für die Sortierung von Paaren von Arrays, die Schlüssel und Werte darstellen.  
  
 Im Codebeispiel wird einen alternativer Vergleich für Zeichenfolgen, die mit dem Namen definiert `ReverseCompare`, implementiert die `IComparer<string>`(`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich ruft die <xref:System.String.CompareTo%28System.String%29> -Methode, die Reihenfolge der verglichenen Elemente umkehren, sodass Zeichenfolgen hoch zu niedrig anstelle von niedrig zu hoch sortieren.  
  
 Das Codebeispiel erstellt und zeigt ein Array von Dinosauriernamen (Schlüssel) und ein Array von ganzen Zahlen, die die maximale Länge der einzelnen Dinosaurier in Metern (Werten) darstellt. Die Arrays werden dann sortiert und mehrmals angezeigt:  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Überladung wird verwendet, um beide Arrays in der Reihenfolge der Dinosauriernamen im ersten Array zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladung und einer Instanz von `ReverseCompare` werden verwendet, um die Sortierreihenfolge der gepaarten Arrays umzukehren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um die letzten drei Elemente beider Arrays, zu sortieren.  
  
-   Die [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > Überladung wird verwendet, um die letzten drei sortieren Elemente beider arrays in umgekehrter Reihenfolge.  
  
> [!NOTE]
>  Die Aufrufe an den generischen Methoden suchen nicht anders als die Aufrufe an ihre nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters vom Typ der ersten beiden Argumente abgeleitet werden. Bei Verwendung der [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als die untere <paramref name="keys" />-Grenze.  Oder:  <paramref name="length" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> ist nicht <see langword="null" />, und die untere Grenze von <paramref name="keys" /> entspricht nicht der unteren Grenze von <paramref name="items" />.  Oder:  <paramref name="items" /> ist nicht <see langword="null" />, und <paramref name="keys" /> ist länger als <paramref name="items" />.  Oder:  <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich in <paramref name="keys" /><see cref="T:System.Array" /> an.  Oder:  <paramref name="items" /> ist nicht gleich <see langword="null" />, und <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich in <paramref name="items" /><see cref="T:System.Array" /> an.  Oder:  Die Implementierung von <paramref name="comparer" /> hat während der Sortierung einen Fehler verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> ist <see langword="null" />, und mindestens ein Element im <paramref name="keys" /><see cref="T:System.Array" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <block subset="none" type="usage">
          <para>Der .NET Framework 4 und früheren Versionen wird nur den Quicksort-Algorithmus verwendet. QuickSort identifiziert ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, ein <see cref="T:System.IndexOutOfRangeException" /> Ausnahme und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer. Beginnend mit dem [! Include[net_v45](~/Includes/NET-V45-MD.MD)], es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <see cref="T:System.ArgumentException" /> eine Ausnahme wird nicht ausgelöst werden, da die Einfügung sortieren und Heapsort Algorithmen ein ungültiger Vergleich nicht erkennen. Dies gilt meistens, für Arrays mit weniger als 16 Elementen.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Array" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die <see cref="T:System.Array" /> synchronisiert werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft implementiert die <xref:System.Collections.ICollection?displayProperty=nameWithType> Schnittstelle.  
  
 .NET Framework-Klassen basierend auf <xref:System.Array> bieten eigene synchronisierte Version der Auflistung unter Verwendung der <xref:System.Array.SyncRoot%2A> Eigenschaft.  
  
 Klassen, die Arrays verwenden, können auch implementieren ihre eigenen Synchronisierung über die <xref:System.Array.SyncRoot%2A> Eigenschaft. Im Synchronisierungscode führen Vorgänge für die `SyncRoot` der Auflistung, nicht direkt für die Auflistung. Dies gewährleistet die einwandfreie Funktion von Auflistungen, die von anderen Objekten abgeleitet sind. Insbesondere verwaltet er die ordnungsgemäße Synchronisierung mit anderen Threads, die gleichzeitig die Auflistung eventuell. Beachten Sie, dass einige Implementierungen von <xref:System.Array.SyncRoot%2A> möglicherweise zurück, die <xref:System.Array> selbst.  
  
 Einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein Array während der gesamten Enumeration sperren, mit der <xref:System.Array.SyncRoot%2A> Eigenschaft.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System.Collections.ICollection.Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente ab, die in <see cref="T:System.Array" /> enthalten sind.</summary>
        <value>Die Anzahl der Elemente in der Auflistung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.ICollection>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das dem <see cref="T:System.Collections.IList" /> hinzuzufügende Objekt.</param>
        <summary>Beim Aufrufen dieser Methode wird immer eine <see cref="T:System.NotSupportedException" />-Ausnahme ausgelöst.</summary>
        <returns>Das Hinzufügen eines Werts zu einem Array wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalerweise eine <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> Implementierung Fügt ein Element einer Auflistung hinzu. Jedoch, da Arrays eine feste Größe aufweisen (die <xref:System.Array.IsFixedSize%2A> -Eigenschaft gibt immer `true`), löst diese Methode immer ein <xref:System.NotSupportedException> Ausnahme.  
  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> hat eine feste Größe.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das in der aktuellen Liste zu suchende Objekt. Das gesuchte Element kann für Referenztypen <see langword="null" />.</param>
        <summary>Bestimmt, ob sich ein Element in <see cref="T:System.Collections.IList" /> befindet.</summary>
        <returns>
          <see langword="true" />, wenn das <paramref name="value" /> in der <see cref="T:System.Collections.IList" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das in der aktuellen Liste zu suchende Objekt.</param>
        <summary>Bestimmt den Index eines bestimmten Elements in der <see cref="T:System.Collections.IList" />.</summary>
        <returns>Der Index von Wert, wenn er in der Liste gefunden wird, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Der Index, an dem <c>value</c> eingefügt werden soll.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <summary>Fügt am angegebenen Index ein Element in die <see cref="T:System.Collections.IList" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kein gültiger Index in <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> ist schreibgeschützt.  Oder:  <see cref="T:System.Collections.IList" /> hat eine feste Größe.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> ist ein NULL-Verweis in <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der Index des abzurufenden oder festzulegenden Elements.</param>
        <summary>Ruft das Element am angegebenen Index ab oder legt dieses fest.</summary>
        <value>Das Element am angegebenen Index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als Null.  Oder:  <paramref name="index" /> ist gleich oder größer als <see cref="P:System.Collections.ICollection.Count" />.</exception>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau eine Dimension.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das aus der <see cref="T:System.Collections.IList" /> zu entfernende Objekt.</param>
        <summary>Entfernt das erste Vorkommen eines angegebenen Objekts aus der <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> ist schreibgeschützt.  Oder:  <see cref="T:System.Collections.IList" /> hat eine feste Größe.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der Index des zu entfernenden Elements.</param>
        <summary>Entfernt das <see cref="T:System.Collections.IList" />-Element am angegebenen Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">index ist kein gültiger Index in <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> ist schreibgeschützt.  Oder:  <see cref="T:System.Collections.IList" /> hat eine feste Größe.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
        <param name="comparer">Ein Objekt, das das aktuelle Objekt und <c>other</c> vergleicht.</param>
        <summary>Bestimmt, ob das aktuelle Auflistungsobjekt in der Sortierreihenfolge vor oder nach einem anderen Objekt oder an derselben Position auftritt.</summary>
        <returns>Eine Ganzzahl, die die Beziehung des aktuellen Auflistungsobjekts zu "other" angibt, wie in der folgenden Tabelle dargestellt.  
  
 <list type="table"><listheader><term> Rückgabewert  </term><description> Beschreibung  </description></listheader><item><term> –1  </term><description> Die aktuelle Instanz steht vor <paramref name="other" />.  </description></item><item><term> 0  </term><description> Die aktuelle Instanz und <paramref name="other" /> sind gleich.  </description></item><item><term> 1  </term><description> Die aktuelle Instanz steht nach <paramref name="other" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IStructuralComparable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
        <param name="comparer">Ein Objekt, das bestimmt, ob die aktuelle Instanz und <c>other</c> gleich sind.</param>
        <summary>Bestimmt, ob ein Objekt gleich der aktuellen Instanz ist.</summary>
        <returns>
          <see langword="true" />, wenn die beiden Objekte gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IStructuralEquatable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Ein Objekt, das den Hashcode des aktuellen Objekts berechnet.</param>
        <summary>Gibt einen Hashcode für die aktuelle Instanz zurück.</summary>
        <returns>Der Hashcode für die aktuelle Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IStructuralEquatable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das auf die Bedingungen geprüft werden soll.</param>
        <param name="match">Das Prädikat, das die Bedingungen definiert, auf die die Elemente geprüft werden sollen.</param>
        <summary>Bestimmt, ob jedes Element im Array die vom angegebenen Prädikat definierten Bedingungen erfüllt.</summary>
        <returns>
          <see langword="true" />, wenn jedes Element in <paramref name="array" /> die vom angegebenen Prädikat definierten Bedingungen erfüllt, andernfalls <see langword="false" />. Wenn es keine Elemente im Array gibt, ist der Rückgabewert <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat an eine Methode, die zurückgibt`true` an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.  Die Elemente der `array` einzeln übergeben werden, um die <xref:System.Predicate%601>, und die Verarbeitung wird beendet, wenn der Delegat zurückgegeben `false` für ein bestimmtes Element.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob das letzte Zeichen der einzelnen Elemente in einem Zeichenfolgenarray eine Zahl ist. Es werden zwei Zeichenfolgen-Arrays erstellt. Die erste Arrayincludes beide Zeichenfolgen, die diesem Ende mit alphabetische Zeichen und Zeichenfolgen, die mit numerischen Zeichen enden. Das zweite Array besteht ausschließlich aus Zeichenfolgen, die mit numerischen Zeichen enden. Im Beispiel definiert auch eine `EndWithANumber` Methode, deren Signatur entspricht, der <xref:System.Predicate%601> delegieren. Das Beispiel übergibt jedes Array an die <xref:System.Array.TrueForAll%2A> -Methode zusammen mit einem Delegaten, der darstellt die `EndsWithANumber` Methode.  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 Das folgende Beispiel ist ähnlich wie die erste, außer dass das Zeichenfolgenarray übergibt, das <xref:System.Array.TrueForAll%2A> -Methode zusammen mit einem Lambda-Ausdruck, der bestimmt, ob eine bestimmte Arrayelement durch die Zeichenfolgendarstellung einer Zahl enden.  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 In beiden Fällen die <xref:System.Array.TrueForAll%2A> -Methode zurückkehrt `false` , sobald er das erste Arrayelement trifft, die nicht in eine Zahl endet. Andernfalls wird zurückgegeben `true` nach Iteration alle Elemente im Array.  
  
> [!NOTE]
>  Analog zur Darstellung der beiden Beispielen in c# und Visual Basic, ist es nicht notwendig, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.  Oder:  <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>