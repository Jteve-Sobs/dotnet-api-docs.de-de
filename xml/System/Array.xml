<Type Name="Array" FullName="System.Array">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bc46739bb42952592fb5e622be24ed66f5c36af5" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="58875540" /></Metadata><TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Methoden zum Erstellen, Bearbeiten, Durchsuchen und Sortieren von Arrays bereit und ist damit Basisklasse für alle Arrays in der Common Language Runtime.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> -Klasse ist nicht Teil der <xref:System.Collections> Namespaces. Allerdings es dennoch als eine Sammlung, da er basiert die <xref:System.Collections.IList> Schnittstelle.  
  
 Die <xref:System.Array> -Klasse ist die Basisklasse für Implementierungen von Sprachen, die Arrays zu unterstützen. Jedoch nur das System und der Compiler können ableiten explizit die <xref:System.Array> Klasse. Benutzer sollten die Arraykonstrukte zur Verfügung gestellt, von der Sprache verwenden.  
  
 Ein Element ist ein Wert in eine <xref:System.Array>. Die Länge einer <xref:System.Array> ist die Gesamtzahl der Elemente, die es enthalten kann. Die untere Grenze des ein <xref:System.Array> ist der Index des ersten Elements. Ein <xref:System.Array> können untere Grenze, aber es wurde eine Untergrenze von 0 (null), wird standardmäßig. Eine andere Untergrenze definiert werden können, beim Erstellen einer Instanz von der <xref:System.Array> -Klasse unter Verwendung <xref:System.Array.CreateInstance%2A>. Ein mehrdimensionales <xref:System.Array> haben verschiedene Grenzen für jede Dimension. Ein Array kann maximal 32 Dimensionen aufweisen.  
  
 Im Gegensatz zu den Klassen in der <xref:System.Collections> Namespaces <xref:System.Array> hat eine feste Kapazität. Um die Kapazität zu erhöhen, müssen Sie ein neues erstellen <xref:System.Array> Objekt mit der erforderlichen Kapazität, kopieren Sie die Elemente aus der alten <xref:System.Array> Objekt in das neue Projekt, und löschen die alte <xref:System.Array>.  

 Die Größe des Arrays ist auf maximal 4 Milliarden-Elemente, und klicken Sie auf eine maximale Index 0X7FEFFFFF in einer beliebigen angegebenen Dimension (für Bytearrays und Arrays von einzelbytestrukturen 0X7FFFFFC7) beschränkt.
  
 **Nur .NET Framework:** Standardmäßig ist die maximale Größe einer <xref:System.Array> beträgt 2 Gigabyte (GB). In einer 64-Bit-Umgebung können Sie die größenbeschränkung vermeiden, indem die `enabled` Attribut der [GcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) Konfigurationselement, `true` in der Runtime-Umgebung.
  
 Eindimensionale Arrays implementieren die <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> und <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> generische Schnittstellen. Die Implementierungen für Arrays zur Laufzeit bereitgestellt werden, und die generischen Schnittstellen werden daher nicht angezeigt, in die Deklarationssyntax für die <xref:System.Array> Klasse. Darüber hinaus stehen keine Referenzthemen für Schnittstellenmember, die nur durch das Umwandeln von ein Array, das den Typ der generischen Schnittstelle (explizite schnittstellenimplementierungen) zugegriffen werden kann. Der wichtigste Punkt zu beachten, wenn Sie ein Array, das eine dieser Schnittstellen umgewandelt wird, dass Mitglieder hinzufügen, einfügen oder Entfernen von Elementen Throw <xref:System.NotSupportedException>.  
  
 <xref:System.Type> Informationen zum Typ Arraydeklarationen bereitgestellt-Objekten. <xref:System.Array> Objekte mit dem gleichen Arraytyp verwenden dieselbe <xref:System.Type> Objekt.  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType> und <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> möglicherweise nicht die erwarteten Ergebnisse mit zurück <xref:System.Array> da ein Array in den Typ umgewandelt wird <xref:System.Array>, das Ergebnis ist ein Objekt, das nicht in ein Array. D. h. `typeof(System.Array).IsArray` gibt `false`, und `typeof(System.Array).GetElementType` gibt `null`.  
  
 Die <xref:System.Array.Copy%2A?displayProperty=nameWithType> Methode kopiert die Elemente nicht nur zwischen Arrays des gleichen Typs, sondern auch zwischen verschiedenen Standardarrays; Typumwandlung von Elementen automatisch behandelt.  
  
 Einige Methoden, wie z. B. <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A>, und <xref:System.Array.SetValue%2A>, stellen Überladungen, die 64-Bit-Ganzzahlen als Parameter für hohe Kapazitäten Arrays gerecht zu akzeptieren. <xref:System.Array.LongLength%2A> und <xref:System.Array.GetLongLength%2A> 64-Bit-Ganzzahlen, die die Länge des Arrays zurück.  
  
 Die <xref:System.Array> ist nicht unbedingt sortiert werden.  Sie sortieren, müssen die <xref:System.Array> vor dem Ausführen von Vorgängen (z. B. <xref:System.Array.BinarySearch%2A>), erfordern die <xref:System.Array> sortiert werden soll.  
  
 Verwenden einer <xref:System.Array> Objekt von Zeigern in systemeigenem Code wird nicht unterstützt und löst eine <xref:System.NotSupportedException> für einige Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Array.Copy%2A?displayProperty=nameWithType> kopiert die Elemente zwischen einem Array vom typinteger und ein Array vom Typ <xref:System.Object>.  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 Im folgenden Codebeispiel wird erstellt und initialisiert ein <xref:System.Array> und zeigt die Eigenschaften und Elemente.  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind threadsicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.  
  
Diese Implementierung bietet keinen synchronisierten (threadsicheren) Wrapper für ein <see cref="T:System.Array" />jedoch .NET Framework-Klassen basierend auf <see cref="T:System.Array" /> Geben Sie ihre eigene synchronisierte Version der Auflistung mithilfe der <see cref="P:System.Array.SyncRoot" /> Eigenschaft.  
  
Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
    <related type="Article" href="~/docs/csharp/programming-guide/arrays/index.md">Arrays (C#-Programmierhandbuch)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/arrays/index.md">Arrays in Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="System.Array.AsReadOnly array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das eindimensionale, nullbasierte Array, das mit einem schreibgeschützten <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />-Wrapper umschlossen werden soll.</param>
        <summary>Gibt einen schreibgeschützten Wrapper für das angegebene Array zurück.</summary>
        <returns>Ein schreibgeschützter <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />-Wrapper für das angegebene Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu verhindern, dass alle Änderungen in das Array, verfügbar zu machen das Array nur über diesen Wrapper.  
  
 Eine Auflistung, die schreibgeschützt ist, ist einfach eine Sammlung mit einem Wrapper, der verhindert, dass die Auflistung zu ändern; Wenn die zugrunde liegende Auflistung Änderungen vorgenommen werden, spiegelt die schreibgeschützte Auflistung aus diesem Grund diese Änderungen wider.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgende Beispiel umschließt ein Array in eine schreibgeschützte <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Durchsucht ein sortiertes eindimensionales <see cref="T:System.Array" /> mithilfe eines binären Suchalgorithmus nach einem Wert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende sortierte eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <summary>Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der <see cref="T:System.IComparable" />-Schnittstelle, die von jedem Element des Arrays und durch das angegebene Objekt implementiert wird, nach einem bestimmten Element.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt keine Arrays der suchen, die negative Indizes enthalten. `array` muss vor dem Aufrufen dieser Methode sortiert werden.  
  
 Wenn die <xref:System.Array> enthält nicht den angegebenen Wert die Methode gibt eine negative ganze Zahl zurück. Sie können die bitweiser Komplementoperator anwenden (~ in c# `Not` in Visual Basic) auf das Ergebnis negativ, um einen Index zu erstellen. Wenn dieser Index eine ist größer als die obere Grenze des Arrays, es sind keine Elemente größer als `value` im Array. Andernfalls wird der Index des ersten Elements, das größer ist als `value`.  
  
 Entweder `value` oder jedes Element der `array` müssen implementieren die <xref:System.IComparable> -Schnittstelle, die für Vergleiche verwendet wird. Die Elemente der `array` muss bereits sortiert werden, erhöht gemäß der Sortierreihenfolge von definiert die <xref:System.IComparable> Implementierung ist; andernfalls kann das Ergebnis falsch sein.  
  
> [!NOTE]
>  Wenn`value` implementiert nicht die <xref:System.IComparable> Schnittstelle, die Elemente der `array` werden nicht getestet, <xref:System.IComparable> vor Beginn der Suche. Eine Ausnahme wird ausgelöst, wenn es sich bei der Suche wird ein Element gefunden, die nicht implementiert <xref:System.IComparable>.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> enthält mehr als ein Element gleich `value`, die Methode gibt den Index nur ein Vorkommen und nicht notwendigerweise die erste Bedingung zurück.  
  
 `null` kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit `null` keine Ausnahme generiert.  
  
> [!NOTE]
>  Für jedes Element getestet `value` übergeben wird, an die entsprechende <xref:System.IComparable> -Implementierung, auch wenn `value` ist `null`. D. h. die <xref:System.IComparable> -Implementierung bestimmt, wie ein angegebenes Element im Vergleich zu `null`.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit <xref:System.Array.BinarySearch%2A> finden Sie ein bestimmtes Objekt in ein <xref:System.Array>.  
  
> [!NOTE]
>  Das Array wird mit der Elemente in aufsteigender Reihenfolge erstellt. Die <xref:System.Array.BinarySearch%2A> Methode muss das Array in aufsteigender Reihenfolge sortiert werden soll.  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> implementiert nicht die <see cref="T:System.IComparable" />-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende sortierte eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der angegebenen <see cref="T:System.Collections.IComparer" />-Schnittstelle nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt keine Arrays der suchen, die negative Indizes enthalten. `array` muss vor dem Aufrufen dieser Methode sortiert werden.  
  
 Wenn die <xref:System.Array> enthält nicht den angegebenen Wert die Methode gibt eine negative ganze Zahl zurück. Sie können die bitweiser Komplementoperator anwenden (~ in c# `Not` in Visual Basic) auf das Ergebnis negativ, um einen Index zu erstellen. Wenn dieser Index eine ist größer als die obere Grenze des Arrays, es sind keine Elemente größer als `value` im Array. Andernfalls wird der Index des ersten Elements, das größer ist als `value`.  
  
 Der Vergleich wird bestimmt, wie die Elemente verglichen werden. Beispielsweise können Sie eine <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> als Vergleich zum Ausführen der Suche nach Groß-/Kleinschreibung von Zeichenfolgen.  
  
 Wenn `comparer` nicht `null`, die Elemente der `array` verglichen werden, auf den angegebenen Wert unter Verwendung des angegebenen <xref:System.Collections.IComparer> Implementierung. Die Elemente der `array` muss bereits in aufsteigender gemäß der Sortierreihenfolge von definierten Wert sortiert werden `comparer`ist, andernfalls das Ergebnis ist möglicherweise falsch.  
  
 Wenn`comparer` ist `null`, der Vergleich erfolgt mithilfe der <xref:System.IComparable> Implementierung, die durch das Element selbst oder durch den angegebenen Wert bereitgestellt. Die Elemente der `array` muss bereits sortiert werden, erhöht gemäß der Sortierreihenfolge von definiert die <xref:System.IComparable> Implementierung ist; andernfalls kann das Ergebnis falsch sein.  
  
> [!NOTE]
>  Wenn `comparer` ist `null` und `value` implementiert nicht die <xref:System.IComparable> Schnittstelle, die Elemente der `array` werden nicht getestet, <xref:System.IComparable> vor Beginn der Suche. Eine Ausnahme wird ausgelöst, wenn es sich bei der Suche wird ein Element gefunden, die nicht implementiert <xref:System.IComparable>.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> enthält mehr als ein Element gleich `value`, die Methode gibt den Index nur ein Vorkommen und nicht notwendigerweise die erste Bedingung zurück.  
  
 `null` kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit `null` keine Ausnahme generiert.  
  
> [!NOTE]
>  Für jedes Element getestet `value` übergeben wird, an die entsprechende <xref:System.IComparable> -Implementierung, auch wenn `value` ist `null`. D. h. die <xref:System.IComparable> -Implementierung bestimmt, wie ein angegebenes Element im Vergleich zu `null`.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> ist <see langword="null" /> und <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist<see langword="null" />, <paramref name="value" /> implementiert nicht die <see cref="T:System.IComparable" />-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende sortierte eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu durchsuchenden Bereichs.</param>
        <param name="length">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <summary>Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der <see cref="T:System.IComparable" />-Schnittstelle, die von jedem Element des Arrays und durch den angegebenen Wert implementiert wird, nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt keine Arrays der suchen, die negative Indizes enthalten. `array` muss vor dem Aufrufen dieser Methode sortiert werden.  
  
 Wenn die <xref:System.Array> enthält nicht den angegebenen Wert die Methode gibt eine negative ganze Zahl zurück. Sie können die bitweiser Komplementoperator anwenden (~ in c# `Not` in Visual Basic) auf das Ergebnis negativ, um einen Index zu erstellen. Wenn dieser Index eine ist größer als die obere Grenze des Arrays, es sind keine Elemente größer als `value` im Array. Andernfalls wird der Index des ersten Elements, das größer ist als `value`.  
  
 Entweder `value` oder jedes Element der `array` müssen implementieren die <xref:System.IComparable> -Schnittstelle, die für Vergleiche verwendet wird. Die Elemente der `array` muss bereits sortiert werden, erhöht gemäß der Sortierreihenfolge von definiert die <xref:System.IComparable> Implementierung ist; andernfalls kann das Ergebnis falsch sein.  
  
> [!NOTE]
>  Wenn `value` implementiert nicht die <xref:System.IComparable> Schnittstelle, die Elemente der `array` werden nicht getestet, <xref:System.IComparable> vor Beginn der Suche. Eine Ausnahme wird ausgelöst, wenn es sich bei der Suche wird ein Element gefunden, die nicht implementiert <xref:System.IComparable>.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> enthält mehr als ein Element gleich `value`, die Methode gibt den Index nur ein Vorkommen und nicht notwendigerweise die erste Bedingung zurück.  
  
 `null` kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit `null` keine Ausnahme generiert.  
  
> [!NOTE]
>  Für jedes Element getestet `value` übergeben wird, an die entsprechende <xref:System.IComparable> -Implementierung, auch wenn `value` ist `null`. D. h. die <xref:System.IComparable> -Implementierung bestimmt, wie ein angegebenes Element im Vergleich zu `null`.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in denen `n` ist `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  
  
- oder - 
 <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> implementiert nicht die <see cref="T:System.IComparable" />-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende sortierte eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu durchsuchenden Bereichs.</param>
        <param name="length">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der angegebenen <see cref="T:System.Collections.IComparer" />-Schnittstelle nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt keine Arrays der suchen, die negative Indizes enthalten. `array` muss vor dem Aufrufen dieser Methode sortiert werden.  
  
 Wenn die <xref:System.Array> enthält nicht den angegebenen Wert die Methode gibt eine negative ganze Zahl zurück. Sie können die bitweiser Komplementoperator anwenden (~ in c# `Not` in Visual Basic) auf das Ergebnis negativ, um einen Index zu erstellen. Wenn dieser Index eine ist größer als die obere Grenze des Arrays, es sind keine Elemente größer als `value` im Array. Andernfalls wird der Index des ersten Elements, das größer ist als `value`.  
  
 Der Vergleich wird bestimmt, wie die Elemente verglichen werden. Beispielsweise können Sie eine <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> als Vergleich zum Ausführen der Suche nach Groß-/Kleinschreibung von Zeichenfolgen.  
  
 Wenn `comparer` nicht `null`, die Elemente der `array` verglichen werden, auf den angegebenen Wert unter Verwendung des angegebenen <xref:System.Collections.IComparer> Implementierung. Die Elemente der `array` muss bereits in aufsteigender gemäß der Sortierreihenfolge von definierten Wert sortiert werden `comparer`ist, andernfalls das Ergebnis ist möglicherweise falsch.  
  
 Wenn `comparer` ist `null`, der Vergleich erfolgt mithilfe der <xref:System.IComparable> Implementierung, die durch das Element selbst oder durch den angegebenen Wert bereitgestellt. Die Elemente der `array` muss bereits sortiert werden, erhöht gemäß der Sortierreihenfolge von definiert die <xref:System.IComparable> Implementierung ist; andernfalls kann das Ergebnis falsch sein.  
  
> [!NOTE]
>  Wenn `comparer` ist `null` und `value` implementiert nicht die <xref:System.IComparable> Schnittstelle, die Elemente der `array` werden nicht getestet, <xref:System.IComparable> vor Beginn der Suche. Eine Ausnahme wird ausgelöst, wenn es sich bei der Suche wird ein Element gefunden, die nicht implementiert <xref:System.IComparable>.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> enthält mehr als ein Element gleich `value`, die Methode gibt den Index nur ein Vorkommen und nicht notwendigerweise die erste Bedingung zurück.  
  
 `null` kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit `null` generieren Sie eine Ausnahme bei Verwendung keine <xref:System.IComparable>.  
  
> [!NOTE]
>  Für jedes Element getestet `value` übergeben wird, an die entsprechende <xref:System.IComparable> -Implementierung, auch wenn `value` ist `null`. D. h. die <xref:System.IComparable> -Implementierung bestimmt, wie ein angegebenes Element im Vergleich zu `null`.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in denen `n` ist `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  
  
- oder - 
 <paramref name="comparer" /> ist <see langword="null" /> und <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist<see langword="null" />, <paramref name="value" /> implementiert nicht die <see cref="T:System.IComparable" />-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende sortierte eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <summary>Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der generischen <see cref="T:System.IComparable`1" />-Schnittstelle, die von jedem Element des <see cref="T:System.Array" /> und vom angegebenen Objekt implementiert wird, nach einem bestimmten Element.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt keine Arrays der suchen, die negative Indizes enthalten. `array` muss vor dem Aufrufen dieser Methode sortiert werden.  
  
 Wenn `array` enthält nicht den angegebenen Wert die Methode gibt eine negative ganze Zahl zurück. Sie können die bitweiser Komplementoperator anwenden (~ in c# `Not` in Visual Basic) auf das Ergebnis negativ, um einen Index zu erstellen. Wenn dieser Index gleich der Größe des Arrays ist, es sind keine Elemente mehr als `value` im Array. Andernfalls wird der Index des ersten Elements, das größer ist als `value`.  
  
 `T` Implementieren Sie müssen die <xref:System.IComparable%601> generische Schnittstelle, die für Vergleiche verwendet wird. Die Elemente der `array` muss bereits sortiert werden, erhöht gemäß der Sortierreihenfolge von definiert die <xref:System.IComparable%601> Implementierung ist; andernfalls kann das Ergebnis falsch sein.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> enthält mehr als ein Element gleich `value`, die Methode gibt den Index nur ein Vorkommen und nicht notwendigerweise die erste Bedingung zurück.  
  
 `null` kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit `null` keine Ausnahme generiert.  
  
> [!NOTE]
>  Für jedes Element getestet `value` übergeben wird, an die entsprechende <xref:System.IComparable%601> -Implementierung, auch wenn `value` ist `null`. D. h. die <xref:System.IComparable%601> -Implementierung bestimmt, wie ein angegebenes Element im Vergleich zu `null`.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> generischen methodenüberladung und <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generischen methodenüberladung. Ein Array von Zeichenfolgen wird in keiner bestimmten Reihenfolge erstellt.  
  
 Das Array wird angezeigt, sortiert und erneut angezeigt. Arrays müssen sortiert werden, um Sie verwenden die <xref:System.Array.BinarySearch%2A> Methode.  
  
> [!NOTE]
>  Die Aufrufe an die <xref:System.Array.Sort%2A> und <xref:System.Array.BinarySearch%2A> generische Methoden sind nicht anders als die Aufrufe an ihre nicht generischen Entsprechungen, gesucht, da Visual Basic, c# und C++ den Typ des generischen Typparameters aus dem Typ des ersten Arguments abzuleiten. Bei Verwendung der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 Die <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generischen methodenüberladung klicken Sie dann zum Suchen nach zwei Zeichenfolgen verwendet wird, ist eine, die nicht in das Array und einer ist. Das Array und der Rückgabewert von der <xref:System.Array.BinarySearch%2A> Methode übergeben werden, um die `ShowWhere` generische Methode, die den Indexwert zeigt an, wenn die Zeichenfolge gefunden wurde, und andernfalls die Elemente die Suchzeichenfolge fiel zwischen handele es sich im Array. Der Index ist negativ, wenn die Zeichenfolge nicht im Array ist daher die `ShowWhere` Methode nimmt das bitweise Komplement (der ~-Operator in c# und Visual C++, `Xor`-1 in Visual Basic) den Index des ersten Elements in der Liste zu erhalten, die größer als die Suche ist str Verbindung.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die generische <see cref="T:System.IComparable`1" />-Schnittstelle wird von <paramref name="T" /> nicht implementiert.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende sortierte eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable`1" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der angegebenen generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt keine Arrays der suchen, die negative Indizes enthalten. `array` muss vor dem Aufrufen dieser Methode sortiert werden.  
  
 Wenn die <xref:System.Array> enthält nicht den angegebenen Wert die Methode gibt eine negative ganze Zahl zurück. Sie können die bitweiser Komplementoperator anwenden (~ in c# `Not` in Visual Basic) auf das Ergebnis negativ, um einen Index zu erstellen. Wenn dieser Index gleich der Größe des Arrays ist, es sind keine Elemente mehr als `value` im Array. Andernfalls wird der Index des ersten Elements, das größer ist als `value`.  
  
 Der Vergleich wird bestimmt, wie die Elemente verglichen werden. Beispielsweise können Sie eine <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> als Vergleich zum Ausführen der Suche nach Groß-/Kleinschreibung von Zeichenfolgen.  
  
 Wenn `comparer` nicht `null`, die Elemente der `array` verglichen werden, auf den angegebenen Wert unter Verwendung des angegebenen <xref:System.Collections.Generic.IComparer%601> Implementierung der generischen Schnittstelle. Die Elemente der `array` muss bereits in aufsteigender gemäß der Sortierreihenfolge von definierten Wert sortiert werden `comparer`ist, andernfalls das Ergebnis ist möglicherweise falsch.  
  
 Wenn `comparer` ist `null`, der Vergleich erfolgt mithilfe der <xref:System.IComparable%601> generische Schnittstelle-Implementierung von `T`. Die Elemente der `array` muss bereits sortiert werden, erhöht gemäß der Sortierreihenfolge von definiert die <xref:System.IComparable%601> Implementierung ist; andernfalls kann das Ergebnis falsch sein.  
  
> [!NOTE]
>  Wenn `comparer` ist `null` und `value` implementiert nicht die <xref:System.IComparable%601> generische Schnittstelle, die Elemente der `array` werden nicht getestet, <xref:System.IComparable%601> vor Beginn der Suche. Eine Ausnahme wird ausgelöst, wenn es sich bei der Suche wird ein Element gefunden, die nicht implementiert <xref:System.IComparable%601>.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> enthält mehr als ein Element gleich `value`, die Methode gibt den Index nur ein Vorkommen und nicht notwendigerweise die erste Bedingung zurück.  
  
 `null` kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit `null` keine Ausnahme generiert.  
  
> [!NOTE]
>  Für jedes Element getestet `value` übergeben wird, an die entsprechende <xref:System.IComparable%601> -Implementierung, auch wenn `value` ist `null`. D. h. die <xref:System.IComparable%601> -Implementierung bestimmt, wie ein angegebenes Element im Vergleich zu `null`.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung und <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung.  
  
 Das Codebeispiel definiert einen alternativen Vergleich für Zeichenfolgen mit der Bezeichnung `ReverseCompare`, implementiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich ruft die <xref:System.String.CompareTo%28System.String%29> Methode, die Umkehrung der verglichenen Elemente angibt, damit die Zeichenfolgen hoch bis Niedrig statt mit niedriger zum höchsten zu sortieren.  
  
 Das Array wird angezeigt, sortiert und erneut angezeigt. Arrays müssen sortiert werden, um Sie verwenden die <xref:System.Array.BinarySearch%2A> Methode.  
  
> [!NOTE]
>  Die Aufrufe an die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> und <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden sind nicht anders als die Aufrufe an ihre nicht generischen Entsprechungen, gesucht, da Visual Basic, c# und C++ den Typ des generischen Typparameters aus dem Typ des ersten Arguments abzuleiten. Bei Verwendung der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 Die <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung klicken Sie dann zum Suchen nach zwei Zeichenfolgen verwendet wird, ist eine, die nicht in das Array und einer ist. Das Array und der Rückgabewert von der <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Methode übergeben werden, um die `ShowWhere` generische Methode, die den Indexwert zeigt an, wenn die Zeichenfolge gefunden wurde, und andernfalls die Elemente die Suchzeichenfolge fiel zwischen handele es sich im Array. Der Index ist negativ, wenn die Zeichenfolge nicht n ist das Array, also die `ShowWhere` Methode nimmt das bitweise Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic), die den Index des ersten Elements in der Liste zu erhalten, die größer als die Suche Stri NG.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> ist <see langword="null" /> und <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" /> und <paramref name="T" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende sortierte eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu durchsuchenden Bereichs.</param>
        <param name="length">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <summary>Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der generischen <see cref="T:System.IComparable`1" />-Schnittstelle, die von jedem Element des <see cref="T:System.Array" /> und vom angegebenen Wert implementiert wird, nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt keine Arrays der suchen, die negative Indizes enthalten. `array` muss vor dem Aufrufen dieser Methode sortiert werden.  
  
 Wenn das Array nicht den angegebenen Wert enthält, gibt die Methode eine negative ganze Zahl zurück. Sie können die bitweiser Komplementoperator anwenden (~ in c# `Not` in Visual Basic) auf das Ergebnis negativ, um einen Index zu erstellen. Wenn dieser Index gleich der Größe des Arrays ist, es sind keine Elemente mehr als `value` im Array. Andernfalls wird der Index des ersten Elements, das größer ist als `value`.  
  
 `T` Implementieren Sie müssen die <xref:System.IComparable%601> generische Schnittstelle, die für Vergleiche verwendet wird. Die Elemente der `array` muss bereits sortiert werden, erhöht gemäß der Sortierreihenfolge von definiert die <xref:System.IComparable%601> Implementierung ist; andernfalls kann das Ergebnis falsch sein.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> enthält mehr als ein Element gleich `value`, die Methode gibt den Index nur ein Vorkommen und nicht notwendigerweise die erste Bedingung zurück.  
  
 `null` kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit `null` keine Ausnahme generiert.  
  
> [!NOTE]
>  Für jedes Element getestet `value` übergeben wird, an die entsprechende <xref:System.IComparable%601> -Implementierung, auch wenn `value` ist `null`. D. h. die <xref:System.IComparable%601> -Implementierung bestimmt, wie ein angegebenes Element im Vergleich zu `null`.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in denen `n` ist `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die Untergrenze von <paramref name="array" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  
  
- oder - 
 <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException">Die generische <see cref="T:System.IComparable`1" />-Schnittstelle wird von <paramref name="T" /> nicht implementiert.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende sortierte eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu durchsuchenden Bereichs.</param>
        <param name="length">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable`1" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der angegebenen generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt keine Arrays der suchen, die negative Indizes enthalten. `array` muss vor dem Aufrufen dieser Methode sortiert werden.  
  
 Wenn das Array nicht den angegebenen Wert enthält, gibt die Methode eine negative ganze Zahl zurück. Sie können die bitweiser Komplementoperator anwenden (~ in c# `Not` in Visual Basic) auf das Ergebnis negativ, um einen Index zu erstellen. Wenn dieser Index gleich der Größe des Arrays ist, es sind keine Elemente mehr als `value` im Array. Andernfalls wird der Index des ersten Elements, das größer ist als `value`.  
  
 Der Vergleich wird bestimmt, wie die Elemente verglichen werden. Beispielsweise können Sie eine <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> als Vergleich zum Ausführen der Suche nach Groß-/Kleinschreibung von Zeichenfolgen.  
  
 Wenn `comparer` nicht `null`, die Elemente der `array` verglichen werden, auf den angegebenen Wert unter Verwendung des angegebenen <xref:System.Collections.Generic.IComparer%601> Implementierung der generischen Schnittstelle. Die Elemente der `array` muss bereits in aufsteigender gemäß der Sortierreihenfolge von definierten Wert sortiert werden `comparer`ist, andernfalls das Ergebnis ist möglicherweise falsch.  
  
 Wenn `comparer` ist `null`, der Vergleich erfolgt mithilfe der <xref:System.IComparable%601> Implementierung der generischen Schnittstelle bereitgestellte für den Typ `T`. Die Elemente der `array` muss bereits sortiert werden, erhöht gemäß der Sortierreihenfolge von definiert die <xref:System.IComparable%601> Implementierung ist; andernfalls kann das Ergebnis falsch sein.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> enthält mehr als ein Element gleich `value`, die Methode gibt den Index nur ein Vorkommen und nicht notwendigerweise die erste Bedingung zurück.  
  
 `null` kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit `null` generieren Sie eine Ausnahme bei Verwendung keine <xref:System.IComparable%601>.  
  
> [!NOTE]
>  Für jedes Element getestet `value` übergeben wird, an die entsprechende <xref:System.IComparable%601> -Implementierung, auch wenn `value` ist `null`. D. h. die <xref:System.IComparable%601> -Implementierung bestimmt, wie ein angegebenes Element im Vergleich zu `null`.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in denen `n` ist `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die Untergrenze von <paramref name="array" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  
  
- oder - 
 <paramref name="comparer" /> ist <see langword="null" />, und <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und <paramref name="T" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Clear : Array * int * int -&gt; unit" Usage="System.Array.Clear (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das Array, dessen Elemente gelöscht werden sollen.</param>
        <param name="index">Der Startindex für den Bereich der zu löschenden Elemente.</param>
        <param name="length">Die Anzahl der zu löschenden Elemente.</param>
        <summary>Legt einen Bereich von Elementen in einem Array mit dem Standardwert der einzelnen Elementtypen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode setzt jedes Element in einem Array auf Standardwert des Elementtyps zurück. Elemente von Verweistypen wird (einschließlich <xref:System.String> Elemente), `null`, und legt die Elemente von Werttypen auf die Standardwerte, die in der folgenden Tabelle gezeigt fest.  
  
|Typ|Wert|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|Alle numerischen Ganzzahl- und Gleitkommatyps Point-Typen|0 (null)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|Andere Werttypen|Standardwert, der die Felder des Typs|  
  
 Der Bereich der gelöschten Elemente umfasst von Zeile zu Zeile, in ein mehrdimensionales Array.  
  
 Diese Methode löscht nur die Werte der Elemente. die Elemente selbst werden nicht gelöscht. Ein Array hat eine feste Größe; aus diesem Grund können nicht Elemente hinzugefügt oder entfernt werden soll.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Array.Clear%2A> Methode, um ganzzahlige Werte in einem eindimensionalen, zwei- und dreidimensionaler Array zurückzusetzen.  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 Das folgende Beispiel definiert eine `TimeZoneTime` -Struktur, die umfasst eine <xref:System.TimeZoneInfo> Feld und einem <xref:System.DateTimeOffset> Feld. Es ruft dann die <xref:System.Array.Clear%2A> Methode, um ein Element in ein Array mit zwei Elementen der löschen `TimeZoneTime` Werte. Die-Methode legt den Wert des gelöschten Elements auf den Standardwert einer <xref:System.TimeZoneInfo> -Objekt, das ist `null`, und der Standardwert von einer <xref:System.DateTimeOffset> -Objekt, das ist <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> ist kleiner als die Untergrenze von <paramref name="array" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.  
  
- oder - 
Die Summe von <paramref name="index" /> und <paramref name="length" /> ist größer als die Größe des <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="array.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine flache Kopie von <see cref="T:System.Array" />.</summary>
        <returns>Eine flache Kopie von <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine flache Kopie einer <xref:System.Array> kopiert nur die Elemente der <xref:System.Array>, ob sie Verweis- oder Werttypen sind, aber die Objekte, die auf die verwiesen wird nicht kopiert. Die Verweise in der neuen <xref:System.Array> zeigen auf dieselben Objekte, die Verweise in der ursprünglichen <xref:System.Array> zeigen Sie auf.  
  
 Im Gegensatz dazu eine tiefe Kopie von einer <xref:System.Array> kopiert die Elemente und alles direkt oder indirekt auf die verwiesen wird durch die Elemente.  
  
 Der Klon hat die gleiche <xref:System.Type> wie das Original <xref:System.Array>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Array.Length%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel Beispiel Klonen eine <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> array und das Verhalten einer flachen Kopie.  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member ConstrainedCopy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.ConstrainedCopy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="sourceIndex">Eine 32-Bit-Ganzzahl, die den Index im <paramref name="sourceArray" /> angibt, ab dem kopiert werden soll.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="destinationIndex">Eine 32-Bit-Ganzzahl, die den Index im <paramref name="destinationArray" /> angibt, ab dem gespeichert werden soll.</param>
        <param name="length">Eine 32-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt.</param>
        <summary>Kopiert einen beim angegebenen Quellindex beginnenden Elementbereich aus einem <see cref="T:System.Array" /> und fügt ihn ab dem angegebenen Zielindex in ein anderes <see cref="T:System.Array" /> ein.  Stellt sicher, dass alle Änderungen rückgängig gemacht werden, wenn der Kopiervorgang nicht vollständig abgeschlossen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `sourceArray` und `destinationArray` -Parameter müssen die gleiche Anzahl von Dimensionen haben.  Die `sourceArray` Typ identisch sein muss, oder von abgeleiteten der `destinationArray` -Typ., andernfalls ein <xref:System.ArrayTypeMismatchException> ausgelöst.  Im Gegensatz zu <xref:System.Array.Copy%2A>, <xref:System.Array.ConstrainedCopy%2A> überprüft die Kompatibilität der Arraytypen vor jeder Aktion.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, in dem die Zeilen (oder Spalten) vom Konzept her End-to-End-angeordnet sind. Wenn ein Array drei Zeilen (oder Spalten) mit vier Elementen, Kopieren von sechs Elementen vom Anfang des Arrays würde z. B. alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopieren. Mit dem Kopieren begonnen, über das zweite Element der dritten Zeile (oder Spalte), `sourceIndex` muss die obere Grenze der ersten Zeile (oder Spalte) plus die Länge der zweiten Zeile (oder Spalte) sowie zwei sein.  
  
 Wenn `sourceArray` und `destinationArray` überlappen, diese Methode verhält sich wie die ursprünglichen Werte der `sourceArray` beibehalten wurden, in einen temporären Speicherort vor dem `destinationArray` wird überschrieben.  
  
 [C++]  
  
 Diese Methode entspricht der C/C++-Standardfunktion `memmove`, nicht `memcpy`.  
  
 Die Arrays können es sich um Verweistyparrays oder Werttypen sein.  Wenn `sourceArray` und `destinationArray` Verweistyp-Arrays sind oder Arrays des Typs sind <xref:System.Object>, eine flache Kopie wird ausgeführt. Eine flache Kopie einer <xref:System.Array> ist ein neues <xref:System.Array> , die Verweise auf die gleichen Elemente wie die ursprüngliche <xref:System.Array>. Die Elemente selbst oder für etwas auf die verwiesen wird durch die Elemente werden nicht kopiert. Im Gegensatz dazu eine tiefe Kopie von einer <xref:System.Array> kopiert die Elemente und alles direkt oder indirekt auf die verwiesen wird durch die Elemente.  
  
 Wenn diese Methode eine während des Kopiervorgangs Ausnahme der `destinationArray` unverändert; aus diesem Grund <xref:System.Array.ConstrainedCopy%2A> kann in einem eingeschränkten Ausführungsbereich verwendet werden (<xref:System.Runtime.ConstrainedExecution.Cer>).  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Der <paramref name="sourceArray" />-Typ entspricht weder dem <paramref name="destinationArray" />-Typ, noch wird er von diesem abgeleitet.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im <paramref name="sourceArray" /> kann nicht in den Typ des <paramref name="destinationArray" />s umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> ist kleiner als die untere Grenze der ersten Dimension von <paramref name="sourceArray" />.  
  
- oder - 
 <paramref name="destinationIndex" /> ist kleiner als die untere Grenze der ersten Dimension von <paramref name="destinationArray" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="sourceIndex" /> bis zum Ende des <paramref name="sourceArray" />s.  
  
- oder - 
 <paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="destinationIndex" /> bis zum Ende des <paramref name="destinationArray" />s.</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="static member ConvertAll : 'Input[] * Converter&lt;'Input, 'Output&gt; -&gt; 'Output[]" Usage="System.Array.ConvertAll (array, converter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Der Typ der Elemente des Quellarrays.</typeparam>
        <typeparam name="TOutput">Der Typ der Elemente des Zielarrays.</typeparam>
        <param name="array">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das in einen Zieltyp konvertiert werden soll.</param>
        <param name="converter">Ein <see cref="T:System.Converter`2" />, der jedes Element von einem Typ in einen anderen Typ konvertiert.</param>
        <summary>Konvertiert ein Array des einen Typs in ein Array eines anderen Typs.</summary>
        <returns>Ein Array des Zieltyps, das die konvertierten Elemente aus dem Quellarray enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Converter%602> ist ein Delegat für eine Methode, ein Objekt in den Zieltyp konvertiert.  Die Elemente der `array` werden einzeln an übergeben die <xref:System.Converter%602>, und die konvertierten Elemente werden in das neue Array gespeichert.  
  
 Die Quelle `array` bleibt unverändert.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Das folgende Codebeispiel definiert eine Methode, die mit dem Namen `PointFToPoint` , konvertiert ein <xref:System.Drawing.PointF> -Struktur in eine <xref:System.Drawing.Point> Struktur. Im Beispiel wird dann erstellt ein Array von <xref:System.Drawing.PointF> strukturiert ist, erstellt eine `Converter<PointF, Point>` delegieren (`Converter(Of PointF, Point)` in Visual Basic) zur Darstellung der `PointFToPoint` -Methode, und übergibt den Delegaten an die <xref:System.Array.ConvertAll%2A> Methode. Die <xref:System.Array.ConvertAll%2A> Methode übergibt jedes Element der Liste der Eingabe der `PointFToPoint` Methode und legt die konvertierten Elemente in eine neue Liste von <xref:System.Drawing.Point> Strukturen. Beide Listen werden angezeigt.  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="converter" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert einen Bereich von Elementen eines <see cref="T:System.Array" /> in ein anderes <see cref="T:System.Array" /> und führt ggf. Typumwandlungen und Boxing durch.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="length">Eine 32-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt.</param>
        <summary>Kopiert einen mit dem ersten Element beginnenden Elementbereich eines <see cref="T:System.Array" /> und fügt ihn ab dem ersten Element in ein anderes <see cref="T:System.Array" /> ein. Die Länge wird als 32-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `sourceArray` und `destinationArray` -Parameter müssen die gleiche Anzahl von Dimensionen haben. Darüber hinaus `destinationArray` muss bereits haben wurde dimensioniert und muss eine ausreichende Anzahl von Elementen, die die kopierten Daten aufzunehmen.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, in dem die Zeilen (oder Spalten) vom Konzept her End-to-End angeordnet sind. Wenn ein Array drei Zeilen (oder Spalten) mit vier Elementen, Kopieren von sechs Elementen vom Anfang des Arrays würde z. B. alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopieren.  
  
 Wenn `sourceArray` und `destinationArray` überlappen, diese Methode verhält sich wie die ursprünglichen Werte der `sourceArray` beibehalten wurden, in einen temporären Speicherort vor dem `destinationArray` wird überschrieben.  
  
 [C++]  
  
 Diese Methode entspricht der C/C++-Standardfunktion `memmove`, nicht `memcpy`.  
  
 Die Arrays können es sich um Verweistyparrays oder Werttypen sein. Eine Umwandlung des Typs ausgeführt wird, nach Bedarf.  
  
-   Beim Kopieren aus einem Verweistyp-Array in ein Array von Werttyp wird jedes Element mittels Unboxing zurückkonvertiert und kopiert. Beim Kopieren aus einem Array von Werttyp in einen Verweistyp-Array wird jedes Element mittels Boxing konvertiert und anschließend kopiert.  
  
-   Beim Kopieren aus einem Verweistyp oder Werttyp-Array eine <xref:System.Object> Array, ein <xref:System.Object> erstellt, um jeden Wert oder Verweis enthalten ist, und klicken Sie dann kopiert. Beim Kopieren aus einer <xref:System.Object> Array, das ein Array vom Verweistyp oder Werttyp und die Zuweisung ist nicht möglich, eine <xref:System.InvalidCastException> ausgelöst.  
  
-   Wenn `sourceArray` und `destinationArray` Verweistyp-Arrays sind oder Arrays des Typs sind <xref:System.Object>, eine flache Kopie wird ausgeführt. Eine flache Kopie einer <xref:System.Array> ist ein neues <xref:System.Array> , die Verweise auf die gleichen Elemente wie die ursprüngliche <xref:System.Array>. Die Elemente selbst oder für etwas auf die verwiesen wird durch die Elemente werden nicht kopiert. Im Gegensatz dazu eine tiefe Kopie von einer <xref:System.Array> kopiert die Elemente und alles direkt oder indirekt auf die verwiesen wird durch die Elemente.  
  
 Ein <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn die Arrays von inkompatiblen Typen sind. Typkompatibilität wird wie folgt definiert:  
  
-   Ein Typ ist kompatibel mit sich selbst.  
  
-   Ein Werttyp ist kompatibel mit <xref:System.Object> und mit einem Schnittstellentyp, der durch diesen Werttyp implementiert. Mit einer Schnittstelle verbunden ist, nur dann, wenn sie diese Schnittstelle direkt implementiert, ist ein Werttyp gilt. Nicht verbundene Typen sind nicht kompatibel.  
  
-   Zwei Arten von systeminternen (vordefinierten) Wert sind kompatibel, wenn kopieren aus einer Datenquelle in den Zieltyp eine erweiternde Konvertierung ist. Nie eine erweiternde Konvertierung verliert Informationen an, während eine einschränkende Konvertierung Informationen verloren gehen kann. Beispielsweise konvertieren eine 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen eine erweiternde Konvertierung ist, und konvertieren eine 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen ist eine einschränkende Konvertierung. Weitere Informationen über Konvertierungen finden Sie unter <xref:System.Convert>.  
  
-   Ein systeminterner (Benutzerdefiniert) Wert ist nur mit sich selbst kompatibel.  
  
-   -Enumerationen verfügen über eine implizite Konvertierung in <xref:System.Enum> und ihren zugrunde liegenden Typ.  
  
 Wenn jedes Element in `sourceArray` eine Umwandlung erfordert (z. B. von einer Basisklasse in einer abgeleiteten Klasse oder von einer Schnittstelle in ein Objekt) und einem oder mehreren Elementen können nicht in den entsprechenden Typ umgewandelt werden `destinationArray`, <xref:System.InvalidCastException> ausgelöst.  
  
 Wenn diese Methode eine beim Kopieren Ausnahme, des Status der `destinationArray` ist nicht definiert.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> weisen inkompatible Typen auf.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element in <paramref name="sourceArray" /> kann nicht in den <paramref name="destinationArray" />-Typ umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="sourceArray" />.  
  
- oder - 
 <paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationArray" Type="System.Array" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="length">Eine 64-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt. Die Ganzzahl muss zwischen 0 (null) und einschließlich <see cref="F:System.Int32.MaxValue" /> liegen.</param>
        <summary>Kopiert einen mit dem ersten Element beginnenden Elementbereich eines <see cref="T:System.Array" /> und fügt ihn ab dem ersten Element in ein anderes <see cref="T:System.Array" /> ein. Die Länge wird als 64-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `sourceArray` und `destinationArray` -Parameter müssen die gleiche Anzahl von Dimensionen haben. Darüber hinaus `destinationArray` muss bereits haben wurde dimensioniert und muss eine ausreichende Anzahl von Elementen, die die kopierten Daten aufzunehmen.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, in dem die Zeilen (oder Spalten) vom Konzept her End-to-End angeordnet sind. Wenn ein Array drei Zeilen (oder Spalten) mit vier Elementen, Kopieren von sechs Elementen vom Anfang des Arrays würde z. B. alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopieren.  
  
 Wenn `sourceArray` und `destinationArray` überlappen, diese Methode verhält sich wie die ursprünglichen Werte der `sourceArray` beibehalten wurden, in einen temporären Speicherort vor dem `destinationArray` wird überschrieben.  
  
 [C++]  
  
 Diese Methode entspricht der C/C++-Standardfunktion `memmove`, nicht `memcpy`.  
  
 Die Arrays können es sich um Verweistyparrays oder Werttypen sein. Eine Umwandlung des Typs ausgeführt wird, nach Bedarf.  
  
-   Beim Kopieren aus einem Verweistyp-Array in ein Array von Werttyp wird jedes Element mittels Unboxing zurückkonvertiert und kopiert. Beim Kopieren aus einem Array von Werttyp in einen Verweistyp-Array wird jedes Element mittels Boxing konvertiert und anschließend kopiert.  
  
-   Beim Kopieren aus einem Verweistyp oder Werttyp-Array eine <xref:System.Object> Array, ein <xref:System.Object> erstellt, um jeden Wert oder Verweis enthalten ist, und klicken Sie dann kopiert. Beim Kopieren aus einer <xref:System.Object> Array, das ein Array vom Verweistyp oder Werttyp und die Zuweisung ist nicht möglich, eine <xref:System.InvalidCastException> ausgelöst.  
  
-   Wenn `sourceArray` und `destinationArray` Verweistyp-Arrays sind oder Arrays des Typs sind <xref:System.Object>, eine flache Kopie wird ausgeführt. Eine flache Kopie einer <xref:System.Array> ist ein neues <xref:System.Array> , die Verweise auf die gleichen Elemente wie die ursprüngliche <xref:System.Array>. Die Elemente selbst oder für etwas auf die verwiesen wird durch die Elemente werden nicht kopiert. Im Gegensatz dazu eine tiefe Kopie von einer <xref:System.Array> kopiert die Elemente und alles direkt oder indirekt auf die verwiesen wird durch die Elemente.  
  
 Ein <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn die Arrays von inkompatiblen Typen sind. Typkompatibilität wird wie folgt definiert:  
  
-   Ein Typ ist kompatibel mit sich selbst.  
  
-   Ein Werttyp ist kompatibel mit <xref:System.Object> und mit einem Schnittstellentyp, der durch diesen Werttyp implementiert. Mit einer Schnittstelle verbunden ist, nur dann, wenn sie diese Schnittstelle direkt implementiert, ist ein Werttyp gilt. Nicht verbundene Typen sind nicht kompatibel.  
  
-   Zwei Arten von systeminternen (vordefinierten) Wert sind kompatibel, wenn kopieren aus einer Datenquelle in den Zieltyp eine erweiternde Konvertierung ist. Nie eine erweiternde Konvertierung verliert Informationen an, während eine einschränkende Konvertierung Informationen verloren gehen kann. Beispielsweise konvertieren eine 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen eine erweiternde Konvertierung ist, und konvertieren eine 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen ist eine einschränkende Konvertierung. Weitere Informationen über Konvertierungen finden Sie unter <xref:System.Convert>.  
  
-   Ein systeminterner (Benutzerdefiniert) Wert ist nur mit sich selbst kompatibel.  
  
-   -Enumerationen verfügen über eine implizite Konvertierung in <xref:System.Enum> und ihren zugrunde liegenden Typ.  
  
 Wenn jedes Element in `sourceArray` eine Umwandlung erfordert (z. B. von einer Basisklasse in einer abgeleiteten Klasse oder von einer Schnittstelle in ein Objekt) und einem oder mehreren Elementen können nicht in den entsprechenden Typ umgewandelt werden `destinationArray`, <xref:System.InvalidCastException> ausgelöst.  
  
 Wenn diese Methode eine beim Kopieren Ausnahme, des Status der `destinationArray` ist nicht definiert.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> weisen inkompatible Typen auf.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im <paramref name="sourceArray" /> kann nicht in den Typ des <paramref name="destinationArray" />s umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> ist kleiner als 0 oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="sourceArray" />.  
  
- oder - 
 <paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="sourceIndex">Eine 32-Bit-Ganzzahl, die den Index im <paramref name="sourceArray" /> angibt, ab dem kopiert werden soll.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="destinationIndex">Eine 32-Bit-Ganzzahl, die den Index im <paramref name="destinationArray" /> angibt, ab dem gespeichert werden soll.</param>
        <param name="length">Eine 32-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt.</param>
        <summary>Kopiert einen beim angegebenen Quellindex beginnenden Elementbereich aus einem <see cref="T:System.Array" /> und fügt ihn ab dem angegebenen Zielindex in ein anderes <see cref="T:System.Array" /> ein. Die Länge und die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `sourceArray` und `destinationArray` -Parameter müssen die gleiche Anzahl von Dimensionen haben. Darüber hinaus `destinationArray` muss bereits haben wurde dimensioniert und muss eine ausreichende Anzahl von Elementen, beginnend mit der `destinationIndex` Position, um die kopierten Daten aufzunehmen.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, in dem die Zeilen (oder Spalten) vom Konzept her End-to-End-angeordnet sind. Wenn ein Array drei Zeilen (oder Spalten) mit vier Elementen, Kopieren von sechs Elementen vom Anfang des Arrays würde z. B. alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopieren. Mit dem Kopieren begonnen, über das zweite Element der dritten Zeile (oder Spalte), `sourceIndex` muss die obere Grenze der ersten Zeile (oder Spalte) plus die Länge der zweiten Zeile (oder Spalte) sowie zwei sein.  
  
 Wenn `sourceArray` und `destinationArray` überlappen, diese Methode verhält sich wie die ursprünglichen Werte der `sourceArray` beibehalten wurden, in einen temporären Speicherort vor dem `destinationArray` wird überschrieben.  
  
 [C++]  
  
 Diese Methode entspricht der C/C++-Standardfunktion `memmove`, nicht `memcpy`.  
  
 Die Arrays können es sich um Verweistyparrays oder Werttypen sein. Eine Umwandlung des Typs ausgeführt wird, nach Bedarf.  
  
-   Beim Kopieren aus einem Verweistyp-Array in ein Array von Werttyp wird jedes Element mittels Unboxing zurückkonvertiert und kopiert. Beim Kopieren aus einem Array von Werttyp in einen Verweistyp-Array wird jedes Element mittels Boxing konvertiert und anschließend kopiert.  
  
-   Beim Kopieren aus einem Verweistyp oder Werttyp-Array eine <xref:System.Object> Array, ein <xref:System.Object> erstellt, um jeden Wert oder Verweis enthalten ist, und klicken Sie dann kopiert. Beim Kopieren aus einer <xref:System.Object> Array, das ein Array vom Verweistyp oder Werttyp und die Zuweisung ist nicht möglich, eine <xref:System.InvalidCastException> ausgelöst.  
  
-   Wenn `sourceArray` und `destinationArray` Verweistyp-Arrays sind oder Arrays des Typs sind <xref:System.Object>, eine flache Kopie wird ausgeführt. Eine flache Kopie einer <xref:System.Array> ist ein neues <xref:System.Array> , die Verweise auf die gleichen Elemente wie die ursprüngliche <xref:System.Array>. Die Elemente selbst oder für etwas auf die verwiesen wird durch die Elemente werden nicht kopiert. Im Gegensatz dazu eine tiefe Kopie von einer <xref:System.Array> kopiert die Elemente und alles direkt oder indirekt auf die verwiesen wird durch die Elemente.  
  
 Ein <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn die Arrays von inkompatiblen Typen sind. Typkompatibilität wird wie folgt definiert:  
  
-   Ein Typ ist kompatibel mit sich selbst.  
  
-   Ein Werttyp ist kompatibel mit <xref:System.Object> und mit einem Schnittstellentyp, der durch diesen Werttyp implementiert. Mit einer Schnittstelle verbunden ist, nur dann, wenn sie diese Schnittstelle direkt implementiert, ist ein Werttyp gilt. Nicht verbundene Typen sind nicht kompatibel.  
  
-   Zwei Arten von systeminternen (vordefinierten) Wert sind kompatibel, wenn kopieren aus einer Datenquelle in den Zieltyp eine erweiternde Konvertierung ist. Nie eine erweiternde Konvertierung verliert Informationen an, während eine einschränkende Konvertierung Informationen verloren gehen kann. Beispielsweise konvertieren eine 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen eine erweiternde Konvertierung ist, und konvertieren eine 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen ist eine einschränkende Konvertierung. Weitere Informationen über Konvertierungen finden Sie unter <xref:System.Convert>.  
  
-   Ein systeminterner (Benutzerdefiniert) Wert ist nur mit sich selbst kompatibel.  
  
-   -Enumerationen verfügen über eine implizite Konvertierung in <xref:System.Enum> und ihren zugrunde liegenden Typ.  
  
 Wenn jedes Element in `sourceArray` eine Umwandlung erfordert (z. B. von einer Basisklasse in einer abgeleiteten Klasse oder von einer Schnittstelle in ein Objekt) und einem oder mehreren Elementen können nicht in den entsprechenden Typ umgewandelt werden `destinationArray`, <xref:System.InvalidCastException> ausgelöst.  
  
 Wenn diese Methode eine beim Kopieren Ausnahme, des Status der `destinationArray` ist nicht definiert.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Kopieren aus einer <xref:System.Array> des Typs <xref:System.Object> in ein anderes <xref:System.Array> vom Integer-Typ.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> weisen inkompatible Typen auf.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im <paramref name="sourceArray" /> kann nicht in den Typ des <paramref name="destinationArray" />s umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> ist kleiner als die untere Grenze der ersten Dimension von <paramref name="sourceArray" />.  
  
- oder - 
 <paramref name="destinationIndex" /> ist kleiner als die untere Grenze der ersten Dimension von <paramref name="destinationArray" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="sourceIndex" /> bis zum Ende des <paramref name="sourceArray" />s.  
  
- oder - 
 <paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="destinationIndex" /> bis zum Ende des <paramref name="destinationArray" />s.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int64 * Array * int64 * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="sourceIndex" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationIndex" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="sourceIndex">Eine 64-Bit-Ganzzahl, die den Index im <paramref name="sourceArray" /> angibt, ab dem kopiert werden soll.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="destinationIndex">Eine 64-Bit-Ganzzahl, die den Index im <paramref name="destinationArray" /> angibt, ab dem gespeichert werden soll.</param>
        <param name="length">Eine 64-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt. Die Ganzzahl muss zwischen 0 (null) und einschließlich <see cref="F:System.Int32.MaxValue" /> liegen.</param>
        <summary>Kopiert einen beim angegebenen Quellindex beginnenden Elementbereich aus einem <see cref="T:System.Array" /> und fügt ihn ab dem angegebenen Zielindex in ein anderes <see cref="T:System.Array" /> ein. Die Länge und die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `sourceArray` und `destinationArray` -Parameter müssen die gleiche Anzahl von Dimensionen haben. Darüber hinaus `destinationArray` muss bereits haben wurde dimensioniert und muss eine ausreichende Anzahl von Elementen, beginnend mit der `destinationIndex` Position, um die kopierten Daten aufzunehmen.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, in dem die Zeilen (oder Spalten) vom Konzept her End-to-End-angeordnet sind. Wenn ein Array drei Zeilen (oder Spalten) mit vier Elementen, Kopieren von sechs Elementen vom Anfang des Arrays würde z. B. alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopieren. Mit dem Kopieren begonnen, über das zweite Element der dritten Zeile (oder Spalte), `sourceIndex` muss die obere Grenze der ersten Zeile (oder Spalte) plus die Länge der zweiten Zeile (oder Spalte) sowie zwei sein.  
  
 Wenn `sourceArray` und `destinationArray` überlappen, diese Methode verhält sich wie die ursprünglichen Werte der `sourceArray` beibehalten wurden, in einen temporären Speicherort vor dem `destinationArray` wird überschrieben.  
  
 [C++]  
  
 Diese Methode entspricht der C/C++-Standardfunktion `memmove`, nicht `memcpy`.  
  
 Die Arrays können es sich um Verweistyparrays oder Werttypen sein. Eine Umwandlung des Typs ausgeführt wird, nach Bedarf.  
  
-   Beim Kopieren aus einem Verweistyp-Array in ein Array von Werttyp wird jedes Element mittels Unboxing zurückkonvertiert und kopiert. Beim Kopieren aus einem Array von Werttyp in einen Verweistyp-Array wird jedes Element mittels Boxing konvertiert und anschließend kopiert.  
  
-   Beim Kopieren aus einem Verweistyp oder Werttyp-Array eine <xref:System.Object> Array, ein <xref:System.Object> erstellt, um jeden Wert oder Verweis enthalten ist, und klicken Sie dann kopiert. Beim Kopieren aus einer <xref:System.Object> Array, das ein Array vom Verweistyp oder Werttyp und die Zuweisung ist nicht möglich, eine <xref:System.InvalidCastException> ausgelöst.  
  
-   Wenn `sourceArray` und `destinationArray` Verweistyp-Arrays sind oder Arrays des Typs sind <xref:System.Object>, eine flache Kopie wird ausgeführt. Eine flache Kopie einer <xref:System.Array> ist ein neues <xref:System.Array> , die Verweise auf die gleichen Elemente wie die ursprüngliche <xref:System.Array>. Die Elemente selbst oder für etwas auf die verwiesen wird durch die Elemente werden nicht kopiert. Im Gegensatz dazu eine tiefe Kopie von einer <xref:System.Array> kopiert die Elemente und alles direkt oder indirekt auf die verwiesen wird durch die Elemente.  
  
 Ein <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn die Arrays von inkompatiblen Typen sind. Typkompatibilität wird wie folgt definiert:  
  
-   Ein Typ ist kompatibel mit sich selbst.  
  
-   Ein Werttyp ist kompatibel mit <xref:System.Object> und mit einem Schnittstellentyp, der durch diesen Werttyp implementiert. Mit einer Schnittstelle verbunden ist, nur dann, wenn sie diese Schnittstelle direkt implementiert, ist ein Werttyp gilt. Nicht verbundene Typen sind nicht kompatibel.  
  
-   Zwei Arten von systeminternen (vordefinierten) Wert sind kompatibel, wenn kopieren aus einer Datenquelle in den Zieltyp eine erweiternde Konvertierung ist. Nie eine erweiternde Konvertierung verliert Informationen an, während eine einschränkende Konvertierung Informationen verloren gehen kann. Beispielsweise konvertieren eine 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen eine erweiternde Konvertierung ist, und konvertieren eine 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen ist eine einschränkende Konvertierung. Weitere Informationen über Konvertierungen finden Sie unter <xref:System.Convert>.  
  
-   Ein systeminterner (Benutzerdefiniert) Wert ist nur mit sich selbst kompatibel.  
  
-   -Enumerationen verfügen über eine implizite Konvertierung in <xref:System.Enum> und ihren zugrunde liegenden Typ.  
  
 Wenn jedes Element in `sourceArray` eine Umwandlung erfordert (z. B. von einer Basisklasse in einer abgeleiteten Klasse oder von einer Schnittstelle in ein Objekt) und einem oder mehreren Elementen können nicht in den entsprechenden Typ umgewandelt werden `destinationArray`, <xref:System.InvalidCastException> ausgelöst.  
  
 Wenn diese Methode eine beim Kopieren Ausnahme, des Status der `destinationArray` ist nicht definiert.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Kopieren aus einer <xref:System.Array> des Typs <xref:System.Object> in ein anderes <xref:System.Array> vom Integer-Typ.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> weisen inkompatible Typen auf.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im <paramref name="sourceArray" /> kann nicht in den Typ des <paramref name="destinationArray" />s umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <paramref name="sourceArray" />.  
  
- oder - 
 <paramref name="destinationIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <paramref name="destinationArray" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als 0 oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="sourceIndex" /> bis zum Ende des <paramref name="sourceArray" />s.  
  
- oder - 
 <paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="destinationIndex" /> bis zum Ende des <paramref name="destinationArray" />s.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert alle Elemente des aktuellen eindimensionalen Arrays in das angegebene eindimensionale Array.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Array, das das Ziel der aus dem aktuellen Array kopierten Elemente ist.</param>
        <param name="index">Eine 32-Bit-Ganzzahl, die den Index im <paramref name="array" /> angibt, ab dem kopiert werden soll.</param>
        <summary>Kopiert alle Elemente des aktuellen eindimensionalen Arrays in das angegebene eindimensionale Array, beginnend am angegebenen Index des Zielarrays. Der Index wird als 32-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert alle Elemente der aktuellen Arrayinstanz zum der `array` Zielarray, beginnend am Index `index`. Die `array` Zielarray muss bereits haben wurde dimensioniert und muss eine ausreichende Anzahl von Elementen, die die kopierten Elemente aufzunehmen. Andernfalls löst die Methode eine Ausnahme aus.  
  
 Diese Methode unterstützt die <xref:System.Collections.ICollection?displayProperty=nameWithType> Schnittstelle. Wenn implementieren <xref:System.Collections.ICollection?displayProperty=nameWithType> ist nicht explizit erforderlich ist, verwenden <xref:System.Array.Copy%2A> um eine zusätzliche Dereferenzierung zu vermeiden.  
  
 Wenn diese Methode eine beim Kopieren Ausnahme, des Status der `array` ist nicht definiert.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Array.Length%2A>. Sie führt nur eine flache Kopie.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Kopieren einer <xref:System.Array> in ein anderes <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Kopieren einer <xref:System.Array> in ein anderes <xref:System.Array> und eine Untergrenze ungleich NULL. Beachten Sie, dass die gesamte Quelle <xref:System.Array> kopiert wurden, einschließlich leere Elemente enthält, die vorhandenen Elemente im Ziel zu überschreiben <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ist mehrdimensional.  
  
- oder - 
Die Anzahl der Elemente im Quellarray ist größer als die verfügbare Anzahl der Elemente vom <paramref name="index" /> bis zum Ende des Ziel-<paramref name="array" />s.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Der Typ des Quell-<see cref="T:System.Array" />s kann nicht automatisch in den Typ des Ziel<paramref name="array" />s umgewandelt werden.</exception>
        <exception cref="T:System.RankException">Das Quellarray ist mehrdimensional.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im Quell-<see cref="T:System.Array" /> kann nicht in den Typ des Ziel<paramref name="array" />s umgewandelt werden.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Array, das das Ziel der aus dem aktuellen Array kopierten Elemente ist.</param>
        <param name="index">Eine 64-Bit-Ganzzahl, die den Index im <paramref name="array" /> angibt, ab dem kopiert werden soll.</param>
        <summary>Kopiert alle Elemente des aktuellen eindimensionalen Arrays in das angegebene eindimensionale Array, beginnend am angegebenen Index des Zielarrays. Der Index wird als 64-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert alle Elemente der aktuellen Arrayinstanz zum der `array` Zielarray, beginnend am Index `index`. Die `array` Zielarray muss bereits haben wurde dimensioniert und muss eine ausreichende Anzahl von Elementen, die die kopierten Elemente aufzunehmen. Andernfalls löst die Methode eine Ausnahme aus.  
  
 Diese Methode unterstützt die <xref:System.Collections.ICollection?displayProperty=nameWithType> Schnittstelle. Wenn implementieren <xref:System.Collections.ICollection?displayProperty=nameWithType> ist nicht explizit erforderlich ist, verwenden <xref:System.Array.Copy%2A> um eine zusätzliche Dereferenzierung zu vermeiden.  
  
 Wenn diese Methode eine beim Kopieren Ausnahme, des Status der `array` ist nicht definiert.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Array.Length%2A>. Sie führt nur eine flache Kopie.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Kopieren einer <xref:System.Array> in ein anderes <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Kopieren einer <xref:System.Array> in ein anderes <xref:System.Array> und eine Untergrenze ungleich NULL. Beachten Sie, dass die gesamte Quelle <xref:System.Array> kopiert wurden, einschließlich leere Elemente enthält, die vorhandenen Elemente im Ziel zu überschreiben <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ist mehrdimensional.  
  
- oder - 
Die Anzahl der Elemente im Quellarray ist größer als die verfügbare Anzahl der Elemente vom <paramref name="index" /> bis zum Ende des Ziel-<paramref name="array" />s.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Der Typ des Quell-<see cref="T:System.Array" />s kann nicht automatisch in den Typ des Ziel-<paramref name="array" />s umgewandelt werden.</exception>
        <exception cref="T:System.RankException">Das Quell-<see cref="T:System.Array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im Quell-<see cref="T:System.Array" /> kann nicht in den Typ des Ziel<paramref name="array" />s umgewandelt werden.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Array" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length">Die Größe des zu erstellenden <see cref="T:System.Array" />.</param>
        <summary>Erstellt ein eindimensionales <see cref="T:System.Array" /> der angegebenen Länge und vom angegebenen <see cref="T:System.Type" /> mit nullbasierter Indizierung.</summary>
        <returns>Ein neues eindimensionales <see cref="T:System.Array" /> der angegebenen Länge und vom angegebenen <see cref="T:System.Type" /> mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen <xref:System.Array> bietet die <xref:System.Array.CreateInstance%2A> anstelle eines öffentlichen Konstruktoren zu verwenden, um Zugriff mit spätem zu ermöglichen.  
  
 Verweistyp-Elemente werden initialisiert, um `null`. Werttypen werden mit 0 (null) initialisiert.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie erstellt und initialisiert ein eindimensionales <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  
  
- oder - 
 <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="lengths">Ein Array von 32-Bit-Ganzzahlen, das die Größe der einzelnen Dimensionen des zu erstellenden <see cref="T:System.Array" /> darstellt.</param>
        <summary>Erstellt ein mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung. Die Längen der Dimension werden in einem Array von 32-Bit-Ganzzahlen angegeben.</summary>
        <returns>Ein neues mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen <xref:System.Array> bietet die <xref:System.Array.CreateInstance%2A> anstelle eines öffentlichen Konstruktoren zu verwenden, um Zugriff mit spätem zu ermöglichen.  
  
 Die Anzahl der Elemente in der `lengths` Array muss die Anzahl der Dimensionen entsprechen, in der neuen <xref:System.Array>. Jedes Element der `lengths` Array muss die Länge der entsprechenden Dimension angeben, in der neuen <xref:System.Array>.  
  
 Verweistyp-Elemente werden initialisiert, um `null`. Werttypen werden mit 0 (null) initialisiert.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist das Produkt aller Werte in `lengths`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen und initialisieren Sie ein mehrdimensionales <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="lengths" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.  
  
- oder - 
Das <paramref name="lengths" />-Array enthält weniger als ein Element.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  
  
- oder - 
 <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Irgendein Wert in <paramref name="lengths" /> ist kleiner als 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int64[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lengths" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="lengths">Ein Array von 64-Bit-Ganzzahlen, das die Größe der einzelnen Dimensionen des zu erstellenden <see cref="T:System.Array" /> darstellt. Jede Ganzzahl im Array muss zwischen 0 (null) und <see cref="F:System.Int32.MaxValue" /> (einschließlich) liegen.</param>
        <summary>Erstellt ein mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung. Die Längen der Dimension werden in einem Array von 64-Bit-Ganzzahlen angegeben.</summary>
        <returns>Ein neues mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen <xref:System.Array> bietet die <xref:System.Array.CreateInstance%2A> anstelle eines öffentlichen Konstruktoren zu verwenden, um Zugriff mit spätem zu ermöglichen.  
  
 Die Anzahl der Elemente in der `lengths` Array muss die Anzahl der Dimensionen entsprechen, in der neuen <xref:System.Array>. Jedes Element der `lengths` Array muss die Länge der entsprechenden Dimension angeben, in der neuen <xref:System.Array>.  
  
 Verweistyp-Elemente werden initialisiert, um `null`. Werttypen werden mit 0 (null) initialisiert.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist das Produkt aller Werte in `lengths`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen und initialisieren Sie ein mehrdimensionales <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="lengths" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.  
  
- oder - 
Das <paramref name="lengths" />-Array enthält weniger als ein Element.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  
  
- oder - 
 <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Jeder Wert in <paramref name="lengths" /> ist kleiner als 0 (null) oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length1">Die Größe der ersten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length2">Die Größe der zweiten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <summary>Erstellt ein zweidimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</summary>
        <returns>Ein neues zweidimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen <xref:System.Array> bietet die <xref:System.Array.CreateInstance%2A> anstelle eines öffentlichen Konstruktoren zu verwenden, um Zugriff mit spätem zu ermöglichen.  
  
 Verweistyp-Elemente werden initialisiert, um `null`. Werttypen werden mit 0 (null) initialisiert.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist das Produkt der `length1` und `length2`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen und initialisieren Sie ein zweidimensionales <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  
  
- oder - 
 <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length1" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="length2" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths, lowerBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="lengths">Ein eindimensionales Array mit den Größen aller Dimensionen des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="lowerBounds">Ein eindimensionales Array mit der unteren Grenze (Startindex) für jede Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <summary>Erstellt ein mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und Untergrenze.</summary>
        <returns>Ein neues mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und Untergrenze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen <xref:System.Array> bietet die <xref:System.Array.CreateInstance%2A> anstelle eines öffentlichen Konstruktoren zu verwenden, um Zugriff mit spätem zu ermöglichen.  
  
 Die `lengths` und `lowerBounds` Arrays müssen die gleiche Anzahl von Elementen aufweisen. Die Anzahl der Elemente in der `lengths` Array muss die Anzahl der Dimensionen entsprechen, in der neuen <xref:System.Array>.  
  
 Jedes Element der `lengths` Array muss die Länge der entsprechenden Dimension angeben, in der neuen <xref:System.Array>.  
  
 Jedes Element der `lowerBounds` Array muss die untere Grenze der entsprechenden Dimension angeben, in der neuen <xref:System.Array>. Der .NET Framework-Klassenbibliothek und viele Programmiersprachen unterstützen im Allgemeinen nicht von ungleich NULL unteren Grenzen.  
  
 Verweistyp-Elemente werden initialisiert, um `null`. Werttypen werden mit 0 (null) initialisiert.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist das Produkt aller Werte in `lengths`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen und initialisieren Sie ein mehrdimensionales <xref:System.Array> mit der angegebenen Untergrenze.  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="lengths" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="lowerBounds" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.  
  
- oder - 
Das <paramref name="lengths" />-Array enthält kein Element.  
  
- oder - 
Das <paramref name="lengths" />- und das <paramref name="lowerBounds" />-Array enthalten nicht dieselbe Anzahl von Elementen.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  
  
- oder - 
 <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Irgendein Wert in <paramref name="lengths" /> ist kleiner als 0 (null).  
  
- oder - 
Irgendein Wert in <paramref name="lowerBounds" /> ist sehr groß, so dass die Summe aus Untergrenze und Länge einer Dimension größer ist als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2, length3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length1">Die Größe der ersten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length2">Die Größe der zweiten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length3">Die Größe der dritten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <summary>Erstellt ein dreidimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</summary>
        <returns>Ein neues dreidimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen <xref:System.Array> bietet die <xref:System.Array.CreateInstance%2A> anstelle eines öffentlichen Konstruktoren zu verwenden, um Zugriff mit spätem zu ermöglichen.  
  
 Verweistyp-Elemente werden initialisiert, um `null`. Werttypen werden mit 0 (null) initialisiert.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist das Produkt der `length1`, `length2`, und `length3`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen und initialisieren Sie ein dreidimensionales <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  
  
- oder - 
 <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length1" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="length2" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="length3" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; 'T[]" Usage="System.Array.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <summary>Gibt ein leeres Array zurück.</summary>
        <returns>Ein leeres Array.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Exists : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.Exists (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für die Elemente definiert, nach denen gesucht werden soll.</param>
        <summary>Bestimmt, ob das angegebene Array Elemente enthält, die mit den vom angegebenen Prädikat definierten Bedingungen übereinstimmen.</summary>
        <returns><see langword="true" />, wenn <paramref name="array" /> ein oder mehr Elemente enthält, die die durch das angegebene Prädikat definierten Bedingungen erfüllen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente der `array` werden einzeln an übergeben die <xref:System.Predicate%601>, und die Verarbeitung wird beendet, wenn eine Übereinstimmung gefunden wird.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die <xref:System.Predicate%601> explizit zu delegieren. Diese Sprachen den richtigen Delegaten aus dem Kontext ableiten und erstellen ihn automatisch.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Match-Bedingungen für die <xref:System.Array.Exists%2A> Methode mithilfe der Lambda-Ausdrücke überprüft, ob eine weltweit mit einem bestimmten Buchstaben beginnt, oder gibt an, ob der Welt auf dem angegebenen Array gefunden wird.  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 Im folgenden Beispiel wird die <xref:System.Array.Exists%2A> Methode, um anzugeben, ob alle Namen in ein Zeichenfolgenarray mit dem angegebenen Zeichen beginnen. Das Beispiel instanziiert ein `StringSearcher` Objekt, indem Sie die Zeichenfolge zu suchende an seinen Klassenkonstruktor übergeben. Die `StringSearcher.StartsWith` Methode hat die gleiche Signatur wie der <xref:System.Predicate%601> delegieren. Wenn die <xref:System.Array.Exists%2A> -Methode aufgerufen wird, die jedes Element des Arrays an den Delegaten übergeben wird, bis zurückgegeben `true` oder alle Elemente im Array durchläuft.  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 Sie können auch einen Lambda-Ausdruck verwenden, anstatt explizit eine Methode, deren Signatur entspricht, der den Delegaten definieren. Im folgenden Beispiel ersetzt die `StringSearcher` Klasse und die zugehörige `StartsWith` -Methode mit einem Lambda-Ausdruck.  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
        <related type="Article" href="~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md">Lambda-Ausdrücke (C#-Programmierhandbuch)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md">Lambdaausdrücke (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T -&gt; unit" Usage="System.Array.Fill (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T * int * int -&gt; unit" Usage="System.Array.Fill (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Find : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.Find (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte Array.</param>
        <param name="match">Das Prädikat, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt das erste Vorkommen im gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Das erste Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, sofern vorhanden, andernfalls der Standardwert für den Typ <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode oder einen Lambda-Ausdruck, der zurückgibt `true` , wenn das Objekt zu übergeben sie die Bedingungen definiert, die im Delegaten oder Lambda-Ausdruck übereinstimmt.  Die Elemente der `array` werden einzeln an übergeben die <xref:System.Predicate%601>, beginnend mit dem ersten Element und endend mit dem letzten Element.  Die Verarbeitung wird beendet, wenn eine Übereinstimmung gefunden wird.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Predicate%601> mit Delegieren der <xref:System.Array.Find%2A> eine generische Methode zum Durchsuchen eines Arrays von <xref:System.Drawing.Point> Strukturen. Die Methode, die dieser Delegat darstellt, `ProductGT10`, gibt `true` ist das Produkt aus den X- und Y-Feldern größer als 100.000. Die <xref:System.Array.Find%2A> Methode ruft den Delegaten für jedes Element des Arrays zurückgeben des ersten Punkts, der die testbedingung erfüllt.  
  
> [!NOTE]
>  Visual Basic und C#-Benutzer keine explizit den Delegaten zu erstellen, oder geben Sie das Typargument der generischen Methode. Der Compiler bestimmen Sie die erforderlichen Typen aus den Argumenten, die Sie angeben.  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 Anstatt explizit definiert eine Methode mit der Signatur, Instanziieren einer <xref:System.Predicate%601> delegieren und die Übergabe der Delegat, der die <xref:System.Array.Find%2A> -Methode, es ist üblich, einen Lambdaausdruck verwenden. Im folgende Beispiel ist identisch mit dem vorherigen Beispiel, außer dass er einen Lambda-Ausdruck als verwendet die `match` Argument.  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindAll : 'T[] * Predicate&lt;'T&gt; -&gt; 'T[]" Usage="System.Array.FindAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für die Elemente definiert, nach denen gesucht werden soll.</param>
        <summary>Ruft alle Elemente ab, die die vom angegebenen Prädikat definierten Bedingungen erfüllen.</summary>
        <returns>Ein <see cref="T:System.Array" /> mit allen Elementen, die die durch das angegebene Prädikat angegebenen Bedingungen erfüllen, sofern gefunden, andernfalls ein leeres <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente der `array` werden einzeln an übergeben die <xref:System.Predicate%601>, und die Elemente, die die Bedingungen im zurückgegebenen Array gespeichert.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein Array von 50 zufälligen Zahlen mit Werten, die zwischen 0 und 1.000 liegen können. Es ruft dann die <xref:System.Array.FindAll%2A> Methode mit einem Lambdaausdruck, die die Werte dieses Bereichs von 300 bis 600 zurückgibt. Beachten Sie, dass der Lambda-Ausdruck mit dem Namen Parameter übergeben wird `x`;  Dies stellt den einzelnen Arraymember, die an die <xref:System.Predicate%601>. Beachten Sie, dass die lokale `lBound` und `uBound` Variablen innerhalb des Lambda-Ausdrucks kann zugegriffen werden.  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, und <xref:System.Array.FindAll%2A> generische Methoden. Ein Array von Zeichenfolgen wird mit 8 Godzilla-Namen, von denen zwei (an Position 1 und 5) "saurus" enden, erstellt. Im Codebeispiel wird definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, die einen Zeichenfolgenparameter akzeptiert und gibt einen booleschen Wert, der angibt, ob die Eingabezeichenfolge in "Saurus" endet.  
  
 Die <xref:System.Array.Find%2A> generische Methode durchläuft das Array von Anfang an und übergibt an jedes Element der `EndsWithSaurus` Methode. Die Suche beendet, wenn die `EndsWithSaurus` Methodenrückgabe `true` für das Element "Amargasaurus".  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen den richtigen Delegaten aus dem Kontext ableiten und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindLast%2A> generische Methode wird verwendet, um das Array, das vom Ende aus rückwärts zu suchen. Es sucht nach dem Element "Dilophosaurus" an Position 5. Die <xref:System.Array.FindAll%2A> generische Methode wird verwendet, um ein Array mit allen Elementen, die für die Enden auf "Saurus" zurückgeben. Die Elemente werden angezeigt.  
  
 Im Codebeispiel wird veranschaulicht, die auch die <xref:System.Array.Exists%2A> und <xref:System.Array.TrueForAll%2A> generische Methoden.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat angegebenen Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens in einem <see cref="T:System.Array" /> oder einem Teil daraus zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens im gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> vorwärts beginnend ab dem ersten Element und endet mit dem letzten Element gesucht wird.  
  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente der `array` werden einzeln an übergeben die <xref:System.Predicate%601>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, alle drei Überladungen, der die <xref:System.Array.FindIndex%2A> generische Methode. Ein Array von Zeichenfolgen wird mit 8 Godzilla-Namen, von denen zwei (an Position 1 und 5) "saurus" enden, erstellt. Im Codebeispiel wird definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, die einen Zeichenfolgenparameter akzeptiert und gibt einen booleschen Wert, der angibt, ob die Eingabezeichenfolge in "Saurus" endet.  
  
 Die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> -methodenüberladung, durchläuft das Array von Anfang an und übergibt an jedes Element der `EndsWithSaurus` Methode. Die Suche beendet, wenn die `EndsWithSaurus` Methodenrückgabe `true` für das Element an Position 1.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen den richtigen Delegaten aus dem Kontext ableiten und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Überladung wird verwendet, um das Array, beginnend an Position 2, und Sie den Vorgang fortsetzen, bis zum Ende des Arrays zu suchen. Das Element an Position 5 findet. Zum Schluss die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Überladung wird verwendet, um das Durchsuchen des Bereichs von drei Elementen, beginnend an Position 2. Es gibt-1 zurück, da keine Godzilla Namen in diesem Bereich aus, die mit "Saurus" vorhanden sind.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Suche.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der vom angegebenen Index bis zum letzten Element reicht.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> Rollforward ab durchsucht `startIndex` beginnt und mit dem letzten Element.  
  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente der `array` werden einzeln an übergeben die <xref:System.Predicate%601>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die Anzahl von Elementen aus `startIndex` bis zum Ende des `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, alle drei Überladungen, der die <xref:System.Array.FindIndex%2A> generische Methode. Ein Array von Zeichenfolgen wird mit 8 Godzilla-Namen, von denen zwei (an Position 1 und 5) "saurus" enden, erstellt. Im Codebeispiel wird definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, die einen Zeichenfolgenparameter akzeptiert und gibt einen booleschen Wert, der angibt, ob die Eingabezeichenfolge in "Saurus" endet.  
  
 Die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> -methodenüberladung, durchläuft das Array von Anfang an und übergibt an jedes Element der `EndsWithSaurus` Methode. Die Suche beendet, wenn die `EndsWithSaurus` Methodenrückgabe `true` für das Element an Position 1.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen den richtigen Delegaten aus dem Kontext ableiten und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Überladung wird verwendet, um das Array, beginnend an Position 2, und Sie den Vorgang fortsetzen, bis zum Ende des Arrays zu suchen. Das Element an Position 5 findet. Zum Schluss die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Überladung wird verwendet, um das Durchsuchen des Bereichs von drei Elementen, beginnend an Position 2. Es gibt-1 zurück, da keine Godzilla Namen in diesem Bereich aus, die mit "Saurus" vorhanden sind.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Suche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der am angegebenen Index beginnt und die angegebene Anzahl von Elementen umfasst.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> Rollforward ab durchsucht `startIndex` und endet um `startIndex` plus `count` minus 1, wenn `count` ist größer als 0.  
  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente der `array` werden einzeln an übergeben die <xref:System.Predicate%601>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist `count`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, alle drei Überladungen, der die <xref:System.Array.FindIndex%2A> generische Methode. Ein Array von Zeichenfolgen wird mit 8 Godzilla-Namen, von denen zwei (an Position 1 und 5) "saurus" enden, erstellt. Im Codebeispiel wird definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, die einen Zeichenfolgenparameter akzeptiert und gibt einen booleschen Wert, der angibt, ob die Eingabezeichenfolge in "Saurus" endet.  
  
 Die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> -methodenüberladung, durchläuft das Array von Anfang an und übergibt an jedes Element der `EndsWithSaurus` Methode. Die Suche beendet, wenn die `EndsWithSaurus` Methodenrückgabe `true` für das Element an Position 1.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen den richtigen Delegaten aus dem Kontext ableiten und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Überladung wird verwendet, um das Array, beginnend an Position 2, und Sie den Vorgang fortsetzen, bis zum Ende des Arrays zu suchen. Das Element an Position 5 findet. Zum Schluss die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Überladung wird verwendet, um das Durchsuchen des Bereichs von drei Elementen, beginnend an Position 2. Es gibt-1 zurück, da keine Godzilla Namen in diesem Bereich aus, die mit "Saurus" vorhanden sind.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt im <paramref name="array" /> an.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLast : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.FindLast (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt das letzte Vorkommen im gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Das letzte Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, sofern vorhanden, andernfalls der Standardwert für den Typ <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente der `array` werden einzeln an übergeben die <xref:System.Predicate%601>aufgelistet, die Abwärtskompatibilität in der <xref:System.Array>, mit dem letzten Element beginnend und endend mit dem ersten Element.  Die Verarbeitung wird beendet, wenn eine Übereinstimmung gefunden wird.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, und <xref:System.Array.FindAll%2A> generische Methoden. Ein Array von Zeichenfolgen wird mit 8 Godzilla-Namen, von denen zwei (an Position 1 und 5) "saurus" enden, erstellt. Im Codebeispiel wird definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, die einen Zeichenfolgenparameter akzeptiert und gibt einen booleschen Wert, der angibt, ob die Eingabezeichenfolge in "Saurus" endet.  
  
 Die <xref:System.Array.Find%2A> generische Methode durchläuft das Array von Anfang an und übergibt an jedes Element der `EndsWithSaurus` Methode. Die Suche beendet, wenn die `EndsWithSaurus` Methodenrückgabe `true` für das Element "Amargasaurus".  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die`Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen den richtigen Delegaten aus dem Kontext ableiten und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindLast%2A> generische Methode wird verwendet, um das Array, das vom Ende aus rückwärts zu suchen. Es sucht nach dem Element "Dilophosaurus" an Position 5. Die <xref:System.Array.FindAll%2A> generische Methode wird verwendet, um ein Array mit allen Elementen, die für die Enden auf "Saurus" zurückgeben. Die Elemente werden angezeigt.  
  
 Im Codebeispiel wird veranschaulicht, die auch die <xref:System.Array.Exists%2A> und <xref:System.Array.TrueForAll%2A> generische Methoden.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat angegebenen Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens in einem <see cref="T:System.Array" /> oder einem Teil daraus zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens im gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> rückwärts beginnend ab dem letzten Element und endend mit dem ersten Element gesucht wird.  
  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente der `array` werden einzeln an übergeben die <xref:System.Predicate%601>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, alle drei Überladungen, der die <xref:System.Array.FindLastIndex%2A> generische Methode. Ein Array von Zeichenfolgen wird mit 8 Godzilla-Namen, von denen zwei (an Position 1 und 5) "saurus" enden, erstellt. Im Codebeispiel wird definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, die einen Zeichenfolgenparameter akzeptiert und gibt einen booleschen Wert, der angibt, ob die Eingabezeichenfolge in "Saurus" endet.  
  
 Die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> -methodenüberladung, durchläuft das Array, die Abwärtskompatibilität von Ende, übergibt an jedes Element der `EndsWithSaurus` Methode. Die Suche beendet, wenn die `EndsWithSaurus` Methodenrückgabe `true` für das Element an Position 5.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen den richtigen Delegaten aus dem Kontext ableiten und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Überladung wird verwendet, um das Array, beginnend an Position 4 und Fortfahren zurück an den Anfang des Arrays zu suchen. Findet das Element an Position 1. Zum Schluss die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung wird verwendet, um das Durchsuchen des Bereichs von drei Elementen beginnend an Position 4 und rückwärts (d. h. Elemente, 4, 3 und 2). Es gibt-1 zurück, da keine Godzilla Namen in diesem Bereich aus, die mit "Saurus" vorhanden sind.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der vom ersten Element bis zum angegeben Index reicht.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> wird rückwärts gesuchten beginnt am `startIndex` bis auf das erste Element.  
  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente der `array` werden einzeln an übergeben die <xref:System.Predicate%601>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die Anzahl der Elemente vom Anfang des `array` zu `startIndex`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, alle drei Überladungen, der die <xref:System.Array.FindLastIndex%2A> generische Methode. Ein Array von Zeichenfolgen wird mit 8 Godzilla-Namen, von denen zwei (an Position 1 und 5) "saurus" enden, erstellt. Im Codebeispiel wird definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, die einen Zeichenfolgenparameter akzeptiert und gibt einen booleschen Wert, der angibt, ob die Eingabezeichenfolge in "Saurus" endet.  
  
 Die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> -methodenüberladung, durchläuft das Array, die Abwärtskompatibilität von Ende, übergibt an jedes Element der `EndsWithSaurus` Methode. Die Suche beendet, wenn die `EndsWithSaurus` Methodenrückgabe `true` für das Element an Position 5.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen den richtigen Delegaten aus dem Kontext ableiten und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Überladung wird verwendet, um das Array, beginnend an Position 4 und Fortfahren zurück an den Anfang des Arrays zu suchen. Findet das Element an Position 1. Zum Schluss die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung wird verwendet, um das Durchsuchen des Bereichs von drei Elementen beginnend an Position 4 und rückwärts (d. h. Elemente, 4, 3 und 2). Es gibt-1 zurück, da keine Godzilla Namen in diesem Bereich aus, die mit "Saurus" vorhanden sind.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der die angegebene Anzahl von Elementen umfasst und am angegebenen Index endet.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> wird rückwärts gesuchten beginnt am `startIndex` und endet um `startIndex` minus `count` plus 1, wenn `count` ist größer als 0.  
  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt `true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente der `array` werden einzeln an übergeben die <xref:System.Predicate%601>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist `count`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, alle drei Überladungen, der die <xref:System.Array.FindLastIndex%2A> generische Methode. Ein Array von Zeichenfolgen wird mit 8 Godzilla-Namen, von denen zwei (an Position 1 und 5) "saurus" enden, erstellt. Im Codebeispiel wird definiert auch eine Prädikat Search-Methode, die mit dem Namen `EndsWithSaurus`, die einen Zeichenfolgenparameter akzeptiert und gibt einen booleschen Wert, der angibt, ob die Eingabezeichenfolge in "Saurus" endet.  
  
 Die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> -methodenüberladung, durchläuft das Array, die Abwärtskompatibilität von Ende, übergibt an jedes Element der `EndsWithSaurus` Methode. Die Suche beendet, wenn die `EndsWithSaurus` Methodenrückgabe `true` für das Element an Position 5.  
  
> [!NOTE]
>  In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen den richtigen Delegaten aus dem Kontext ableiten und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> Überladung wird verwendet, um das Array, beginnend an Position 4 und Fortfahren zurück an den Anfang des Arrays zu suchen. Findet das Element an Position 1. Zum Schluss die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> methodenüberladung wird verwendet, um das Durchsuchen des Bereichs von drei Elementen beginnend an Position 4 und rückwärts (d. h. Elemente, 4, 3 und 2). Es gibt-1 zurück, da keine Godzilla Namen in diesem Bereich aus, die mit "Saurus" vorhanden sind.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt im <paramref name="array" /> an.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForEach : 'T[] * Action&lt;'T&gt; -&gt; unit" Usage="System.Array.ForEach (array, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das eindimensionale nullbasierte <see cref="T:System.Array" />, für dessen Elemente die Aktion ausgeführt werden soll.</param>
        <param name="action">Die <see cref="T:System.Action`1" />, die für jedes Element von <paramref name="array" /> ausgeführt werden soll.</param>
        <summary>Führt die angegebene Aktion für jedes Element des angegebenen Arrays aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Action%601> ein Delegaten an eine Methode, die eine Aktion, für das Objekt ausführt übergeben wird.  Die Elemente der `array` werden einzeln an übergeben die <xref:System.Action%601>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit <xref:System.Array.ForEach%2A> Quadrate der jedes Element in einem ganzzahligen Array angezeigt.  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="action" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="array.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.Collections.IEnumerator" /> für das <see cref="T:System.Array" /> zurück.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" /> für das <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 Die `foreach` -Anweisung der c#-Sprache (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist <xref:System.Collections.IEnumerator.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.IEnumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.IEnumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung. Daher ist die Enumeration einer Auflistung systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit <xref:System.Array.GetEnumerator%2A> zum Auflisten der Elemente eines Arrays.  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLength : int -&gt; int" Usage="array.GetLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Eine nullbasierte Dimension des <see cref="T:System.Array" />, deren Länge bestimmt werden soll.</param>
        <summary>Ruft eine 32-Bit-Ganzzahl ab, die die Anzahl der Elemente in der angegebenen Dimension des <see cref="T:System.Array" /> angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl, die die Anzahl der Elemente in der angegebenen Dimension angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Beispiel für <xref:System.Array.GetLength%2A> ist `GetLength(0)`, womit die Anzahl der Elemente in der ersten Dimension des der <xref:System.Array>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit <xref:System.Array.GetLength%2A> um die Dimensionen von zwei Arrays mit unterschiedlichem Rang anzuzeigen.  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="dimension" /> ist größer oder gleich <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLongLength : int -&gt; int64" Usage="array.GetLongLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="dimension">Eine nullbasierte Dimension des <see cref="T:System.Array" />, deren Länge bestimmt werden soll.</param>
        <summary>Ruft eine 64-Bit-Ganzzahl ab, die die Anzahl der Elemente in der angegebenen Dimension des <see cref="T:System.Array" /> angibt.</summary>
        <returns>Eine 64-Bit-Ganzzahl, die die Anzahl der Elemente in der angegebenen Dimension angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Beispiel für <xref:System.Array.GetLongLength%2A> ist `GetLongLength(0)`, womit die Anzahl der Elemente in der ersten Dimension des der <xref:System.Array>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="dimension" /> ist größer oder gleich <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLowerBound : int -&gt; int" Usage="array.GetLowerBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Eine nullbasierte Dimension des Arrays, dessen Startindex bestimmt werden soll.</param>
        <summary>Ruft den Index des ersten Elements der angegebenen Dimension im Array ab.</summary>
        <returns>Der Index des ersten Elements der angegebenen Dimension im Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)` den Startindex für die erste Dimension des Arrays zurückgibt und `GetLowerBound(Rank - 1)` gibt den Index ab, der letzten Dimension des Arrays zurück.  
  
 Die <xref:System.Array.GetLowerBound%2A> Methode gibt immer einen Wert, der den Index, der die untere Grenze des Arrays angibt zurück, auch wenn das Array leer ist.  
  
 Beachten Sie, dass, obwohl die meisten Arrays in .NET Framework nullbasiert sind (d. h. die <xref:System.Array.GetLowerBound%2A> Methode gibt 0 (null) für jede Dimension eines Arrays zurück), .NET Framework unterstützt Arrays, die nicht nullbasiert sind. Solche Arrays können erstellt werden, mit der <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> -Methode, und auch aus nicht verwaltetem Code zurückgegeben werden kann.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden, um die Grenzen eines zwei- und eindimensionale Arrays anzuzeigen und um die Werte der entsprechenden Arrayelemente anzuzeigen.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="dimension" /> ist größer oder gleich <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetUpperBound : int -&gt; int" Usage="array.GetUpperBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Eine nullbasierte Dimension des Array, dessen obere Grenze bestimmt werden soll.</param>
        <summary>Ruft den Index des letzten Elements der angegebenen Dimension im Array ab.</summary>
        <returns>Der Index des letzten Elements in der angegebenen Dimension im Array oder -1, wenn die angegebene Dimension leer ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)` Gibt den letzten Index in der ersten Dimension des Arrays zurück und `GetUpperBound(Rank - 1)` gibt den letzten Index der letzten Dimension des Arrays zurück.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden, um die Grenzen eines zwei- und eindimensionale Arrays anzuzeigen und um die Werte der entsprechenden Arrayelemente anzuzeigen.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="dimension" /> ist größer oder gleich <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Wert des angegebenen Elements im aktuellen <see cref="T:System.Array" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="index">Eine 32-Bit-Ganzzahl, die die Position des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des eindimensionalen <see cref="T:System.Array" /> ab. Der Index wird als 32-Bit-Ganzzahl angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des eindimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob der Wert des `index` typu je MIMO rozsah.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau eine Dimension.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Ein eindimensionales Array von 32-Bit-Ganzzahlen, das die Indizes darstellt, die die Position des abzurufenden <see cref="T:System.Array" />-Elements angeben.</param>
        <summary>Ruft den Wert an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als Array von 32-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Elemente in `indices` muss gleich der Anzahl der Dimensionen in der <xref:System.Array>. Alle Elemente in der `indices` Array muss zusammen die Position des gewünschten Elements angeben, in der mehrdimensionalen <xref:System.Array>.  
  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Dimensionen im aktuellen <see cref="T:System.Array" /> ist nicht gleich der Anzahl der Elemente von <paramref name="indices" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Ein Element von <paramref name="indices" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">Eine 64-Bit-Ganzzahl, die die Position des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des eindimensionalen <see cref="T:System.Array" /> ab. Der Index wird als 64-Bit-Ganzzahl angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des eindimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob der Wert des `index` typu je MIMO rozsah.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau eine Dimension.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Ein eindimensionales Array von 64-Bit-Ganzzahlen, das die Indizes darstellt, die die Position des abzurufenden <see cref="T:System.Array" />-Elements angeben.</param>
        <summary>Ruft den Wert an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als Array von 64-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Elemente in `indices` muss gleich der Anzahl der Dimensionen in der <xref:System.Array>. Alle Elemente in der `indices` Array muss zusammen die Position des gewünschten Elements angeben, in der mehrdimensionalen <xref:System.Array>.  
  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Dimensionen im aktuellen <see cref="T:System.Array" /> ist nicht gleich der Anzahl der Elemente von <paramref name="indices" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein Element von <paramref name="indices" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau zwei Dimensionen.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> oder <paramref name="index2" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau zwei Dimensionen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> oder <paramref name="index2" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int * int -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index3">Eine 32-Bit-Ganzzahl, die den Index für die dritte Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau drei Dimensionen.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" />, <paramref name="index2" /> oder <paramref name="index3" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index3">Eine 64-Bit-Ganzzahl, die den Index für die dritte Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau drei Dimensionen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" />, <paramref name="index2" /> oder <paramref name="index3" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht das angegebene Objekt und gibt den Index seines ersten Auftretens in einem eindimensionalen Array oder in einem Elementbereich im Array zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale Array.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des ersten Vorkommens in einem eindimensionalen Array zurück.</summary>
        <returns>Der Index des ersten Vorkommens von <paramref name="value" /> in <paramref name="array" />, sofern gefunden, andernfalls die untere Grenze des Arrays minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht alle Elemente eines eindimensionalen Arrays für `value`. Um zu bestimmen, ob `value` vorhanden ist, `array`, die Methode führt einen Gleichheitsvergleich durch Aufrufen eines jeden Elements `Equals` Methode, bis eine Übereinstimmung gefunden wird. Dies bedeutet, dass, wenn das Element überschreibt der <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Methode, die Außerkraftsetzung wird aufgerufen.  
  
 Da die meisten Arrays auf eine unteren Grenze von 0 (null) haben, diese Methode in der Regel-1 zurück, wenn`value` nicht gefunden. In dem seltenen Fall, das die untere Grenze des Arrays gleich <xref:System.Int32.MinValue?displayProperty=nameWithType>(0 x 80000000) und `value` nicht gefunden, Rückgabe dieser Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im Beispiel wird die folgenden drei Überladungen der <xref:System.Array.IndexOf%2A> Methode, um den Index einer Zeichenfolge in einem Zeichenfolgenarray zu ermitteln:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in einem Zeichenfolgenarray.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" im vierten auf die letzten Elemente eines Zeichenfolgenarrays.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in einer Zeichenfolge array aus dem Element, das die letzte erfolgreiche Übereinstimmung am Ende des Arrays folgt.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale Array.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der Startindex für die Suche. 0 (null) ist in einem leeren Array gültig.</param>
        <summary>Sucht das angegebene Objekt in einem Elementbereich eines eindimensionalen Arrays und gibt den Index seines ersten Auftretens zurück. Der Bereich erstreckt sich von einem angegebenen Index bis zum Ende des Arrays.</summary>
        <returns>Der Index des ersten Vorkommens von <paramref name="value" />, sofern gefunden, innerhalb des Bereichs von Elementen in <paramref name="array" />, der sich von <paramref name="startIndex" /> bis zum letzten Element erstreckt; andernfalls die untere Grenze des Arrays minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht ein eindimensionales Array aus dem Element am Index `startIndex` bis zum letzten Element. Um zu bestimmen, ob `value` vorhanden ist, `array`, die Methode führt einen Gleichheitsvergleich durch Aufrufen der `Equals` Methode jedes Elements, bis eine Übereinstimmung gefunden wird. Dies bedeutet, dass, wenn das Element überschreibt der <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Methode, die Außerkraftsetzung wird aufgerufen.  
  
 Da die meisten Arrays auf eine unteren Grenze von 0 (null) haben, diese Methode in der Regel-1 zurück, wenn `value` nicht gefunden. In dem seltenen Fall, das die untere Grenze des Arrays gleich <xref:System.Int32.MinValue?displayProperty=nameWithType>(0 x 80000000) und `value` nicht gefunden, Rückgabe dieser Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Wenn `startIndex` gleich <xref:System.Array.Length%2A?displayProperty=nameWithType>, die Methode gibt-1 zurück. Wenn `startIndex` ist größer als <xref:System.Array.Length%2A?displayProperty=nameWithType>, löst die Methode eine <xref:System.ArgumentOutOfRangeException>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die Anzahl von Elementen aus `startIndex` bis zum Ende des `array`.  
  
   
  
## Examples  
 Im Beispiel wird die folgenden drei Überladungen der <xref:System.Array.IndexOf%2A> Methode, um den Index einer Zeichenfolge in einem Zeichenfolgenarray zu ermitteln:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in einem Zeichenfolgenarray.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" im vierten auf die letzten Elemente eines Zeichenfolgenarrays.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in einer Zeichenfolge array aus dem Element, das die letzte erfolgreiche Übereinstimmung am Ende des Arrays folgt.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale Array.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der Startindex für die Suche. 0 (null) ist in einem leeren Array gültig.</param>
        <param name="count">Die Anzahl der zu suchenden Elemente.</param>
        <summary>Sucht das angegebene Objekt in einem Bereich von Elementen eines eindimensionalen Arrays und gibt den Index des ersten Vorkommens zurück. Der Bereich erstreckt sich von einem angegebenen Index für eine angegebene Anzahl von Elementen.</summary>
        <returns>Der Index des ersten Vorkommens von <paramref name="value" />, sofern gefunden im <paramref name="array" /> vom <paramref name="startIndex" />-Index bis <paramref name="startIndex" /> + <paramref name="count" /> – 1; andernfalls die untere Grenze des Arrays minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht die Elemente eines eindimensionalen Arrays von `startIndex` zu `startIndex` plus `count` minus 1, wenn `count` ist größer als 0. Um zu bestimmen, ob `value` vorhanden ist, `array`, die Methode führt einen Gleichheitsvergleich durch Aufrufen der `Equals` Methode jedes Elements, bis eine Übereinstimmung gefunden wird. Dies bedeutet, dass, wenn das Element überschreibt der <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode, die Außerkraftsetzung wird aufgerufen.  
  
 Da die meisten Arrays auf eine unteren Grenze von 0 (null) haben, gibt diese Methode in der Regel 1, wenn `value` nicht gefunden. In dem seltenen Fall, das die untere Grenze des Arrays gleich <xref:System.Int32.MinValue?displayProperty=nameWithType> (0 x 80000000) und `value` nicht gefunden, Rückgabe dieser Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Wenn `startindex` gleich <xref:System.Array.Length%2A?displayProperty=nameWithType>, die Methode gibt-1 zurück. Wenn `startIndex` ist größer als <xref:System.Array.Length%2A?displayProperty=nameWithType>, löst die Methode eine <xref:System.ArgumentOutOfRangeException>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist `count`.  
  
   
  
## Examples  
 Im Beispiel wird die folgenden drei Überladungen der <xref:System.Array.IndexOf%2A> Methode, um den Index einer Zeichenfolge in einem Zeichenfolgenarray zu ermitteln:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in einem Zeichenfolgenarray.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" im vierten auf die letzten Elemente eines Zeichenfolgenarrays.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in einer Zeichenfolge array aus dem Element, das die letzte erfolgreiche Übereinstimmung am Ende des Arrays folgt. Zum Bestimmen des Werts von der `count` -Argument, es subtrahiert die obere Grenze des Arrays aus den startIndex und hinzugefügt.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in <paramref name="array" /> an.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte Array.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des ersten Vorkommens in einem eindimensionalen Array zurück.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="value" /> im gesamten <paramref name="array" />, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht alle Elemente eines eindimensionalen Arrays für `value`. Um zu bestimmen, ob `value` vorhanden ist, im `array`, die Methode führt einen Gleichheitsvergleich durch Aufrufen der `T.Equals` Methode für jedes Element. Dies bedeutet, dass bei `T` überschreibt die <xref:System.Object.Equals%2A> Methode, die Außerkraftsetzung wird aufgerufen.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei generische Überladungen, der die <xref:System.Array.IndexOf%2A> Methode. Ein Array von Zeichenfolgen wird mit einem Eintrag erstellt, die an der Indexposition 0 und Indexposition 5 zweimal angezeigt wird. Die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> -methodenüberladung, durchsucht das Array ab und sucht das erste Vorkommen der Zeichenfolge. Die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Überladung wird verwendet, um das Array, beginnend mit der Indexposition 3 und an das Ende des Arrays zu suchen und das zweite Vorkommen der Zeichenfolge sucht. Zum Schluss die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um einen Bereich von zwei Einträge, beginnend an der Indexposition zwei suchen; es gibt-1 zurück, da keine Instanzen der Suchzeichenfolge in diesem Bereich vorhanden sind.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte Array.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Suche. 0 (null) ist in einem leeren Array gültig.</param>
        <summary>Sucht das angegebene Objekt in einem Bereich von Elementen eines eindimensionalen Arrays und gibt den Index des ersten Vorkommens zurück. Der Bereich erstreckt sich von einem angegebenen Index bis zum Ende des Arrays.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen in <paramref name="array" />, der sich von <paramref name="startIndex" /> bis zum letzten Element erstreckt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht ein eindimensionales Array aus dem Element am `startIndex` bis zum Ende des Arrays. Um zu bestimmen, ob `value` vorhanden ist, im `array`, die Methode führt einen Gleichheitsvergleich durch Aufrufen der `T.Equals` Methode für jedes Element. Dies bedeutet, dass bei `T` überschreibt die <xref:System.Object.Equals%2A> Methode, die Außerkraftsetzung wird aufgerufen.  
  
 Wenn `startIndex` gleich <xref:System.Array.Length%2A>, gibt die Methode zurück – 1.If `startIndex` ist größer als <xref:System.Array.Length%2A?displayProperty=nameWithType>, löst die Methode eine <xref:System.ArgumentOutOfRangeException>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die Anzahl von Elementen aus `startIndex` bis zum Ende des `array`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei generische Überladungen, der die <xref:System.Array.IndexOf%2A> Methode. Ein Array von Zeichenfolgen wird mit einem Eintrag erstellt, die an der Indexposition 0 und Indexposition 5 zweimal angezeigt wird. Die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> -methodenüberladung, durchsucht das Array ab und sucht das erste Vorkommen der Zeichenfolge. Die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Überladung wird verwendet, um das Array, beginnend mit der Indexposition 3 und an das Ende des Arrays zu suchen und das zweite Vorkommen der Zeichenfolge sucht. Zum Schluss die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um einen Bereich von zwei Einträge, beginnend an der Indexposition zwei suchen; es gibt-1 zurück, da keine Instanzen der Suchzeichenfolge in diesem Bereich vorhanden sind.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte Array.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Suche. 0 (null) ist in einem leeren Array gültig.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht das angegebene Objekt in einem Elementbereich eines eindimensionalen Arrays und gibt den Index seines ersten Auftretens zurück. Der Bereich erstreckt sich von einem angegebenen Index für eine angegebene Anzahl von Elementen.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen im <paramref name="array" />, das beim <paramref name="startIndex" /> beginnt und die in <paramref name="count" /> angegebene Anzahl von Elementen enthält, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sucht die Elemente eines eindimensionalen Arrays von `startIndex` zu `startIndex` plus `count` minus 1, wenn `count` ist größer als 0. Um zu bestimmen, ob `value` vorhanden ist, im `array`, die Methode führt einen Gleichheitsvergleich durch Aufrufen der `T.Equals` Methode für jedes Element. Dies bedeutet, dass bei `T` überschreibt die <xref:System.Object.Equals%2A> Methode, die Außerkraftsetzung wird aufgerufen.  
  
 Wenn `startIndex` gleich <xref:System.Array.Length%2A?displayProperty=nameWithType>, die Methode gibt-1 zurück.  Wenn `startIndex` ist größer als <xref:System.Array.Length%2A?displayProperty=nameWithType>, löst die Methode eine <xref:System.ArgumentOutOfRangeException>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist `count`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt alle drei generische Überladungen, der die <xref:System.Array.IndexOf%2A> Methode. Ein Array von Zeichenfolgen wird mit einem Eintrag erstellt, die an der Indexposition 0 und Indexposition 5 zweimal angezeigt wird. Die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> -methodenüberladung, durchsucht das Array ab und sucht das erste Vorkommen der Zeichenfolge. Die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Überladung wird verwendet, um das Array, beginnend mit der Indexposition 3 und an das Ende des Arrays zu suchen und das zweite Vorkommen der Zeichenfolge sucht. Zum Schluss die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um einen Bereich von zwei Einträge, beginnend an der Indexposition zwei suchen; es gibt-1 zurück, da keine Instanzen der Suchzeichenfolge in diesem Bereich vorhanden sind.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt im <paramref name="array" /> an.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberSignature Language="F#" Value="member this.Initialize : unit -&gt; unit" Usage="array.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialisiert jedes Element des Werttyp-<see cref="T:System.Array" /> durch einen Aufruf des Standardkonstruktors für den Werttyp.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode soll Compiler Werttypen unterstützen helfen; Die meisten Benutzer ist diese Methode nicht erforderlich. Es muss nicht auf Verweistyp-Arrays verwendet werden.  
  
 Wenn die <xref:System.Array> ist es sich nicht um ein Werttyp <xref:System.Array> oder wenn der Werttyp keinen Standardkonstruktor der <xref:System.Array> wird nicht geändert.  
  
 Der Werttyp <xref:System.Array> untere Grenze und eine beliebige Anzahl von Dimensionen aufweisen.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Array.Length%2A>.  
  
> [!CAUTION]
>  Sie können diese Methode nur auf Werttypen, die über Konstruktoren verfügen; Allerdings sind Werttypen, die in c# sind keine Konstruktoren aufweisen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Array.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Array" /> eine feste Größe aufweist.</summary>
        <value>Diese Eigenschaft ist für alle Arrays immer <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementiert die <xref:System.Array.IsFixedSize%2A> Eigenschaft, da dies erforderlich ist der <xref:System.Collections.IList?displayProperty=nameWithType> Schnittstelle.  
  
 Ein Array mit fester Größe lässt das Hinzufügen oder Entfernen von Elementen nach dem das Array erstellt wird, die Änderung der vorhandenen Elemente ermöglicht jedoch nicht zu.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Array.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Array" /> schreibgeschützt ist.</summary>
        <value>Diese Eigenschaft ist für alle Arrays immer <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementiert die <xref:System.Array.IsReadOnly%2A> Eigenschaft, da dies erforderlich ist der <xref:System.Collections.IList?displayProperty=nameWithType> Schnittstelle. Ein Array, das ist schreibgeschützt und lässt das Hinzufügen, entfernen oder Ändern von Elementen nach der Erstellung des Arrays nicht zu.  
  
 Wenn Sie eine schreibgeschützte Auflistung benötigen, verwenden Sie eine <xref:System.Collections> Klasse, die implementiert die <xref:System.Collections.IList?displayProperty=nameWithType> Schnittstelle.  
  
 Wenn Sie umwandeln oder Konvertieren ein Array, das eine <xref:System.Collections.IList> Schnittstellenobjekt, das <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> -Eigenschaft gibt `false`. Jedoch wenn Sie umwandeln oder Konvertieren ein Array, das eine <xref:System.Collections.Generic.IList%601> -Schnittstelle, die `IsReadOnly` -Eigenschaft gibt `true`.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Array.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Array" /> synchronisiert (threadsicher) ist.</summary>
        <value>Diese Eigenschaft ist für alle Arrays immer <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementiert die <xref:System.Array.IsSynchronized%2A> Eigenschaft, da dies erforderlich ist der <xref:System.Collections.ICollection?displayProperty=nameWithType> Schnittstelle.  
  
 .NET Framework-Klassen basierend auf <xref:System.Array> Geben Sie ihre eigene synchronisierte Version der Auflistung mithilfe der <xref:System.Array.SyncRoot%2A> Eigenschaft.  
  
 Klassen, die Arrays verwenden können auch implementieren ihre eigenen Synchronisierung über die <xref:System.Array.SyncRoot%2A> Eigenschaft. Der Synchronisierungscode dürfen Vorgänge auf den `SyncRoot` der Auflistung, nicht direkt in der Auflistung. Dies gewährleistet die einwandfreie Funktion von Auflistungen, die von anderen Objekten abgeleitet sind. Insbesondere verwaltet er die ordnungsgemäße Synchronisierung mit anderen Threads, die gleichzeitig die Auflistung geändert werden kann. Beachten Sie, dass einige Implementierungen von <xref:System.Array.SyncRoot%2A> möglicherweise die <xref:System.Array> selbst.  
  
 Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein Array während der gesamten Enumeration sperren, mit der <xref:System.Array.SyncRoot%2A> Eigenschaft.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Index des letzten Vorkommens eines Werts in einem eindimensionalen <see cref="T:System.Array" /> oder in einem Teil des <see cref="T:System.Array" /> zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des gesamten eindimensionalen <see cref="T:System.Array" /> zurück.</summary>
        <returns>Der Index des letzten Vorkommens von <paramref name="value" /> im gesamten <paramref name="array" />, sofern gefunden, andernfalls die untere Grenze des Arrays - 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das eindimensionale <xref:System.Array> rückwärts beginnend ab dem letzten Element und endend mit dem ersten Element gesucht wird.  
  
 Die Elemente werden mit dem angegebenen Wert verglichen die <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode. Wenn der Elementtyp ein systeminterner (Benutzerdefiniert) Typ, ist die `Equals` Implementierung dieses Typs verwendet.  
  
 Da die meisten Arrays mit eine unteren Grenze von 0 (null) hat, würde diese Methode in der Regel 1, wenn zurückgeben `value` wurde nicht gefunden. In dem seltenen Fall, das die untere Grenze des Arrays gleich <xref:System.Int32.MinValue?displayProperty=nameWithType> und `value` nicht gefunden wird, gibt diese Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType>, d.h. `System.Int32.MinValue - 1`.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
 In .NET Framework, Version 2.0, diese Methode verwendet die <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> Methoden der <xref:System.Array> um zu bestimmen, ob die <xref:System.Object> gemäß der `value` Parameter vorhanden ist. Diese Entscheidung wurde in früheren Versionen von .NET Framework, mit der <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> Methoden der `value` <xref:System.Object> selbst.  
  
 <xref:System.IComparable.CompareTo%2A> Methoden der `item` Parameter für die Objekte in der Auflistung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die den Index des letzten Vorkommens eines angegebenen Elements in einem Array zu bestimmen.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der Startindex für die Rückwärtssuche.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im eindimensionalen <see cref="T:System.Array" /> zurück, der sich vom ersten Element bis zum angegebenen Index erstreckt.</summary>
        <returns>Der Index des letzten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen in <paramref name="array" />, der sich vom ersten Element bis zu <paramref name="startIndex" /> erstreckt, sofern gefunden, andernfalls die untere Grenze des Arrays - 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das eindimensionale <xref:System.Array> wird rückwärts gesuchten beginnt am `startIndex` bis auf das erste Element.  
  
 Die Elemente werden mit dem angegebenen Wert verglichen die <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode. Wenn der Elementtyp ein systeminterner (Benutzerdefiniert) Typ, ist die `Equals` Implementierung dieses Typs verwendet.  
  
 Da die meisten Arrays mit eine unteren Grenze von 0 (null) hat, würde diese Methode in der Regel 1, wenn zurückgeben `value` wurde nicht gefunden. In dem seltenen Fall, das die untere Grenze des Arrays gleich <xref:System.Int32.MinValue?displayProperty=nameWithType> und `value` nicht gefunden wird, gibt diese Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType>, d.h. `System.Int32.MinValue - 1`.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die Anzahl der Elemente vom Anfang des `array` zu `startIndex`.  
  
 In .NET Framework, Version 2.0, diese Methode verwendet die <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> Methoden der <xref:System.Array> um zu bestimmen, ob die <xref:System.Object> gemäß der `value` Parameter vorhanden ist. Diese Entscheidung wurde in früheren Versionen von .NET Framework, mit der <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> Methoden der `value` <xref:System.Object> selbst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die den Index des letzten Vorkommens eines angegebenen Elements in einem Array zu bestimmen.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im eindimensionalen <see cref="T:System.Array" /> zurück, der die angegebene Anzahl von Elementen enthält und am angegebenen Index endet.</summary>
        <returns>Der Index des letzten Vorkommens von <paramref name="value" /> im Bereich von Elementen in <paramref name="array" />, der die durch <paramref name="count" /> angegebene Anzahl von Elementen enthält und sich bis zu <paramref name="startIndex" /> erstreckt, sofern gefunden, andernfalls die untere Grenze des Arrays - 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das eindimensionale <xref:System.Array> wird rückwärts gesuchten beginnt am `startIndex` und endet um `startIndex` minus `count` plus 1, wenn `count` ist größer als 0.  
  
 Die Elemente werden mit dem angegebenen Wert verglichen die <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode. Wenn der Elementtyp ein systeminterner (Benutzerdefiniert) Typ, ist die`Equals` Implementierung dieses Typs verwendet.  
  
 Da die meisten Arrays mit eine unteren Grenze von 0 (null) hat, würde diese Methode in der Regel 1, wenn zurückgeben `value` wurde nicht gefunden. In dem seltenen Fall, das die untere Grenze des Arrays gleich <xref:System.Int32.MinValue?displayProperty=nameWithType> und `value` nicht gefunden wird, gibt diese Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType>, d.h. `System.Int32.MinValue - 1`.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist `count`.  
  
 In .NET Framework, Version 2.0, diese Methode verwendet die <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> Methoden der <xref:System.Array> um zu bestimmen, ob die <xref:System.Object> gemäß der `value` Parameter vorhanden ist. Diese Entscheidung wurde in früheren Versionen von .NET Framework, mit der <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> Methoden der `value` <xref:System.Object> selbst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die den Index des letzten Vorkommens eines angegebenen Elements in einem Array zu bestimmen. Beachten Sie, dass die <xref:System.Array.LastIndexOf%2A> Methode ist eine Rückwärtssuche daher `count` muss kleiner als oder gleich sein (`startIndex` minus die untere Grenze des Arrays plus 1).  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in <paramref name="array" /> an.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="value" /> im gesamten <paramref name="array" />, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> rückwärts beginnend ab dem letzten Element und endend mit dem ersten Element gesucht wird.  
  
 Die Elemente werden mit dem angegebenen Wert verglichen die <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode. Wenn der Elementtyp ein systeminterner (Benutzerdefiniert) Typ, ist die `Equals` Implementierung dieses Typs verwendet.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, alle drei generische Überladungen, der die <xref:System.Array.LastIndexOf%2A> Methode. Ein Array von Zeichenfolgen wird mit einem Eintrag erstellt, die an der Indexposition 0 und Indexposition 5 zweimal angezeigt wird. Die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> -methodenüberladung, durchsucht das gesamte Array am Ende und das zweite Vorkommen der Zeichenfolge sucht. Die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Überladung wird verwendet, um das umgekehrten Array, beginnend mit der Indexposition 3 und weiterhin auf den Anfang des Arrays zu suchen, und sucht das erste Vorkommen der Zeichenfolge. Zum Schluss die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um einen Bereich von vier Einträge, beginnend an Position 4 des Index, und Erweitern von Rückwärts suchen (d. h. er durchsucht die Elemente an Stellen, 4, 3, 2 und 1); diese Suche gibt-1 zurück, da keine Instanzen der Suche vorhanden sind die Zeichenfolge in diesem Bereich.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der sich vom ersten Element bis zum angegebenen Index erstreckt.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen im <paramref name="array" />, das sich vom ersten Element bis <paramref name="startIndex" /> erstreckt, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> wird rückwärts gesuchten beginnt am `startIndex` bis auf das erste Element.  
  
 Die Elemente werden mit dem angegebenen Wert verglichen die <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode. Wenn der Elementtyp ein systeminterner (Benutzerdefiniert) Typ, ist die `Equals` Implementierung dieses Typs verwendet.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die Anzahl der Elemente vom Anfang des `array` zu `startIndex`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, alle drei generische Überladungen, der die <xref:System.Array.LastIndexOf%2A> Methode. Ein Array von Zeichenfolgen wird mit einem Eintrag erstellt, die an der Indexposition 0 und Indexposition 5 zweimal angezeigt wird. Die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> -methodenüberladung, durchsucht das gesamte Array am Ende und das zweite Vorkommen der Zeichenfolge sucht. Die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Überladung wird verwendet, um das umgekehrten Array, beginnend mit der Indexposition 3 und weiterhin auf den Anfang des Arrays zu suchen, und sucht das erste Vorkommen der Zeichenfolge. Zum Schluss die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um einen Bereich von vier Einträge, beginnend an Position 4 des Index, und Erweitern von Rückwärts suchen (d. h. er durchsucht die Elemente an Stellen, 4, 3, 2 und 1); diese Suche gibt-1 zurück, da keine Instanzen der Suche vorhanden sind die Zeichenfolge in diesem Bereich.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der die angegebene Anzahl von Elementen enthält und am angegebenen Index endet.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen im <paramref name="array" />, das die in <paramref name="count" /> angegebene Anzahl von Elementen enthält und am <paramref name="startIndex" /> endet, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> wird rückwärts gesuchten beginnt am `startIndex` und endet um `startIndex` minus `count` plus 1, wenn `count` ist größer als 0.  
  
 Die Elemente werden mit dem angegebenen Wert verglichen die <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode. Wenn der Elementtyp ein systeminterner (Benutzerdefiniert) Typ, ist die `Equals` Implementierung dieses Typs verwendet.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist `count`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, alle drei generische Überladungen, der die <xref:System.Array.LastIndexOf%2A> Methode. Ein Array von Zeichenfolgen wird mit einem Eintrag erstellt, die an der Indexposition 0 und Indexposition 5 zweimal angezeigt wird. Die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> -methodenüberladung, durchsucht das gesamte Array am Ende und das zweite Vorkommen der Zeichenfolge sucht. Die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> Überladung wird verwendet, um das umgekehrten Array, beginnend mit der Indexposition 3 und weiterhin auf den Anfang des Arrays zu suchen, und sucht das erste Vorkommen der Zeichenfolge. Zum Schluss die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um einen Bereich von vier Einträge, beginnend an Position 4 des Index, und Erweitern von Rückwärts suchen (d. h. er durchsucht die Elemente an Stellen, 4, 3, 2 und 1); diese Suche gibt-1 zurück, da keine Instanzen der Suche vorhanden sind die Zeichenfolge in diesem Bereich.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt im <paramref name="array" /> an.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtanzahl der Elemente in allen Dimensionen im <see cref="T:System.Array" /> ab.</summary>
        <value>Die Gesamtanzahl der Elemente in allen Dimensionen im <see cref="T:System.Array" />, 0 (null), wenn keine Elemente im Array enthalten sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Array.Length%2A> Eigenschaft, um die Gesamtzahl der Elemente in einem Array abzurufen. Darüber hinaus verwendet er die <xref:System.Array.GetUpperBound%2A> Methode, um zu bestimmen, die Anzahl der Elemente in jeder Dimension eines mehrdimensionalen Arrays.  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Das Array ist mehrdimensional und enthält mehr als <see cref="F:System.Int32.MaxValue" />-Elemente.</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LongLength : int64" Usage="System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine 64-Bit-Ganzzahl ab, die die Gesamtanzahl der Elemente in allen Dimensionen des <see cref="T:System.Array" /> angibt.</summary>
        <value>Eine 64-Bit-Ganzzahl, die die Gesamtanzahl der Elemente in allen Dimensionen des <see cref="T:System.Array" /> angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft der Rang (Anzahl der Dimensionen) des <see cref="T:System.Array" /> ab. Beispielsweise gibt ein eindimensionales Array 1 zurück, eines zweidimensionalen Arrays gibt 2 zurück, usw.</summary>
        <value>Der Rang (Anzahl der Dimensionen) des <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Z. B. Visual Basic-code  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 und der C#-code  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 erstellt ein Array von drei Dimensionen mit einer <xref:System.Array.Rank%2A> Eigenschaft, deren Wert 3.  
  
 Ein verzweigtes Array (ein Array von Arrays) ist ein eindimensionales Array. der Wert des der <xref:System.Array.Rank%2A> -Eigenschaft ist 1.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgende Beispiel initialisiert ein eindimensionales Array, ein zweidimensionales Array und ein verzweigtes Array und ruft die <xref:System.Array.Rank%2A> Eigenschaft der einzelnen.  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberSignature Language="F#" Value="static member Resize :  * int -&gt; unit" Usage="System.Array.Resize (array, newSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="newSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das eindimensionale nullbasierte Array, dessen Größe geändert werden soll, oder <see langword="null" />, um ein neues Array mit der angegebenen Größe zu erstellen.</param>
        <param name="newSize">Die Größe des neuen Arrays.</param>
        <summary>Ändert die Anzahl der Elemente eines eindimensionalen Arrays in die angegebene neue Größe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ordnet ein neues Array mit der angegebenen Größe, kopiert Elemente aus dem alten Array in das neue Projekt und klicken Sie dann das alte Array durch den neuen ersetzt. `array` ein eindimensionales Array muss sein.  
  
 Wenn `array` ist `null`, diese Methode erstellt ein neues Array mit der angegebenen Größe.  
  
 Wenn `newSize` ist größer als die <xref:System.Array.Length%2A> des alten Arrays ist, ein neues Array zugeordnet, und alle Elemente aus dem alten Array in das neue Projekt kopiert werden.  Wenn `newSize` ist kleiner als der <xref:System.Array.Length%2A> des alten Arrays ist, wird ein neues Array zugeordnet und Elemente werden aus dem alten Array in das neue Projekt kopiert, bis das neue Array aufgefüllt ist, der Rest der Elemente in der alten Arrays werden ignoriert.  Wenn `newSize` ist gleich der <xref:System.Array.Length%2A> des alten Arrays, diese Methode führt keine Aktion.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist `newSize`.  
  
 Die <xref:System.Array.Resize%2A> Methode wird nur ein eindimensionales Array. Die <xref:System.Array> Klasse schließt sich nicht auf eine Methode zum Ändern der Größe von mehrdimensionalen Arrays. Zu diesem Zweck müssen Sie Ihren eigenen Code bereitstellen oder eine spezielle-Methode in einer Drittanbieter-Bibliothek aufrufen. Der folgende Code veranschaulicht eine mögliche Implementierung für eine Methode, ein Array von der Größe der *n* Dimensionen.  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie das Ändern der Größe des Arrays auswirkt.  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newSize" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kehrt die Reihenfolge der Elemente in einem eindimensionalen <see cref="T:System.Array" /> oder in einen Teil des <see cref="T:System.Array" /> um.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Das umzukehrende eindimensionale <see cref="T:System.Array" />.</param>
        <summary>Kehrt die Reihenfolge der Elemente im gesamten eindimensionalen <see cref="T:System.Array" /> um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach einem Aufruf dieser Methode das Element am `myArray[i]`, wobei `i` ein Index im Array ist, verschiebt in `myArray[j]`, wobei `j` gleich `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
 Wie im folgenden Beispiel wird gezeigt, die <xref:System.Array.Reverse%2A> Methode kann verwendet werden, um ein verzweigtes Array umzukehren. Initialisiert ein verzweigtes Array mit einem Element für jeden Monat des laufenden Jahres in der aktuellen Kultur dar. Jedes Element enthält ein Array mit so viele Elemente wie diesen Monat Tage hat. Das Beispiel zeigt den Inhalt des Arrays, Aufrufe der <xref:System.Array.Reverse%2A> -Methode, und dann den Inhalt des umgekehrten Arrays.  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Reihenfolge der Werte in umgekehrt ein <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das umzukehrende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des umzukehrenden Abschnitts.</param>
        <param name="length">Die Anzahl der Elemente im umzukehrenden Abschnitt.</param>
        <summary>Kehrt die Reihenfolge der Elemente in einem Bereich von Elementen im eindimensionalen <see cref="T:System.Array" /> um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach einem Aufruf dieser Methode das Element am `myArray[i]`, wobei `i` ein Index im Array ist, verschiebt in `myArray[j]`, wobei `j` gleich `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 Die <xref:System.Array.Reverse%2A> Methode kann verwendet werden, um ein verzweigtes Array umzukehren.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Reihenfolge der Werte in einem Bereich von Elementen in umgekehrt ein <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt das angegebene Element im aktuellen <see cref="T:System.Array" /> auf den angegebenen Wert fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index">Eine 32-Bit-Ganzzahl, die die Position des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des eindimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Der Index wird als 32-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob der Wert des `index` typu je MIMO rozsah.  
  
 Weitere Informationen über Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> zugewiesen `null` auf ein Element eines Arrays von Werttypen werden alle Felder des Elements auf 0 (null) initialisiert. Der Wert des Elements ist kein null-Verweis, und kann nicht gefunden werden, indem ein null-Verweis gesucht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau eine Dimension.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="indices">Ein eindimensionales Array von 32-Bit-Ganzzahlen, das die Indizes darstellt, die die Position des festzulegenden Elements angeben.</param>
        <summary>Legt das Element an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als Array von 32-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Elemente in `indices` muss gleich der Anzahl der Dimensionen in der <xref:System.Array>. Alle Elemente in der `indices` Array muss zusammen die Position des gewünschten Elements angeben, in der mehrdimensionalen <xref:System.Array>.  
  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Werte in der `indices` Array ist, außerhalb des gültigen Bereichs.  
  
 Weitere Informationen über Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> zugewiesen `null` auf ein Element eines Arrays von Werttypen werden alle Felder des Elements auf 0 (null) initialisiert. Der Wert des Elements ist kein null-Verweis, und kann nicht gefunden werden, indem ein null-Verweis gesucht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Dimensionen im aktuellen <see cref="T:System.Array" /> ist nicht gleich der Anzahl der Elemente von <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Ein Element von <paramref name="indices" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index">Eine 64-Bit-Ganzzahl, die die Position des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des eindimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Der Index wird als 64-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob der Wert des `index` typu je MIMO rozsah.  
  
 Weitere Informationen über Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> zugewiesen `null` auf ein Element eines Arrays von Werttypen werden alle Felder des Elements auf 0 (null) initialisiert. Der Wert des Elements ist kein null-Verweis, und kann nicht gefunden werden, indem ein null-Verweis gesucht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau eine Dimension.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indices" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="indices">Ein eindimensionales Array von 64-Bit-Ganzzahlen, das die Indizes darstellt, die die Position des festzulegenden Elements angeben.</param>
        <summary>Legt das Element an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als Array von 64-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Elemente in `indices` muss gleich der Anzahl der Dimensionen in der <xref:System.Array>. Alle Elemente in der `indices` Array muss zusammen die Position des gewünschten Elements angeben, in der mehrdimensionalen <xref:System.Array>.  
  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Werte in der `indices` Array ist, außerhalb des gültigen Bereichs.  
  
 Weitere Informationen über Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> zugewiesen `null` auf ein Element eines Arrays von Werttypen werden alle Felder des Elements auf 0 (null) initialisiert. Der Wert des Elements ist kein null-Verweis, und kann nicht gefunden werden, indem ein null-Verweis gesucht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Dimensionen im aktuellen <see cref="T:System.Array" /> ist nicht gleich der Anzahl der Elemente von <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein Element von <paramref name="indices" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index1">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Weitere Informationen über Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> zugewiesen `null` auf ein Element eines Arrays von Werttypen werden alle Felder des Elements auf 0 (null) initialisiert. Der Wert des Elements ist kein null-Verweis, und kann nicht gefunden werden, indem ein null-Verweis gesucht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau zwei Dimensionen.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> oder <paramref name="index2" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index1">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Weitere Informationen über Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> zugewiesen `null` auf ein Element eines Arrays von Werttypen werden alle Felder des Elements auf 0 (null) initialisiert. Der Wert des Elements ist kein null-Verweis, und kann nicht gefunden werden, indem ein null-Verweis gesucht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau zwei Dimensionen.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> oder <paramref name="index2" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index1">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index3">Eine 32-Bit-Ganzzahl, die den Index für die dritte Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Weitere Informationen über Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> zugewiesen `null` auf ein Element eines Arrays von Werttypen werden alle Felder des Elements auf 0 (null) initialisiert. Der Wert des Elements ist kein null-Verweis, und kann nicht gefunden werden, indem ein null-Verweis gesucht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau drei Dimensionen.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" />, <paramref name="index2" /> oder <paramref name="index3" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index1">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index3">Eine 64-Bit-Ganzzahl, die den Index für die dritte Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.  
  
 Weitere Informationen über Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> zugewiesen `null` auf ein Element eines Arrays von Werttypen werden alle Felder des Elements auf 0 (null) initialisiert. Der Wert des Elements ist kein null-Verweis, und kann nicht gefunden werden, indem ein null-Verweis gesucht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau drei Dimensionen.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" />, <paramref name="index2" /> oder <paramref name="index3" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortiert die Elemente in einem eindimensionalen Array.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : Array -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Das zu sortierende eindimensionale <see cref="T:System.Array" />.</param>
        <summary>Sortiert die Elemente in einem ganzen eindimensionalen <see cref="T:System.Array" /> mithilfe der <see cref="T:System.IComparable" />-Implementierung jedes Elements des <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element der `array` müssen implementieren die <xref:System.IComparable> Schnittstelle kann Vergleiche mit jedem anderen Element im `array`.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die Beobachtung der inneren Abläufe Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird ein [Einfügesortierung](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es, eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und wenden die Schnellsortierung im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Log `n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Sortieren der Werte in einer <xref:System.Array> mithilfe des Standardvergleichs und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt. Beachten Sie, die das Ergebnis, abhängig vom aktuellen variieren kann <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens ein Element in <paramref name="array" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Das eindimensionale <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale <see cref="T:System.Array" /> mit den Elementen, die den jeweiligen Schlüsseln im <paramref name="keys" />-<see cref="T:System.Array" /> entsprechen.  
  
- oder - 
 <see langword="null" />, wenn nur das <paramref name="keys" />-<see cref="T:System.Array" /> sortiert werden soll.</param>
        <summary>Sortiert ein Paar von eindimensionalen <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die <see cref="T:System.IComparable" />-Implementierung jedes Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array>. Wenn ein Schlüssel wird neu angeordnet, bei der Sortierung, des entsprechenden Elements in der `items` <xref:System.Array> wird neu positioniert. Aus diesem Grund die `items` <xref:System.Array> sortiert wird, entsprechend der Anordnung der entsprechenden Schlüssel in der `keys` <xref:System.Array>.  
  
 Jeder Schlüssel in der `keys` <xref:System.Array> müssen implementieren die <xref:System.IComparable> Benutzeroberfläche kann mit jedem anderen Schlüssel verglichen werden.  
  
 Sie können sortiert, wenn es mehr Elemente als Schlüssel gibt, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert. Wenn es weitere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies eine <xref:System.ArgumentException>.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die Beobachtung der inneren Abläufe Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird ein [Einfügesortierung](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es, eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und wenden die Schnellsortierung im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Log `n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `keys`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie zwei verknüpften Arrays sortiert, wobei das erste Array enthält die Schlüssel und das zweite Array enthält die Werte. Sortierungen erfolgen mithilfe des Standardvergleichs und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt. Beachten Sie, die das Ergebnis, abhängig vom aktuellen variieren kann <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Das <paramref name="keys" /><see cref="T:System.Array" /> ist mehrdimensional.  
  
- oder - 
Das <paramref name="items" /><see cref="T:System.Array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens ein Element im <paramref name="keys" /><see cref="T:System.Array" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Das zu sortierende eindimensionale Array.</param>
        <param name="comparer">Die Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Sortiert die Elemente in einem eindimensionalen <see cref="T:System.Array" /> mithilfe des angegebenen <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` ist `null`, jedes Element der `array` müssen implementieren die <xref:System.IComparable> Schnittstelle kann Vergleiche mit jedem anderen Element im `array`.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die Beobachtung der inneren Abläufe Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird ein [Einfügesortierung](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es, eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und wenden die Schnellsortierung im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Log `n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
 .NET Framework enthält vordefinierte <xref:System.Collections.IComparer> Implementierungen in der folgenden Tabelle aufgeführt.  
  
|Implementierung|Beschreibung |  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Vergleicht zwei Objekte, jedoch führt einen Vergleich Groß-/Kleinschreibung von Zeichenfolgen.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Vergleicht zwei Objekte mithilfe der Sortierkonventionen der aktuellen Kultur.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Vergleicht zwei Objekte mithilfe der Sortierkonventionen der invarianten Kultur.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Vergleicht zwei Objekte des Typs `T` mithilfe von Standard-Sortierreihenfolge des Typs.|  
  
 Sie können auch benutzerdefinierte Vergleiche unterstützen, durch die Bereitstellung einer Instanz Ihrer eigenen <xref:System.Collections.IComparer> Implementierung, die die `comparer` Parameter. Durch die Definition wird im Beispiel eine `ReverseComparer` -Klasse, die die Standardsortierreihenfolge für kehrt Instanzen eines Typs und führt die Groß-/Kleinschreibung Zeichenfolgenvergleich.  
  
   
  
## Examples  
 Im folgende Beispiel sortiert die Werte in ein Array von Zeichenfolgen mithilfe des Standardvergleichs. Sie definiert auch eine benutzerdefinierte <xref:System.Collections.IComparer> Implementierung, die mit dem Namen `ReverseComparer` , die ein Objekt des Standard-Sortierreihenfolge beim Ausführen eines Zeichenfolgenvergleichs umgekehrt. Beachten Sie, dass die Ausgabe abhängig von der aktuellen Kultur variieren kann.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und mindestens ein Element in <paramref name="array" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <block subset="none" type="usage"><para>Die .NET Framework 4 und früheren Versionen verwendet nur den Quicksort-Algorithmus. QuickSort identifiziert die ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, eine <see cref="T:System.IndexOutOfRangeException" /> -Ausnahme aus, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer. Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <see cref="T:System.ArgumentException" /> wird keine Ausnahme, da die Einfügung sortieren und Heapsort Algorithmen eine ungültige Vergleich nicht erkennen. Zum größten Teil, gilt dies für Arrays mit weniger als 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Das eindimensionale <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale <see cref="T:System.Array" /> mit den Elementen, die den jeweiligen Schlüsseln im <paramref name="keys" />-<see cref="T:System.Array" /> entsprechen.  
  
- oder - 
 <see langword="null" />, wenn nur das <paramref name="keys" />-<see cref="T:System.Array" /> sortiert werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Sortiert ein Paar von eindimensionalen <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei den angegebenen <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array>. Wenn ein Schlüssel wird neu angeordnet, bei der Sortierung, des entsprechenden Elements in der `items` <xref:System.Array> wird neu positioniert. Aus diesem Grund die `items` <xref:System.Array> sortiert wird, entsprechend der Anordnung der entsprechenden Schlüssel in der `keys` <xref:System.Array>.  
  
 Wenn `comparer` ist `null`, die jeweils-Schlüssel in der `keys` <xref:System.Array> müssen implementieren die <xref:System.IComparable> Benutzeroberfläche kann mit jedem anderen Schlüssel verglichen werden.  
  
 Sie können sortiert, wenn es mehr Elemente als Schlüssel gibt, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert. Wenn es weitere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies eine <xref:System.ArgumentException>.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 .NET Framework enthält vordefinierte <xref:System.Collections.IComparer> Implementierungen in der folgenden Tabelle aufgeführt.  
  
|Implementierung|Beschreibung |  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Vergleicht zwei Objekte, jedoch führt einen Vergleich Groß-/Kleinschreibung von Zeichenfolgen.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Vergleicht zwei Objekte mithilfe der Sortierkonventionen der aktuellen Kultur.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Vergleicht zwei Objekte mithilfe der Sortierkonventionen der invarianten Kultur.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Vergleicht zwei Objekte des Typs `T` mithilfe von Standard-Sortierreihenfolge des Typs.|  
  
 Sie können auch benutzerdefinierte Vergleiche unterstützen, durch die Bereitstellung einer Instanz Ihrer eigenen <xref:System.Collections.IComparer> Implementierung, die die `comparer` Parameter. Durch die Definition wird im Beispiel ein <xref:System.Collections.IComparer> Implementierung, kehrt die Standardsortierreihenfolge und führt die Groß-/Kleinschreibung Zeichenfolgenvergleich.  
  
 Diese Methode verwendet die Beobachtung der inneren Abläufe Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird ein [Einfügesortierung](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es, eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und wenden die Schnellsortierung im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Log `n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `keys`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie zwei verknüpften Arrays sortiert, wobei das erste Array enthält die Schlüssel und das zweite Array enthält die Werte. Sortierungen erfolgen mithilfe des Standardvergleichs und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt. Beachten Sie, die das Ergebnis, abhängig vom aktuellen variieren kann <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Das <paramref name="keys" /><see cref="T:System.Array" /> ist mehrdimensional.  
  
- oder - 
Das <paramref name="items" /><see cref="T:System.Array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  
  
- oder - 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und mindestens ein Element im <paramref name="keys" /><see cref="T:System.Array" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <block subset="none" type="usage"><para>Die .NET Framework 4 und früheren Versionen verwendet nur den Quicksort-Algorithmus. QuickSort identifiziert die ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, eine <see cref="T:System.IndexOutOfRangeException" /> -Ausnahme aus, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer. Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <see cref="T:System.ArgumentException" /> wird keine Ausnahme, da die Einfügung sortieren und Heapsort Algorithmen eine ungültige Vergleich nicht erkennen. Zum größten Teil, gilt dies für Arrays mit weniger als 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu sortierende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen in einem eindimensionalen <see cref="T:System.Array" /> mithilfe der <see cref="T:System.IComparable" />-Implementierung jedes Elements des <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element innerhalb des angegebenen Bereichs von Elementen in `array` müssen implementieren die <xref:System.IComparable> Schnittstelle kann Vergleiche mit jedem anderen Element im `array`.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die Beobachtung der inneren Abläufe Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird ein [Einfügesortierung](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es, eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und wenden die Schnellsortierung im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Log `n`)-Vorgang, in denen `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Sortieren der Werte in einer <xref:System.Array> mithilfe des Standardvergleichs und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt. Beachten Sie, die das Ergebnis, abhängig vom aktuellen variieren kann <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens ein Element in <paramref name="array" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Das eindimensionale <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale <see cref="T:System.Array" /> mit den Elementen, die den jeweiligen Schlüsseln im <paramref name="keys" />-<see cref="T:System.Array" /> entsprechen.  
  
- oder - 
 <see langword="null" />, wenn nur das <paramref name="keys" />-<see cref="T:System.Array" /> sortiert werden soll.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <summary>Sortiert einen Bereich von Elementen in einem Paar von eindimensionalen <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die <see cref="T:System.IComparable" />-Implementierung jedes Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array>. Wenn ein Schlüssel wird neu angeordnet, bei der Sortierung, des entsprechenden Elements in der `items` <xref:System.Array> wird neu positioniert. Aus diesem Grund die `items` <xref:System.Array> sortiert wird, entsprechend der Anordnung der entsprechenden Schlüssel in der `keys` <xref:System.Array>.  
  
 Jeder Schlüssel im angegebenen Bereich von Elementen in der `keys` <xref:System.Array> müssen implementieren die <xref:System.IComparable> Benutzeroberfläche kann mit jedem anderen Schlüssel verglichen werden.  
  
 Sie können sortiert, wenn es mehr Elemente als Schlüssel gibt, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert. Wenn es weitere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies eine <xref:System.ArgumentException>.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die Beobachtung der inneren Abläufe Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird ein [Einfügesortierung](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es, eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und wenden die Schnellsortierung im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Log `n`)-Vorgang, in denen `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Sortieren von zwei verknüpften Arrays, in dem das erste Array enthält die Schlüssel und das zweite Array enthält die Werte, veranschaulicht. Sortierungen erfolgen mithilfe des Standardvergleichs und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt. Beachten Sie, die das Ergebnis, abhängig vom aktuellen variieren kann <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Das <paramref name="keys" /><see cref="T:System.Array" /> ist mehrdimensional.  
  
- oder - 
Das <paramref name="items" /><see cref="T:System.Array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="keys" />-Grenze.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  
  
- oder - 
 <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="keys" /><see cref="T:System.Array" /> an.  
  
- oder - 
 <paramref name="items" /> ist nicht <see langword="null" />, und <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="items" /><see cref="T:System.Array" /> an.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens ein Element im <paramref name="keys" /><see cref="T:System.Array" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Das zu sortierende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen in einem eindimensionalen <see cref="T:System.Array" /> mithilfe dem angegebenen <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` ist `null`, jedes Element innerhalb des angegebenen Bereichs von Elementen in `array` müssen implementieren die <xref:System.IComparable> Schnittstelle kann Vergleiche mit jedem anderen Element im `array`.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 .NET Framework enthält vordefinierte <xref:System.Collections.IComparer> Implementierungen in der folgenden Tabelle aufgeführt.  
  
|Implementierung|Beschreibung |  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Vergleicht zwei Objekte, jedoch führt einen Vergleich Groß-/Kleinschreibung von Zeichenfolgen.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Vergleicht zwei Objekte mithilfe der Sortierkonventionen der aktuellen Kultur.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Vergleicht zwei Objekte mithilfe der Sortierkonventionen der invarianten Kultur.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Vergleicht zwei Objekte des Typs `T` mithilfe von Standard-Sortierreihenfolge des Typs.|  
  
 Sie können auch benutzerdefinierte Vergleiche unterstützen, durch die Bereitstellung einer Instanz Ihrer eigenen <xref:System.Collections.IComparer> Implementierung, die die `comparer` Parameter. Durch die Definition wird im Beispiel eine `ReverseComparer` -Klasse, die die Standardsortierreihenfolge für kehrt Instanzen eines Typs und führt die Groß-/Kleinschreibung Zeichenfolgenvergleich.  
  
 Diese Methode verwendet die Beobachtung der inneren Abläufe Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird ein [Einfügesortierung](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es, eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und wenden die Schnellsortierung im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Log `n`)-Vorgang, in denen `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Sortieren der Werte in einer <xref:System.Array> mithilfe des Standardvergleichs und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt. Beachten Sie, die das Ergebnis, abhängig vom aktuellen variieren kann <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  
  
- oder - 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und mindestens ein Element in <paramref name="array" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <block subset="none" type="usage"><para>Die .NET Framework 4 und früheren Versionen verwendet nur den Quicksort-Algorithmus. QuickSort identifiziert die ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, eine <see cref="T:System.IndexOutOfRangeException" /> -Ausnahme aus, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer. Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <see cref="T:System.ArgumentException" /> wird keine Ausnahme, da die Einfügung sortieren und Heapsort Algorithmen eine ungültige Vergleich nicht erkennen. Zum größten Teil, gilt dies für Arrays mit weniger als 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Das eindimensionale <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale <see cref="T:System.Array" /> mit den Elementen, die den jeweiligen Schlüsseln im <paramref name="keys" />-<see cref="T:System.Array" /> entsprechen.  
  
- oder - 
 <see langword="null" />, wenn nur das <paramref name="keys" />-<see cref="T:System.Array" /> sortiert werden soll.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Sortiert einen Bereich von Elementen in einem Paar von eindimensionalen <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei den angegebenen <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array>. Wenn ein Schlüssel wird neu angeordnet, bei der Sortierung, des entsprechenden Elements in der `items` <xref:System.Array> wird neu positioniert. Aus diesem Grund die `items` <xref:System.Array> sortiert wird, entsprechend der Anordnung der entsprechenden Schlüssel in der `keys` <xref:System.Array>.  
  
 Wenn `comparer` ist `null`, jeder Schlüssel im angegebenen Bereich von Elementen in der `keys` <xref:System.Array> müssen implementieren die <xref:System.IComparable> Benutzeroberfläche kann mit jedem anderen Schlüssel verglichen werden.  
  
 Sie können sortiert, wenn es mehr Elemente als Schlüssel gibt, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert. Wenn es weitere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies eine <xref:System.ArgumentException>.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 .NET Framework enthält vordefinierte <xref:System.Collections.IComparer> Implementierungen in der folgenden Tabelle aufgeführt.  
  
|Implementierung|Beschreibung |  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Vergleicht zwei Objekte, jedoch führt einen Vergleich Groß-/Kleinschreibung von Zeichenfolgen.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Vergleicht zwei Objekte mithilfe der Sortierkonventionen der aktuellen Kultur.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Vergleicht zwei Objekte mithilfe der Sortierkonventionen der invarianten Kultur.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Vergleicht zwei Objekte des Typs `T` mithilfe von Standard-Sortierreihenfolge des Typs.|  
  
 Sie können auch benutzerdefinierte Vergleiche unterstützen, durch die Bereitstellung einer Instanz Ihrer eigenen <xref:System.Collections.IComparer> Implementierung, die die `comparer` Parameter. Im Beispiel wird dieses durch Definieren eines benutzerdefinierten <xref:System.Collections.IComparer> Implementierung, kehrt die Standardsortierreihenfolge und führt die Groß-/Kleinschreibung Zeichenfolgenvergleich.  
  
 Diese Methode verwendet die Beobachtung der inneren Abläufe Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird ein [Einfügesortierung](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es, eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und wenden die Schnellsortierung im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Log `n`)-Vorgang, in denen `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das Sortieren von zwei verknüpften Arrays, in dem das erste Array enthält die Schlüssel und das zweite Array enthält die Werte, veranschaulicht. Sortierungen erfolgen mithilfe des Standardvergleichs und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt. Beachten Sie, die das Ergebnis, abhängig vom aktuellen variieren kann <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Das <paramref name="keys" /><see cref="T:System.Array" /> ist mehrdimensional.  
  
- oder - 
Das <paramref name="items" /><see cref="T:System.Array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="keys" />-Grenze.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die untere Grenze von <paramref name="keys" /> entspricht nicht der unteren Grenze von <paramref name="items" />.  
  
- oder - 
 <paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  
  
- oder - 
 <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="keys" /><see cref="T:System.Array" /> an.  
  
- oder - 
 <paramref name="items" /> ist nicht <see langword="null" />, und <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="items" /><see cref="T:System.Array" /> an.  
  
- oder - 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und mindestens ein Element im <paramref name="keys" /><see cref="T:System.Array" /> implementiert die <see cref="T:System.IComparable" />-Schnittstelle nicht.</exception>
        <block subset="none" type="usage"><para>Die .NET Framework 4 und früheren Versionen verwendet nur den Quicksort-Algorithmus. QuickSort identifiziert die ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, eine <see cref="T:System.IndexOutOfRangeException" /> -Ausnahme aus, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer. Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <see cref="T:System.ArgumentException" /> wird keine Ausnahme, da die Einfügung sortieren und Heapsort Algorithmen eine ungültige Vergleich nicht erkennen. Zum größten Teil, gilt dies für Arrays mit weniger als 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <summary>Sortiert die Elemente in einem ganzen <see cref="T:System.Array" /> mithilfe der Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle jedes Elements des <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element der `array` müssen implementieren die <xref:System.IComparable%601> generische Schnittstelle für Vergleiche mit jedem anderen Element in werden `array`.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die Beobachtung der inneren Abläufe Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird ein [Einfügesortierung](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es, eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und wenden die Schnellsortierung im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Log `n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> generischen methodenüberladung und <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generischen methodenüberladung. Ein Array von Zeichenfolgen wird in keiner bestimmten Reihenfolge erstellt.  
  
 Das Array wird angezeigt, sortiert und erneut angezeigt.  
  
> [!NOTE]
>  Die Aufrufe an die <xref:System.Array.Sort%2A> und <xref:System.Array.BinarySearch%2A> generische Methoden sind nicht anders als die Aufrufe an ihre nicht generischen Entsprechungen, gesucht, da Visual Basic, c# und C++ den Typ des generischen Typparameters aus dem Typ des ersten Arguments abzuleiten. Bei Verwendung der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 Die <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generischen methodenüberladung klicken Sie dann zum Suchen nach zwei Zeichenfolgen verwendet wird, ist eine, die nicht in das Array und einer ist. Das Array und der Rückgabewert von der <xref:System.Array.BinarySearch%2A> Methode übergeben werden, um die `ShowWhere` generische Methode, die den Indexwert zeigt an, wenn die Zeichenfolge gefunden wurde, und andernfalls die Elemente die Suchzeichenfolge fiel zwischen handele es sich im Array. Der Index ist negativ, wenn die Zeichenfolge nicht n ist das Array, also die `ShowWhere` Methode nimmt das bitweise Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic), die den Index des ersten Elements in der Liste zu erhalten, die größer als die Suche Stri NG.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens ein Element in <paramref name="array" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <see langword="null" />, um die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle der einzelnen Elemente zu verwenden.</param>
        <summary>Sortiert die Elementen in einem <see cref="T:System.Array" /> mit der angegebenen generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` ist `null`, jedes Element der `array` müssen implementieren die <xref:System.IComparable%601> generische Schnittstelle für Vergleiche mit jedem anderen Element in werden `array`.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die Beobachtung der inneren Abläufe Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird ein [Einfügesortierung](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es, eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und wenden die Schnellsortierung im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Log `n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung und <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung.  
  
 Das Codebeispiel definiert einen alternativen Vergleich für Zeichenfolgen mit der Bezeichnung `ReverseCompare`, implementiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich ruft die <xref:System.String.CompareTo%28System.String%29> Methode, die Umkehrung der verglichenen Elemente angibt, damit die Zeichenfolgen hoch bis Niedrig statt mit niedriger zum höchsten zu sortieren.  
  
 Das Array wird angezeigt, sortiert und erneut angezeigt. Arrays müssen sortiert werden, um Sie verwenden die <xref:System.Array.BinarySearch%2A> Methode.  
  
> [!NOTE]
>  Die Aufrufe an die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> und <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden sind nicht anders als die Aufrufe an ihre nicht generischen Entsprechungen, gesucht, da Visual Basic, c# und C++ den Typ des generischen Typparameters aus dem Typ des ersten Arguments abzuleiten. Bei Verwendung der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 Die <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung klicken Sie dann zum Suchen nach zwei Zeichenfolgen verwendet wird, ist eine, die nicht in das Array und einer ist. Das Array und der Rückgabewert von der <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Methode übergeben werden, um die `ShowWhere` generische Methode, die den Indexwert zeigt an, wenn die Zeichenfolge gefunden wurde, und andernfalls die Elemente die Suchzeichenfolge fiel zwischen handele es sich im Array. Der Index ist negativ, wenn die Zeichenfolge nicht n ist das Array, also die `ShowWhere` Methode nimmt das bitweise Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic), die den Index des ersten Elements in der Liste zu erhalten, die größer als die Suche Stri NG.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und mindestens ein Element in <paramref name="array" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <block subset="none" type="usage"><para>Die .NET Framework 4 und früheren Versionen verwendet nur den Quicksort-Algorithmus. QuickSort identifiziert die ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, eine <see cref="T:System.IndexOutOfRangeException" /> -Ausnahme aus, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer. Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <see cref="T:System.ArgumentException" /> wird keine Ausnahme, da die Einfügung sortieren und Heapsort Algorithmen eine ungültige Vergleich nicht erkennen. Zum größten Teil, gilt dies für Arrays mit weniger als 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * Comparison&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="comparison">Die <see cref="T:System.Comparison`1" />, die beim Vergleich von Elementen verwendet werden soll.</param>
        <summary>Sortiert die Elemente in einem <see cref="T:System.Array" /> mithilfe der angegebenen <see cref="T:System.Comparison`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die Beobachtung der inneren Abläufe Sortieralgorithmus (Introsort) wie folgt:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird ein [Einfügesortierung](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es, eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und wenden die Schnellsortierung im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Log `n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> -methodenüberladung.  
  
 Das Codebeispiel definiert eine alternative Vergleichsmethode für Zeichenfolgen wird mit dem Namen `CompareDinosByLength`. Diese Methode funktioniert wie folgt aus: Zunächst werden die zu vergleichenden Objekte für getestet`null`, und als kleiner als ein Wert ungleich Null ein null-Verweis behandelt wird. Zweitens: die Länge der Zeichenfolge verglichen werden und größer sein als die längere Zeichenfolge angesehen wird. Wenn die Länge gleich sind, wird im dritten gewöhnliche Zeichenfolgenvergleich verwendet.  
  
 Ein Array von Zeichenfolgen erstellt und mit vier Zeichenfolgen, in keiner bestimmten Reihenfolge aufgefüllt. Die Liste enthält auch eine leere Zeichenfolge und ein null-Verweis. Die Liste wird angezeigt, sortiert, mit einem <xref:System.Comparison%601> generischen Delegaten darstellt der `CompareDinosByLength` -Methode, und erneut angezeigt.  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="comparison" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparison" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparison" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <block subset="none" type="usage"><para>Die .NET Framework 4 und früheren Versionen verwendet nur den Quicksort-Algorithmus. QuickSort identifiziert die ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, eine <see cref="T:System.IndexOutOfRangeException" /> -Ausnahme aus, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer. Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <see cref="T:System.ArgumentException" /> wird keine Ausnahme, da die Einfügung sortieren und Heapsort Algorithmen eine ungültige Vergleich nicht erkennen. Zum größten Teil, gilt dies für Arrays mit weniger als 16 Elementen.</para></block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen in einem <see cref="T:System.Array" /> mithilfe der Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle jedes Elements des <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element innerhalb des angegebenen Bereichs von Elementen in `array` müssen implementieren die <xref:System.IComparable%601> generische Schnittstelle für Vergleiche mit jedem anderen Element in werden `array`.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die Beobachtung der inneren Abläufe Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird ein [Einfügesortierung](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es, eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und wenden die Schnellsortierung im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Log `n`)-Vorgang, in denen `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generischen methodenüberladung und <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung für einen Bereich in einem Array zu sortieren.  
  
 Das Codebeispiel definiert einen alternativen Vergleich für Zeichenfolgen mit der Bezeichnung `ReverseCompare`, implementiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich ruft die <xref:System.String.CompareTo%28System.String%29> Methode, die Umkehrung der verglichenen Elemente angibt, damit die Zeichenfolgen hoch bis Niedrig statt mit niedriger zum höchsten zu sortieren.  
  
 Im Codebeispiel wird erstellt und zeigt ein Array der Namen von Godzilla, drei Pflanzenfresser und drei Fleischfresser (Tyrannosaurids, um genau zu sein). Die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generische Überladung wird verwendet, um die letzten drei Elemente des Arrays, sortieren, die dann angezeigt werden. Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung der Verwendung `ReverseCompare` der letzten drei Elemente in umgekehrter Reihenfolge zu sortieren. Die Dinosaurier gründlich verwechselt werden erneut angezeigt.  
  
> [!NOTE]
>  Die Aufrufe an die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> und <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden sind nicht anders als die Aufrufe an ihre nicht generischen Entsprechungen, gesucht, da Visual Basic, c# und C++ den Typ des generischen Typparameters aus dem Typ des ersten Arguments abzuleiten. Bei Verwendung der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die Untergrenze von <paramref name="array" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens ein Element in <paramref name="array" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <see langword="null" />, um die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle der einzelnen Elemente zu verwenden.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen in der <see cref="T:System.Array" /> mithilfe der angegebenen generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` ist `null`, jedes Element innerhalb des angegebenen Bereichs von Elementen in `array` müssen implementieren die <xref:System.IComparable%601> generische Schnittstelle für Vergleiche mit jedem anderen Element in werden `array`.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die Beobachtung der inneren Abläufe Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird ein [Einfügesortierung](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es, eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und wenden die Schnellsortierung im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Log `n`)-Vorgang, in denen `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generischen methodenüberladung und <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung für einen Bereich in einem Array zu sortieren.  
  
 Das Codebeispiel definiert einen alternativen Vergleich für Zeichenfolgen mit der Bezeichnung `ReverseCompare`, implementiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich ruft die <xref:System.String.CompareTo%28System.String%29> Methode, die Umkehrung der verglichenen Elemente angibt, damit die Zeichenfolgen hoch bis Niedrig statt mit niedriger zum höchsten zu sortieren.  
  
 Im Codebeispiel wird erstellt und zeigt ein Array der Namen von Godzilla, drei Pflanzenfresser und drei Fleischfresser (Tyrannosaurids, um genau zu sein). Die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generische Überladung wird verwendet, um die letzten drei Elemente des Arrays, sortieren, die dann angezeigt werden. Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generischen methodenüberladung der Verwendung `ReverseCompare` der letzten drei Elemente in umgekehrter Reihenfolge zu sortieren. Die Dinosaurier gründlich verwechselt werden erneut angezeigt.  
  
> [!NOTE]
>  Die Aufrufe an die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> und <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden sind nicht anders als die Aufrufe an ihre nicht generischen Entsprechungen, gesucht, da Visual Basic, c# und C++ den Typ des generischen Typparameters aus dem Typ des ersten Arguments abzuleiten. Bei Verwendung der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die Untergrenze von <paramref name="array" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  
  
- oder - 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und mindestens ein Element in <paramref name="array" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <block subset="none" type="usage"><para>Die .NET Framework 4 und früheren Versionen verwendet nur den Quicksort-Algorithmus. QuickSort identifiziert die ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, eine <see cref="T:System.IndexOutOfRangeException" /> -Ausnahme aus, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer. Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <see cref="T:System.ArgumentException" /> wird keine Ausnahme, da die Einfügung sortieren und Heapsort Algorithmen eine ungültige Vergleich nicht erkennen. Zum größten Teil, gilt dies für Arrays mit weniger als 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Der Typ der Elemente des Schlüsselarrays.</typeparam>
        <typeparam name="TValue">Der Typ der Elemente des Elementarrays.</typeparam>
        <param name="keys">Das eindimensionale nullbasierte <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das die den Schlüsseln in <paramref name="keys" /> entsprechenden Elemente enthält, oder <see langword="null" />, um nur <paramref name="keys" /> zu sortieren.</param>
        <summary>Sortiert ein Paar von <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle jedes Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array>. Wenn ein Schlüssel wird neu angeordnet, bei der Sortierung, des entsprechenden Elements in der `items` <xref:System.Array> wird neu positioniert. Aus diesem Grund die `items` <xref:System.Array> sortiert wird, entsprechend der Anordnung der entsprechenden Schlüssel in der `keys` <xref:System.Array>.  
  
 Jeder Schlüssel in der `keys` <xref:System.Array> müssen implementieren die <xref:System.IComparable%601> generische Schnittstelle für die er mit jedem anderen Schlüssel verglichen werden.  
  
 Sie können sortiert, wenn es mehr Elemente als Schlüssel gibt, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert. Wenn es weitere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies eine <xref:System.ArgumentException>.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die Beobachtung der inneren Abläufe Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird ein [Einfügesortierung](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es, eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und wenden die Schnellsortierung im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Log `n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, und <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladungen der generischen Methode, für die Sortierung der Paare von Arrays, die Schlüssel und Werte darstellen.  
  
 Das Codebeispiel definiert einen alternativen Vergleich für Zeichenfolgen mit der Bezeichnung `ReverseCompare`, implementiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich ruft die <xref:System.String.CompareTo%28System.String%29> Methode, die Umkehrung der verglichenen Elemente angibt, damit die Zeichenfolgen hoch bis Niedrig statt mit niedriger zum höchsten zu sortieren.  
  
 Im Codebeispiel wird erstellt und zeigt ein Array von Godzilla Namen (Schlüssel) und ein Array von ganzen Zahlen, die die maximale Länge der einzelnen Godzilla in Metern (Werte) darstellt. Die Arrays werden dann sortiert und mehrmals angezeigt:  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Überladung wird verwendet, um beide Arrays in der Reihenfolge der Namen Godzilla im ersten Array zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladung und einer Instanz von `ReverseCompare` werden verwendet, um die Sortierreihenfolge der gekoppelten Arrays umzukehren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um die letzten drei Elemente beider Arrays zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladung wird verwendet, um die letzten drei Elemente beider Arrays in umgekehrter Reihenfolge zu sortieren.  
  
> [!NOTE]
>  Die Aufrufe an den generischen Methoden suchen nicht anders als die Aufrufe an ihre nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters aus dem Typ der ersten beiden Argumente abzuleiten. Bei Verwendung der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die untere Grenze von <paramref name="keys" /> entspricht nicht der unteren Grenze von <paramref name="items" />.  
  
- oder - 
 <paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens ein Element im <paramref name="keys" /><see cref="T:System.Array" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Der Typ der Elemente des Schlüsselarrays.</typeparam>
        <typeparam name="TValue">Der Typ der Elemente des Elementarrays.</typeparam>
        <param name="keys">Das eindimensionale nullbasierte <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das die den Schlüsseln in <paramref name="keys" /> entsprechenden Elemente enthält, oder <see langword="null" />, um nur <paramref name="keys" /> zu sortieren.</param>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <see langword="null" />, um die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle der einzelnen Elemente zu verwenden.</param>
        <summary>Sortiert ein Paar von <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die angegebene generische <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array>. Wenn ein Schlüssel wird neu angeordnet, bei der Sortierung, des entsprechenden Elements in der `items` <xref:System.Array> wird neu positioniert. Aus diesem Grund die `items` <xref:System.Array> sortiert wird, entsprechend der Anordnung der entsprechenden Schlüssel in der `keys` <xref:System.Array>.  
  
 Wenn `comparer` ist `null`, die jeweils-Schlüssel in der `keys` <xref:System.Array> müssen implementieren die <xref:System.IComparable%601> generische Schnittstelle für die er mit jedem anderen Schlüssel verglichen werden.  
  
 Sie können sortiert, wenn es mehr Elemente als Schlüssel gibt, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert. Wenn es weitere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies eine <xref:System.ArgumentException>.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die Beobachtung der inneren Abläufe Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird ein [Einfügesortierung](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es, eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und wenden die Schnellsortierung im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Log `n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, und <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladungen der generischen Methode, für die Sortierung der Paare von Arrays, die Schlüssel und Werte darstellen.  
  
 Das Codebeispiel definiert einen alternativen Vergleich für Zeichenfolgen mit der Bezeichnung `ReverseCompare`, implementiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich ruft die <xref:System.String.CompareTo%28System.String%29> Methode, die Umkehrung der verglichenen Elemente angibt, damit die Zeichenfolgen hoch bis Niedrig statt mit niedriger zum höchsten zu sortieren.  
  
 Im Codebeispiel wird erstellt und zeigt ein Array von Godzilla Namen (Schlüssel) und ein Array von ganzen Zahlen, die die maximale Länge der einzelnen Godzilla in Metern (Werte) darstellt. Die Arrays werden dann sortiert und mehrmals angezeigt:  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Überladung wird verwendet, um beide Arrays in der Reihenfolge der Namen Godzilla im ersten Array zu sortieren.  
  
-   Die [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >-Überladung und einer Instanz von `ReverseCompare` werden verwendet, um die Sortierreihenfolge umzukehren der paarweise zugeordneten Arrays.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um die letzten drei Elemente beider Arrays zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladung wird verwendet, um die letzten drei Elemente beider Arrays in umgekehrter Reihenfolge zu sortieren.  
  
> [!NOTE]
>  Die Aufrufe an den generischen Methoden suchen nicht anders als die Aufrufe an ihre nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters aus dem Typ der ersten beiden Argumente abzuleiten. Bei Verwendung der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die untere Grenze von <paramref name="keys" /> entspricht nicht der unteren Grenze von <paramref name="items" />.  
  
- oder - 
 <paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  
  
- oder - 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und mindestens ein Element im <paramref name="keys" /><see cref="T:System.Array" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <block subset="none" type="usage"><para>Die .NET Framework 4 und früheren Versionen verwendet nur den Quicksort-Algorithmus. QuickSort identifiziert die ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, eine <see cref="T:System.IndexOutOfRangeException" /> -Ausnahme aus, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer. Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <see cref="T:System.ArgumentException" /> wird keine Ausnahme, da die Einfügung sortieren und Heapsort Algorithmen eine ungültige Vergleich nicht erkennen. Zum größten Teil, gilt dies für Arrays mit weniger als 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Der Typ der Elemente des Schlüsselarrays.</typeparam>
        <typeparam name="TValue">Der Typ der Elemente des Elementarrays.</typeparam>
        <param name="keys">Das eindimensionale nullbasierte <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das die den Schlüsseln in <paramref name="keys" /> entsprechenden Elemente enthält, oder <see langword="null" />, um nur <paramref name="keys" /> zu sortieren.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <summary>Sortiert einen Bereich von Elementen in einem Paar von <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle jedes Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array>. Wenn ein Schlüssel wird neu angeordnet, bei der Sortierung, des entsprechenden Elements in der `items` <xref:System.Array> wird neu positioniert. Aus diesem Grund die `items` <xref:System.Array> sortiert wird, entsprechend der Anordnung der entsprechenden Schlüssel in der `keys` <xref:System.Array>.  
  
 Jeder Schlüssel im angegebenen Bereich von Elementen in der `keys` <xref:System.Array> müssen implementieren die <xref:System.IComparable%601> generische Schnittstelle für die er mit jedem anderen Schlüssel verglichen werden.  
  
 Sie können sortiert, wenn es mehr Elemente als Schlüssel gibt, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert. Wenn es weitere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies eine <xref:System.ArgumentException>.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die Beobachtung der inneren Abläufe Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird ein [Einfügesortierung](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es, eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und wenden die Schnellsortierung im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Log `n`)-Vorgang, in denen `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >, und <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische-methodenüberladungen, für die Sortierung der Paare von Arrays, die Schlüssel und Werte darstellen.  
  
 Das Codebeispiel definiert einen alternativen Vergleich für Zeichenfolgen mit der Bezeichnung `ReverseCompare`, implementiert die `IComparer<string>` (`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich ruft die <xref:System.String.CompareTo%28System.String%29> Methode, die Umkehrung der verglichenen Elemente angibt, damit die Zeichenfolgen hoch bis Niedrig statt mit niedriger zum höchsten zu sortieren.  
  
 Im Codebeispiel wird erstellt und zeigt ein Array von Godzilla Namen (Schlüssel) und ein Array von ganzen Zahlen, die die maximale Länge der einzelnen Godzilla in Metern (Werte) darstellt. Die Arrays werden dann sortiert und mehrmals angezeigt:  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Überladung wird verwendet, um beide Arrays in der Reihenfolge der Namen Godzilla im ersten Array zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladung und einer Instanz von `ReverseCompare` werden verwendet, um die Sortierreihenfolge der gekoppelten Arrays umzukehren.  
  
-   Die [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > Überladung wird verwendet, um die letzten drei Elemente beider Arrays zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladung wird verwendet, um die letzten drei Elemente beider Arrays in umgekehrter Reihenfolge zu sortieren.  
  
> [!NOTE]
>  Die Aufrufe an den generischen Methoden suchen nicht anders als die Aufrufe an ihre nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters aus dem Typ der ersten beiden Argumente abzuleiten. Bei Verwendung der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die Untergrenze von <paramref name="keys" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die untere Grenze von <paramref name="keys" /> entspricht nicht der unteren Grenze von <paramref name="items" />.  
  
- oder - 
 <paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  
  
- oder - 
 <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="keys" /><see cref="T:System.Array" /> an.  
  
- oder - 
 <paramref name="items" /> ist nicht <see langword="null" />, und <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="items" /><see cref="T:System.Array" /> an.</exception>
        <exception cref="T:System.InvalidOperationException">Mindestens ein Element im <paramref name="keys" /><see cref="T:System.Array" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Der Typ der Elemente des Schlüsselarrays.</typeparam>
        <typeparam name="TValue">Der Typ der Elemente des Elementarrays.</typeparam>
        <param name="keys">Das eindimensionale nullbasierte <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das die den Schlüsseln in <paramref name="keys" /> entsprechenden Elemente enthält, oder <see langword="null" />, um nur <paramref name="keys" /> zu sortieren.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <see langword="null" />, um die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle der einzelnen Elemente zu verwenden.</param>
        <summary>Sortiert einen Bereich von Elementen in einem Paar von <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die angegebene generische <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array>. Wenn ein Schlüssel wird neu angeordnet, bei der Sortierung, des entsprechenden Elements in der `items` <xref:System.Array> wird neu positioniert. Aus diesem Grund die `items` <xref:System.Array> sortiert wird, entsprechend der Anordnung der entsprechenden Schlüssel in der `keys` <xref:System.Array>.  
  
 Wenn `comparer` ist `null`, jeder Schlüssel im angegebenen Bereich von Elementen in der `keys` <xref:System.Array> müssen implementieren die <xref:System.IComparable%601> generische Schnittstelle für die er mit jedem anderen Schlüssel verglichen werden.  
  
 Sie können sortiert, wenn es mehr Elemente als Schlüssel gibt, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert. Wenn es weitere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies eine <xref:System.ArgumentException>.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet die Beobachtung der inneren Abläufe Sortieralgorithmus (Introsort) wie folgt aus:  
  
-   Wenn die Größe der Partition weniger als 16 Elementen ist, wird ein [Einfügesortierung](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus.  
  
-   Überschreitet die Anzahl der Partitionen 2 * Log<sup>N</sup>, wobei *N* ist der Bereich des Eingabearrays, er verwendet eine [Heapsort](https://en.wikipedia.org/wiki/Heapsort) Algorithmus.  
  
-   Andernfalls verwendet es, eine [Quicksort](https://en.wikipedia.org/wiki/Quicksort) Algorithmus.  
  
 Diese Implementierung führt eine instabile Sortierung. d.h., wenn zwei Elemente gleich sind, möglicherweise die Reihenfolge nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung, die Reihenfolge der Elemente, die gleich sind.  
  
 Für Arrays, die mithilfe von Algorithmen Heapsort und wenden die Schnellsortierung im schlimmsten Fall sortiert sind, ist diese Methode eine O (`n` Log `n`)-Vorgang, in denen `n` ist `length`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, und [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32% 2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > Überladungen der generischen Methode, für die Sortierung der Paare von Arrays, die Schlüssel und Werte darstellen.  
  
 Das Codebeispiel definiert einen alternativen Vergleich für Zeichenfolgen mit der Bezeichnung `ReverseCompare`, implementiert die `IComparer<string>`(`IComparer(Of String)` in Visual Basic `IComparer<String^>` in Visual C++) generische Schnittstelle. Der Vergleich ruft die <xref:System.String.CompareTo%28System.String%29> Methode, die Umkehrung der verglichenen Elemente angibt, damit die Zeichenfolgen hoch bis Niedrig statt mit niedriger zum höchsten zu sortieren.  
  
 Im Codebeispiel wird erstellt und zeigt ein Array von Godzilla Namen (Schlüssel) und ein Array von ganzen Zahlen, die die maximale Länge der einzelnen Godzilla in Metern (Werte) darstellt. Die Arrays werden dann sortiert und mehrmals angezeigt:  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> Überladung wird verwendet, um beide Arrays in der Reihenfolge der Namen Godzilla im ersten Array zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladung und einer Instanz von `ReverseCompare` werden verwendet, um die Sortierreihenfolge der gekoppelten Arrays umzukehren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Überladung wird verwendet, um die letzten drei Elemente beider Arrays zu sortieren.  
  
-   Die [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > Überladung wird verwendet, um die letzten drei zu sortieren. Elemente beider arrays in umgekehrter Reihenfolge.  
  
> [!NOTE]
>  Die Aufrufe an den generischen Methoden suchen nicht anders als die Aufrufe an ihre nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters aus dem Typ der ersten beiden Argumente abzuleiten. Bei Verwendung der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die Untergrenze von <paramref name="keys" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die untere Grenze von <paramref name="keys" /> entspricht nicht der unteren Grenze von <paramref name="items" />.  
  
- oder - 
 <paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  
  
- oder - 
 <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="keys" /><see cref="T:System.Array" /> an.  
  
- oder - 
 <paramref name="items" /> ist nicht <see langword="null" />, und <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="items" /><see cref="T:System.Array" /> an.  
  
- oder - 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und mindestens ein Element im <paramref name="keys" /><see cref="T:System.Array" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <block subset="none" type="usage"><para>Die .NET Framework 4 und früheren Versionen verwendet nur den Quicksort-Algorithmus. QuickSort identifiziert die ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, eine <see cref="T:System.IndexOutOfRangeException" /> -Ausnahme aus, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer. Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <see cref="T:System.ArgumentException" /> wird keine Ausnahme, da die Einfügung sortieren und Heapsort Algorithmen eine ungültige Vergleich nicht erkennen. Zum größten Teil, gilt dies für Arrays mit weniger als 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Array.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Array" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die <see cref="T:System.Array" /> synchronisiert werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft implementiert die <xref:System.Collections.ICollection?displayProperty=nameWithType> Schnittstelle.  
  
 .NET Framework-Klassen basierend auf <xref:System.Array> Geben Sie ihre eigene synchronisierte Version der Auflistung mithilfe der <xref:System.Array.SyncRoot%2A> Eigenschaft.  
  
 Klassen, die Arrays verwenden können auch implementieren ihre eigenen Synchronisierung über die <xref:System.Array.SyncRoot%2A> Eigenschaft. Der Synchronisierungscode dürfen Vorgänge auf den `SyncRoot` der Auflistung, nicht direkt in der Auflistung. Dies gewährleistet die einwandfreie Funktion von Auflistungen, die von anderen Objekten abgeleitet sind. Insbesondere verwaltet er die ordnungsgemäße Synchronisierung mit anderen Threads, die gleichzeitig die Auflistung geändert werden kann. Beachten Sie, dass einige Implementierungen von <xref:System.Array.SyncRoot%2A> möglicherweise die <xref:System.Array> selbst.  
  
 Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein Array während der gesamten Enumeration sperren, mit der <xref:System.Array.SyncRoot%2A> Eigenschaft.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente ab, die in <see cref="T:System.Array" /> enthalten sind.</summary>
        <value>Die Anzahl der Elemente in der Auflistung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.ICollection>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf <see cref="T:System.Array" /> synchronisiert (threadsicher) ist.</summary>
        <value>"true", wenn der Zugriff auf die <see cref="T:System.Array" />-Klasse synchronisiert ist (threadsicher), andernfalls "false".</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Array" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die <see cref="T:System.Array" /> synchronisiert werden kann.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das dem <see cref="T:System.Collections.IList" /> hinzuzufügende Objekt.</param>
        <summary>Beim Aufrufen dieser Methode wird immer eine <see cref="T:System.NotSupportedException" />-Ausnahme ausgelöst.</summary>
        <returns>Das Hinzufügen eines Werts zu einem Array wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalerweise eine <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> Implementierung Fügt ein Element einer Auflistung hinzu. Aber da Arrays eine feste Größe aufweisen (der <xref:System.Array.IsFixedSize%2A> -Eigenschaft gibt immer `true`), diese Methode löst immer eine <xref:System.NotSupportedException> Ausnahme.  
  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> hat eine feste Größe.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das in der aktuellen Liste zu suchende Objekt. Das gesuchte Element kann für Referenztypen <see langword="null" />.</param>
        <summary>Bestimmt, ob sich ein Element in <see cref="T:System.Collections.IList" /> befindet.</summary>
        <returns><see langword="true" />, wenn das <paramref name="value" /> in der <see cref="T:System.Collections.IList" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das in der aktuellen Liste zu suchende Objekt.</param>
        <summary>Bestimmt den Index eines bestimmten Elements in der <see cref="T:System.Collections.IList" />.</summary>
        <returns>Der Index von value, wenn das Element in der Liste gefunden wird, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Der Index, an dem <paramref name="value" /> eingefügt werden soll.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <summary>Fügt am angegebenen Index ein Element in die <see cref="T:System.Collections.IList" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kein gültiger Index in <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> ist schreibgeschützt.  
  
- oder - 
<see cref="T:System.Collections.IList" /> hat eine feste Größe.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> ist ein NULL-Verweis in <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Array" /> eine feste Größe hat.</summary>
        <value>True, wenn die <see cref="T:System.Array" /> hat eine feste Größe; andernfalls "false".</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Array" /> schreibgeschützt ist.</summary>
        <value>True, wenn die <see cref="T:System.Array" /> ist sie schreibgeschützt ist; andernfalls "false".</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der Index des abzurufenden oder zu festzulegenden Elements.</param>
        <summary>Ruft das Element am angegebenen Index ab oder legt dieses fest.</summary>
        <value>Das Element am angegebenen Index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="index" /> ist größer oder gleich <see cref="P:System.Collections.ICollection.Count" />.</exception>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> hat nicht genau eine Dimension.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das aus der <see cref="T:System.Collections.IList" /> zu entfernende Objekt.</param>
        <summary>Entfernt das erste Vorkommen eines angegebenen Objekts aus der <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> ist schreibgeschützt.  
  
- oder - 
<see cref="T:System.Collections.IList" /> hat eine feste Größe.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der Index des zu entfernenden Elements.</param>
        <summary>Entfernt das <see cref="T:System.Collections.IList" />-Element am angegebenen Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">index ist kein gültiger Index in <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> ist schreibgeschützt.  
  
- oder - 
<see cref="T:System.Collections.IList" /> hat eine feste Größe.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
        <param name="comparer">Ein Objekt, das das aktuelle Objekt und <paramref name="other" /> vergleicht.</param>
        <summary>Bestimmt, ob das aktuelle Auflistungsobjekt in der Sortierreihenfolge vor oder nach einem anderen Objekt oder an derselben Position auftritt.</summary>
        <returns>Eine ganze Zahl, die die Beziehung des aktuellen Auflistungsobjekts zu "other" angibt, wie in der folgenden Tabelle dargestellt.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> Beschreibung  
 </description></listheader><item><term> -1 
 </term><description> Die aktuelle Instanz tritt vor <paramref name="other" /> auf.  
  
 </description></item><item><term> 0 
 </term><description> Die aktuelle Instanz und <paramref name="other" /> sind gleich.  
  
 </description></item><item><term> 1 
 </term><description> Die aktuelle Instanz folgt auf <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IStructuralComparable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
        <param name="comparer">Ein Objekt, das bestimmt, ob die aktuelle Instanz und <paramref name="other" /> gleich sind.</param>
        <summary>Bestimmt, ob ein Objekt gleich der aktuellen Instanz ist.</summary>
        <returns><see langword="true" />, wenn die beiden Objekte gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IStructuralEquatable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="comparer">Ein Objekt, das den Hashcode des aktuellen Objekts berechnet.</param>
        <summary>Gibt einen Hashcode für die aktuelle Instanz zurück.</summary>
        <returns>Der Hashcode für die aktuelle Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IStructuralEquatable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member TrueForAll : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.TrueForAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das auf die Bedingungen geprüft werden soll.</param>
        <param name="match">Das Prädikat, das die Bedingungen definiert, auf die die Elemente geprüft werden sollen.</param>
        <summary>Bestimmt, ob jedes Element im Array die vom angegebenen Prädikat definierten Bedingungen erfüllt.</summary>
        <returns><see langword="true" />, wenn jedes Element in <paramref name="array" /> die vom angegebenen Prädikat definierten Bedingungen erfüllt, andernfalls <see langword="false" />. Wenn es keine Elemente im Array gibt, ist der Rückgabewert <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Predicate%601> ist ein Delegat einer Methode, die zurückgibt`true` , wenn das Objekt zu übergeben sie mit der im Delegat definierten Bedingungen übereinstimmt.  Die Elemente der `array` werden einzeln an übergeben die <xref:System.Predicate%601>, und die Verarbeitung wird beendet, wenn der Delegat zurückgegeben `false` für jedes Element.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist die <xref:System.Array.Length%2A> von `array`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob das letzte Zeichen der einzelnen Elemente in einem Zeichenfolgenarray mit einer Zahl ist. Es werden zwei Zeichenfolgen-Arrays erstellt. Das erste Array schließt Zeichenfolgen, die mit alphabetische Zeichen und Zeichenfolgen, die mit numerischen Zeichen enden. Das zweite Array besteht ausschließlich aus Zeichenfolgen, die mit numerischen Zeichen enden. Im Beispiel definiert auch eine `EndWithANumber` Methode, deren Signatur entspricht, der <xref:System.Predicate%601> delegieren. Das Beispiel übergibt jedes Arrays, um die <xref:System.Array.TrueForAll%2A> -Methode zusammen mit der ein Delegat, der darstellt der `EndsWithANumber` Methode.  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 Im folgende Beispiel ähnelt die erste, außer dass das Zeichenfolgenarray, übergibt die <xref:System.Array.TrueForAll%2A> -Methode zusammen mit einem Lambda-Ausdruck, der bestimmt, ob einem bestimmten Arrayelement durch die Zeichenfolgendarstellung einer Zahl endet.  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 In beiden Fällen die <xref:System.Array.TrueForAll%2A> Methodenrückgabe `false` , sobald das erste Arrayelement gefunden, die nicht in eine Zahl endet. Andernfalls wird `true` nach dem alle Elemente im Array durchlaufen.  
  
> [!NOTE]
>  Wie in beiden Beispielen gezeigt wird, in c# und Visual Basic ist es nicht erforderlich, erstellen Sie die `Predicate<string>` delegieren (`Predicate(Of String)` in Visual Basic) explizit. Diese Sprachen den richtigen Delegaten aus dem Kontext ableiten und erstellen ihn automatisch.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>
